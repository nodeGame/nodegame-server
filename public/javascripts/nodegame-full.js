/**
 * # nodeGame IE support
 * Copyright(c) 2015 Stefano Balietti
 * MIT Licensed
 *
 * Shims of methods required by nodeGame, but missing in old IE browsers
 *
 * ---
 */

if ('undefined' === typeof String.prototype.trim) {
    String.prototype.trim = function() {
        return this.replace(/^\s+|\s+$/g, '');
    };
}

if ('undefined' === typeof console) {
    this.console = {log: function() {}};
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/
// Global_Objects/Date/now
if (!Date.now) {
    Date.now = function now() {
        return new Date().getTime();
    };
}

// http://stackoverflow.com/questions/2790001/
// fixing-javascript-array-functions-in-internet-explorer-indexof-foreach-etc
if (!('indexOf' in Array.prototype)) {
    Array.prototype.indexOf= function(find, i /*opt*/) {
        if (i===undefined) i= 0;
        if (i<0) i+= this.length;
        if (i<0) i= 0;
        for (var n= this.length; i<n; i++)
            if (i in this && this[i]===find)
                return i;
        return -1;
    };
}
if (!('lastIndexOf' in Array.prototype)) {
    Array.prototype.lastIndexOf= function(find, i /*opt*/) {
        if (i===undefined) i= this.length-1;
        if (i<0) i+= this.length;
        if (i>this.length-1) i= this.length-1;
        for (i++; i-->0;) /* i++ because from-argument is sadly inclusive */
            if (i in this && this[i]===find)
                return i;
        return -1;
    };
}

if (typeof Object.create !== 'function') {
    Object.create = (function() {
        var Temp = function() {};
        return function (prototype) {
            if (arguments.length > 1) {
                throw Error('Second argument not supported');
            }
            if (typeof prototype != 'object') {
                throw TypeError('Argument must be an object');
            }
            Temp.prototype = prototype;
            var result = new Temp();
            Temp.prototype = null;
            return result;
        };
    })();
}

/**
   JSON2
   http://www.JSON.org/json2.js
   2011-02-23
*/

var JSON;
if (!JSON) {
    JSON = {};
}

(function () {
    "use strict";

    var global = new Function('return this')()
      , JSON = global.JSON
      ;

    if (!JSON) {
      JSON = {};
    }

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                this.getUTCFullYear()     + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate())      + 'T' +
                f(this.getUTCHours())     + ':' +
                f(this.getUTCMinutes())   + ':' +
                f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' : gap ?
                '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }

    global.JSON = JSON;
}());


// Production steps of ECMA-262, Edition 5, 15.4.4.14
// Reference: http://es5.github.io/#x15.4.4.14
if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function(searchElement, fromIndex) {

        var k;

        // 1. Let O be the result of calling ToObject passing
        //    the this value as the argument.
        if (this == null) {
            throw new TypeError('"this" is null or not defined');
        }

        var O = Object(this);

        // 2. Let lenValue be the result of calling the Get
        //    internal method of O with the argument "length".
        // 3. Let len be ToUint32(lenValue).
        var len = O.length >>> 0;

        // 4. If len is 0, return -1.
        if (len === 0) {
            return -1;
        }

        // 5. If argument fromIndex was passed let n be
        //    ToInteger(fromIndex); else let n be 0.
        var n = +fromIndex || 0;

        if (Math.abs(n) === Infinity) {
            n = 0;
        }

        // 6. If n >= len, return -1.
        if (n >= len) {
            return -1;
        }

        // 7. If n >= 0, then Let k be n.
        // 8. Else, n<0, Let k be len - abs(n).
        //    If k is less than 0, then let k be 0.
        k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

        // 9. Repeat, while k < len
        while (k < len) {
            // a. Let Pk be ToString(k).
            //   This is implicit for LHS operands of the in operator
            // b. Let kPresent be the result of calling the
            //    HasProperty internal method of O with argument Pk.
            //   This step can be combined with c
            // c. If kPresent is true, then
            //    i.  Let elementK be the result of calling the Get
            //        internal method of O with the argument ToString(k).
            //   ii.  Let same be the result of applying the
            //        Strict Equality Comparison Algorithm to
            //        searchElement and elementK.
            //  iii.  If same is true, return k.
            if (k in O && O[k] === searchElement) {
                return k;
            }
            k++;
        }
        return -1;
    };
}

/**
 * # JSUS: JavaScript UtilS.
 * Copyright(c) 2017 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Collection of general purpose javascript functions. JSUS helps!
 *
 * See README.md for extra help.
 * ---
 */
(function(exports) {

    var JSUS = exports.JSUS = {};

    // ## JSUS._classes
    // Reference to all the extensions
    JSUS._classes = {};

    // Make sure that the console is available also in old browser, e.g. < IE8.
    if ('undefined' === typeof console) console = {};
    if ('undefined' === typeof console.log) console.log = function() {};

    /**
     * ## JSUS.log
     *
     * Reference to standard out, by default `console.log`
     *
     * Override to redirect the standard output of all JSUS functions.
     *
     * @param {string} txt Text to output
     */
    JSUS.log = function(txt) { console.log(txt); };

    /**
     * ## JSUS.extend
     *
     * Extends JSUS with additional methods and or properties
     *
     * The first parameter can be an object literal or a function.
     * A reference of the original extending object is stored in
     * JSUS._classes
     *
     * If a second parameter is passed, that will be the target of the
     * extension.
     *
     * @param {object} additional Text to output
     * @param {object|function} target The object to extend
     *
     * @return {object|function} target The extended object
     */
    JSUS.extend = function(additional, target) {
        var name, prop;
        if ('object' !== typeof additional &&
            'function' !== typeof additional) {
            return target;
        }

        // If we are extending JSUS, store a reference
        // of the additional object into the hidden
        // JSUS._classes object;
        if ('undefined' === typeof target) {
            target = target || this;
            if ('function' === typeof additional) {
                name = additional.toString();
                name = name.substr('function '.length);
                name = name.substr(0, name.indexOf('('));
            }
            // Must be object.
            else {
                name = additional.constructor ||
                    additional.__proto__.constructor;
            }
            if (name) {
                this._classes[name] = additional;
            }
        }

        for (prop in additional) {
            if (additional.hasOwnProperty(prop)) {
                if (typeof target[prop] !== 'object') {
                    target[prop] = additional[prop];
                } else {
                    JSUS.extend(additional[prop], target[prop]);
                }
            }
        }

        // Additional is a class (Function)
        // TODO: this is true also for {}
        if (additional.prototype) {
            JSUS.extend(additional.prototype, target.prototype || target);
        }

        return target;
    };

    /**
     * ## JSUS.require
     *
     * Returns a copy/reference of one/all the JSUS components
     *
     * @param {string} component The name of the requested JSUS library.
     *   If undefined, all JSUS components are returned. Default: undefined.
     * @param {boolean} clone Optional. If TRUE, the requested component
     *   is cloned before being returned. Default: TRUE
     *
     * @return {function|boolean} The copy of the JSUS component, or
     *   FALSE if the library does not exist, or cloning is not possible
     */
    JSUS.require = function(component, clone) {
        var out;
        clone = 'undefined' === typeof clone ? true : clone;
        if (clone && 'undefined' === typeof JSUS.clone) {
            JSUS.log('JSUS.require: JSUS.clone not found, but clone ' +
                     'requested. Cannot continue.');
            return false;
        }
        if ('undefined' === typeof component) {
            out = JSUS._classes;
        }
        else {
            out = JSUS._classes[component]
            if ('undefined' === typeof out) {
                JSUS.log('JSUS.require: could not find component ' + component);
                return false;
            }
        }
        return clone ? JSUS.clone(out) : out;
    };

    /**
     * ## JSUS.isNodeJS
     *
     * Returns TRUE when executed inside Node.JS environment
     *
     * @return {boolean} TRUE when executed inside Node.JS environment
     */
    JSUS.isNodeJS = function() {
        return 'undefined' !== typeof module &&
            'undefined' !== typeof module.exports &&
            'function' === typeof require;
    };

    // ## Node.JS includes
    if (JSUS.isNodeJS()) {
        require('./lib/compatibility');
        require('./lib/obj');
        require('./lib/array');
        require('./lib/time');
        require('./lib/eval');
        require('./lib/dom');
        require('./lib/random');
        require('./lib/parse');
        require('./lib/queue');
        require('./lib/fs');
    }
    else {
        // Exports J in the browser.
        exports.J = exports.JSUS;
    }

})(
    'undefined' !== typeof module && 'undefined' !== typeof module.exports ?
        module.exports: window
);

/**
 * # COMPATIBILITY
 *
 * Copyright(c) 2015 Stefano Balietti
 * MIT Licensed
 *
 * Tests browsers ECMAScript 5 compatibility
 *
 * For more information see http://kangax.github.com/es5-compat-table/
 */
(function(JSUS) {
    "use strict";

    function COMPATIBILITY() {}

    /**
     * ## COMPATIBILITY.compatibility
     *
     * Returns a report of the ECS5 features available
     *
     * Useful when an application routinely performs an operation
     * depending on a potentially unsupported ECS5 feature.
     *
     * Transforms multiple try-catch statements in a if-else
     *
     * @return {object} support The compatibility object
     */
    COMPATIBILITY.compatibility = function() {

        var support = {};

        try {
            Object.defineProperty({}, "a", {enumerable: false, value: 1});
            support.defineProperty = true;
        }
        catch(e) {
            support.defineProperty = false;
        }

        try {
            eval('({ get x(){ return 1 } }).x === 1');
            support.setter = true;
        }
        catch(err) {
            support.setter = false;
        }

        try {
            var value;
            eval('({ set x(v){ value = v; } }).x = 1');
            support.getter = true;
        }
        catch(err) {
            support.getter = false;
        }

        return support;
    };


    JSUS.extend(COMPATIBILITY);

})('undefined' !== typeof JSUS ? JSUS : module.parent.exports.JSUS);

/**
 * # ARRAY
 * Copyright(c) 2017 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Collection of static functions to manipulate arrays
 */
(function(JSUS) {

    "use strict";

    function ARRAY() {}

    /**
     * ## ARRAY.filter
     *
     * Add the filter method to ARRAY objects in case the method is not
     * supported natively.
     *
     * @see https://developer.mozilla.org/en/JavaScript/Reference/
     *              Global_Objects/ARRAY/filter
     */
    if (!Array.prototype.filter) {
        Array.prototype.filter = function(fun /*, thisp */) {
            if (this === void 0 || this === null) throw new TypeError();

            var t = new Object(this);
            var len = t.length >>> 0;
            if (typeof fun !== "function") throw new TypeError();

            var res = [];
            var thisp = arguments[1];
            for (var i = 0; i < len; i++) {
                if (i in t) {
                    var val = t[i]; // in case fun mutates this
                    if (fun.call(thisp, val, i, t)) {
                        res.push(val);
                    }
                }
            }
            return res;
        };
    }

    /**
     * ## ARRAY.isArray
     *
     * Returns TRUE if a variable is an Array
     *
     * This method is exactly the same as `Array.isArray`,
     * but it works on a larger share of browsers.
     *
     * @param {object} o The variable to check.
     *
     * @see Array.isArray
     */
    ARRAY.isArray = (function(f) {
        if ('function' === typeof f) return f;
        else return function(o) {
            if (!o) return false;
            return Object.prototype.toString.call(o) === '[object Array]';
        };
    })(Array.isArray);

    /**
     * ## ARRAY.seq
     *
     * Returns an array of sequential numbers from start to end
     *
     * If start > end the series goes backward.
     *
     * The distance between two subsequent numbers can be controlled
     * by the increment parameter.
     *
     * When increment is not a divider of Abs(start - end), end will
     * be missing from the series.
     *
     * A callback function to apply to each element of the sequence
     * can be passed as fourth parameter.
     *
     * Returns FALSE, in case parameters are incorrectly specified
     *
     * @param {number} start The first element of the sequence
     * @param {number} end The last element of the sequence
     * @param {number} increment Optional. The increment between two
     *   subsequents element of the sequence
     * @param {Function} func Optional. A callback function that can modify
     *   each number of the sequence before returning it
     *
     * @return {array} The final sequence
     */
    ARRAY.seq = function(start, end, increment, func) {
        var i, out;
        if ('number' !== typeof start) return false;
        if (start === Infinity) return false;
        if ('number' !== typeof end) return false;
        if (end === Infinity) return false;
        // TODO: increment zero might be fine if start=end. Check.
        if (increment === 0) return false;
        if (!JSUS.inArray(typeof increment, ['undefined', 'number'])) {
            return false;
        }
        if (start === end) {
            if (!func) return [ start ];
            return [ func(start) ];
        }
        increment = increment || 1;
        func = func || function(e) {return e;};

        i = start;
        out = [];

        if (start < end) {
            while (i <= end) {
                out.push(func(i));
                i = i + increment;
            }
        }
        else {
            while (i >= end) {
                out.push(func(i));
                i = i - increment;
            }
        }

        return out;
    };

    /**
     * ## ARRAY.each
     *
     * Executes a callback on each element of the array
     *
     * If an error occurs returns FALSE.
     *
     * @param {array} array The array to loop in
     * @param {Function} cb The callback for each element in the array
     * @param {object} context Optional. The context of execution of the
     *   callback. Defaults ARRAY.each
     */
    ARRAY.each = function(array, cb, context) {
        var i, len;
        if ('object' !== typeof array) {
            throw new TypeError('ARRAY.each: array must be object. Found: ' +
                                array);
        }
        if ('function' !== typeof cb) {
            throw new TypeError('ARRAY.each: cb must be function. Found: ' +
                                cb);
        }

        context = context || this;
        len = array.length;
        for (i = 0 ; i < len; i++) {
            cb.call(context, array[i], i);
        }
    };

    /**
     * ## ARRAY.map
     *
     * Executes a callback to each element of the array and returns the result
     *
     * Any number of additional parameters can be passed after the
     * callback function.
     *
     * @return {array} The result of the mapping execution
     *
     * @see ARRAY.each
     */
    ARRAY.map = function() {
        var i, len, args, out, o;
        var array, func;

        array = arguments[0];
        func = arguments[1];

        if (!ARRAY.isArray(array)) {
            JSUS.log('ARRAY.map: first parameter must be array. Found: ' +
                     array);
            return;
        }
        if ('function' !== typeof func) {
            JSUS.log('ARRAY.map: second parameter must be function. Found: ' +
                     func);
            return;
        }

        len = arguments.length;
        if (len === 3) args = [ null, arguments[2] ];
        else if (len === 4) args = [ null, arguments[2], arguments[3] ];
        else {
            len = len - 1;
            args = new Array(len);
            for (i = 1; i < (len); i++) {
                args[i] = arguments[i+1];
            }
        }

        out = [], len = array.length;
        for (i = 0; i < len; i++) {
            args[0] = array[i];
            o = func.apply(this, args);
            if ('undefined' !== typeof o) out.push(o);
        }
        return out;
    };


    /**
     * ## ARRAY.removeElement
     *
     * Removes an element from the the array, and returns it
     *
     * For objects, deep equality comparison is performed
     * through JSUS.equals.
     *
     * If no element is removed returns FALSE.
     *
     * @param {mixed} needle The element to search in the array
     * @param {array} haystack The array to search in
     *
     * @return {mixed} The element that was removed, FALSE if none was removed
     *
     * @see JSUS.equals
     */
    ARRAY.removeElement = function(needle, haystack) {
        var func, i;
        if ('undefined' === typeof needle || !haystack) return false;

        if ('object' === typeof needle) {
            func = JSUS.equals;
        }
        else {
            func = function(a, b) {
                return (a === b);
            };
        }

        for (i = 0; i < haystack.length; i++) {
            if (func(needle, haystack[i])){
                return haystack.splice(i,1);
            }
        }
        return false;
    };

    /**
     * ## ARRAY.inArray
     *
     * Returns TRUE if the element is contained in the array,
     * FALSE otherwise
     *
     * For objects, deep equality comparison is performed
     * through JSUS.equals.
     *
     * @param {mixed} needle The element to search in the array
     * @param {array} haystack The array to search in
     *
     * @return {boolean} TRUE, if the element is contained in the array
     *
     * @see JSUS.equals
     */
    ARRAY.inArray = function(needle, haystack) {
        var func, i, len;
        if (!haystack) return false;
        func = JSUS.equals;
        len = haystack.length;
        for (i = 0; i < len; i++) {
            if (func.call(this, needle, haystack[i])) {
                return true;
            }
        }
        return false;
    };

    ARRAY.in_array = function(needle, haystack) {
        console.log('***ARRAY.in_array is deprecated. ' +
                    'Use ARRAY.inArray instead.***');
        return ARRAY.inArray(needle, haystack);
    };

    /**
     * ## ARRAY.getNGroups
     *
     * Returns an array of N array containing the same number of elements
     * If the length of the array and the desired number of elements per group
     * are not multiple, the last group could have less elements
     *
     * The original array is not modified.
     *
     *  @see ARRAY.getGroupsSizeN
     *  @see ARRAY.generateCombinations
     *  @see ARRAY.matchN
     *
     * @param {array} array The array to split in subgroups
     * @param {number} N The number of subgroups
     *
     * @return {array} Array containing N groups
     */
    ARRAY.getNGroups = function(array, N) {
        return ARRAY.getGroupsSizeN(array, Math.floor(array.length / N));
    };

    /**
     * ## ARRAY.getGroupsSizeN
     *
     * Returns an array of arrays containing N elements each
     *
     * The last group could have less elements
     *
     * @param {array} array The array to split in subgroups
     * @param {number} N The number of elements in each subgroup
     *
     * @return {array} Array containing groups of size N
     *
     * @see ARRAY.getNGroups
     * @see ARRAY.generateCombinations
     * @see ARRAY.matchN
     */
    ARRAY.getGroupsSizeN = function(array, N) {

        var copy = array.slice(0);
        var len = copy.length;
        var originalLen = copy.length;
        var result = [];

        // Init values for the loop algorithm.
        var i, idx;
        var group = [], count = 0;
        for (i=0; i < originalLen; i++) {

            // Get a random idx between 0 and array length.
            idx = Math.floor(Math.random()*len);

            // Prepare the array container for the elements of a new group.
            if (count >= N) {
                result.push(group);
                count = 0;
                group = [];
            }

            // Insert element in the group.
            group.push(copy[idx]);

            // Update.
            copy.splice(idx,1);
            len = copy.length;
            count++;
        }

        // Add any remaining element.
        if (group.length > 0) {
            result.push(group);
        }

        return result;
    };

    /**
     * ## ARRAY._latinSquare
     *
     * Generate a random Latin Square of size S
     *
     * If N is defined, it returns "Latin Rectangle" (SxN)
     *
     * A parameter controls for self-match, i.e. whether the symbol "i"
     * is found or not in in column "i".
     *
     * @api private
     * @param {number} S The number of rows
     * @param {number} Optional. N The number of columns. Defaults N = S
     * @param {boolean} Optional. If TRUE self-match is allowed. Defaults TRUE
     *
     * @return {array} The resulting latin square (or rectangle)
     */
    ARRAY._latinSquare = function(S, N, self) {
        self = ('undefined' === typeof self) ? true : self;
        // Infinite loop.
        if (S === N && !self) return false;
        var seq = [];
        var latin = [];
        for (var i=0; i< S; i++) {
            seq[i] = i;
        }

        var idx = null;

        var start = 0;
        var limit = S;
        var extracted = [];
        if (!self) limit = S-1;

        for (i=0; i < N; i++) {
            do {
                idx = JSUS.randomInt(start,limit);
            }
            while (JSUS.inArray(idx, extracted));
            extracted.push(idx);

            if (idx == 1) {
                latin[i] = seq.slice(idx);
                latin[i].push(0);
            }
            else {
                latin[i] = seq.slice(idx).concat(seq.slice(0,(idx)));
            }

        }

        return latin;
    };

    /**
     * ## ARRAY.latinSquare
     *
     * Generate a random Latin Square of size S
     *
     * If N is defined, it returns "Latin Rectangle" (SxN)
     *
     * @param {number} S The number of rows
     * @param {number} Optional. N The number of columns. Defaults N = S
     *
     * @return {array} The resulting latin square (or rectangle)
     */
    ARRAY.latinSquare = function(S, N) {
        if (!N) N = S;
        if (!S || S < 0 || (N < 0)) return false;
        if (N > S) N = S;

        return ARRAY._latinSquare(S, N, true);
    };

    /**
     * ## ARRAY.latinSquareNoSelf
     *
     * Generate a random Latin Square of size Sx(S-1), where
     * in each column "i", the symbol "i" is not found
     *
     * If N < S, it returns a "Latin Rectangle" (SxN)
     *
     * @param {number} S The number of rows
     * @param {number} Optional. N The number of columns. Defaults N = S-1
     *
     * @return {array} The resulting latin square (or rectangle)
     */
    ARRAY.latinSquareNoSelf = function(S, N) {
        if (!N) N = S-1;
        if (!S || S < 0 || (N < 0)) return false;
        if (N > S) N = S-1;

        return ARRAY._latinSquare(S, N, false);
    };

    /**
     * ## ARRAY.generateCombinations
     *
     * Generates all distinct combinations of exactly r elements each
     *
     * @param {array} array The array from which the combinations are extracted
     * @param {number} r The number of elements in each combination
     *
     * @return {array} The total sets of combinations
     *
     * @see ARRAY.getGroupSizeN
     * @see ARRAY.getNGroups
     * @see ARRAY.matchN
     *
     * Kudos: http://rosettacode.org/wiki/Combinations#JavaScript
     */
    ARRAY.generateCombinations = function combinations(arr, k) {
        var i, subI, ret, sub, next;
        ret = [];
        for (i = 0; i < arr.length; i++) {
            if (k === 1) {
                ret.push( [ arr[i] ] );
            }
            else {
                sub = combinations(arr.slice(i+1, arr.length), k-1);
                for (subI = 0; subI < sub.length; subI++ ){
                    next = sub[subI];
                    next.unshift(arr[i]);
                    ret.push( next );
                }
            }
        }
        return ret;
    };

    /**
     * ## ARRAY.matchN
     *
     * Match each element of the array with N random others
     *
     * If strict is equal to true, elements cannot be matched multiple times.
     *
     * *Important*: this method has a bug / feature. If the strict parameter
     * is set, the last elements could remain without match, because all the
     * other have been already used. Another recombination would be able
     * to match all the elements instead.
     *
     * @param {array} array The array in which operate the matching
     * @param {number} N The number of matches per element
     * @param {boolean} strict Optional. If TRUE, matched elements cannot be
     *   repeated. Defaults, FALSE
     *
     * @return {array} The results of the matching
     *
     * @see ARRAY.getGroupSizeN
     * @see ARRAY.getNGroups
     * @see ARRAY.generateCombinations
     */
    ARRAY.matchN = function(array, N, strict) {
        var result, i, copy, group, len, found;
        if (!array) return;
        if (!N) return array;

        result = [];
        len = array.length;
        found = [];
        for (i = 0 ; i < len ; i++) {
            // Recreate the array.
            copy = array.slice(0);
            copy.splice(i,1);
            if (strict) {
                copy = ARRAY.arrayDiff(copy,found);
            }
            group = ARRAY.getNRandom(copy,N);
            // Add to the set of used elements.
            found = found.concat(group);
            // Re-add the current element.
            group.splice(0,0,array[i]);
            result.push(group);

            // Update.
            group = [];
        }
        return result;
    };

    /**
     * ## ARRAY.rep
     *
     * Appends an array to itself a number of times and return a new array
     *
     * The original array is not modified.
     *
     * @param {array|mixed} array the array to repeat. If not an array, it
     *   it will be made an array.
     * @param {number} times The number of times the array must be appended
     *   to itself
     *
     * @return {array} A copy of the original array appended to itself
     */
    ARRAY.rep = function(array, times) {
        var i, result;
        if (!ARRAY.isArray(array)) array = [ array ];
        if (!times) return array.slice(0);
        if (times < 1) {
            JSUS.log('times must be greater or equal 1', 'ERR');
            return;
        }
        i = 1;
        result = array.slice(0);
        for (; i < times; i++) {
            result = result.concat(array);
        }
        return result;
    };

    /**
     * ## ARRAY.stretch
     *
     * Repeats each element of the array N times
     *
     * N can be specified as an integer or as an array. In the former case all
     * the elements are repeat the same number of times. In the latter, each
     * element can be repeated a custom number of times. If the length of the
     * `times` array differs from that of the array to stretch a recycle rule
     * is applied.
     *
     * The original array is not modified.
     *
     * E.g.:
     *
     * ```js
     *  var foo = [1,2,3];
     *
     *  ARRAY.stretch(foo, 2); // [1, 1, 2, 2, 3, 3]
     *
     *  ARRAY.stretch(foo, [1,2,3]); // [1, 2, 2, 3, 3, 3];
     *
     *  ARRAY.stretch(foo, [2,1]); // [1, 1, 2, 3, 3];
     * ```
     *
     * @param {array} array the array to strech
     * @param {number|array} times The number of times each element
     *   must be repeated
     * @return {array} A stretched copy of the original array
     */
    ARRAY.stretch = function(array, times) {
        var result, i, repeat, j;
        if (!array) return;
        if (!times) return array.slice(0);
        if ('number' === typeof times) {
            if (times < 1) {
                JSUS.log('times must be greater or equal 1', 'ERR');
                return;
            }
            times = ARRAY.rep([times], array.length);
        }

        result = [];
        for (i = 0; i < array.length; i++) {
            repeat = times[(i % times.length)];
            for (j = 0; j < repeat ; j++) {
                result.push(array[i]);
            }
        }
        return result;
    };


    /**
     * ## ARRAY.arrayIntersect
     *
     * Computes the intersection between two arrays
     *
     * Arrays can contain both primitive types and objects.
     *
     * @param {array} a1 The first array
     * @param {array} a2 The second array
     * @return {array} All the values of the first array that are found
     *   also in the second one
     */
    ARRAY.arrayIntersect = function(a1, a2) {
        return a1.filter( function(i) {
            return JSUS.inArray(i, a2);
        });
    };

    /**
     * ## ARRAY.arrayDiff
     *
     * Performs a diff between two arrays
     *
     * Arrays can contain both primitive types and objects.
     *
     * @param {array} a1 The first array
     * @param {array} a2 The second array
     * @return {array} All the values of the first array that are not
     *   found in the second one
     */
    ARRAY.arrayDiff = function(a1, a2) {
        return a1.filter( function(i) {
            return !(JSUS.inArray(i, a2));
        });
    };

    /**
     * ## ARRAY.shuffle
     *
     * Shuffles the elements of the array using the Fischer algorithm
     *
     * The original array is not modified, and a copy is returned.
     *
     * @param {array} shuffle The array to shuffle
     *
     * @return {array} copy The shuffled array
     *
     * @see http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
     */
    ARRAY.shuffle = function(array) {
        var copy, len, j, tmp, i;
        if (!array) return;
        copy = Array.prototype.slice.call(array);
        len = array.length-1; // ! -1
        for (i = len; i > 0; i--) {
            j = Math.floor(Math.random()*(i+1));
            tmp = copy[j];
            copy[j] = copy[i];
            copy[i] = tmp;
        }
        return copy;
    };

    /**
     * ## ARRAY.getNRandom
     *
     * Select N random elements from the array and returns them
     *
     * @param {array} array The array from which extracts random elements
     * @paran {number} N The number of random elements to extract
     *
     * @return {array} An new array with N elements randomly chosen
     */
    ARRAY.getNRandom = function(array, N) {
        return ARRAY.shuffle(array).slice(0,N);
    };

    /**
     * ## ARRAY.distinct
     *
     * Removes all duplicates entries from an array and returns a copy of it
     *
     * Does not modify original array.
     *
     * Comparison is done with `JSUS.equals`.
     *
     * @param {array} array The array from which eliminates duplicates
     *
     * @return {array} A copy of the array without duplicates
     *
     * @see JSUS.equals
     */
    ARRAY.distinct = function(array) {
        var out = [];
        if (!array) return out;

        ARRAY.each(array, function(e) {
            if (!ARRAY.inArray(e, out)) {
                out.push(e);
            }
        });
        return out;
    };

    /**
     * ## ARRAY.transpose
     *
     * Transposes a given 2D array.
     *
     * The original array is not modified, and a new copy is
     * returned.
     *
     * @param {array} array The array to transpose
     *
     * @return {array} The Transposed Array
     */
    ARRAY.transpose = function(array) {
        if (!array) return;

        // Calculate width and height
        var w, h, i, j, t = [];
        w = array.length || 0;
        h = (ARRAY.isArray(array[0])) ? array[0].length : 0;
        if (w === 0 || h === 0) return t;

        for ( i = 0; i < h; i++) {
            t[i] = [];
            for ( j = 0; j < w; j++) {
                t[i][j] = array[j][i];
            }
        }
        return t;
    };

    JSUS.extend(ARRAY);

})('undefined' !== typeof JSUS ? JSUS : module.parent.exports.JSUS);

/**
 * # DOM
 * Copyright(c) 2019 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Helper library to perform generic operation with DOM elements.
 */
(function(JSUS) {

    "use strict";

    var onFocusChange, changeTitle;

    function DOM() {}

    // ## GET/ADD

    /**
     * ### DOM.get
     *
     * Creates a generic HTML element with specified attributes
     *
     * @param {string} elem The name of the tag
     * @param {object|string} attributes Optional. Object containing
     *   attributes for the element. If string, the id of the element. If
     *   the request element is an 'iframe', the `name` attribute is set
     *   equal to the `id` attribute.
     *
     * @return {HTMLElement} The newly created HTML element
     *
     * @see DOM.add
     * @see DOM.addAttributes
     */
    DOM.get = function(name, attributes) {
        var el;
        el = document.createElement(name);
        if ('string' === typeof attributes) el.id = attributes;
        else if (attributes) this.addAttributes(el, attributes);
        // For firefox, name of iframe must be set as well.
        if (name === 'iframe' && el.id && !el.name) el.name = el.id;
        return el;
    };

    /**
     * ### DOM.add|append
     *
     * Creates and append an element with specified attributes to a root
     *
     * @param {string} name The name of the HTML tag
     * @param {HTMLElement} root The root element to which the new element
     *   will be appended
     * @param {object|string} options Optional. Object containing
     *   attributes for the element and rules about how to insert it relative
     *   to root. Available options: insertAfter, insertBefore (default:
     *   child of root). If string, it is the id of the element. Examples:
     *
     * ```javascript
     * // Appends a new new to the body.
     * var div = DOM.add('div', document.body);
     * // Appends a new new to the body with id 'myid'.
     * var div1 = DOM.add('div', document.body, 'myid');
     * // Appends a new new to the body with id 'myid2' and class name 'c'.
     * var div2 = DOM.add('div', document.body, { id: 'myid2', className: 'c'});
     * // Appends a new div after div1 with id 'myid'.
     * var div3 = DOM.add('div', div1, { id: 'myid3', insertAfter: true });
     * // Appends a new div before div2 with id 'myid'.
     * var div3 = DOM.add('div', div2, { id: 'myid3', insertBefore: true });
     * ```
     *
     * @return {HTMLElement} The newly created HTML element
     *
     * @see DOM.get
     * @see DOM.addAttributes
     */
    DOM.add = DOM.append = function(name, root, options) {
        var el;
        el = this.get(name, options);
        if (options && options.insertBefore) {
            if (options.insertAfter) {
                throw new Error('DOM.add: options.insertBefore and ' +
                                'options.insertBefore cannot be ' +
                                'both set.');
            }
            if (!root.parentNode) {
                throw new Error('DOM.add: root.parentNode not found. ' +
                                'Cannot insert before.');
            }
            root.parentNode.insertBefore(el, root);
        }
        else if (options && options.insertAfter) {
            if (!root.parentNode) {
                throw new Error('DOM.add: root.parentNode not found. ' +
                                'Cannot insert after.');
            }
            DOM.insertAfter(el, root);
        }
        else {
            root.appendChild(el);
        }
        return el;
    };

    /**
     * ### DOM.addAttributes
     *
     * Adds attributes to an HTML element and returns it
     *
     * Attributes are defined as key-values pairs and added
     *
     * Special cases:
     *
     *   - 'className': alias for class
     *   - 'class': add a class to the className property (does not overwrite)
     *   - 'style': adds property to the style property (see DOM.style)
     *   - 'id': the id of the element
     *   - 'innerHTML': the innerHTML property of the element (overwrites)
     *   - 'insertBefore': ignored
     *   - 'insertAfter': ignored
     *
     * @param {HTMLElement} elem The element to decorate
     * @param {object} attributes Object containing attributes to
     *   add to the element
     *
     * @return {HTMLElement} The element with speficied attributes added
     *
     * @see DOM.addClass
     * @see DOM.style
     */
     DOM.addAttributes = function(elem, attributes) {
        var key;
        if (!DOM.isElement(elem)) {
            throw new TypeError('DOM.addAttributes: elem must be ' +
                                'HTMLElement. Found: ' + elem);
        }
        if ('undefined' === typeof attributes) return elem;
        if ('object' !== typeof attributes) {
            throw new TypeError('DOM.addAttributes: attributes must be ' +
                                'object or undefined. Found: ' + attributes);
        }
        for (key in attributes) {
            if (attributes.hasOwnProperty(key)) {
                if (key === 'id' || key === 'innerHTML') {
                    elem[key] = attributes[key];
                }
                else if (key === 'class' || key === 'className') {
                    DOM.addClass(elem, attributes[key]);
                }
                else if (key === 'style') {
                    DOM.style(elem, attributes[key]);
                }
                else if (key !== 'insertBefore' && key !== 'insertAfter') {
                    elem.setAttribute(key, attributes[key]);
                }
            }
        }
        return elem;
    };

    // ## WRITE

    /**
     * ### DOM.write
     *
     * Write a text, or append an HTML element or node, into a root element
     *
     * @param {HTMLElement} root The HTML element where to write into
     * @param {string|HTMLElement} text The text to write or an element
     *    to append. Default: an ampty string
     *
     * @return {TextNode} The text node inserted in the root element
     *
     * @see DOM.writeln
     */
    DOM.write = function(root, text) {
        var content;
        if ('undefined' === typeof text || text === null) text = "";
        if (JSUS.isNode(text) || JSUS.isElement(text)) content = text;
        else content = document.createTextNode(text);
        root.appendChild(content);
        return content;
    };

    /**
     * ### DOM.writeln
     *
     * Write a text and a break into a root element
     *
     * Default break element is <br> tag
     *
     * @param {HTMLElement} root The HTML element where to write into
     * @param {string|HTMLElement} text The text to write or an element
     *    to append. Default: an ampty string
     * @param {string} rc the name of the tag to use as a break element
     *
     * @return {TextNode} The text node inserted in the root element
     *
     * @see DOM.write
     */
    DOM.writeln = function(root, text, rc) {
        var content;
        content = DOM.write(root, text);
        this.add(rc || 'br', root);
        return content;
    };

    /**
     * ### DOM.sprintf
     *
     * Builds up a decorated HTML text element
     *
     * Performs string substitution from an args object where the first
     * character of the key bears the following semantic:
     *
     * - '@': variable substitution with escaping
     * - '!': variable substitution without variable escaping
     * - '%': wraps a portion of string into a _span_ element to which is
     *        possible to associate a css class or id. Alternatively,
     *        it also possible to add in-line style. E.g.:
     *
     * ```javascript
     *      sprintf('%sImportant!%s An error has occurred: %pre@err%pre', {
     *              '%pre': {
     *                      style: 'font-size: 12px; font-family: courier;'
     *              },
     *              '%s': {
     *                      id: 'myId',
     *                      'class': 'myClass',
     *              },
     *              '@err': 'file not found',
     *      }, document.body);
     * ```
     *
     * Special span elements are %strong and %em, which add
     * respectively a _strong_ and _em_ tag instead of the default
     * _span_ tag. They cannot be styled.
     *
     * @param {string} string A text to transform
     * @param {object} args Optional. An object containing string
     *   transformations
     * @param {Element} root Optional. An HTML element to which append the
     *    string. Defaults, a new _span_ element
     *
     * @return {Element} The root element.
     */
    DOM.sprintf = function(string, args, root) {

        var text, span, idx_start, idx_finish, idx_replace, idxs;
        var spans, key, i;

        root = root || document.createElement('span');
        spans = {};

        // Create an args object, if none is provided.
        // Defaults %em and %strong are added.
        args = args || {};
        args['%strong'] = '';
        args['%em'] = '';

        // Transform arguments before inserting them.
        for (key in args) {
            if (args.hasOwnProperty(key)) {

                switch(key.charAt(0)) {

                case '%': // Span/Strong/Emph .

                    idx_start = string.indexOf(key);

                    // Pattern not found. No error.
                    if (idx_start === -1) continue;

                    idx_replace = idx_start + key.length;
                    idx_finish = string.indexOf(key, idx_replace);

                    if (idx_finish === -1) {
                        JSUS.log('Error. Could not find closing key: ' + key);
                        continue;
                    }

                    // Can be strong, emph or a generic span.
                    spans[idx_start] = key;

                    break;

                case '@': // Replace and sanitize.
                    string = string.replace(key, escape(args[key]));
                    break;

                case '!': // Replace and not sanitize.
                    string = string.replace(key, args[key]);
                    break;

                default:
                    JSUS.log('Identifier not in [!,@,%]: ' + key[0]);

                }
            }
        }

        // No span to create, return what we have.
        if (!JSUS.size(spans)) {
            return root.appendChild(document.createTextNode(string));
        }

        // Re-assamble the string.

        idxs = JSUS.keys(spans).sort(function(a, b){ return a - b; });
        idx_finish = 0;
        for (i = 0; i < idxs.length; i++) {

            // Add span.
            key = spans[idxs[i]];
            idx_start = string.indexOf(key);

            // Add fragments of string.
            if (idx_finish !== idx_start-1) {
                root.appendChild(document.createTextNode(
                    string.substring(idx_finish, idx_start)));
            }

            idx_replace = idx_start + key.length;
            idx_finish = string.indexOf(key, idx_replace);

            if (key === '%strong') {
                span = document.createElement('strong');
            }
            else if (key === '%em') {
                span = document.createElement('em');
            }
            else {
                span = DOM.get('span', args[key]);
            }

            text = string.substring(idx_replace, idx_finish);

            span.appendChild(document.createTextNode(text));

            root.appendChild(span);
            idx_finish = idx_finish + key.length;
        }

        // Add the final part of the string.
        if (idx_finish !== string.length) {
            root.appendChild(document.createTextNode(
                string.substring(idx_finish)));
        }

        return root;
    };

    // ## ELEMENTS

    /**
     * ### DOM.isNode
     *
     * Returns TRUE if the object is a DOM node
     *
     * @param {mixed} The variable to check
     *
     * @return {boolean} TRUE, if the the object is a DOM node
     */
    DOM.isNode = function(o) {
        if (!o || 'object' !== typeof o) return false;
        return 'object' === typeof Node ? o instanceof Node :
            'number' === typeof o.nodeType &&
            'string' === typeof o.nodeName;
    };

    /**
     * ### DOM.isElement
     *
     * Returns TRUE if the object is a DOM element
     *
     * Notice: instanceof HTMLElement is not reliable in Safari, even if
     * the method is defined.
     *
     * @param {mixed} The variable to check
     *
     * @return {boolean} TRUE, if the the object is a DOM element
     */
    DOM.isElement = function(o) {
        return o && 'object' === typeof o && o.nodeType === 1 &&
            'string' === typeof o.nodeName;
    };

    /**
     * ### DOM.shuffleElements
     *
     * Shuffles the order of children of a parent Element
     *
     * All children *must* have the id attribute (live list elements cannot
     * be identified by position).
     *
     * Notice the difference between Elements and Nodes:
     *
     * http://stackoverflow.com/questions/7935689/
     * what-is-the-difference-between-children-and-childnodes-in-javascript
     *
     * @param {Node} parent The parent node
     * @param {array} order Optional. A pre-specified order. Defaults, random
     * @param {function} cb Optional. A callback to execute one each shuffled
     *   element (after re-positioning). This is always the last parameter,
     *   so if order is omitted, it goes second. The callback takes as input:
     *     - the element
     *     - the new order
     *     - the old order
     *
     *
     * @return {array} The order used to shuffle the nodes
     */
    DOM.shuffleElements = function(parent, order, cb) {
        var i, len, numOrder, idOrder, children, child;
        var id;
        if (!JSUS.isNode(parent)) {
            throw new TypeError('DOM.shuffleElements: parent must be a node. ' +
                               'Found: ' + parent);
        }
        if (!parent.children || !parent.children.length) {
            JSUS.log('DOM.shuffleElements: parent has no children.', 'ERR');
            return false;
        }
        if (order) {
            if ('undefined' === typeof cb && 'function' === typeof order) {
                cb = order;
            }
            else {
                if (!JSUS.isArray(order)) {
                    throw new TypeError('DOM.shuffleElements: order must be ' +
                                        'array. Found: ' + order);
                }
                if (order.length !== parent.children.length) {
                    throw new Error('DOM.shuffleElements: order length must ' +
                                    'match the number of children nodes.');
                }
            }
        }
        if (cb && 'function' !== typeof cb) {
            throw new TypeError('DOM.shuffleElements: order must be ' +
                                'array. Found: ' + order);
        }

        // DOM4 compliant browsers.
        children = parent.children;

        //https://developer.mozilla.org/en/DOM/Element.children
        //[IE lt 9] IE < 9
        if ('undefined' === typeof children) {
            child = this.firstChild;
            while (child) {
                if (child.nodeType == 1) children.push(child);
                child = child.nextSibling;
            }
        }

        // Get all ids.
        len = children.length;
        idOrder = new Array(len);
        if (cb) numOrder = new Array(len);
        if (!order) order = JSUS.sample(0, (len-1));
        for (i = 0 ; i < len; i++) {
            id = children[order[i]].id;
            if ('string' !== typeof id || id === "") {
                throw new Error('DOM.shuffleElements: no id found on ' +
                                'child n. ' + order[i]);
            }
            idOrder[i] = id;
            if (cb) numOrder[i] = order[i];
        }

        // Two fors are necessary to follow the real sequence (Live List).
        // However, parent.children is a special object, so the sequence
        // could be unreliable.
        for (i = 0 ; i < len; i++) {
            parent.appendChild(children[idOrder[i]]);
            if (cb) cb(children[idOrder[i]], i, numOrder[i]);
        }
        return idOrder;
    };

    /**
     * ### DOM.populateSelect
     *
     * Appends a list of options into a HTML select element
     *
     * @param {HTMLElement} select HTML select element
     * @param {object} options Optional. List of options to add to
     *   the select element. List is in the format of key-values pairs
     *   as innerHTML and value attributes of the option.
     *
     * @return {HTMLElement} select The updated select element
     */
    DOM.populateSelect = function(select, options) {
        var key, opt;
        if (!DOM.isElement(select)) {
            throw new TypeError('DOM.populateSelect: select must be ' +
                                'HTMLElement. Found: ' + select);
        }
        if (options) {
            if ('object' !== typeof options) {
                throw new TypeError('DOM.populateSelect: options must be ' +
                                    'object or undefined. Found: ' + options);
            }
            for (key in options) {
                if (options.hasOwnProperty(key)) {
                    opt = document.createElement('option');
                    opt.value = key;
                    opt.innerHTML = options[key];
                    select.appendChild(opt);
                }
            }
        }
        return select;
    };

    /**
     * ### DOM.removeChildrenFromNode
     *
     * Removes all children from a node
     *
     * @param {HTMLNode} node HTML node.
     */
    DOM.removeChildrenFromNode = function(node) {
        while (node.hasChildNodes()) {
            node.removeChild(node.firstChild);
        }
    };

    /**
     * ### DOM.insertAfter
     *
     * Inserts a node element after another one
     *
     * @param {Node} node The node element to insert
     * @param {Node} referenceNode The node element after which the
     *   the insertion is performed
     *
     * @return {Node} The inserted node
     */
    DOM.insertAfter = function(node, referenceNode) {
        return referenceNode.insertBefore(node, referenceNode.nextSibling);
    };

    // ## CSS / JS

    /**
     * ### DOM.addCSS
     *
     * Adds a CSS link to the page
     *
     * @param {string} cssPath The path to the css
     * @param {HTMLElement} root Optional. The root element. If no root
     *    element is passed, it tries document.head, document.body, and
     *    document. If it fails, it throws an error.
     * @param {object|string} attributes Optional. Object containing
     *   attributes for the element. If string, the id of the element
     *
     * @return {HTMLElement} The link element
     */
    DOM.addCSS = function(cssPath, root, attributes) {
        if ('string' !== typeof cssPath || cssPath.trim() === '') {
            throw new TypeError('DOM.addCSS: cssPath must be a non-empty ' +
                                'string. Found: ' + cssPath);
        }
        root = root || document.head || document.body || document;
        if (!root) {
            throw new Error('DOM.addCSS: root is undefined, and could not ' +
                            'detect a valid root for css: ' + cssPath);
        }
        attributes = JSUS.mixin({
            rel : 'stylesheet',
            type: 'text/css',
            href: cssPath
        }, attributes);
        return this.add('link', root, attributes);
    };

    /**
     * ### DOM.addJS
     *
     * Adds a JavaScript script to the page
     *
     * @param {string} cssPath The path to the css
     * @param {HTMLElement} root Optional. The root element. If no root
     *    element is passed, it tries document.head, document.body, and
     *    document. If it fails, it throws an error.
     * @param {object|string} attributes Optional. Object containing
     *   attributes for the element. If string, the id of the element
     *
     * @return {HTMLElement} The link element
     *
     */
    DOM.addJS = function(jsPath, root, attributes) {
        if ('string' !== typeof jsPath || jsPath.trim() === '') {
            throw new TypeError('DOM.addCSS: jsPath must be a non-empty ' +
                                'string. Found: ' + jsPath);
        }
        root = root || document.head || document.body || document;
        if (!root) {
            throw new Error('DOM.addCSS: root is undefined, and could not ' +
                            'detect a valid root for css: ' + jsPath);
        }
        attributes = JSUS.mixin({
            charset : 'utf-8',
            type: 'text/javascript',
            src: jsPath
        }, attributes);
        return this.add('script', root, attributes);
    };

    // ## STYLE

    /**
     * ### DOM.highlight
     *
     * Highlights an element by adding a custom border around it
     *
     * Three pre-defined modes are implemented:
     *
     * - OK: green
     * - WARN: yellow
     * - ERR: red (default)
     *
     * Alternatively, it is possible to specify a custom
     * color as HEX value. Examples:
     *
     * ```javascript
     * highlight(myDiv, 'WARN');  // yellow border
     * highlight(myDiv);          // red border
     * highlight(myDiv, '#CCC');  // grey border
     * ```
     *
     * @param {HTMLElement} elem The element to highlight
     * @param {string} code The type of highlight
     *
     * @return {HTMLElement} elem The styled element
     *
     * @see DOM.addBorder
     * @see DOM.style
     */
    DOM.highlight = function(elem, code) {
        var color;
        // Default value is ERR.
        switch (code) {
        case 'OK':
            color =  'green';
            break;
        case 'WARN':
            color = 'yellow';
            break;
        case 'ERR':
            color = 'red';
            break;
        default:
            if (code.charAt(0) === '#') color = code;
            else color = 'red';
        }
        return this.addBorder(elem, color);
    };

    /**
     * ### DOM.addBorder
     *
     * Adds a border around the specified element
     *
     * @param {HTMLElement} elem The element to which adding the borders
     * @param {string} color Optional. The color of border. Default: 'red'.
     * @param {string} width Optional. The width of border. Default: '5px'.
     * @param {string} type Optional. The type of border. Default: 'solid'.
     *
     * @return {HTMLElement} The element to which a border has been added
     */
    DOM.addBorder = function(elem, color, width, type) {
        var properties;
        color = color || 'red';
        width = width || '5px';
        type = type || 'solid';
        properties = { border: width + ' ' + type + ' ' + color };
        return DOM.style(elem, properties);
    };

    /**
     * ### DOM.style
     *
     * Styles an element as an in-line css.
     *
     * Existing style properties are maintained, and new ones added.
     *
     * @param {HTMLElement} elem The element to style
     * @param {object} Objects containing the properties to add.
     *
     * @return {HTMLElement} The styled element
     */
    DOM.style = function(elem, properties) {
        var i;
        if (!DOM.isElement(elem)) {
            throw new TypeError('DOM.style: elem must be HTMLElement. ' +
                                'Found: ' + elem);
        }
        if (properties) {
            if ('object' !== typeof properties) {
                throw new TypeError('DOM.style: properties must be object or ' +
                                    'undefined. Found: ' + properties);
            }
            for (i in properties) {
                if (properties.hasOwnProperty(i)) {
                    elem.style[i] = properties[i];
                }
            }
        }
        return elem;
    };

    // ## ID

    /**
     * ### DOM.generateUniqueId
     *
     * Generates a unique id for the whole page, frames included
     *
     * The resulting id is of the type: prefix_randomdigits.
     *
     * @param {string} prefix Optional. A given prefix. Default: a random
     *   string of 8 characters.
     * @param {boolean} checkFrames Optional. If TRUE, the id will be unique
     *   all frames as well. Default: TRUE
     *
     * @return {string} id The unique id
     */
    DOM.generateUniqueId = (function() {
        var limit;
        limit = 100;

        // Returns TRUE if id is NOT found in all docs (optimized).
        function scanDocuments(docs, id) {
            var i, len;
            len = docs.length;
            if (len === 1) {
                return !docs[0].document.getElementById(id);
            }
            if (len === 2) {
                return !!(docs[0].document.getElementById(id) &&
                          docs[1].document.getElementById(id));
            }
            i = -1;
            for ( ; ++i < len ; ) {
                if (docs[i].document.getElementById(id)) return false;
            }
            return true;
        }

        return function(prefix, checkFrames) {
            var id, windows;
            var found, counter;

            if (prefix) {
                if ('string' !== typeof prefix && 'number' !== typeof prefix) {
                    throw new TypeError('DOM.generateUniqueId: prefix must ' +
                                        'be string or number. Found: ' +
                                        prefix);
                }
            }
            else {
                prefix = JSUS.randomString(8, 'a');
            }
            id = prefix + '_';

            windows = [ window ];
            if ((checkFrames || 'undefined' === typeof checkFrames) &&
                window.frames) {

                windows = windows.concat(window.frames);
            }

            found = true;
            counter = -1;
            while (found) {
                id = prefix + '_' + JSUS.randomInt(1000);
                found = scanDocuments(windows, id);
                if (++counter > limit) {
                    throw new Error('DOM.generateUniqueId: could not ' +
                                    'find unique id within ' + limit +
                                    ' trials.');
                }
            }
            return id;
        };
    })();

    // ## CLASSES

    /**
     * ### DOM.removeClass
     *
     * Removes a specific class from the className attribute of a given element
     *
     * @param {HTMLElement|object} elem An HTML element, or an object with
     *   a className property if force is TRUE
     * @param {string} className The name of a CSS class already in the element
     * @param {boolean} force Optional. If TRUE, the method is applied also
     *   to non HTMLElements
     *
     * @return {HTMLElement|undefined} The HTML element with the removed
     *   class, or undefined if the inputs are misspecified
     */
    DOM.removeClass = function(elem, className, force) {
        var regexpr, o;
        if (!force && !DOM.isElement(elem)) {
            throw new TypeError('DOM.removeClass: elem must be HTMLElement. ' +
                                'Found: ' + elem);
        }
        if (className) {
            if ('string' !== typeof className || className.trim() === '') {
                throw new TypeError('DOM.removeClass: className must be ' +
                                    'HTMLElement. Found: ' + className);
            }
            regexpr = new RegExp('(?:^|\\s)' + className + '(?!\\S)');
            o = elem.className = elem.className.replace(regexpr, '' );
        }
        return elem;
    };

    /**
     * ### DOM.addClass
     *
     * Adds one or more classes to the className attribute of the given element
     *
     * Takes care not to overwrite already existing classes.
     *
     * @param {HTMLElement|object} elem An HTML element, or an object with
     *   a className property if force is TRUE
     * @param {string|array} className The name/s of CSS class/es
     * @param {boolean} force Optional. If TRUE, the method is applied also
     *   to non HTMLElements
     *
     * @return {HTMLElement} The HTML element with the additional
     *   class, or undefined if the inputs are misspecified
     */
    DOM.addClass = function(elem, className, force) {
        if (!force && !DOM.isElement(elem)) {
            throw new TypeError('DOM.addClass: elem must be HTMLElement. ' +
                                'Found: ' + elem);
        }
        if (className) {
            if (className instanceof Array) className = className.join(' ');
            if ('string' !== typeof className || className.trim() === '') {
                throw new TypeError('DOM.addClass: className must be ' +
                                    'HTMLElement. Found: ' + className);
            }
            if (!elem.className) elem.className = className;
            else elem.className += (' ' + className);
        }
        return elem;
    };

    /**
     * ### DOM.getElementsByClassName
     *
     * Returns an array of elements with requested class name
     *
     * @param {object} document The document object of a window or iframe
     * @param {string} className The requested className
     * @param {string}  nodeName Optional. If set only elements with
     *   the specified tag name will be searched
     *
     * @return {array} Array of elements with the requested class name
     *
     * @see https://gist.github.com/E01T/6088383
     * @see http://stackoverflow.com/
     *      questions/8808921/selecting-a-css-class-with-xpath
     */
    DOM.getElementsByClassName = function(document, className, nodeName) {
        var result, node, tag, seek, i, rightClass;
        result = [];
        tag = nodeName || '*';
        if (document.evaluate) {
            seek = '//' + tag +
                '[contains(concat(" ", normalize-space(@class), " "), "' +
                className + ' ")]';
            seek = document.evaluate(seek, document, null, 0, null );
            while ((node = seek.iterateNext())) {
                result.push(node);
            }
        }
        else {
            rightClass = new RegExp( '(^| )'+ className +'( |$)' );
            seek = document.getElementsByTagName(tag);
            for (i = 0; i < seek.length; i++)
                if (rightClass.test((node = seek[i]).className )) {
                    result.push(seek[i]);
                }
        }
        return result;
    };

    // ## IFRAME

    /**
     * ### DOM.getIFrameDocument
     *
     * Returns a reference to the document of an iframe object
     *
     * @param {HTMLIFrameElement} iframe The iframe object
     *
     * @return {HTMLDocument|null} The document of the iframe, or
     *   null if not found.
     */
    DOM.getIFrameDocument = function(iframe) {
        if (!iframe) return null;
        return iframe.contentDocument ||
            iframe.contentWindow ? iframe.contentWindow.document : null;
    };

    /**
     * ### DOM.getIFrameAnyChild
     *
     * Gets the first available child of an IFrame
     *
     * Tries head, body, lastChild and the HTML element
     *
     * @param {HTMLIFrameElement} iframe The iframe object
     *
     * @return {HTMLElement|undefined} The child, or undefined if none is found
     */
    DOM.getIFrameAnyChild = function(iframe) {
        var contentDocument;
        if (!iframe) return;
        contentDocument = DOM.getIFrameDocument(iframe);
        return contentDocument.head || contentDocument.body ||
            contentDocument.lastChild ||
            contentDocument.getElementsByTagName('html')[0];
    };

    // ## EVENTS

    /**
     * ### DOM.addEvent
     *
     * Adds an event listener to an element (cross-browser)
     *
     * @param {Element} element A target element
     * @param {string} event The name of the event to handle
     * @param {function} func The event listener
     * @param {boolean} Optional. If TRUE, the event will initiate a capture.
     *   Available only in some browsers. Default, FALSE
     *
     * @return {boolean} TRUE, on success. However, the return value is
     *   browser dependent.
     *
     * @see DOM.removeEvent
     *
     * Kudos:
     * http://stackoverflow.com/questions/6348494/addeventlistener-vs-onclick
     */
    DOM.addEvent = function(element, event, func, capture) {
        capture = !!capture;
        if (element.attachEvent) return element.attachEvent('on' + event, func);
        else return element.addEventListener(event, func, capture);
    };

    /**
     * ### DOM.removeEvent
     *
     * Removes an event listener from an element (cross-browser)
     *
     * @param {Element} element A target element
     * @param {string} event The name of the event to remove
     * @param {function} func The event listener
     * @param {boolean} Optional. If TRUE, the event was registered
     *   as a capture. Available only in some browsers. Default, FALSE
     *
     * @return {boolean} TRUE, on success. However, the return value is
     *   browser dependent.
     *
     * @see DOM.addEvent
     */
    DOM.removeEvent = function(element, event, func, capture) {
        capture = !!capture;
        if (element.detachEvent) return element.detachEvent('on' + event, func);
        else return element.removeEventListener(event, func, capture);
    };

    /**
     * ### DOM.onFocusIn
     *
     * Registers a callback to be executed when the page acquires focus
     *
     * @param {function|null} cb Callback executed if page acquires focus,
     *   or NULL, to delete an existing callback.
     * @param {object|function} ctx Optional. Context of execution for cb
     *
     * @see onFocusChange
     */
    DOM.onFocusIn = function(cb, ctx) {
        var origCb;
        if ('function' !== typeof cb && null !== cb) {
            throw new TypeError('JSUS.onFocusIn: cb must be function or null.');
        }
        if (ctx) {
            if ('object' !== typeof ctx && 'function' !== typeof ctx) {
                throw new TypeError('JSUS.onFocusIn: ctx must be object, ' +
                                    'function or undefined.');
            }
            origCb = cb;
            cb = function() { origCb.call(ctx); };
        }

        onFocusChange(cb);
    };

    /**
     * ### DOM.onFocusOut
     *
     * Registers a callback to be executed when the page loses focus
     *
     * @param {function} cb Callback executed if page loses focus,
     *   or NULL, to delete an existing callback.
     * @param {object|function} ctx Optional. Context of execution for cb
     *
     * @see onFocusChange
     */
    DOM.onFocusOut = function(cb, ctx) {
        var origCb;
        if ('function' !== typeof cb && null !== cb) {
            throw new TypeError('JSUS.onFocusOut: cb must be ' +
                                'function or null.');
        }
        if (ctx) {
            if ('object' !== typeof ctx && 'function' !== typeof ctx) {
                throw new TypeError('JSUS.onFocusIn: ctx must be object, ' +
                                    'function or undefined.');
            }
            origCb = cb;
            cb = function() { origCb.call(ctx); };
        }
        onFocusChange(undefined, cb);
    };

    // ## UI

    /**
     * ### DOM.disableRightClick
     *
     * Disables the popup of the context menu by right clicking with the mouse
     *
     * @param {Document} Optional. A target document object. Defaults, document
     *
     * @see DOM.enableRightClick
     */
    DOM.disableRightClick = function(doc) {
        doc = doc || document;
        if (doc.layers) {
            doc.captureEvents(Event.MOUSEDOWN);
            doc.onmousedown = function clickNS4(e) {
                if (doc.layers || doc.getElementById && !doc.all) {
                    if (e.which == 2 || e.which == 3) {
                        return false;
                    }
                }
            };
        }
        else if (doc.all && !doc.getElementById) {
            doc.onmousedown = function clickIE4() {
                if (event.button == 2) {
                    return false;
                }
            };
        }
        doc.oncontextmenu = function() { return false; };
    };

    /**
     * ### DOM.enableRightClick
     *
     * Enables the popup of the context menu by right clicking with the mouse
     *
     * It unregisters the event handlers created by `DOM.disableRightClick`
     *
     * @param {Document} Optional. A target document object. Defaults, document
     *
     * @see DOM.disableRightClick
     */
    DOM.enableRightClick = function(doc) {
        doc = doc || document;
        if (doc.layers) {
            doc.releaseEvents(Event.MOUSEDOWN);
            doc.onmousedown = null;
        }
        else if (doc.all && !doc.getElementById) {
            doc.onmousedown = null;
        }
        doc.oncontextmenu = null;
    };

    /**
     * ### DOM.disableBackButton
     *
     * Disables/re-enables backward navigation in history of browsed pages
     *
     * When disabling, it inserts twice the current url.
     *
     * It will still be possible to manually select the uri in the
     * history pane and nagivate to it.
     *
     * @param {boolean} disable Optional. If TRUE disables back button,
     *   if FALSE, re-enables it. Default: TRUE.
     *
     * @return {boolean} The state of the back button (TRUE = disabled),
     *   or NULL if the method is not supported by browser.
     */
    DOM.disableBackButton = (function(isDisabled) {
        return function(disable) {
            disable = 'undefined' === typeof disable ? true : disable;
            if (disable && !isDisabled) {
                if (!history.pushState || !history.go) {
                    JSUS.log('DOM.disableBackButton: method not ' +
                             'supported by browser.');
                    return null;
                }
                history.pushState(null, null, location.href);
                window.onpopstate = function(event) {
                    history.go(1);
                };
            }
            else if (isDisabled) {
                window.onpopstate = null;
            }
            isDisabled = disable;
            return disable;
        };
    })(false);

    // ## EXTRA

    /**
     * ### DOM.playSound
     *
     * Plays a sound
     *
     * @param {various} sound Audio tag or path to audio file to be played
     */
    DOM.playSound = 'undefined' === typeof Audio ?
        function() {
            console.log('JSUS.playSound: Audio tag not supported in your' +
                    ' browser. Cannot play sound.');
        } :
        function(sound) {
        var audio;
        if ('string' === typeof sound) {
            audio = new Audio(sound);
        }
        else if ('object' === typeof sound &&
            'function' === typeof sound.play) {
            audio = sound;
        }
        else {
            throw new TypeError('JSUS.playSound: sound must be string' +
               ' or audio element.');
        }
        audio.play();
    };

    /**
     * ### DOM.blinkTitle
     *
     * Changes the title of the page in regular intervals
     *
     * Calling the function without any arguments stops the blinking
     * If an array of strings is provided, that array will be cycled through.
     * If a signle string is provided, the title will alternate between '!!!'
     *   and that string.
     *
     * @param {mixed} titles New title to blink
     * @param {object} options Optional. Configuration object.
     *   Accepted values and default in parenthesis:
     *
     *     - stopOnFocus (false): Stop blinking if user switched to tab
     *     - stopOnClick (false): Stop blinking if user clicks on the
     *         specified element
     *     - finalTitle (document.title): Title to set after blinking is done
     *     - repeatFor (undefined): Show each element in titles at most
     *         N times -- might be stopped earlier by other events.
     *     - startOnBlur(false): Start blinking if user switches
     *          away from tab
     *     - period (1000) How much time between two blinking texts in the title
     *
     * @return {function|null} A function to clear the blinking of texts,
     *    or NULL, if the interval was not created yet (e.g. with startOnBlur
     *    option), or just destroyed.
     */
    DOM.blinkTitle = (function(id) {
        var clearBlinkInterval, finalTitle, elem;
        clearBlinkInterval = function(opts) {
            clearInterval(id);
            id = null;
            if (elem) {
                elem.removeEventListener('click', clearBlinkInterval);
                elem = null;
            }
            if (finalTitle) {
                document.title = finalTitle;
                finalTitle = null;
            }
        };
        return function(titles, options) {
            var period, where, rotation;
            var rotationId, nRepeats;

            if (null !== id) clearBlinkInterval();
            if ('undefined' === typeof titles) return null;

            where = 'JSUS.blinkTitle: ';
            options = options || {};

            // Option finalTitle.
            if ('undefined' === typeof options.finalTitle) {
                finalTitle = document.title;
            }
            else if ('string' === typeof options.finalTitle) {
                finalTitle = options.finalTitle;
            }
            else {
                throw new TypeError(where + 'options.finalTitle must be ' +
                                    'string or undefined. Found: ' +
                                    options.finalTitle);
            }

            // Option repeatFor.
            if ('undefined' !== typeof options.repeatFor) {
                nRepeats = JSUS.isInt(options.repeatFor, 0);
                if (false === nRepeats) {
                    throw new TypeError(where + 'options.repeatFor must be ' +
                                        'a positive integer. Found: ' +
                                        options.repeatFor);
                }
            }

            // Option stopOnFocus.
            if (options.stopOnFocus) {
                JSUS.onFocusIn(function() {
                    clearBlinkInterval();
                    onFocusChange(null, null);
                });
            }

            // Option stopOnClick.
            if ('undefined' !== typeof options.stopOnClick) {
                if ('object' !== typeof options.stopOnClick ||
                    !options.stopOnClick.addEventListener) {

                    throw new TypeError(where + 'options.stopOnClick must be ' +
                                        'an HTML element with method ' +
                                        'addEventListener. Found: ' +
                                        options.stopOnClick);
                }
                elem = options.stopOnClick;
                elem.addEventListener('click', clearBlinkInterval);
            }

            // Option startOnBlur.
            if (options.startOnBlur) {
                options.startOnBlur = null;
                JSUS.onFocusOut(function() {
                    JSUS.blinkTitle(titles, options);
                });
                return null;
            }

            // Prepare the rotation.
            if ('string' === typeof titles) {
                titles = [titles, '!!!'];
            }
            else if (!JSUS.isArray(titles)) {
                throw new TypeError(where + 'titles must be string, ' +
                                    'array of strings or undefined. Found: ' +
                                    titles);
            }
            rotationId = 0;
            period = options.period || 1000;
            // Function to be executed every period.
            rotation = function() {
                changeTitle(titles[rotationId]);
                rotationId = (rotationId+1) % titles.length;
                // Control the number of times it should be cycled through.
                if ('number' === typeof nRepeats) {
                    if (rotationId === 0) {
                        nRepeats--;
                        if (nRepeats === 0) clearBlinkInterval();
                    }
                }
            };
            // Perform first rotation right now.
            rotation();
            id = setInterval(rotation, period);

            // Return clear function.
            return clearBlinkInterval;
        };
    })(null);

    /**
     * ### DOM.cookieSupport
     *
     * Tests for cookie support
     *
     * @return {boolean|null} The type of support for cookies. Values:
     *
     *   - null: no cookies
     *   - false: only session cookies
     *   - true: session cookies and persistent cookies (although
     *       the browser might clear them on exit)
     *
     * Kudos: http://stackoverflow.com/questions/2167310/
     *        how-to-show-a-message-only-if-cookies-are-disabled-in-browser
     */
    DOM.cookieSupport = function() {
        var c, persist;
        persist = true;
        do {
            c = 'gCStest=' + Math.floor(Math.random()*100000000);
            document.cookie = persist ? c +
                ';expires=Tue, 01-Jan-2030 00:00:00 GMT' : c;

            if (document.cookie.indexOf(c) !== -1) {
                document.cookie= c + ';expires=Sat, 01-Jan-2000 00:00:00 GMT';
                return persist;
            }
        } while (!(persist = !persist));

        return null;
    };

    /**
     * ### DOM.viewportSize
     *
     * Returns the current size of the viewport in pixels
     *
     * The viewport's size is the actual visible part of the browser's
     * window. This excludes, for example, the area occupied by the
     * JavaScript console.
     *
     * @param {string} dim Optional. Controls the return value ('x', or 'y')
     *
     * @return {object|number} An object containing x and y property, or
     *   number specifying the value for x or y
     *
     * Kudos: http://stackoverflow.com/questions/3437786/
     *        get-the-size-of-the-screen-current-web-page-and-browser-window
     */
    DOM.viewportSize = function(dim) {
        var w, d, e, g, x, y;
        if (dim && dim !== 'x' && dim !== 'y') {
            throw new TypeError('DOM.viewportSize: dim must be "x","y" or ' +
                                'undefined. Found: ' + dim);
        }
        w = window;
        d = document;
        e = d.documentElement;
        g = d.getElementsByTagName('body')[0];
        x = w.innerWidth || e.clientWidth || g.clientWidth;
        y = w.innerHeight|| e.clientHeight|| g.clientHeight;
        return !dim ? { x: x, y: y } : dim === 'x' ? x : y;
    };

    /**
     * ### DOM.makeTabbable
     *
     * Adds the tabindex property to an HTML element
     *
     * @param {HTMLElement} elem The element to make tabbable
     * @param {object} opts Optional. Configuration options, avalable:
     *    - index: the tabindex, default 0
     *    - clickable: if TRUE, calls DOM.makeClickable on the element.
     *      Default: FALSE
     *
     * @return {HTMLElement} The tabbable element
     */
    DOM.makeTabbable =  function(elem, opts) {
        opts = opts || {};
        elem.setAttribute('tabindex', opts.index || 0);
        if (opts.clicklable) DOM.makeClickable(elem);
        return elem;
    };

    /**
     * ### DOM.makeClickable
     *
     * Adds a listener that clicks on the element if SPACE or ENTER are hit
     *
     * The kewydown event listener callback is available under `cb`.
     *
     * @param {HTMLElement} elem The element to make clickable
     * @param {boolean} add If FALSE, the listener is removed. Default: TRUE
     *
     * @return {HTMLElement} The clickable element
     */
    DOM.makeClickable = (function() {
        function clickCb(event) {
            if (event.keyCode === 32 || event.keyCode === 13) {
                event.preventDefault();
                event.target.click();
            }
        }
        var cb;
        cb = function(elem, add) {
            if ('undefined' === typeof add) add = true;
            if (add) elem.addEventListener('keydown', clickCb);
            else elem.removeEventListener('keydown', clickCb);
            return elem;
        };
        cb.cb = clickCb;
        return cb;
    })();

    // ## Helper methods

    /**
     * ### onFocusChange
     *
     * Helper function for DOM.onFocusIn and DOM.onFocusOut (cross-browser)
     *
     * Expects only one callback, either inCb, or outCb.
     *
     * @param {function|null} inCb Optional. Executed if page acquires focus,
     *   or NULL, to delete an existing callback.
     * @param {function|null} outCb Optional. Executed if page loses focus,
     *   or NULL, to delete an existing callback.
     *
     * Kudos: http://stackoverflow.com/questions/1060008/
     *   is-there-a-way-to-detect-if-a-browser-window-is-not-currently-active
     *
     * @see http://www.w3.org/TR/page-visibility/
     */
    onFocusChange = (function(document) {
        var inFocusCb, outFocusCb, event, hidden, evtMap;

        if (!document) {
            return function() {
                JSUS.log('onFocusChange: no document detected.');
                return;
            };
        }

        if ('hidden' in document) {
            hidden = 'hidden';
            event = 'visibilitychange';
        }
        else if ('mozHidden' in document) {
            hidden = 'mozHidden';
            event = 'mozvisibilitychange';
        }
        else if ('webkitHidden' in document) {
            hidden = 'webkitHidden';
            event = 'webkitvisibilitychange';
        }
        else if ('msHidden' in document) {
            hidden = 'msHidden';
            event = 'msvisibilitychange';
        }

        evtMap = {
            focus: true, focusin: true, pageshow: true,
            blur: false, focusout: false, pagehide: false
        };

        function onchange(evt) {
            var isHidden;
            evt = evt || window.event;
            // If event is defined as one from event Map.
            if (evt.type in evtMap) isHidden = evtMap[evt.type];
            // Or use the hidden property.
            else isHidden = this[hidden] ? true : false;
            // Call the callback, if defined.
            if (!isHidden) { if (inFocusCb) inFocusCb(); }
            else { if (outFocusCb) outFocusCb(); }
        }

        return function(inCb, outCb) {
            var onchangeCb;

            if ('undefined' !== typeof inCb) inFocusCb = inCb;
            else outFocusCb = outCb;

            onchangeCb = !inFocusCb && !outFocusCb ? null : onchange;

            // Visibility standard detected.
            if (event) {
                if (onchangeCb) document.addEventListener(event, onchange);
                else document.removeEventListener(event, onchange);
            }
            else if ('onfocusin' in document) {
                document.onfocusin = document.onfocusout = onchangeCb;
            }
            // All others.
            else {
                window.onpageshow = window.onpagehide =
                    window.onfocus = window.onblur = onchangeCb;
            }
        };
    })('undefined' !== typeof document ? document : null);

    /**
     * ### changeTitle
     *
     * Changes title of page
     *
     * @param {string} title New title of the page
     */
    changeTitle = function(title) {
        if ('string' === typeof title) {
            document.title = title;
        }
        else {
            throw new TypeError('JSUS.changeTitle: title must be string. ' +
                                'Found: ' + title);
        }
    };

    JSUS.extend(DOM);

})('undefined' !== typeof JSUS ? JSUS : module.parent.exports.JSUS);

/**
 * # EVAL
 * Copyright(c) 2015 Stefano Balietti
 * MIT Licensed
 *
 * Evaluation of strings as JavaScript commands
 */
(function(JSUS) {

    "use strict";

    function EVAL() {}

    /**
     * ## EVAL.eval
     *
     * Cross-browser eval function with context.
     *
     * If no context is passed a reference, `this` is used.
     *
     * In old IEs it will use _window.execScript_ instead.
     *
     * @param {string} str The command to executes
     * @param {object} context Optional. Execution context. Defaults, `this`
     *
     * @return {mixed} The return value of the executed commands
     *
     * @see eval
     * @see execScript
     * @see JSON.parse
     */
    EVAL.eval = function(str, context) {
        var func;
        if (!str) return;
        context = context || this;
        // Eval must be called indirectly
        // i.e. eval.call is not possible
        func = function(str) {
            // TODO: Filter str.
            str = '(' + str + ')';
            if ('undefined' !== typeof window && window.execScript) {
                // Notice: execScript doesnt return anything.
                window.execScript('__my_eval__ = ' + str);
                return __my_eval__;
            }
            else {
                return eval(str);
            }
        };
        return func.call(context, str);
    };

    JSUS.extend(EVAL);

})('undefined' !== typeof JSUS ? JSUS : module.parent.exports.JSUS);

/**
 * # OBJ
 * Copyright(c) 2019 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Collection of static functions to manipulate JavaScript objects
 */
(function(JSUS) {

    "use strict";

    function OBJ() {}

    var compatibility = null;

    if ('undefined' !== typeof JSUS.compatibility) {
        compatibility = JSUS.compatibility();
    }

    /**
     * ## OBJ.createObj
     *
     * Polyfill for Object.create (when missing)
     */
    OBJ.createObj = (function() {
        // From MDN Object.create (Polyfill)
        if (typeof Object.create !== 'function') {
            // Production steps of ECMA-262, Edition 5, 15.2.3.5
            // Reference: http://es5.github.io/#x15.2.3.5
            return (function() {
                // To save on memory, use a shared constructor
                function Temp() {}

                // make a safe reference to Object.prototype.hasOwnProperty
                var hasOwn = Object.prototype.hasOwnProperty;

                return function(O) {
                    // 1. If Type(O) is not Object or Null
                    if (typeof O != 'object') {
                        throw new TypeError('Object prototype may only ' +
                                            'be an Object or null');
                    }

                    // 2. Let obj be the result of creating a new object as if
                    //    by the expression new Object() where Object is the
                    //    standard built-in constructor with that name
                    // 3. Set the [[Prototype]] internal property of obj to O.
                    Temp.prototype = O;
                    var obj = new Temp();
                    Temp.prototype = null;

                    // 4. If the argument Properties is present and not
                    //    undefined, add own properties to obj as if by calling
                    //    the standard built-in function Object.defineProperties
                    //    with arguments obj and Properties.
                    if (arguments.length > 1) {
                        // Object.defineProperties does ToObject on
                        // its first argument.
                        var Properties = new Object(arguments[1]);
                        for (var prop in Properties) {
                            if (hasOwn.call(Properties, prop)) {
                                obj[prop] = Properties[prop];
                            }
                        }
                    }

                    // 5. Return obj
                    return obj;
                };
            })();
        }
        return Object.create;
    })();

    /**
     * ## OBJ.equals
     *
     * Checks for deep equality between two objects, strings or primitive types
     *
     * All nested properties are checked, and if they differ in at least
     * one returns FALSE, otherwise TRUE.
     *
     * Takes care of comparing the following special cases:
     *
     * - undefined
     * - null
     * - NaN
     * - Infinity
     * - {}
     * - falsy values
     *
     * @param {object} o1 The first object
     * @param {object} o2 The second object
     *
     * @return {boolean} TRUE if the objects are deeply equal
     */
    OBJ.equals = function(o1, o2) {
        var type1, type2, primitives, p;
        type1 = typeof o1;
        type2 = typeof o2;

        if (type1 !== type2) return false;

        if ('undefined' === type1 || 'undefined' === type2) {
            return (o1 === o2);
        }
        if (o1 === null || o2 === null) {
            return (o1 === o2);
        }
        if (('number' === type1 && isNaN(o1)) &&
            ('number' === type2 && isNaN(o2))) {
            return (isNaN(o1) && isNaN(o2));
        }

        // Check whether arguments are not objects
        primitives = {number: '', string: '', boolean: ''};
        if (type1 in primitives) {
            return o1 === o2;
        }

        if ('function' === type1) {
            return o1.toString() === o2.toString();
        }

        for (p in o1) {
            if (o1.hasOwnProperty(p)) {

                if ('undefined' === typeof o2[p] &&
                    'undefined' !== typeof o1[p]) return false;

                if (!o2[p] && o1[p]) return false;

                if ('function' === typeof o1[p]) {
                    if (o1[p].toString() !== o2[p].toString()) return false;
                }
                else
                    if (!OBJ.equals(o1[p], o2[p])) return false;
            }
        }

        // Check whether o2 has extra properties
        // TODO: improve, some properties have already been checked!
        for (p in o2) {
            if (o2.hasOwnProperty(p)) {
                if ('undefined' === typeof o1[p] &&
                    'undefined' !== typeof o2[p]) return false;

                if (!o1[p] && o2[p]) return false;
            }
        }

        return true;
    };

    /**
     * ## OBJ.isEmpty
     *
     * Returns TRUE if an object has no own properties (supports other types)
     *
     * Map of input-type and return values:
     *
     *   - undefined: TRUE
     *   - null: TRUE
     *   - string: TRUE if string === '' or if contains only spaces
     *   - number: FALSE if different from 0
     *   - function: FALSE
     *   - array: TRUE, if it contains zero elements
     *   - object: TRUE, if it does not contain **own** properties
     *
     * Notice: for object, it is much faster than Object.keys(o).length === 0,
     * because it does not pull out all keys. Own properties must be enumerable.
     *
     * @param {mixed} o The object (or other type) to check
     *
     * @return {boolean} TRUE, if the object is empty
     */
    OBJ.isEmpty = function(o) {
        var key;
        if (!o) return true;
        if ('string' === typeof o) return o.trim() === '';
        if ('number' === typeof o) return false;
        if ('function' === typeof o) return false;
        for (key in o) if (o.hasOwnProperty(key)) return false;
        return true;
    };

    /**
     * ## OBJ.size
     *
     * Counts the number of own properties of an object.
     *
     * Prototype chain properties are excluded.
     *
     * @param {object} obj The object to check
     *
     * @return {number} The number of properties in the object
     */
    OBJ.size = OBJ.getListSize = function(obj) {
        var n, key;
        if (!obj) return 0;
        if ('number' === typeof obj) return 0;
        if ('string' === typeof obj) return 0;

        n = 0;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                n++;
            }
        }
        return n;
    };

    /**
     * ## OBJ._obj2Array
     *
     * Explodes an object into an array of keys and values,
     * according to the specified parameters.
     *
     * A fixed level of recursion can be set.
     *
     * @api private
     * @param {object} obj The object to convert in array
     * @param {boolean} keyed TRUE, if also property names should be included.
     *   Defaults, FALSE
     * @param {number} level Optional. The level of recursion.
     *   Defaults, undefined
     *
     * @return {array} The converted object
     */
    OBJ._obj2Array = function(obj, keyed, level, cur_level) {
        var result, key;
        if ('object' !== typeof obj) return [obj];

        if (level) {
            cur_level = ('undefined' !== typeof cur_level) ? cur_level : 1;
            if (cur_level > level) return [obj];
            cur_level = cur_level + 1;
        }

        result = [];
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (keyed) result.push(key);
                if ('object' === typeof obj[key]) {
                    result = result.concat(OBJ._obj2Array(obj[key], keyed,
                                                          level, cur_level));
                }
                else {
                    result.push(obj[key]);
                }
            }
        }
        return result;
    };

    /**
     * ## OBJ.obj2Array
     *
     * Converts an object into an array, keys are lost
     *
     * Recursively put the values of the properties of an object into
     * an array and returns it.
     *
     * The level of recursion can be set with the parameter level.
     * By default recursion has no limit, i.e. that the whole object
     * gets totally unfolded into an array.
     *
     * @param {object} obj The object to convert in array
     * @param {number} level Optional. The level of recursion. Defaults,
     *   undefined
     *
     * @return {array} The converted object
     *
     * @see OBJ._obj2Array
     * @see OBJ.obj2KeyedArray
     */
    OBJ.obj2Array = function(obj, level) {
        return OBJ._obj2Array(obj, false, level);
    };

    /**
     * ## OBJ.obj2KeyedArray
     *
     * Converts an object into array, keys are preserved
     *
     * Creates an array containing all keys and values of an object and
     * returns it.
     *
     * @param {object} obj The object to convert in array
     * @param {number} level Optional. The level of recursion. Defaults,
     *   undefined
     *
     * @return {array} The converted object
     *
     * @see OBJ.obj2Array
     */
    OBJ.obj2KeyedArray = OBJ.obj2KeyArray = function(obj, level) {
        return OBJ._obj2Array(obj, true, level);
    };

    /**
     * ## OBJ.obj2QueryString
     *
     * Creates a querystring with the key-value pairs of the given object.
     *
     * @param {object} obj The object to convert
     *
     * @return {string} The created querystring
     *
     * Kudos:
     * @see http://stackoverflow.com/a/1714899/3347292
     */
    OBJ.obj2QueryString = function(obj) {
        var str;
        var key;

        if ('object' !== typeof obj) {
            throw new TypeError(
                    'JSUS.objectToQueryString: obj must be object.');
        }

        str = [];
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                str.push(encodeURIComponent(key) + '=' +
                         encodeURIComponent(obj[key]));
            }
        }

        return '?' + str.join('&');
    };

    /**
     * ## OBJ.keys
     *
     * Returns all the keys of an object until desired level of nestedness
     *
     * The second parameter can be omitted, and the level can be specified
     * inside the options object passed as second parameter.
     *
     * @param {object} obj The object from which extract the keys
     * @param {number} level Optional. How many nested levels to scan.
     *   Default: 0, meaning 0 recursion, i.e., only first level keys.
     * @param {object} options Optional. Configuration options:
     *
     *   - type: 'all':   all keys (default),
     *           'level': keys of the specified level,
     *           'leaf':  keys that are leaves, i.e., keys that are at the
     *                    the desired level or that do not point to an object
     *   - concat: true/false: If TRUE, keys are prefixed by parent keys
     *   - separator: a character to inter between parent and children keys;
     *                 (default: '.')
     *   - distinct: if TRUE, only unique keys are returned  (default: false)
     *   - parent: the name of initial parent key (default: '')
     *   - array: an array to which the keys will be appended (default: [])
     *   - skip: an object containing keys to skip
     *   - cb: a callback to be applied to every key before adding to results.
     *         The return value of the callback is interpreted as follows:
     *         - string|number: inserted as it is
     *         - array: concatenated
     *         - undefined: the original key is inserted
     *         - null: nothing is inserted
     *
     * @return {array} The array containing the extracted keys
     *
     * @see Object.keys
     */
    OBJ.keys = (function() {
        return function(obj, level, options) {
            var keys, type, allKeys, leafKeys, levelKeys;
            var separator, myLevel, curParent;

            if (arguments.length === 2 && 'object' === typeof level) {
                options = level;
                level = options.level;
            }

            options = options || {};

            type = options.type ? options.type.toLowerCase() : 'all';
            if (type === 'all') allKeys = true;
            else if (type === 'leaf') leafKeys = true;
            else if (type === 'level') levelKeys = true;
            else throw new Error('keys: unknown type option: ' + type);

            if (options.cb && 'function' !== typeof options.cb) {
                throw new TypeError('JSUS.keys: options.cb must be function ' +
                                    'or undefined. Found: ' + options.cb);
            }

            if ('undefined' === typeof level) myLevel = 0;
            else if ('number' === typeof level) myLevel = level;
            else if ('string' === typeof level) myLevel = parseInt(level, 10);
            if ('number' !== typeof myLevel || isNaN(myLevel)) {
                throw new Error('JSUS.keys: level must be number, undefined ' +
                                'or a parsable string. Found: ' + level);
            }
            // No keys at level -1;
            if (level < 0) return [];

            if (options.concat) {
                if ('undefined' === typeof options.separator) separator = '.';
                else separator = options.separator;
            }

            if (options.parent) curParent = options.parent + separator;
            else curParent = '';

            if (!options.concat && options.distinct) keys = {};

            return _keys(obj, myLevel, 0, curParent, options.concat,
                         allKeys, leafKeys, levelKeys, separator,
                         options.array || [], keys, options.skip || {},
                         options.cb);
        }

        function _keys(obj, level, curLevel, curParent,
                       concatKeys, allKeys, leafKeys, levelKeys,
                       separator, res, uniqueKeys, skipKeys, cb) {

            var key, isLevel, isObj, tmp;
            isLevel = curLevel === level;
            for (key in obj) {
                if (obj.hasOwnProperty(key)) {

                    isObj = 'object' === typeof obj[key];
                    if (allKeys ||
                        (leafKeys && (isLevel || !isObj)) ||
                        (levelKeys && isLevel)) {

                        if (concatKeys) {
                            tmp = curParent + key;
                            if (!skipKeys[tmp]) {
                                if (cb) _doCb(tmp, res, cb);
                                else res.push(tmp);
                            }
                        }
                        else if (!skipKeys[key]) {
                            if (uniqueKeys){
                                if (!uniqueKeys[key]) {
                                    if (cb) _doCb(key, res, cb);
                                    else res.push(key);
                                    uniqueKeys[key] = true;
                                }
                            }
                            else {
                                if (cb) _doCb(key, res, cb);
                                else res.push(key);
                            }
                        }
                    }
                    if (isObj && (curLevel < level)) {
                        _keys(obj[key], level, (curLevel+1),
                              concatKeys ? curParent + key + separator : key,
                              concatKeys, allKeys, leafKeys, levelKeys,
                              separator, res, uniqueKeys, skipKeys, cb);
                    }
                }
            }
            return res;
        }

        function _doCb(key, res, cb) {
            var tmp;
            tmp = cb(key);
            // If string, substitute it.
            if ('string' === typeof tmp || 'number' === typeof tmp) {
                res.push(tmp);
            }
            // If array, expand it.
            else if (JSUS.isArray(tmp) && tmp.length) {
                if (tmp.length < 4) {
                    res.push(tmp[0]);
                    if (tmp.length > 1) {
                        res.push(tmp[1]);
                        if (tmp.length > 2) {
                            res.push(tmp[2]);
                        }
                    }
                }
                else {
                    (function() {
                        var i = -1, len = tmp.length;
                        for ( ; ++i < len ; ) {
                            res.push(tmp[i]);
                        }
                    })(tmp, res);
                }
            }
            else if ('undefined' === typeof tmp) {
                res.push(key);
            }
            // Else, e.g. null, ignore it.
        }
    })();


    /**
     * ## OBJ.implode
     *
     * Separates each property into a new object and returns them into an array
     *
     * E.g.
     *
     * ```javascript
     * var a = { b:2, c: {a:1}, e:5 };
     * OBJ.implode(a); // [{b:2}, {c:{a:1}}, {e:5}]
     * ```
     *
     * @param {object} obj The object to implode
     *
     * @return {array} The array containing all the imploded properties
     */
    OBJ.implode = OBJ.implodeObj = function(obj) {
        var result, key, o;
        if (!obj) return [];
        result = [];
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                o = {};
                o[key] = obj[key];
                result.push(o);
            }
        }
        return result;
    };

    /**
     * ## OBJ.clone
     *
     * Creates a perfect copy of the object passed as parameter
     *
     * Recursively scans all the properties of the object to clone.
     * Properties of the prototype chain are copied as well.
     *
     * Primitive types and special values are returned as they are.
     *
     * @param {object} obj The object to clone
     *
     * @return {object} The clone of the object
     */
    OBJ.clone = function(obj) {
        var clone, i, value;
        if (!obj) return obj;
        if ('number' === typeof obj) return obj;
        if ('string' === typeof obj) return obj;
        if ('boolean' === typeof obj) return obj;
        // NaN and +-Infinity are numbers, so no check is necessary.

        if ('function' === typeof obj) {
            clone = function() {
                var len, args;
                len = arguments.length;
                if (!len) return obj.call(clone);
                else if (len === 1) return obj.call(clone, arguments[0]);
                else if (len === 2) {
                    return obj.call(clone, arguments[0], arguments[1]);
                }
                else {
                    args = new Array(len);
                    for (i = 0; i < len; i++) {
                        args[i] = arguments[i];
                    }
                    return obj.apply(clone, args);
                }
            };
        }
        else {
            clone = Object.prototype.toString.call(obj) === '[object Array]' ?
                [] : {};
        }
        for (i in obj) {
            // It is not NULL and it is an object.
            // Even if it is an array we need to use CLONE,
            // because `slice()` does not clone arrays of objects.
            if (obj[i] && 'object' === typeof obj[i]) {
                value = OBJ.clone(obj[i]);
            }
            else {
                value = obj[i];
            }

            if (obj.hasOwnProperty(i)) {
                clone[i] = value;
            }
            else {
                // We know if object.defineProperty is available.
                if (compatibility && compatibility.defineProperty) {
                    Object.defineProperty(clone, i, {
                        value: value,
                        writable: true,
                        configurable: true
                    });
                }
                else {
                    setProp(clone, i, value);
                }
            }
        }
        return clone;
    };

    function setProp(clone, i, value) {
        try {
            Object.defineProperty(clone, i, {
                value: value,
                writable: true,
                configurable: true
            });
        }
        catch(e) {
            clone[i] = value;
        }
    }


    /**
     * ## OBJ.classClone
     *
     * Creates a copy (keeping class) of the object passed as parameter
     *
     * Recursively scans all the properties of the object to clone.
     * The clone is an instance of the type of obj.
     *
     * @param {object} obj The object to clone
     * @param {Number} depth how deep the copy should be
     *
     * @return {object} The clone of the object
     */
    OBJ.classClone = function(obj, depth) {
        var clone, i;
        if (depth === 0) {
            return obj;
        }

        if (obj && 'object' === typeof obj) {
            clone = Object.prototype.toString.call(obj) === '[object Array]' ?
                [] : JSUS.createObj(obj.constructor.prototype);

            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    if (obj[i] && 'object' === typeof obj[i]) {
                        clone[i] = JSUS.classClone(obj[i], depth - 1);
                    }
                    else {
                        clone[i] = obj[i];
                    }
                }
            }
            return clone;
        }
        else {
            return JSUS.clone(obj);
        }
    };

    /**
     * ## OBJ.join
     *
     * Performs a *left* join on the keys of two objects
     *
     * Creates a copy of obj1, and in case keys overlap
     * between obj1 and obj2, the values from obj2 are taken.
     *
     * Returns a new object, the original ones are not modified.
     *
     * E.g.
     *
     * ```javascript
     * var a = { b:2, c:3, e:5 };
     * var b = { a:10, b:2, c:100, d:4 };
     * OBJ.join(a, b); // { b:2, c:100, e:5 }
     * ```
     *
     * @param {object} obj1 The object where the merge will take place
     * @param {object} obj2 The merging object
     *
     * @return {object} The joined object
     *
     * @see OBJ.merge
     */
    OBJ.join = function(obj1, obj2) {
        var clone, i;
        clone = OBJ.clone(obj1);
        if (!obj2) return clone;
        for (i in clone) {
            if (clone.hasOwnProperty(i)) {
                if ('undefined' !== typeof obj2[i]) {
                    if ('object' === typeof obj2[i]) {
                        clone[i] = OBJ.join(clone[i], obj2[i]);
                    } else {
                        clone[i] = obj2[i];
                    }
                }
            }
        }
        return clone;
    };

    /**
     * ## OBJ.merge
     *
     * Merges two objects in one
     *
     * In case keys overlap the values from obj2 are taken.
     *
     * Only own properties are copied.
     *
     * Returns a new object, the original ones are not modified.
     *
     * E.g.
     *
     * ```javascript
     * var a = { a:1, b:2, c:3 };
     * var b = { a:10, b:2, c:100, d:4 };
     * OBJ.merge(a, b); // { a: 10, b: 2, c: 100, d: 4 }
     * ```
     *
     * @param {object} obj1 The object where the merge will take place
     * @param {object} obj2 The merging object
     *
     * @return {object} The merged object
     *
     * @see OBJ.join
     * @see OBJ.mergeOnKey
     */
    OBJ.merge = function(obj1, obj2) {
        var clone, i;
        // Checking before starting the algorithm
        if (!obj1 && !obj2) return false;
        if (!obj1) return OBJ.clone(obj2);
        if (!obj2) return OBJ.clone(obj1);

        clone = OBJ.clone(obj1);
        for (i in obj2) {

            if (obj2.hasOwnProperty(i)) {
                // it is an object and it is not NULL
                if (obj2[i] && 'object' === typeof obj2[i]) {
                    // If we are merging an object into
                    // a non-object, we need to cast the
                    // type of obj1
                    if ('object' !== typeof clone[i]) {
                        if (Object.prototype.toString.call(obj2[i]) ===
                            '[object Array]') {

                            clone[i] = [];
                        }
                        else {
                            clone[i] = {};
                        }
                    }
                    clone[i] = OBJ.merge(clone[i], obj2[i]);
                }
                else {
                    clone[i] = obj2[i];
                }
            }
        }
        return clone;
    };

    /**
     * ## OBJ.mixin
     *
     * Adds all the properties of obj2 into obj1
     *
     * Original object is modified.
     *
     * @param {object} obj1 The object to which the new properties will be added
     * @param {object} obj2 The mixin-in object
     *
     * @return {object} obj1
     */
    OBJ.mixin = function(obj1, obj2) {
        var i;
        if (!obj1 && !obj2) return;
        if (!obj1) return obj2;
        if (!obj2) return obj1;
        for (i in obj2) {
            obj1[i] = obj2[i];
        }
        return obj1;
    };

    /**
     * ## OBJ.mixout
     *
     * Copies only non-overlapping properties from obj2 to obj1
     *
     * Check only if a property is defined, not its value.
     * Original object is modified.
     *
     * @param {object} obj1 The object to which the new properties will be added
     * @param {object} obj2 The mixin-in object
     *
     * @return {object} obj1
     */
    OBJ.mixout = function(obj1, obj2) {
        var i;
        if (!obj1 && !obj2) return;
        if (!obj1) return obj2;
        if (!obj2) return obj1;
        for (i in obj2) {
            if ('undefined' === typeof obj1[i]) obj1[i] = obj2[i];
        }
        return obj1;
    };

    /**
     * ## OBJ.mixcommon
     *
     * Copies only overlapping properties from obj2 to obj1
     *
     * Check only if a property is defined, not its value.
     * Original object is modified.
     *
     * @param {object} obj1 The object to which the new properties will be added
     * @param {object} obj2 The mixin-in object
     *
     * @return {object} obj1
     */
    OBJ.mixcommon = function(obj1, obj2) {
        var i;
        if (!obj1 && !obj2) return;
        if (!obj1) return obj2;
        if (!obj2) return obj1;
        for (i in obj2) {
            if ('undefined' !== typeof obj1[i]) obj1[i] = obj2[i];
        }
        return obj1;
    };

    /**
     * ## OBJ.mergeOnKey
     *
     * Merges the properties of obj2 into a new property named 'key' in obj1.
     *
     * Returns a new object, the original ones are not modified.
     *
     * This method is useful when we want to merge into a larger
     * configuration (e.g. with properties min, max, value) object, another one
     * that contains just a subset of properties (e.g. value).
     *
     * @param {object} obj1 The object where the merge will take place
     * @param {object} obj2 The merging object
     * @param {string} key The name of property under which the second object
     *   will be merged
     *
     * @return {object} The merged object
     *
     * @see OBJ.merge
     */
    OBJ.mergeOnKey = function(obj1, obj2, key) {
        var clone, i;
        clone = OBJ.clone(obj1);
        if (!obj2 || !key) return clone;
        for (i in obj2) {
            if (obj2.hasOwnProperty(i)) {
                if (!clone[i] || 'object' !== typeof clone[i]) {
                    clone[i] = {};
                }
                clone[i][key] = obj2[i];
            }
        }
        return clone;
    };

    /**
     * ## OBJ.subobj | subObj
     *
     * Creates a copy of an object containing only the properties
     * passed as second parameter
     *
     * The parameter select can be an array of strings, or the name
     * of a property.
     *
     * Use '.' (dot) to point to a nested property, however if a property
     * with a '.' in the name is found, it will be used first.
     *
     * @param {object} o The object to dissect
     * @param {string|array} select The selection of properties to extract
     *
     * @return {object} The subobject with the properties from the parent
     *
     * @see OBJ.getNestedValue
     */
    OBJ.subobj = OBJ.subObj = function(o, select) {
        var out, i, key;
        if (!o) return false;
        out = {};
        if (!select) return out;
        if (!(select instanceof Array)) select = [select];
        for (i=0; i < select.length; i++) {
            key = select[i];
            if (o.hasOwnProperty(key)) {
                out[key] = o[key];
            }
            else if (OBJ.hasOwnNestedProperty(key, o)) {
                OBJ.setNestedValue(key, OBJ.getNestedValue(key, o), out);
            }
        }
        return out;
    };

    /**
     * ## OBJ.skim
     *
     * Creates a copy of an object with some of the properties removed
     *
     * The parameter `remove` can be an array of strings, or the name
     * of a property.
     *
     * Use '.' (dot) to point to a nested property, however if a property
     * with a '.' in the name is found, it will be deleted first.
     *
     * @param {object} o The object to dissect
     * @param {string|array} remove The selection of properties to remove
     *
     * @return {object} The subobject with the properties from the parent
     *
     * @see OBJ.getNestedValue
     */
    OBJ.skim = function(o, remove) {
        var out, i;
        if (!o) return false;
        out = OBJ.clone(o);
        if (!remove) return out;
        if (!(remove instanceof Array)) remove = [remove];
        for (i = 0; i < remove.length; i++) {
            if (out.hasOwnProperty(i)) {
                delete out[i];
            }
            else {
                OBJ.deleteNestedKey(remove[i], out);
            }
        }
        return out;
    };


    /**
     * ## OBJ.setNestedValue
     *
     * Sets the value of a nested property of an object and returns it.
     *
     * If the object is not passed a new one is created.
     * If the nested property is not existing, a new one is created.
     *
     * Use '.' (dot) to point to a nested property.
     *
     * The original object is modified.
     *
     * @param {string} str The path to the value
     * @param {mixed} value The value to set
     *
     * @return {object|boolean} The modified object, or FALSE if error
     *   occurrs
     *
     * @see OBJ.getNestedValue
     * @see OBJ.deleteNestedKey
     */
    OBJ.setNestedValue = function(str, value, obj) {
        var keys, k;
        if (!str) {
            JSUS.log('Cannot set value of undefined property', 'ERR');
            return false;
        }
        obj = ('object' === typeof obj) ? obj : {};
        keys = str.split('.');
        if (keys.length === 1) {
            obj[str] = value;
            return obj;
        }
        k = keys.shift();
        obj[k] = OBJ.setNestedValue(keys.join('.'), value, obj[k]);
        return obj;
    };

    /**
     * ## OBJ.getNestedValue
     *
     * Returns the value of a property of an object, as defined
     * by a path string.
     *
     * Use '.' (dot) to point to a nested property.
     *
     * Returns undefined if the nested property does not exist.
     *
     * E.g.
     *
     * ```javascript
     * var o = { a:1, b:{a:2} };
     * OBJ.getNestedValue('b.a', o); // 2
     * ```
     *
     * @param {string} str The path to the value
     * @param {object} obj The object from which extract the value
     *
     * @return {mixed} The extracted value
     *
     * @see OBJ.setNestedValue
     * @see OBJ.deleteNestedKey
     */
    OBJ.getNestedValue = function(str, obj) {
        var keys, k;
        if (!obj) return;
        keys = str.split('.');
        if (keys.length === 1) {
            return obj[str];
        }
        k = keys.shift();
        return OBJ.getNestedValue(keys.join('.'), obj[k]);
    };

    /**
     * ## OBJ.deleteNestedKey
     *
     * Deletes a property from an object, as defined by a path string
     *
     * Use '.' (dot) to point to a nested property.
     *
     * The original object is modified.
     *
     * E.g.
     *
     * ```javascript
     * var o = { a:1, b:{a:2} };
     * OBJ.deleteNestedKey('b.a', o); // { a:1, b: {} }
     * ```
     *
     * @param {string} str The path string
     * @param {object} obj The object from which deleting a property
     * @param {boolean} TRUE, if the property was existing, and then deleted
     *
     * @see OBJ.setNestedValue
     * @see OBJ.getNestedValue
     */
    OBJ.deleteNestedKey = function(str, obj) {
        var keys, k;
        if (!obj) return;
        keys = str.split('.');
        if (keys.length === 1) {
            delete obj[str];
            return true;
        }
        k = keys.shift();
        if ('undefined' === typeof obj[k]) {
            return false;
        }
        return OBJ.deleteNestedKey(keys.join('.'), obj[k]);
    };

    /**
     * ## OBJ.hasOwnNestedProperty
     *
     * Returns TRUE if a (nested) property exists
     *
     * Use '.' to specify a nested property.
     *
     * E.g.
     *
     * ```javascript
     * var o = { a:1, b:{a:2} };
     * OBJ.hasOwnNestedProperty('b.a', o); // TRUE
     * ```
     *
     * @param {string} str The path of the (nested) property
     * @param {object} obj The object to test
     *
     * @return {boolean} TRUE, if the (nested) property exists
     */
    OBJ.hasOwnNestedProperty = function(str, obj) {
        var keys, k;
        if (!obj) return false;
        keys = str.split('.');
        if (keys.length === 1) {
            return obj.hasOwnProperty(str);
        }
        k = keys.shift();
        return OBJ.hasOwnNestedProperty(keys.join('.'), obj[k]);
    };

    /**
     * ## OBJ.split
     *
     * Splits an object along a specified dimension
     *
     * All fragments are returned in an array (as copies).
     *
     * It creates as many new objects as the number of properties
     * contained in the specified dimension. E.g.
     *
     * ```javascript
     *  var o = { a: 1,
     *            b: {c: 2,
     *                d: 3
     *            },
     *            e: 4
     *  };
     *
     *  o = OBJ.split(o, 'b');
     *
     *  // o becomes:
     *
     *  [{ a: 1,
     *     b: {c: 2},
     *     e: 4
     *  },
     *  { a: 1,
     *    b: {d: 3},
     *    e: 4
     *  }];
     * ```
     *
     * @param {object} o The object to split
     * @param {string} key The name of the property to split
     * @param {number} l Optional. The recursion level. Default: 1.
     * @param {boolean} positionAsKey Optional. If TRUE, the position
     *   of an element in the array to split will be used as key.
     *
     * @return {array} A list of copies of the object with split values
     */
    OBJ.split = (function() {
        var makeClone, splitValue;
        var model, level, _key, posAsKeys;

        makeClone = function(value, out, keys) {
            var i, len, tmp, copy;
            copy = JSUS.clone(model);

            switch(keys.length) {
            case 0:
                copy[_key] = JSUS.clone(value);
                break;
            case 1:
                copy[_key][keys[0]] = JSUS.clone(value);
                break;
            case 2:
                copy[_key][keys[0]] = {};
                copy[_key][keys[0]][keys[1]] = JSUS.clone(value);
                break;
            default:
                i = -1, len = keys.length-1;
                tmp = copy[_key];
                for ( ; ++i < len ; ) {
                    tmp[keys[i]] = {};
                    tmp = tmp[keys[i]];
                }
                tmp[keys[keys.length-1]] = JSUS.clone(value);
            }
            out.push(copy);
            return;
        };

        splitValue = function(value, out, curLevel, keysArray) {
            var i, curPosAsKey;

            // level == 0 means no limit.
            if (level && (curLevel >= level)) {
                makeClone(value, out, keysArray);
            }
            else {

                curPosAsKey = posAsKeys || !JSUS.isArray(value);

                for (i in value) {
                    if (value.hasOwnProperty(i)) {

                        if ('object' === typeof value[i] &&
                            (level && ((curLevel+1) <= level))) {

                            splitValue(value[i], out, (curLevel+1),
                                       curPosAsKey ?
                                       keysArray.concat(i) : keysArray);
                        }
                        else {
                            makeClone(value[i], out, curPosAsKey ?
                                      keysArray.concat(i) : keysArray);
                        }
                    }
                }
            }
        };

        return function(o, key, l, positionAsKey) {
            var out;
            if ('object' !== typeof o) {
                throw new TypeError('JSUS.split: o must be object. Found: ' +
                                    o);
            }
            if ('string' !== typeof key || key.trim() === '') {
                throw new TypeError('JSUS.split: key must a non-empty ' +
                                    'string. Found: ' + key);
            }
            if (l && ('number' !== typeof l || l < 0)) {
                throw new TypeError('JSUS.split: l must a non-negative ' +
                                    'number or undefined. Found: ' + l);
            }
            model = JSUS.clone(o);
            if ('object' !== typeof o[key]) return [model];
            // Init.
            out = [];
            _key = key;
            model[key] = {};
            level = 'undefined' === typeof l ? 1 : l;
            posAsKeys = positionAsKey;
            // Recursively compute split.
            splitValue(o[key], out, 0, []);
            // Cleanup.
            _key = undefined;
            model = undefined;
            level = undefined;
            posAsKeys = undefined;
            // Return.
            return out;
        };
    })();

    /**
     * ## OBJ.melt
     *
     * Creates a new object with specific combination of properties - values
     *
     * The values are assigned cyclically to the properties, so that
     * they do not need to have the same length. E.g.
     *
     * ```javascript
     *  J.melt(['a','b','c'], [1,2]); // { a: 1, b: 2, c: 1 }
     * ```
     * @param {array} keys The names of the keys to add to the object
     * @param {array} values The values to associate to the keys
     *
     * @return {object} A new object with keys and values melted together
     */
    OBJ.melt = function(keys, values) {
        var o = {}, valen = values.length;
        for (var i = 0; i < keys.length; i++) {
            o[keys[i]] = values[i % valen];
        }
        return o;
    };

    /**
     * ## OBJ.uniqueKey
     *
     * Creates a random unique key name for a collection
     *
     * User can specify a tentative unique key name, and if already
     * existing an incremental index will be added as suffix to it.
     *
     * Notice: the method does not actually create the key
     * in the object, but it just returns the name.
     *
     * @param {object} obj The collection for which a unique key will be created
     * @param {string} prefixName Optional. A tentative key name. Defaults,
     *   a 15-digit random number
     * @param {number} stop Optional. The number of tries before giving up
     *   searching for a unique key name. Defaults, 1000000.
     *
     * @return {string|undefined} The unique key name, or undefined if it was
     *   not found
     */
    OBJ.uniqueKey = function(obj, prefixName, stop) {
        var name, duplicateCounter;
        if (!obj) {
            JSUS.log('Cannot find unique name in undefined object', 'ERR');
            return;
        }
        duplicateCounter = 1;
        prefixName = '' + (prefixName ||
                           Math.floor(Math.random()*1000000000000000));
        stop = stop || 1000000;
        name = prefixName;
        while (obj[name]) {
            name = prefixName + duplicateCounter;
            duplicateCounter++;
            if (duplicateCounter > stop) {
                return;
            }
        }
        return name;
    };

    /**
     * ## OBJ.randomKey
     *
     * Returns a random key from an existing object
     *
     * @param {object} obj The object from which the key will be extracted
     *
     * @return {string} The random key
     */
    OBJ.randomKey = function(obj) {
        var keys;
        if ('object' !== typeof obj) {
            throw new TypeError('OBJ.randomKey: obj must be object. ' +
                                'Found: ' + obj);
        }
        keys = Object.keys(obj);
        return keys[ keys.length * Math.random() << 0];
    };

    /**
     * ## OBJ.augment
     *
     * Pushes the values of the properties of an object into another one
     *
     * User can specifies the subset of keys from both objects
     * that will subject to augmentation. The values of the other keys
     * will not be changed
     *
     * Notice: the method modifies the first input paramteer
     *
     * E.g.
     *
     * ```javascript
     * var a = { a:1, b:2, c:3 };
     * var b = { a:10, b:2, c:100, d:4 };
     * OBJ.augment(a, b); // { a: [1, 10], b: [2, 2], c: [3, 100]}
     *
     * OBJ.augment(a, b, ['b', 'c', 'd']);
     * // { a: 1, b: [2, 2], c: [3, 100], d: [4]});
     *
     * ```
     *
     * @param {object} obj1 The object whose properties will be augmented
     * @param {object} obj2 The augmenting object
     * @param {array} key Optional. Array of key names common to both objects
     *   taken as the set of properties to augment
     */
    OBJ.augment = function(obj1, obj2, keys) {
        var i, k;
        keys = keys || OBJ.keys(obj1);

        for (i = 0 ; i < keys.length; i++) {
            k = keys[i];
            if ('undefined' !== typeof obj1[k] &&
                Object.prototype.toString.call(obj1[k]) !== '[object Array]') {
                obj1[k] = [obj1[k]];
            }
            if ('undefined' !== obj2[k]) {
                if (!obj1[k]) obj1[k] = [];
                obj1[k].push(obj2[k]);
            }
        }
    };


    /**
     * ## OBJ.pairwiseWalk
     *
     * Executes a callback on all pairs of  attributes with the same name
     *
     * The results of each callback are aggregated in a new object under the
     * same property name.
     *
     * Does not traverse nested objects, and properties of the prototype
     * are excluded.
     *
     * Returns a new object, the original ones are not modified.
     *
     * E.g.
     *
     * ```javascript
     * var a = { b:2, c:3, d:5 };
     * var b = { a:10, b:2, c:100, d:4 };
     * var sum = function(a,b) {
     *     if ('undefined' !== typeof a) {
     *         return 'undefined' !== typeof b ? a + b : a;
     *     }
     *     return b;
     * };
     * OBJ.pairwiseWalk(a, b, sum); // { a:10, b:4, c:103, d:9 }
     * ```
     *
     * @param {object} o1 The first object
     * @param {object} o2 The second object
     *
     * @return {object} The object aggregating the results
     */
    OBJ.pairwiseWalk = function(o1, o2, cb) {
        var i, out;
        if (!o1 && !o2) return;
        if (!o1) return o2;
        if (!o2) return o1;

        out = {};
        for (i in o1) {
            if (o1.hasOwnProperty(i)) {
                out[i] = o2.hasOwnProperty(i) ? cb(o1[i], o2[i]) : cb(o1[i]);
            }
        }

        for (i in o2) {
            if (o2.hasOwnProperty(i)) {
                if ('undefined' === typeof out[i]) {
                    out[i] = cb(undefined, o2[i]);
                }
            }
        }
        return out;
    };

    /**
     * ## OBJ.getKeyByValue
     *
     * Returns the key/s associated with a specific value
     *
     * Uses OBJ.equals so it can perform complicated comparisons of
     * the value of the keys.
     *
     * Properties of the prototype are not skipped.
     *
     * @param {object} obj The object to search
     * @param {mixed} value The value to match
     * @param {boolean} allKeys Optional. If TRUE, all keys with the
     *   specific value are returned. Default FALSE
     *
     * @return {object} The object aggregating the results
     *
     * @see OBJ.equals
     */
    OBJ.getKeyByValue = function(obj, value, allKeys) {
        var key, out;
        if ('object' !== typeof obj) {
            throw new TypeError('OBJ.getKeyByValue: obj must be object. ' +
                                'Found: ' + obj);
        }
        if (allKeys) out = [];
        for (key in obj) {
            if (obj.hasOwnProperty(key) ) {
                if (OBJ.equals(value, obj[key])) {
                    if (!allKeys) return key;
                    else out.push(key);
                }
            }
        }
        return out;
    };

    /**
     * ## OBJ.reverseObj
     *
     * Returns a new object where they keys and values are switched
     *
     * @param {object} obj The object to reverse
     * @param {function} cb Optional. A callback processing a key-value pair.
     *   Takes as inputs current key and value and must return an array with
     *   updated key and value: [ newKey, newValue ].
     *
     * @return {object} The reversed object
     */
    OBJ.reverseObj = function(o, cb) {
        var k, res;
        if (cb && 'function' !== typeof cb) {
            throw new TypeError('OBJ.reverseObj: cb must be function or ' +
                                'undefined. Found: ' + cb);
        }
        res = {};
        if (!o) return res;
        for (k in o) {
            if (o.hasOwnProperty(k)) {
                if (cb) {
                    k = cb(k, o[k]);
                    res[k[1]] = res[k[0]];
                }
                else {
                    res[o[k]] = k;
                }
            }
        }
        return res;
    };

    JSUS.extend(OBJ);

})('undefined' !== typeof JSUS ? JSUS : module.parent.exports.JSUS);

/**
 * # RANDOM
 * Copyright(c) 2017 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Generates pseudo-random numbers
 */
(function(JSUS) {

    "use strict";

    function RANDOM() {}

    /**
     * ## RANDOM.random
     *
     * Generates a pseudo-random floating point number in interval [a,b)
     *
     * Interval is a inclusive and b exclusive.
     *
     * If b is undefined, the interval is [0, a).
     *
     * If both a and b are undefined the interval is [0, 1)
     *
     * @param {number} a Optional. The lower limit, or the upper limit
     *   if b is undefined
     * @param {number} b Optional. The upper limit
     *
     * @return {number} A random floating point number in [a,b)
     */
    RANDOM.random = function(a, b) {
        var c;
        if ('undefined' === typeof b) {
            if ('undefined' === typeof a) {
                return Math.random();
            }
            else {
                b = a;
                a = 0;
            }
        }
        if (a === b) return a;

        if (b < a) {
            c = a;
            a = b;
            b = c;
        }
        return (Math.random() * (b - a)) + a;
    };

    /**
     * ## RANDOM.randomInt
     *
     * Generates a pseudo-random integer between (a,b] a exclusive, b inclusive
     *
     * @TODO: Change to interval [a,b], and allow 1 parameter for [0,a)
     *
     * @param {number} a The lower limit
     * @param {number} b The upper limit
     *
     * @return {number} A random integer in (a,b]
     *
     * @see RANDOM.random
     */
    RANDOM.randomInt = function(a, b) {
        if (a === b) return a;
        return Math.floor(RANDOM.random(a, b) + 1);
    };

    /**
     * ## RANDOM.randomDate
     *
     * Generates a pseudo-random date between
     *
     * @param {Date} startDate Optional. The lower date. Default: 01-01-1900.
     * @param {Date} endDate Optional. The upper date. Default: today.
     *
     * @return {number} A random date in the chosen interval
     *
     * @see RANDOM.randomDate
     */
    RANDOM.randomDate = (function() {
        function isValidDate(date) {
            return date &&
                Object.prototype.toString.call(date) === "[object Date]" &&
                !isNaN(date);
        }
        return function(startDate, endDate) {
            if ('undefined' === typeof startDate) {
                startDate = new Date("1900");
            }
            else if (!isValidDate(startDate)) {
                throw new TypeError('randomDate: startDate must be a valid ' +
                                    'date. Found: ' + startDate);
            }
            if ('undefined' === typeof endDate) {
                endDate = new Date();
            }
            else if (!isValidDate(endDate)) {
                throw new TypeError('randomDate: endDate must be a valid ' +
                                    'date or undefined. Found: ' + endDate);
            }
            return new Date(startDate.getTime() + Math.random() *
                            (endDate.getTime() - startDate.getTime()));
        };
    })();

    /**
     * ## RANDOM.sample
     *
     * Generates a randomly shuffled sequence of numbers in [a,b)]
     *
     * Both _a_ and _b_ are included in the interval.
     *
     * @param {number} a The lower limit
     * @param {number} b The upper limit
     *
     * @return {array} The randomly shuffled sequence.
     *
     * @see RANDOM.seq
     */
    RANDOM.sample = function(a, b) {
        var out;
        out = JSUS.seq(a,b);
        if (!out) return false;
        return JSUS.shuffle(out);
    };

    /**
     * ## RANDOM.getNormalGenerator
     *
     * Returns a new generator of normally distributed pseudo random numbers
     *
     * The generator is independent from RANDOM.nextNormal
     *
     * @return {function} An independent generator
     *
     * @see RANDOM.nextNormal
     */
    RANDOM.getNormalGenerator = function() {

        return (function() {

            var oldMu, oldSigma;
            var x2, multiplier, genReady;

            return function normal(mu, sigma) {

                var x1, u1, u2, v1, v2, s;

                if ('number' !== typeof mu) {
                    throw new TypeError('nextNormal: mu must be number.');
                }
                if ('number' !== typeof sigma) {
                    throw new TypeError('nextNormal: sigma must be number.');
                }

                if (mu !== oldMu || sigma !== oldSigma) {
                    genReady = false;
                    oldMu = mu;
                    oldSigma = sigma;
                }

                if (genReady) {
                    genReady = false;
                    return (sigma * x2) + mu;
                }

                u1 = Math.random();
                u2 = Math.random();

                // Normalize between -1 and +1.
                v1 = (2 * u1) - 1;
                v2 = (2 * u2) - 1;

                s = (v1 * v1) + (v2 * v2);

                // Condition is true on average 1.27 times,
                // with variance equal to 0.587.
                if (s >= 1) {
                    return normal(mu, sigma);
                }

                multiplier = Math.sqrt(-2 * Math.log(s) / s);

                x1 = v1 * multiplier;
                x2 = v2 * multiplier;

                genReady = true;

                return (sigma * x1) + mu;

            };
        })();
    };

    /**
     * ## RANDOM.nextNormal
     *
     * Generates random numbers with Normal Gaussian distribution.
     *
     * User must specify the expected mean, and standard deviation a input
     * parameters.
     *
     * Implements the Polar Method by Knuth, "The Art Of Computer
     * Programming", p. 117.
     *
     * @param {number} mu The mean of the distribution
     * param {number} sigma The standard deviation of the distribution
     *
     * @return {number} A random number following a Normal Gaussian distribution
     *
     * @see RANDOM.getNormalGenerator
     */
    RANDOM.nextNormal = RANDOM.getNormalGenerator();

    /**
     * ## RANDOM.nextLogNormal
     *
     * Generates random numbers with LogNormal distribution.
     *
     * User must specify the expected mean, and standard deviation of the
     * underlying gaussian distribution as input parameters.
     *
     * @param {number} mu The mean of the gaussian distribution
     * @param {number} sigma The standard deviation of the gaussian distribution
     *
     * @return {number} A random number following a LogNormal distribution
     *
     * @see RANDOM.nextNormal
     */
    RANDOM.nextLogNormal = function(mu, sigma) {
        if ('number' !== typeof mu) {
            throw new TypeError('nextLogNormal: mu must be number.');
        }
        if ('number' !== typeof sigma) {
            throw new TypeError('nextLogNormal: sigma must be number.');
        }
        return Math.exp(RANDOM.nextNormal(mu, sigma));
    };

    /**
     * ## RANDOM.nextExponential
     *
     * Generates random numbers with Exponential distribution.
     *
     * User must specify the lambda the _rate parameter_ of the distribution.
     * The expected mean of the distribution is equal to `Math.pow(lamba, -1)`.
     *
     * @param {number} lambda The rate parameter
     *
     * @return {number} A random number following an Exponential distribution
     */
    RANDOM.nextExponential = function(lambda) {
        if ('number' !== typeof lambda) {
            throw new TypeError('nextExponential: lambda must be number.');
        }
        if (lambda <= 0) {
            throw new TypeError('nextExponential: ' +
                                'lambda must be greater than 0.');
        }
        return - Math.log(1 - Math.random()) / lambda;
    };

    /**
     * ## RANDOM.nextBinomial
     *
     * Generates random numbers following the Binomial distribution.
     *
     * User must specify the probability of success and the number of trials.
     *
     * @param {number} p The probability of success
     * @param {number} trials The number of trials
     *
     * @return {number} The sum of successes in n trials
     */
    RANDOM.nextBinomial = function(p, trials) {
        var counter, sum;

        if ('number' !== typeof p) {
            throw new TypeError('nextBinomial: p must be number.');
        }
        if ('number' !== typeof trials) {
            throw new TypeError('nextBinomial: trials must be number.');
        }
        if (p < 0 || p > 1) {
            throw new TypeError('nextBinomial: p must between 0 and 1.');
        }
        if (trials < 1) {
            throw new TypeError('nextBinomial: trials must be greater than 0.');
        }

        counter = 0;
        sum = 0;

        while(counter < trials){
            if (Math.random() < p) {
                sum += 1;
            }
            counter++;
        }

        return sum;
    };

    /**
     * ## RANDOM.nextGamma
     *
     * Generates random numbers following the Gamma distribution.
     *
     * This function is experimental and untested. No documentation.
     *
     * @experimental
     */
    RANDOM.nextGamma = function(alpha, k) {
        var intK, kDiv, alphaDiv;
        var u1, u2, u3;
        var x, i, tmp;

        if ('number' !== typeof alpha) {
            throw new TypeError('nextGamma: alpha must be number.');
        }
        if ('number' !== typeof k) {
            throw new TypeError('nextGamma: k must be number.');
        }
        if (alpha < 1) {
            throw new TypeError('nextGamma: alpha must be greater than 1.');
        }
        if (k < 1) {
            throw new TypeError('nextGamma: k must be greater than 1.');
        }

        u1 = Math.random();
        u2 = Math.random();
        u3 = Math.random();

        intK = Math.floor(k) + 3;
        kDiv = 1 / k;

        alphaDiv = 1 / alpha;

        x = 0;
        for (i = 3 ; ++i < intK ; ) {
            x += Math.log(Math.random());
        }

        x *= - alphaDiv;

        tmp = Math.log(u3) *
            (Math.pow(u1, kDiv) /
             ((Math.pow(u1, kDiv) + Math.pow(u2, 1 / (1 - k)))));

        tmp *=  - alphaDiv;

        return x + tmp;
    };

    /**
     * ### RANDOM.randomString
     *
     * Creates a parametric random string
     *
     * @param {number} len The length of string (must be > 0). Default, 6.
     * @param {string} chars A code specifying which sets of characters
     *   to use. Available symbols (default 'a'):
     *      - 'a': lower case letters
     *      - 'A': upper case letters
     *      - '1': digits
     *      - '!': all remaining symbols (excluding spaces)
     *      - '_': spaces (it can be followed by an integer > 0
     *             controlling the frequency of spaces, default = 1)
     * @param {boolean} useChars If TRUE, the characters of the chars
     *   parameter are used as they are instead of interpreted as
     *   special symbols. Default FALSE.
     *
     * @return {string} result The random string
     *
     * Kudos to: http://stackoverflow.com/questions/10726909/
     *           random-alpha-numeric-string-in-javascript
     */
    RANDOM.randomString = function(len, chars, useChars) {
        var mask, result, i, nSpaces;
        if ('undefined' !== typeof len) {
            if ('number' !== typeof len || len < 1) {
                throw new Error('randomString: len must a number > 0 or ' +
                                'undefined. Found: ' + len);

            }
        }
        if ('undefined' !== typeof chars) {
            if ('string' !== typeof chars || chars.trim() === '') {
                throw new Error('randomString: chars must a non-empty string ' +
                                'or undefined. Found: ' + chars);

            }
        }
        else if (useChars) {
            throw new Error('randomString: useChars is TRUE, but chars ' +
                            'is undefined.');

        }

        // Defaults.
        len = len || 6;
        chars = chars || 'a';

        // Create/use mask from chars.
        mask = '';
        if (!useChars) {
            if (chars.indexOf('a') > -1) mask += 'abcdefghijklmnopqrstuvwxyz';
            if (chars.indexOf('A') > -1) mask += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            if (chars.indexOf('1') > -1) mask += '0123456789';
            if (chars.indexOf('!') > -1) {
                mask += '!~`@#$%^&*()_+-={}[]:";\'<>?,./|\\';
            }
            // Check how many spaces we should add.
            nSpaces = chars.indexOf('_');
            if (nSpaces > -1) {
                nSpaces = chars.charAt(nSpaces + 1);
                // nSpaces is integer > 0 or 1.
                nSpaces = JSUS.isInt(nSpaces, 0) || 1;
                if (nSpaces === 1) mask += ' ';
                else if (nSpaces === 2) mask += '  ';
                else if (nSpaces === 3) mask += '   ';
                else {
                    i = -1;
                    for ( ; ++i < nSpaces ; ) {
                        mask += ' ';
                    }
                }
            }
        }
        else {
            mask = chars;
        }

        i = -1, result = '';
        for ( ; ++i < len ; ) {
            result += mask[Math.floor(Math.random() * mask.length)];
        }
        return result;
    };

    /**
     * ### RANDOM.randomEmail
     *
     * Creates a random email address
     *
     * @TODO: add options.
     *
     * @return {string} result The random email
     */
    RANDOM.randomEmail = function() {
        return RANDOM.randomString(RANDOM.randomInt(5,15), '!Aa0') + '@' +
            RANDOM.randomString(RANDOM.randomInt(3,10))  + '.' +
            RANDOM.randomString(RANDOM.randomInt(2,3));
    };

    JSUS.extend(RANDOM);

})('undefined' !== typeof JSUS ? JSUS : module.parent.exports.JSUS);

/**
 * # TIME
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Collection of static functions related to the generation,
 * manipulation, and formatting of time strings in JavaScript
 */
(function (JSUS) {

    "use strict";

    function TIME() {}

    function pad(number) {
        return (number < 10) ? '0' + number : number;
    }

    function _getTime(ms) {
        var d, res;
        d = new Date();
        res = pad(d.getHours()) + ':' + pad(d.getMinutes()) + ':' +
              pad(d.getSeconds());
        if (ms) res += ':' + pad(d.getMilliseconds());
        return res;
    }

    // Polyfill for Date.toISOString (IE7, IE8, IE9)
    // Kudos: https://developer.mozilla.org/en-US/docs/Web/
    // JavaScript/Reference/Global_Objects/Date/toISOString
    if (!Date.prototype.toISOString) {

        Date.prototype.toISOString = function() {
            var ms = (this.getUTCMilliseconds() / 1000).toFixed(3);
            return this.getUTCFullYear() +
                '-' + pad(this.getUTCMonth() + 1) +
                '-' + pad(this.getUTCDate()) +
                'T' + pad(this.getUTCHours()) +
                ':' + pad(this.getUTCMinutes()) +
                ':' + pad(this.getUTCSeconds()) +
                '.' + ms.slice(2, 5) + 'Z';
        };
    }

    /**
     * ## TIME.getDate
     *
     * Returns a string representation of the current date and time (ISO)
     *
     * String is formatted as follows:
     *
     * YYYY-MM-DDTHH:mm:ss.sssZ
     *
     * @return {string} Formatted time string YYYY-MM-DDTHH:mm:ss.sssZ
     */
    TIME.getDate = TIME.getFullDate = function() {
        return new Date().toISOString();
    };

    /**
     * ## TIME.getTime
     *
     * Returns a string representation of the current time
     *
     * String is ormatted as follows:
     *
     * hh:mm:ss
     *
     * @return {string} Formatted time string hh:mm:ss
     *
     * @see TIME.getTimeM
     */
    TIME.getTime = function() {
        return _getTime();
    };

    /**
     * ## TIME.getTimeM
     *
     * Like TIME.getTime, but with millisecondsx
     *
     * String is ormatted as follows:
     *
     * hh:mm:ss:mls
     *
     * @return {string} Formatted time string hh:mm:ss:mls
     *
     * @see TIME.getTime
     */
    TIME.getTimeM = function() {
        return _getTime(true);
    };

    /**
     * ## TIME.parseMilliseconds
     *
     * Parses milliseconds into an array of days, hours, minutes and seconds
     *
     * @param {number} ms Integer representing milliseconds
     *
     * @return {array} Milleconds parsed in days, hours, minutes, and seconds
     */
    TIME.parseMilliseconds = function(ms) {
        var result, x, seconds, minutes, hours, days;
        if ('number' !== typeof ms) {
            throw new TypeError('TIME.parseMilliseconds: ms must be number.');
        }
        result = [];
        x = ms / 1000;
        result[4] = x;
        seconds = x % 60;
        result[3] = Math.floor(seconds);
        x = x / 60;
        minutes = x % 60;
        result[2] = Math.floor(minutes);
        x = x / 60;
        hours = x % 24;
        result[1] = Math.floor(hours);
        x = x / 24;
        days = x;
        result[1] = Math.floor(days);
        return result;
    };

    /**
     * ## TIME.now
     *
     * Shortcut to Date.now (when existing), or its polyfill
     *
     * @return {number} The timestamp now
     */
    TIME.now = 'function' === typeof Date.now ?
        Date.now : function() { return new Date().getTime(); }

    JSUS.extend(TIME);

})('undefined' !== typeof JSUS ? JSUS : module.parent.exports.JSUS);

/**
 * # PARSE
 * Copyright(c) 2017 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Collection of static functions related to parsing strings
 */
(function(JSUS) {

    "use strict";

    function PARSE() {}

    /**
     * ## PARSE.stringify_prefix
     *
     * Prefix used by PARSE.stringify and PARSE.parse
     * to decode strings with special meaning
     *
     * @see PARSE.stringify
     * @see PARSE.parse
     */
    PARSE.stringify_prefix = '!?_';

    PARSE.marker_func = PARSE.stringify_prefix + 'function';
    PARSE.marker_null = PARSE.stringify_prefix + 'null';
    PARSE.marker_und = PARSE.stringify_prefix + 'undefined';
    PARSE.marker_nan = PARSE.stringify_prefix + 'NaN';
    PARSE.marker_inf = PARSE.stringify_prefix + 'Infinity';
    PARSE.marker_minus_inf = PARSE.stringify_prefix + '-Infinity';

    /**
     * ## PARSE.getQueryString
     *
     * Parses current querystring and returns the requested variable.
     *
     * If no variable name is specified, returns the full query string.
     * If requested variable is not found returns false.
     *
     * @param {string} name Optional. If set, returns only the value
     *   associated with this variable
     * @param {string} referer Optional. If set, searches this string
     *
     * @return {string|boolean} The querystring, or a part of it, or FALSE
     *
     * Kudos:
     * @see http://stackoverflow.com/q/901115/3347292
     */
    PARSE.getQueryString = function(name, referer) {
        var regex, results;
        if (referer && 'string' !== typeof referer) {
            throw new TypeError('JSUS.getQueryString: referer must be string ' +
                                'or undefined. Found: ' + referer);
        }
        referer = referer || window.location.search;
        if ('undefined' === typeof name) return referer;
        name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
        regex = new RegExp("[\\?&]" + name + "=([^&#]*)");
        results = regex.exec(referer);
        return results === null ? false :
            decodeURIComponent(results[1].replace(/\+/g, " "));
    };

    /**
     * ## PARSE.isMobileAgent
     *
     * Returns TRUE if a user agent is for a mobile device
     *
     * @param {string} agent Optional. The user agent to check. Default:
     *   navigator.userAgent
     *
     * @return {boolean} TRUE if a user agent is for a mobile device
     */
    PARSE.isMobileAgent = function(agent) {
        var rx;
        if (!agent){
            if (!navigator) {
                throw new Error('JSUS.isMobileAgent: agent undefined and ' +
                                'no navigator. Are you in the browser?');
            }
            agent = navigator.userAgent;
        }
        else if ('string' !== typeof agent) {
            throw new TypeError('JSUS.isMobileAgent: agent must be undefined ' +
                                'or string. Found: ' + agent);
        }
        rx = new RegExp('Android|webOS|iPhone|iPad|BlackBerry|' +
                        'Windows Phone|Opera Mini|IEMobile|Mobile', 'i');

        return rx.test(agent);
    };

    /**
     * ## PARSE.tokenize
     *
     * Splits a string in tokens that users can specified as input parameter.
     * Additional options can be specified with the modifiers parameter
     *
     * - limit: An integer that specifies the number of split items
     *     after the split limit will not be included in the array
     *
     * @param {string} str The string to split
     * @param {array} separators Array containing the separators words
     * @param {object} modifiers Optional. Configuration options
     *   for the tokenizing
     *
     * @return {array} Tokens in which the string was split
     */
    PARSE.tokenize = function(str, separators, modifiers) {
        var pattern, regex;
        if (!str) return;
        if (!separators || !separators.length) return [str];
        modifiers = modifiers || {};

        pattern = '[';

        JSUS.each(separators, function(s) {
            if (s === ' ') s = '\\s';

            pattern += s;
        });

        pattern += ']+';

        regex = new RegExp(pattern);
        return str.split(regex, modifiers.limit);
    };

    /**
     * ## PARSE.stringify
     *
     * Stringifies objects, functions, primitive, undefined or null values
     *
     * Makes uses `JSON.stringify` with a special reviver function, that
     * strinfifies also functions, undefined, and null values.
     *
     * A special prefix is prepended to avoid name collisions.
     *
     * @param {mixed} o The value to stringify
     * @param {number} spaces Optional the number of indentation spaces.
     *   Defaults, 0
     *
     * @return {string} The stringified result
     *
     * @see JSON.stringify
     * @see PARSE.stringify_prefix
     */
    PARSE.stringify = function(o, spaces) {
        return JSON.stringify(o, function(key, value) {
            var type = typeof value;
            if ('function' === type) {
                return PARSE.stringify_prefix + value.toString();
            }

            if ('undefined' === type) return PARSE.marker_und;
            if (value === null) return PARSE.marker_null;
            if ('number' === type && isNaN(value)) return PARSE.marker_nan;
            if (value === Number.POSITIVE_INFINITY) return PARSE.marker_inf;
            if (value === Number.NEGATIVE_INFINITY) {
                return PARSE.marker_minus_inf;
            }

            return value;

        }, spaces);
    };

    /**
     * ## PARSE.stringifyAll
     *
     * Copies all the properties of the prototype before stringifying
     *
     * Notice: The original object is modified!
     *
     * @param {mixed} o The value to stringify
     * @param {number} spaces Optional the number of indentation spaces.
     *   Defaults, 0
     *
     * @return {string} The stringified result
     *
     * @see PARSE.stringify
     */
    PARSE.stringifyAll = function(o, spaces) {
        var i;
        if ('object' === typeof o) {
            for (i in o) {
                if (!o.hasOwnProperty(i)) {
                    if ('object' === typeof o[i]) {
                        o[i] = PARSE.stringifyAll(o[i]);
                    }
                    else {
                        o[i] = o[i];
                    }
                }
            }
        }
        return PARSE.stringify(o);
    };

    /**
     * ## PARSE.parse
     *
     * Decodes strings in objects and other values
     *
     * Uses `JSON.parse` and then looks  for special strings
     * encoded by `PARSE.stringify`
     *
     * @param {string} str The string to decode
     * @param {function} cb Optional. A callback to apply to each decoded item
     *
     * @return {mixed} The decoded value
     *
     * @see JSON.parse
     * @see PARSE.stringify_prefix
     */
    PARSE.parse = (function() {

        var len_prefix = PARSE.stringify_prefix.length,
            len_func = PARSE.marker_func.length,
            len_null = PARSE.marker_null.length,
            len_und = PARSE.marker_und.length,
            len_nan = PARSE.marker_nan.length,
            len_inf = PARSE.marker_inf.length,
            len_minus_inf = PARSE.marker_minus_inf.length;

        var customCb;

        function walker(o) {
            var i;
            if ('object' !== typeof o) return reviver(o);
            for (i in o) {
                if (o.hasOwnProperty(i)) {
                    if ('object' === typeof o[i]) walker(o[i]);
                    else o[i] = reviver(o[i]);
                }
            }
            // On the full object.
            if (customCb) customCb(o);
            return o;
        }

        function reviver(value) {
            var type;
            type = typeof value;

            if (type === 'string') {
                if (value.substring(0, len_prefix) !== PARSE.stringify_prefix) {
                    return value;
                }
                else if (value.substring(0, len_func) === PARSE.marker_func) {
                    return JSUS.eval(value.substring(len_prefix));
                }
                else if (value.substring(0, len_null) === PARSE.marker_null) {
                    return null;
                }
                else if (value.substring(0, len_und) === PARSE.marker_und) {
                    return undefined;
                }

                else if (value.substring(0, len_nan) === PARSE.marker_nan) {
                    return NaN;
                }
                else if (value.substring(0, len_inf) === PARSE.marker_inf) {
                    return Infinity;
                }
                else if (value.substring(0, len_minus_inf) ===
                         PARSE.marker_minus_inf) {

                    return -Infinity;
                }
            }

            return value;
        }

        return function(str, cb) {
            customCb = cb;
            return walker(JSON.parse(str));
        };

    })();

    /**
     * ## PARSE.isInt
     *
     * Checks if a value is an integer number or a string containing one
     *
     * Non-numbers, Infinity, NaN, and floats will return FALSE
     *
     * @param {mixed} n The value to check
     * @param {number} lower Optional. If set, n must be greater than lower
     * @param {number} upper Optional. If set, n must be smaller than upper
     * @param {boolean} leq Optional. If TRUE, n can also be equal to lower
     * @param {boolean} ueq Optional. If TRUE, n can also be equal to upper
     *
     * @return {boolean|number} The parsed integer, or FALSE if none was found
     *
     * @see PARSE.isFloat
     * @see PARSE.isNumber
     */
    PARSE.isInt = function(n, lower, upper, leq, ueq) {
        var regex, i;
        regex = /^-?\d+$/;
        if (!regex.test(n)) return false;
        i = parseInt(n, 10);
        if (i !== parseFloat(n)) return false;
        return PARSE.isNumber(i, lower, upper, leq, ueq);
    };

    /**
     * ## PARSE.isFloat
     *
     * Checks if a value is a float number or a string containing one
     *
     * Non-numbers, Infinity, NaN, and integers will return FALSE
     *
     * @param {mixed} n The value to check
     * @param {number} lower Optional. If set, n must be greater than lower
     * @param {number} upper Optional. If set, n must be smaller than upper
     * @param {boolean} leq Optional. If TRUE, n can also be equal to lower
     * @param {boolean} ueq Optional. If TRUE, n can also be equal to upper
     *
     * @return {boolean|number} The parsed float, or FALSE if none was found
     *
     * @see PARSE.isInt
     * @see PARSE.isNumber
     */
    PARSE.isFloat = function(n, lower, upper, leq, ueq) {
        var regex;
        regex = /^-?\d*(\.\d+)?$/;
        if (!regex.test(n)) return false;
        if (n.toString().indexOf('.') === -1) return false;
        return PARSE.isNumber(n, lower, upper, leq, ueq);
    };

    /**
     * ## PARSE.isNumber
     *
     * Checks if a value is a number (int or float) or a string containing one
     *
     * Non-numbers, Infinity, NaN will return FALSE
     *
     * @param {mixed} n The value to check
     * @param {number} lower Optional. If set, n must be greater than lower
     * @param {number} upper Optional. If set, n must be smaller than upper
     * @param {boolean} leq Optional. If TRUE, n can also be equal to lower
     * @param {boolean} ueq Optional. If TRUE, n can also be equal to upper
     *
     * @return {boolean|number} The parsed number, or FALSE if none was found
     *
     * @see PARSE.isInt
     * @see PARSE.isFloat
     */
    PARSE.isNumber = function(n, lower, upper, leq, ueq) {
        if (isNaN(n) || !isFinite(n) || n === "") return false;
        n = parseFloat(n);
        if ('number' === typeof lower && (leq ? n < lower : n <= lower)) {
            return false;
        }
        if ('number' === typeof upper && (ueq ? n > upper : n >= upper)) {
            return false;
        }
        return n;
    };

    /**
     * ## PARSE.isEmail
     *
     * Returns TRUE if the email's format is valid
     *
     * @param {string} The email to check
     *
     * @return {boolean} TRUE, if the email format is valid
     */
    PARSE.isEmail = function(email) {
        var idx;
        if ('string' !== typeof email) return false;
        if (email.trim().length < 5) return false;
        idx = email.indexOf('@');
        if (idx === -1 || idx === 0 || idx === (email.length-1)) return false;
        idx = email.lastIndexOf('.');
        if (idx === -1 || idx === (email.length-1) || idx > (idx+1)) {
            return false;
        }
        return true;
    };

    /**
     * ## PARSE.range
     *
     * Decodes semantic strings into an array of integers
     *
     * Let n, m  and l be integers, then the tokens of the string are
     * interpreted in the following way:
     *
     *  - `*`: Any integer
     *  - `n`: The integer `n`
     *  - `begin`: The smallest integer in `available`
     *  - `end`: The largest integer in `available`
     *  - `<n`, `<=n`, `>n`, `>=n`: Any integer (strictly) smaller/larger than n
     *  - `n..m`, `[n,m]`: Any integer between n and m (both inclusively)
     *  - `n..l..m`: Any i
     *  - `[n,m)`: Any integer between n (inclusively) and m (exclusively)
     *  - `(n,m]`: Any integer between n (exclusively) and m (inclusively)
     *  - `(n,m)`: Any integer between n and m (both exclusively)
     *  - `%n`: Divisible by n
     *  - `%n = m`: Divisible with rest m
     *  - `!`: Logical not
     *  - `|`, `||`, `,`: Logical or
     *  - `&`, `&&`: Logical and
     *
     * The elements of the resulting array are all elements of the `available`
     * array which satisfy the expression defined by `expr`.
     *
     * Examples:
     *
     *   PARSE.range('2..5, >8 & !11', '[-2,12]'); // [2,3,4,5,9,10,12]
     *
     *   PARSE.range('begin...end/2 | 3*end/4...3...end', '[0,40) & %2 = 1');
     *        // [1,3,5,7,9,11,13,15,17,19,29,35] (end == 39)
     *
     *   PARSE.range('<=19, 22, %5', '>6 & !>27');
     *        // [7,8,9,10,11,12,13,14,15,16,17,18,19,20,22,25]
     *
     *   PARSE.range('*','(3,8) & !%4, 22, (10,12]'); // [5,6,7,11,12,22]
     *
     *   PARSE.range('<4', {
     *       begin: 0,
     *       end: 21,
     *       prev: 0,
     *       cur: 1,
     *       next: function() {
     *           var temp = this.prev;
     *           this.prev = this.cur;
     *           this.cur += temp;
     *           return this.cur;
     *       },
     *       isFinished: function() {
     *           return this.cur + this.prev > this.end;
     *       }
     *   }); // [5, 8, 13, 21]
     *
     * @param {string|number} expr The selection expression
     * @param {mixed} available Optional. If undefined `expr` is used. If:
     *  - string: it is interpreted according to the same rules as `expr`;
     *  - array: it is used as it is;
     *  - object: provide functions next, isFinished and attributes begin, end
     *
     * @return {array} The array containing the specified values
     *
     * @see JSUS.eval
     */
    PARSE.range = function(expr, available) {
        var i,len, x;
        var solution;
        var begin, end, lowerBound, numbers;
        var invalidChars, invalidBeforeOpeningBracket, invalidDot;

        solution = [];
        if ('undefined' === typeof expr) return solution;

        // TODO: this could be improved, i.e. if it is a number, many
        // checks and regular expressions could be avoided.
        if ('number' === typeof expr) expr = '' + expr;
        else if ('string' !== typeof expr) {
            throw new TypeError('PARSE.range: expr must be string, number, ' +
                                'undefined. Found: ' + expr);
        }
        // If no available numbers defined, assumes all possible are allowed.
        if ('undefined' === typeof available) {
            available = expr;
        }
        else if (JSUS.isArray(available)) {
            if (available.length === 0) return solution;
            begin = Math.min.apply(null, available);
            end = Math.max.apply(null, available);
        }
        else if ('object' === typeof available) {
            if ('function' !== typeof available.next) {
                throw new TypeError('PARSE.range: available.next must be ' +
                                    'function. Found: ' + available.next);
            }
            if ('function' !== typeof available.isFinished) {
                throw new TypeError('PARSE.range: available.isFinished must ' +
                                    'be function. Found: ' +
                                    available.isFinished);
            }
            if ('number' !== typeof available.begin) {
                throw new TypeError('PARSE.range: available.begin must be ' +
                                    'number. Found: ' + available.begin);
            }
            if ('number' !== typeof available.end) {
                throw new TypeError('PARSE.range: available.end must be ' +
                                    'number. Found: ' + available.end);
            }

            begin = available.begin;
            end = available.end;
        }
        else if ('string' === typeof available) {
            // If the availble points are also only given implicitly,
            // compute set of available numbers by first guessing a bound.
            available = preprocessRange(available);

            numbers = available.match(/([-+]?\d+)/g);
            if (numbers === null) {
                throw new Error('PARSE.range: no numbers in available: ' +
                                available);
            }
            lowerBound = Math.min.apply(null, numbers);

            available = PARSE.range(available, {
                begin: lowerBound,
                end: Math.max.apply(null, numbers),
                value: lowerBound,
                next: function() {
                    return this.value++;
                },
                isFinished: function() {
                    return this.value > this.end;
                }
            });
            begin = Math.min.apply(null, available);
            end = Math.max.apply(null, available);
        }
        else {
            throw new TypeError('PARSE.range: available must be string, ' +
                                'array, object or undefined. Found: ' +
                                available);
        }

        // end -> maximal available value.
        expr = expr.replace(/end/g, parseInt(end, 10));

        // begin -> minimal available value.
        expr = expr.replace(/begin/g, parseInt(begin, 10));

        // Do all computations.
        expr = preprocessRange(expr);

        // Round all floats
        expr = expr.replace(/([-+]?\d+\.\d+)/g, function(match, p1) {
            return parseInt(p1, 10);
        });

        // Validate expression to only contain allowed symbols.
        invalidChars = /[^ \*\d<>=!\|&\.\[\],\(\)\-\+%]/g;
        if (expr.match(invalidChars)) {
            throw new Error('PARSE.range: invalid characters found: ' + expr);
        }

        // & -> && and | -> ||.
        expr = expr.replace(/([^& ]) *& *([^& ])/g, "$1&&$2");
        expr = expr.replace(/([^| ]) *\| *([^| ])/g, "$1||$2");

        // n -> (x == n).
        expr = expr.replace(/([-+]?\d+)/g, "(x==$1)");

        // n has already been replaced by (x==n) so match for that from now on.

        // %n -> !(x%n)
        expr = expr.replace(/% *\(x==([-+]?\d+)\)/,"!(x%$1)");

        // %n has already been replaced by !(x%n) so match for that from now on.
        // %n = m, %n == m -> (x%n == m).
        expr = expr.replace(/!\(x%([-+]?\d+)\) *={1,} *\(x==([-+]?\d+)\)/g,
            "(x%$1==$2)");

        // <n, <=n, >n, >=n -> (x < n), (x <= n), (x > n), (x >= n)
        expr = expr.replace(/([<>]=?) *\(x==([-+]?\d+)\)/g, "(x$1$2)");

        // n..l..m -> (x >= n && x <= m && !((x-n)%l)) for positive l.
        expr = expr.replace(
            /\(x==([-+]?\d+)\)\.{2,}\(x==(\+?\d+)\)\.{2,}\(x==([-+]?\d+)\)/g,
            "(x>=$1&&x<=$3&&!((x- $1)%$2))");

        // n..l..m -> (x <= n && x >= m && !((x-n)%l)) for negative l.
        expr = expr.replace(
            /\(x==([-+]?\d+)\)\.{2,}\(x==(-\d+)\)\.{2,}\(x==([-+]?\d+)\)/g,
            "(x<=$1&&x>=$3&&!((x- $1)%$2))");

        // n..m -> (x >= n && x <= m).
        expr = expr.replace(/\(x==([-+]?\d+)\)\.{2,}\(x==([-+]?\d+)\)/g,
                "(x>=$1&&x<=$2)");

        // (n,m), ... ,[n,m] -> (x > n && x < m), ... , (x >= n && x <= m).
        expr = expr.replace(
            /([(\[]) *\(x==([-+]?\d+)\) *, *\(x==([-+]?\d+)\) *([\])])/g,
                function (match, p1, p2, p3, p4) {
                    return "(x>" + (p1 == '(' ? '': '=') + p2 + "&&x<" +
                        (p4 == ')' ? '' : '=') + p3 + ')';
            }
        );

        // * -> true.
        expr = expr.replace('*', 1);

        // Remove spaces.
        expr = expr.replace(/\s/g, '');

        // a, b -> (a) || (b)
        expr = expr.replace(/\)[,] *(!*)\(/g, ")||$1(");

        // Validating the expression before eval"ing it.
        invalidChars = /[^ \d<>=!\|&,\(\)\-\+%x\.]/g;
        // Only & | ! may be before an opening bracket.
        invalidBeforeOpeningBracket = /[^ &!|\(] *\(/g;
        // Only dot in floats.
        invalidDot = /\.[^\d]|[^\d]\./;

        if (expr.match(invalidChars)) {
            throw new Error('PARSE.range: invalid characters found: ' + expr);
        }
        if (expr.match(invalidBeforeOpeningBracket)) {
            throw new Error('PARSE.range: invalid character before opending ' +
                            'bracket found: ' + expr);
        }
        if (expr.match(invalidDot)) {
            throw new Error('PARSE.range: invalid dot found: ' + expr);
        }

        if (JSUS.isArray(available)) {
            i = -1, len = available.length;
            for ( ; ++i < len ; ) {
                x = parseInt(available[i], 10);
                if (JSUS.eval(expr.replace(/x/g, x))) {
                    solution.push(x);
                }
            }
        }
        else {
            while (!available.isFinished()) {
                x = parseInt(available.next(), 10);
                if (JSUS.eval(expr.replace(/x/g, x))) {
                    solution.push(x);
                }
            }
        }
        return solution;
    };

    function preprocessRange(expr) {
        var mult = function(match, p1, p2, p3) {
            var n1 = parseInt(p1, 10);
            var n3 = parseInt(p3, 10);
            return p2 == '*' ? n1*n3 : n1/n3;
        };
        var add = function(match, p1, p2, p3) {
            var n1 = parseInt(p1, 10);
            var n3 = parseInt(p3, 10);
            return p2 == '-' ? n1 - n3 : n1 + n3;
        };
        var mod = function(match, p1, p2, p3) {
            var n1 = parseInt(p1, 10);
            var n3 = parseInt(p3, 10);
            return n1 % n3;
        };

        while (expr.match(/([-+]?\d+) *([*\/]) *([-+]?\d+)/g)) {
            expr = expr.replace(/([-+]?\d+) *([*\/]) *([-+]?\d+)/, mult);
        }

        while (expr.match(/([-+]?\d+) *([-+]) *([-+]?\d+)/g)) {
            expr = expr.replace(/([-+]?\d+) *([-+]) *([-+]?\d+)/, add);
        }
        while (expr.match(/([-+]?\d+) *% *([-+]?\d+)/g)) {
            expr = expr.replace(/([-+]?\d+) *% *([-+]?\d+)/, mod);
        }
        return expr;
    }

    /**
     * ## PARSE.funcName
     *
     * Returns the name of the function
     *
     * Function.name is a non-standard JavaScript property,
     * although many browsers implement it. This is a cross-browser
     * implementation for it.
     *
     * In case of anonymous functions, an empty string is returned.
     *
     * @param {function} func The function to check
     *
     * @return {string} The name of the function
     *
     * Kudos to:
     * http://matt.scharley.me/2012/03/09/monkey-patch-name-ie.html
     */
    if ('undefined' !== typeof Function.prototype.name) {
        PARSE.funcName = function(func) {
            if ('function' !== typeof func) {
                throw new TypeError('PARSE.funcName: func must be function. ' +
                                    'Found: ' + func);
            }
            return func.name;
        };
    }
    else {
        PARSE.funcName = function(func) {
            var funcNameRegex, res;
            if ('function' !== typeof func) {
                throw new TypeError('PARSE.funcName: func must be function. ' +
                                   'Found: ' + func);
            }
            funcNameRegex = /function\s([^(]{1,})\(/;
            res = (funcNameRegex).exec(func.toString());
            return (res && res.length > 1) ? res[1].trim() : "";
        };
    }

    JSUS.extend(PARSE);

})('undefined' !== typeof JSUS ? JSUS : module.parent.exports.JSUS);

/**
 * # NDDB: N-Dimensional Database
 * Copyright(c) 2021 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * NDDB is a powerful and versatile object database for node.js and the browser.
 * ---
 */
(function(J) {

    "use strict";

    if ('undefined' !== typeof module &&
        'undefined' !== typeof module.exports) {

        J = module.parent.exports.JSUS || require('JSUS').JSUS;
        module.exports = NDDB;
        // Backward compatibility.
        module.exports.NDDB = NDDB;
    }
    else {
        J = JSUS;
        window.NDDB = NDDB;
    }

    if (!J) throw new Error('NDDB: missing dependency: JSUS.');

    /**
     * ### df
     *
     * Flag indicating support for method Object.defineProperty
     *
     * If support is missing, the index `_nddbid` will be as a normal
     * property, and, therefore, it will be enumerable.
     *
     * @see nddb_insert
     * JSUS.compatibility
     */
    var df = J.compatibility().defineProperty;

    /**
     * ### NDDB.db
     *
     * Returns a new db
     *
     * @param {object} options Optional. Configuration options
     * @param {db} db Optional. An initial set of items to import
     *
     * @return {object} A new database
     */
    NDDB.db = function(opts, db) { return new NDDB(opts, db); };

    // Might get overwritten in index.js.
    NDDB.lineBreak = '\n';


    /**
     * ### NDDB.decycle
     *
     * Removes cyclic references from an object
     *
     * @param {object} e The object to decycle
     *
     * @return {object} e The decycled object
     *
     * @see https://github.com/douglascrockford/JSON-js/
     */
    NDDB.decycle = function(e) {
        if (JSON && 'function' === typeof JSON.decycle) {
            e = JSON.decycle(e);
        }
        return e;
    };

    /**
     * ### NDDB.retrocycle
     *
     * Restores cyclic references in an object previously decycled
     *
     * @param {object} e The object to retrocycle
     *
     * @return {object} e The retrocycled object
     *
     * @see https://github.com/douglascrockford/JSON-js/
     */
    NDDB.retrocycle = function(e) {
        if (JSON && 'function' === typeof JSON.retrocycle) {
            e = JSON.retrocycle(e);
        }
        return e;
    };

    /**
     * ## NDDB constructor
     *
     * Creates a new instance of NDDB
     *
     * @param {object} options Optional. Configuration options
     * @param {db} db Optional. An initial set of items to import
     */
    function NDDB(opts, db) {
        var that;
        that = this;
        opts = opts || {};

        // ## Public properties.

        this.name = opts.name || 'nddb';

        // ### nddbid
        // A global index of all objects.
        this.nddbid = new NDDBIndex('nddbid', this);

        // ### db
        // The default database.
        this.db = [];

        // ### lastSelection
        // The subset of items that were selected during the last operation
        // Notice: some of the items might not exist any more in the database.
        // @see NDDB.fetch
        this.lastSelection = [];

        // ### nddbid
        // A global index of all hashed objects
        // @see NDDBHashtray
        this.hashtray = new NDDBHashtray();

        // ###tags
        // The tags list.
        this.tags = {};

        // ### hooks
        // The list of hooks and associated callbacks
        this.hooks = {
            insert: [],
            remove: [],
            update: [],
            setwd: [],
            save: [],
            load: []
        };

        // ### sharedHooks
        // The list of hooks and associated callbacks shared with child database
        // @experimental
        this.sharedHooks = {
            insert: [],
            remove: [],
            update: [],
            setwd: [],
            save: [],
            load: []
        };

        // ### nddb_pointer
        // Pointer for iterating along all the elements
        this.nddb_pointer = 0;

        // ### query
        // QueryBuilder obj
        // @see QueryBuilder
        this.query = new QueryBuilder();

        // ### filters
        // Available db filters
        this.filters = {};
        this.addDefaultFilters();

        // ### __userDefinedFilters
        // Filters that are defined with addFilter
        // The field is needed by cloneSettings
        // @see NDDB.addFilter
        this.__userDefinedFilters = {};

        // ### __C
        // List of comparator functions
        this.__C = {};

        // ### __H
        // List of hash functions
        this.__H = {};

        // ### __I
        // List of index functions
        this.__I = {};

        // ### __I
        // List of view functions
        this.__V = {};

        // ### __update
        // Auto update options container
        this.__update = {};

        // ### __update.pointer
        // If TRUE, nddb_pointer always points to the last insert
        this.__update.pointer = false;

        // ### __update.indexes
        // If TRUE, rebuild indexes on every insert and remove
        this.__update.indexes = true;

        // ### __update.sort
        // If TRUE, sort db on every insert and remove
        this.__update.sort = false;

        // ### __shared
        // Objects shared (not cloned) among breeded NDDB instances
        this.__shared = {};

        // ### __formats
        // Currently supported formats for saving/loading items.
        this.__formats = {};

        // ### __defaultFormat
        // Default format for saving and loading items.
        this.__defaultFormat = null;

        // ### __wd
        // Default working directory for saving and loading files.
        this.__wd = null;

        // ### __parentDb
        // The parent NDDB instance from which this db was created.
        // Set in views and hashes.
        // @experimental
        this.__parentDb = null;

        // ### log
        // Std out for log messages
        //
        // It can be overriden in options by another function (`opts.log`).
        // `opts.logCtx` specif the context of execution.
        // @see NDDB.initLog
        this.log = console.log;

        // ### globalCompare
        // Dummy compare function used to sort elements in the database
        //
        // It can be overriden with a compare function returning:
        //
        //  - 0 if the objects are the same
        //  - a positive number if o2 precedes o1
        //  - a negative number if o1 precedes o2
        //
        this.globalCompare = function(o1, o2) {
            return -1;
        };

        // Adding the "compareInAllFields" function.
        //
        // @see NDDB.comparator
        this.comparator('*', function(o1, o2, trigger1, trigger2) {
            var d, c, res;
            for (d in o1) {
               c = that.getComparator(d);
               o2[d] = o2['*'];
               res = c(o1, o2);
               if (res === trigger1) return res;
               if ('undefined' !== trigger2 && res === trigger2) return res;
               // No need to delete o2[d] afer comparison.
            }

           // We are not interested in sorting.
           // Figuring out the right return value.
           if (trigger1 === 0) {
               return trigger2 === 1 ? -1 : 1;
           }
           if (trigger1 === 1) {
               return trigger2 === 0 ? -1 : 0;
           }

           return trigger2 === 0 ? 1 : 0;
        });

        // Add default formats (e.g. CSV, JSON in Node.js).
        // See `/lib/fs.js`.
        if ('function' === typeof this.addDefaultFormats) {
            this.addDefaultFormats();
        }

        // Stores information about files saved (e.g., headers).
        // Keys are filenames. There is one centeral cache for
        // all hashes and views.
        // @experimental.
        this.__cache = {};

        // Mixing in user options and defaults.
        this.init(opts);

        // Importing items, if any.
        if (db) this.importDB(db);

        if (opts.journal && 'function' === typeof NDDB.prototype.journal) {
            this.journal({ filename: opts.journal, load: true, cb: opts.cb });
        }
    }

    /**
     * ### NDDB.addFilter
     *
     * Registers a _select_ function under an alphanumeric id
     *
     * When calling `NDDB.select('d','OP','value')` the second parameter (_OP_)
     * will be matched with the callback function specified here.
     *
     * Callback function must accept three input parameters:
     *
     *  - d: dimension of comparison
     *  - value: second-term of comparison
     *  - comparator: the comparator function as defined by `NDDB.comparator`
     *
     * and return a function that execute the desired operation.
     *
     * Registering a new filter with the same name of an already existing
     * one, will overwrite the old filter without warnings.
     *
     * A reference to newly added filters are registered under
     * `__userDefinedFilter`, so that they can be copied by `cloneSettings`.
     *
     * @param {string} op An alphanumeric id
     * @param {function} cb The callback function
     *
     * @see QueryBuilder.addDefaultOperators
     */
    NDDB.prototype.addFilter = function(op, cb) {
        this.filters[op] = cb;
        this.__userDefinedFilters[op] = this.filters[op];
    };

    /**
     * ### NDDB.addDefaultFilters
     *
     * Register default filters for NDDB
     *
     * Default filters include standard logical operators:
     *
     *   - '=', '==', '!=', ''>', >=', '<', '<=',
     *
     * and:
     *
     *   - 'E': field exists (can be omitted, it is the default one)
     *   - '><': between values
     *   - '<>': not between values
     *   - 'in': element is found in array
     *   - '!in': element is noi found in array
     *   - 'LIKE': string SQL LIKE (case sensitive)
     *   - 'iLIKE': string SQL LIKE (case insensitive)
     *
     * @see NDDB.filters
     */
    NDDB.prototype.addDefaultFilters = function() {
        var that;
        that = this;

        // Exists.
        this.filters['E'] = function(d, value, comparator) {
            if ('object' === typeof d) {
                return function(elem) {
                    var d, c;
                    for (d in elem) {
                        c = that.getComparator(d);
                        value[d] = value[0]['*'];
                        if (c(elem, value, 1) > 0) {
                            value[d] = value[1]['*'];
                            if (c(elem, value, -1) < 0) {
                                return elem;
                            }
                        }
                    }
                    if ('undefined' !== typeof elem[d]) {
                        return elem;
                    }
                    else if ('undefined' !== typeof J.getNestedValue(d,elem)) {
                        return elem;
                    }
                };
            }
            else {
                return function(elem) {
                    if ('undefined' !== typeof elem[d]) {
                        return elem;
                    }
                    else if ('undefined' !== typeof J.getNestedValue(d,elem)) {
                        return elem;
                    }
                };
            }
        };

        // (strict) Equals.
        this.filters['=='] = function(d, value, comparator) {
            return function(elem) {
                if (comparator(elem, value, 0) === 0) return elem;
            };
        };

        // (strict) Not Equals.
        this.filters['!='] = function(d, value, comparator) {
            return function(elem) {
                if (comparator(elem, value, 0) !== 0) return elem;
            };
        };

        // Smaller than.
        this.filters['>'] = function(d, value, comparator) {
            if ('object' === typeof d || d === '*') {
                return function(elem) {
                    if (comparator(elem, value, 1) === 1) return elem;
                };
            }
            else {
                return function(elem) {
                    if ('undefined' === typeof elem[d]) return;
                    if (comparator(elem, value, 1) === 1) return elem;
                };
            }
        };

        // Greater than.
        this.filters['>='] = function(d, value, comparator) {
            if ('object' === typeof d || d === '*') {
                return function(elem) {
                    var compared = comparator(elem, value, 0, 1);
                    if (compared === 1 || compared === 0) return elem;
                };
            }
            else {
                return function(elem) {
                    if ('undefined' === typeof elem[d]) return;
                    var compared = comparator(elem, value, 0, 1);
                    if (compared === 1 || compared === 0) return elem;
                };
            }
        };

        // Smaller than.
        this.filters['<'] = function(d, value, comparator) {
            if ('object' === typeof d || d === '*') {
                return function(elem) {
                    if (comparator(elem, value, -1) === -1) return elem;
                };
            }
            else {
                return function(elem) {
                    if ('undefined' === typeof elem[d]) return;
                    if (comparator(elem, value, -1) === -1) return elem;
                };
            }
        };

        //  Smaller or equal than.
        this.filters['<='] = function(d, value, comparator) {
            if ('object' === typeof d || d === '*') {
                return function(elem) {
                    var compared = comparator(elem, value, 0, -1);
                    if (compared === -1 || compared === 0) return elem;
                };
            }
            else {
                return function(elem) {
                    if ('undefined' === typeof elem[d]) return;
                    var compared = comparator(elem, value, 0, -1);
                    if (compared === -1 || compared === 0) return elem;
                };
            }
        };

        // Between.
        this.filters['><'] = function(d, value, comparator) {
            if ('object' === typeof d) {
                return function(elem) {
                    var i, len;
                    len = d.length;
                    for (i = 0; i < len ; i++) {
                        if (comparator(elem, value[0], 1) > 0 &&
                            comparator(elem, value[1], -1) < 0) {
                            return elem;
                        }
                    }
                };
            }
            else if (d === '*') {
                return function(elem) {
                    var d, c;
                    for (d in elem) {
                        c = that.getComparator(d);
                        value[d] = value[0]['*'];
                        if (c(elem, value, 1) > 0) {
                            value[d] = value[1]['*'];
                            if (c(elem, value, -1) < 0) {
                                return elem;
                            }
                        }
                    }
                };
            }
            else {
                return function(elem) {
                    if (comparator(elem, value[0], 1) > 0 &&
                        comparator(elem, value[1], -1) < 0) {
                        return elem;
                    }
                };
            }
        };

        // Not Between.
        this.filters['<>'] = function(d, value, comparator) {
            if ('object' === typeof d || d === '*') {
                return function(elem) {
                    if (comparator(elem, value[0], -1) < 0 ||
                        comparator(elem, value[1], 1) > 0) {
                        return elem;
                    }
                };
            }
            else {
                return function(elem) {
                    if ('undefined' === typeof elem[d]) return;
                    if (comparator(elem, value[0], -1) < 0 ||
                        comparator(elem, value[1], 1) > 0) {
                        return elem;
                    }
                };
            }
        };

        // In Array.
        this.filters['in'] = function(d, value, comparator) {
            if ('object' === typeof d) {
                return function(elem) {
                    var i, len;
                    len = value.length;
                    for (i = 0; i < len; i++) {
                        if (comparator(elem, value[i], 0) === 0) {
                            return elem;
                        }
                    }
                };
            }
            else {
                return function(elem) {
                    var i, obj, len;
                    obj = {}, len = value.length;
                    for (i = 0; i < len; i++) {
                        obj[d] = value[i];
                        if (comparator(elem, obj, 0) === 0) {
                            return elem;
                        }
                    }
                };
            }
        };

        // Not In Array.
        this.filters['!in'] = function(d, value, comparator) {
            if ('object' === typeof d) {
                return function(elem) {
                    var i, len;
                    len = value.length;
                    for (i = 0; i < len; i++) {
                        if (comparator(elem, value[i], 0) === 0) {
                            return;
                        }
                    }
                    return elem;
                };
            }
            else {
                return function(elem) {
                    var i, obj, len;
                    obj = {}, len = value.length;
                    for (i = 0; i < len; i++) {
                        obj[d] = value[i];
                        if (comparator(elem, obj, 0) === 0) {
                            return;
                        }
                    }
                    return elem;
                };
            }
        };

        // Supports `_` and `%` wildcards.
        function generalLike(d, value, comparator, sensitive) {
            var regex;

            RegExp.escape = function(str) {
                return str.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
            };

            regex = RegExp.escape(value);
            regex = regex.replace(/%/g, '.*').replace(/_/g, '.');
            regex = new RegExp('^' + regex + '$', sensitive);

            if ('object' === typeof d) {
                return function(elem) {
                    var i, len;
                    len = d.length;
                    for (i = 0; i < len; i++) {
                        if ('undefined' !== typeof elem[d[i]]) {
                            if (regex.test(elem[d[i]])) {
                                return elem;
                            }
                        }
                    }
                };
            }
            else if (d === '*') {
                return function(elem) {
                    var d;
                    for (d in elem) {
                        if ('undefined' !== typeof elem[d]) {
                            if (regex.test(elem[d])) {
                                return elem;
                            }
                        }
                    }
                };
            }
            else {
                return function(elem) {
                    if ('undefined' !== typeof elem[d]) {
                        if (regex.test(elem[d])) {
                            return elem;
                        }
                    }
                };
            }
        }

        // Like operator (Case Sensitive).
        this.filters['LIKE'] = function likeOperator(d, value, comparator) {
            return generalLike(d, value, comparator);
        };

        // Like operator (Case Insensitive).
        this.filters['iLIKE'] = function likeOperatorI(d, value, comparator) {
            return generalLike(d, value, comparator, 'i');
        };

    };

    // ## METHODS

    /**
     * ### NDDB.throwErr
     *
     * Throws an error with a predefined format
     *
     * The format is "constructor name" . "method name" : "error text" .
     *
     * It does **not** perform type checking on itw own input parameters.
     *
     * @param {string} type Optional. The error type, e.g. 'TypeError'.
     *   Default, 'Error'
     * @param {string} method Optional. The name of the method
     * @param {string|object} err Optional. The error. Default, 'generic error'
     */
    NDDB.prototype.throwErr = function(type, method, err) {
        var errMsg, text;

        if ('object' === typeof err) text = err.stack || err;
        else if ('string' === typeof err) text = err;

        text = text || 'generic error';
        errMsg = this._getConstrName();
        if (method) errMsg = errMsg + '.' + method;
        errMsg = errMsg + ': ' + text;
        if (type === 'TypeError') throw new TypeError(errMsg);
        throw new Error(errMsg);
    };

    /**
     * ### NDDB.init
     *
     * Sets global options based on local configuration
     *
     * @param {object} options Optional. Configuration options
     *
     * TODO: type checking on input params
     */
    NDDB.prototype.init = function(options) {
        var filter, sh, i;
        var errMsg;
        options = options || {};

        this.__options = options;

        if (options.tags) {
            if ('object' !== typeof options.tags) {
                errMsg = 'options.tag must be object or undefined';
                this.throwErr('TypeError', 'init', errMsg);
            }
            this.tags = options.tags;
        }

        if ('undefined' !== typeof options.nddb_pointer) {
            if ('number' !== typeof options.nddb_pointer) {
                errMsg = 'options.nddb_pointer must be number or undefined';
                this.throwErr('TypeError', 'init', errMsg);
            }
            this.nddb_pointer = options.nddb_pointer;
        }

        if (options.hooks) {
            if ('object' !== typeof options.hooks) {
                errMsg = 'options.hooks must be object or undefined';
                this.throwErr('TypeError', 'init', errMsg);
            }
            this.hooks = options.hooks;
        }

        if (options.globalCompare) {
            if ('function' !== typeof options.globalCompare) {
                errMsg = 'options.globalCompare must be function or undefined';
                this.throwErr('TypeError', 'init', errMsg);
            }
            this.globalCompare = options.globalCompare;
        }

        if (options.update) {
            if ('object' !== typeof options.update) {
                errMsg = 'options.update must be object or undefined';
                this.throwErr('TypeError', 'init', errMsg);
            }
            if ('undefined' !== typeof options.update.pointer) {
                this.__update.pointer = options.update.pointer;
            }

            if ('undefined' !== typeof options.update.indexes) {
                this.__update.indexes = options.update.indexes;
            }

            if ('undefined' !== typeof options.update.sort) {
                this.__update.sort = options.update.sort;
            }
        }

        if ('object' === typeof options.filters) {
            if ('object' !== typeof options.filters) {
                errMsg = 'options.filters must be object or undefined';
                this.throwErr('TypeError', 'init', errMsg);
            }
            for (filter in options.filters) {
                this.addFilter(filter, options.filters[filter]);
            }
        }

        if ('object' === typeof options.shared) {
            for (sh in options.shared) {
                if (options.shared.hasOwnProperty(sh)) {
                    this.__shared[sh] = options.shared[sh];
                }
            }
        }
        // Delete the shared object, it must not be copied by _cloneSettings_.
        delete this.__options.shared;

        if (options.log) {
            this.initLog(options.log, options.logCtx);
        }

        if (options.formats) {
            if ('object' !== typeof options.formats) {
                errMsg = 'options.formats must be object or undefined';
                this.throwErr('TypeError', 'init', errMsg);
            }
            for (i in options.formats) {
                if (options.formats.hasOwnProperty(i)) {
                    this.addFormat(i, options.formats[i]);
                }
            }
        }

        if (options.defaultFormat) {
            this.setDefaultFormat(options.defaultFormat);
        }

        if (options.wd && 'function' === typeof this.setWD) {
            this.setWD(options.wd);
        }

        // Below there might modifications to the options
        // object via the cloneSettings method.

        if (options.C) {
            if ('object' !== typeof options.C) {
                errMsg = 'options.C must be object or undefined';
                this.throwErr('TypeError', 'init', errMsg);
            }
            this.__C = options.C;
        }

        if (options.H) {
            if ('object' !== typeof options.H) {
                errMsg = 'options.H must be object or undefined';
                this.throwErr('TypeError', 'init', errMsg);
            }
            for (i in options.H) {
                if (options.H.hasOwnProperty(i)) {
                    this.hash(i, options.H[i]);
                }
            }
        }

        if (options.I) {
            if ('object' !== typeof options.I) {
                errMsg = 'options.I must be object or undefined';
                this.throwErr('TypeError', 'init', errMsg);
            }
            this.__I = options.I;
            for (i in options.I) {
                if (options.I.hasOwnProperty(i)) {
                    this.index(i, options.I[i]);
                }
            }
        }
        // Views must be created at the end because they are cloning
        // all the previous settings (the method would also pollute
        // this.__options if called before all options in init are set).
        if (options.V) {
            if ('object' !== typeof options.V) {
                errMsg = 'options.V must be object or undefined';
                this.throwErr('TypeError', 'init', errMsg);
            }
            this.__V = options.V;
            for (i in options.V) {
                if (options.V.hasOwnProperty(i)) {
                    this.view(i, options.V[i]);
                }
            }
        }
    };

    /**
     * ### NDDB.initLog
     *
     * Setups and external log function to be executed in the proper context
     *
     * @param {function} cb The logging function
     * @param {object} ctx Optional. The context of the log function
     */
    NDDB.prototype.initLog = function(cb, ctx) {
        if ('function' !== typeof cb) {
            this.throwErr('TypeError', 'initLog', 'cb must be function');
        }
        ctx = ctx || this;
        if ('function' !== typeof ctx && 'object' !== typeof ctx) {
            this.throwErr('TypeError', 'initLog', 'ctx must be object or ' +
                          'function');
        }
        this.log = function() {
            var args, i, len;
            len = arguments.length;
            args = new Array(len);
            for (i = 0; i < len; i++) {
                args[i] = arguments[i];
            }
            return cb.apply(ctx, args);
        };
    };

    /**
     * ### NDDB._getConstrName
     *
     * Returns 'NDDB' or the name of the inheriting class.
     */
    NDDB.prototype._getConstrName = function() {
        return this.constructor && this.constructor.name ?
            this.constructor.name : 'NDDB';
    };

    // ## CORE

    /**
     * ### NDDB._autoUpdate
     *
     * Updates pointer, indexes, and sort items
     *
     * What is updated depends on configuration stored in `this.__update`.
     *
     * @param {object} options Optional. Configuration object
     *
     * @see NDDB.__update
     *
     * @api private
     */
    NDDB.prototype._autoUpdate = function(options) {
        var u;
        u = this.__update;
        options = options || {};

        if (options.pointer ||
            ('undefined' === typeof options.pointer && u.pointer)) {

            this.nddb_pointer = this.db.length-1;
        }
        if (options.sort ||
            ('undefined' === typeof options.sort && u.sort)) {

            this.sort();
        }
        if (options.indexes ||
            ('undefined' === typeof options.indexes && u.indexes)) {

            this.rebuildIndexes();
        }
    };

    /**
     * ### NDDB.importDB
     *
     * Imports an array of items at once
     *
     * @param {array} db Array of items to import
     */
    NDDB.prototype.importDB = function(db) {
        var i, len;
        if (!J.isArray(db)) {
            this.throwErr('TypeError', 'importDB', 'db must be array. Found: ' +
                         db);
        }
        i = -1, len = db.length;
        for ( ; ++i < len ; ) {
            nddb_insert.call(this, db[i], this.__update.indexes);
        }
        this._autoUpdate({indexes: false});
    };

    /**
     * ### NDDB.insert
     *
     * Insert an item into the database
     *
     * Item must be of type object or function.
     *
     * The following entries will be ignored:
     *
     *  - strings
     *  - numbers
     *  - undefined
     *  - null
     *
     * @param {object} o The item or array of items to insert
     * @param {object} updateRules Optional. Update rules to overwrite
     *   system-wide settings stored in `this.__update`
     *
     * @return {object|boolean} o The inserted object (might have been
     *   updated by on('insert') callbacks), or FALSE if the object could
     *   not be inserted, e.g. if a on('insert') callback returned FALSE.
     *
     * @see NDDB.__update
     * @see nddb_insert
     */
    NDDB.prototype.insert = function(o, updateRules) {
        var res;
        if ('undefined' === typeof updateRules) {
            updateRules = this.__update;
        }
        else if ('object' !== typeof updateRules) {
            this.throwErr('TypeError', 'insert',
                          'updateRules must be object or undefined. Found: ',
                          updateRules);
        }
        res = nddb_insert.call(this, o, updateRules.indexes);
        if (res === false) return false;
        // If updateRules.indexes is false, then we do not want to do it.
        // If it was true, we did it already.
        this._autoUpdate({
            indexes: false,
            pointer: updateRules.pointer,
            sort: updateRules.sort
        });
        return o;
    };

    /**
     * ### NDDB.size
     *
     * Returns the number of elements in the database
     *
     * It always returns the length of the full database, regardless of
     * current selection.
     *
     * @return {number} The total number of elements in the database
     *
     * @see NDDB.count
     */
    NDDB.prototype.size = function() {
        return this.db.length;
    };

    /**
     * ### NDDB.slice
     *
     * Creates a clone of the current NDDB object
     *
     * Takes care of calling the actual constructor of the class,
     * so that inheriting objects will preserve their prototype.
     *
     * @param {array} db Optional. Array of items to import in the new database.
     *   Default, items currently in the database
     *
     * @return {NDDB|object} The new database
     */
    NDDB.prototype.slice = function(start, end) {
        if ('number' !== typeof start) {
            this.throwErr('TypeError', 'slice', 'start must be number. ' +
                          'Found: ' + start);
        }
        if ('undefined' !== typeof end && 'number' !== typeof end) {
            this.throwErr('TypeError', 'slice', 'end must be number or ' +
                          'undefined. Found: ' + end);
        }
        // In case the class was inherited.
        return this.breed(this.fetch().slice(start, end));
    };

    /**
     * ### NDDB.breed
     *
     * Creates a clone of the current NDDB object
     *
     * Takes care of calling the actual constructor of the class,
     * so that inheriting objects will preserve their prototype.
     *
     * @param {array} db Optional. Array of items to import in the new database.
     *   Default, items currently in the database
     *
     * @return {NDDB|object} The new database
     */
    NDDB.prototype.breed = function(db) {
        if (db && !J.isArray(db)) {
            this.throwErr('TypeError', 'breed', 'db must be array ' +
                          'or undefined. Found: ' + db);
        }
        // In case the class was inherited.
        return new this.constructor(this.cloneSettings(), db || this.fetch());
    };

    /**
     * ### NDDB.cloneSettings
     *
     * Creates a clone of the configuration of this instance
     *
     * Clones:
     *  - the hashing, indexing, comparator, and view functions
     *  - the current tags
     *  - the update settings
     *  - the callback hooks
     *  - the globalCompare callback
     *
     * Copies by reference:
     *  - the shared objects
     *  - the log and logCtx options (might have cyclyc structures)
     *
     * It is possible to specifies the name of the properties to leave out
     * out of the cloned object as a parameter. By default, all options
     * are cloned.
     *
     * @param {object} leaveOut Optional. An object containing the name of
     *   the properties to leave out of the clone as keys.
     *
     * @return {object} options A copy of the current settings
     *   plus the shared objects
     */
    NDDB.prototype.cloneSettings = function(leaveOut) {
        var i, options, keepShared;
        var logCopy, logCtxCopy;
        options = this.__options || {};
        keepShared = true;

        options.H = this.__H;
        options.I = this.__I;
        options.C = this.__C;
        options.V = this.__V;
        options.tags = this.tags;
        options.update = this.__update;
        options.hooks = this.hooks;
        options.globalCompare = this.globalCompare;
        options.filters = this.__userDefinedFilters;
        options.formats = this.__formats;
        options.defaultFormat = this.__defaultFormat;
        options.wd = this.__wd;

        // Must be removed before cloning.
        if (options.log) {
            logCopy = options.log;
            delete options.log;
        }
        // Must be removed before cloning.
        if (options.logCtx) {
            logCtxCopy = options.logCtx;
            delete options.logCtx;
        }

        // Cloning.
        options = J.clone(options);

        // Removing unwanted options.
        for (i in leaveOut) {
            if (leaveOut.hasOwnProperty(i)) {
                if (i === 'shared') {
                    // 'shared' is not in `options`, we just have
                    // to remember not to add it later.
                    keepShared = false;
                    continue;
                }
                delete options[i];
            }
        }

        if (keepShared) {
            options.shared = this.__shared;
        }
        if (logCopy) {
            options.log = logCopy;
            this.__options.log = logCopy;
        }
        if (logCtxCopy) {
            options.logCtx = logCtxCopy;
            this.__options.logCtx = logCtxCopy;
        }

        return options;
    };

    /**
     * ### NDDB.toString
     *
     * Returns a human-readable representation of the database
     *
     * @return {string} out A human-readable representation of the database
     */
    NDDB.prototype.toString = function() {
        var out, i;
        out = '';
        for (i = 0; i < this.db.length; i++) {
            out += this.db[i] + "\n";
        }
        return out;
    };

    /**
     * ### NDDB.stringify
     *
     * Stringifies the items in the database in *JSON format
     *
     * Cyclic objects are decycled, functions, null, undefined, are kept.
     *
     * Evaluates pending queries with `fetch`.
     *
     * @param {object} opts Configuration options:
     *    - enclose:    adds [] around all items. Default: false.
     *    - comma:      separates items with a comma. Default: false.
     *    - pretty:     pretty-print items. Default: false
     *    - lineBreak:  line-break separator. Default: os.EOL or '\n';
     *    - decycle:    Decycle ciclic objects. Default: true.
     *
     * @return {string} out A machine-readable representation of the database
     *
     * @see JSUS.stringify
     */
    NDDB.prototype.stringify = (function() {

        function stringifyItem(item, lineBreak, spaces, comma, decycle) {
            var item, res, re;
            // TODO: merge stringify and decycle in one.
            if (decycle) item = NDDB.decycle(item);
            res = J.stringify(item, spaces);
            // Auto-escaped.
            // if (stripLineBreaks) {
            //     re = new RegExp(lineBreak, 'g');
            //     res = res.replace(re, lineBreakReplace);
            // }
            if (comma) res += ', ';
            if (lineBreak) res += lineBreak;
            return res;
        };

        return function(opts) {
            var db, i, len, out;
            var spaces, lineBreak, decycle;

            opts = opts || {};

            if (!this.size()) return opts.enclose ? '[]' : '';

            decycle = opts.decycle !== false;
            lineBreak = opts.lineBreak || NDDB.lineBreak;

            spaces = opts.pretty ? 4 : 0;
            out = opts.enclose ? '[' + lineBreak : '';

            db = this.fetch();


            // Main loop.
            i = -1, len = (db.length -1);
            for ( ; ++i < len ; ) {
                out += stringifyItem(db[i], lineBreak, spaces,
                                     opts.comma, decycle);
            }
            // Last item (no comma).
            out += stringifyItem(db[i], lineBreak, spaces, false, decycle);

            if (opts.enclose) out += ']';
            return out;
        };
    })();





    /**
     * ### NDDB.comparator
     *
     * Registers a comparator function for dimension d
     *
     * Each time a comparison between two objects containing
     * property named as the specified dimension, the registered
     * comparator function will be used.
     *
     * @param {string} d The name of the dimension
     * @param {function} comparator The comparator function
     */
    NDDB.prototype.comparator = function(d, comparator) {
        if ('string' !== typeof d) {
            this.throwErr('TypeError', 'comparator', 'd must be string');
        }
        if ('function' !== typeof comparator) {
            this.throwErr('TypeError', 'comparator', 'comparator ' +
                          'must be function');
        }
        this.__C[d] = comparator;
    };

    /**
     * ### NDDB.getComparator
     *
     * Retrieves the comparator function for dimension d.
     *
     * If no comparator function is found, returns a general comparator
     * function. Supports nested attributes search, but if a property
     * containing dots with the same name is found, this will
     * returned first.
     *
     * The dimension can be the wildcard '*' or an array of dimesions.
     * In the latter case a custom comparator function is built on the fly.
     *
     * @param {string|array} d The name/s of the dimension/s
     * @return {function} The comparator function
     *
     * @see NDDB.compare
     */
    NDDB.prototype.getComparator = function(d) {
        var i, len, comparator, comparators;

        // Given field or '*'.
        if ('string' === typeof d) {
            if ('undefined' !== typeof this.__C[d]) {
                comparator = this.__C[d];
            }
            else {
                comparator = function generalComparator(o1, o2) {
                    var v1, v2;
                    if ('undefined' === typeof o1 &&
                        'undefined' === typeof o2) return 0;
                    if ('undefined' === typeof o1) return 1;
                    if ('undefined' === typeof o2) return -1;

                    if ('undefined' !== typeof o1[d]) {
                        v1 = o1[d];
                    }
                    else if (d.lastIndexOf('.') !== -1) {
                        v1 = J.getNestedValue(d, o1);
                    }

                    if ('undefined' !== typeof o2[d]) {
                        v2 = o2[d];
                    }
                    else if (d.lastIndexOf('.') !== -1) {
                        v2 = J.getNestedValue(d, o2);
                    }

                    if ('undefined' === typeof v1 &&
                        'undefined' === typeof v2) return 0;
                    if ('undefined' === typeof v1) return 1;
                    if ('undefined' === typeof v2) return -1;
                    if (v1 > v2) return 1;
                    if (v2 > v1) return -1;

                    // In case v1 and v2 are of different types
                    // they might not be equal here.
                    if (v2 === v1) return 0;

                    // Return 1 if everything else fails.
                    return 1;
                };
            }
        }
        // Pre-defined array o fields to check.
        else {
            // Creates the array of comparators functions.
            comparators = {};
            len = d.length;
            for (i = 0; i < len; i++) {
                // Every comparator has its own d in scope.
                // TODO: here there should be no wildcard '*' (check earlier)
                comparators[d[i]] = this.getComparator(d[i]);
            }

            comparator = function(o1, o2, trigger1, trigger2) {
                var i, res, obj;
                for (i in comparators) {
                    if (comparators.hasOwnProperty(i)) {
                        if ('undefined' === typeof o1[i]) continue;
                        obj = {};
                        obj[i] = o2;
                        res = comparators[i](o1, obj);
                        if (res === trigger1) return res;
                        if ('undefined' !== trigger2 && res === trigger2) {
                            return res;
                        }
                    }
                }
                // We are not interested in sorting.
                // Figuring out the right return value
                if (trigger1 === 0) {
                    return trigger2 === 1 ? -1 : 1;
                }
                if (trigger1 === 1) {
                    return trigger2 === 0 ? -1 : 0;
                }

                return trigger2 === 0 ? 1 : 0;

            };
        }
        return comparator;
    };

    /**
     * ### NDDB.isReservedWord
     *
     * Returns TRUE if a key is a reserved word
     *
     * A word is reserved if a property or a method with
     * the same name already exists in the current instance
     *
     * @param {string} key The name of the property
     *
     * @return {boolean} TRUE, if the property exists
     */
    NDDB.prototype.isReservedWord = function(key) {
        return (this[key]) ? true : false;
    };

    /**
     * ### NDDB.index
     *
     * Registers a new indexing function
     *
     * Indexing functions give fast direct access to the
     * entries of the dataset.
     *
     * A new object `NDDB[idx]` is created, whose properties
     * are the elements indexed by the function.
     *
     * An indexing function must return a _string_ with a unique name of
     * the property under which the entry will registered, or _undefined_ if
     * the entry does not need to be indexed.
     *
     * @param {string} idx The name of index
     * @param {function} func Optional. The hashing function. Default: a
     *   function that returns the property named after the index
     *
     * @see NDDB.isReservedWord
     * @see NDDB.rebuildIndexes
     */
    NDDB.prototype.index = function(idx, func) {
        if (('string' !== typeof idx) && ('number' !== typeof idx)) {
            this.throwErr('TypeError', 'index', 'idx must be string or number');
        }
        if (this.isReservedWord(idx)) {
            this.throwErr('TypeError', 'index', 'idx is reserved word: ' + idx);
        }
        if ('undefined' === typeof func) {
            func = function(item) { return item[idx]; };
        }
        else if ('function' !== typeof func) {
            this.throwErr('TypeError', 'index', 'func must be function or ' +
                          'undefined. Found: ' + func);
        }
        this.__I[idx] = func, this[idx] = new NDDBIndex(idx, this);
    };

    /**
     * ### NDDB.view
     *
     * Registers a new view function
     *
     * View functions create a _view_ on the database that
     * excludes automatically some of the entries.
     *
     * A nested NDDB dataset is created as `NDDB[idx]`, containing
     * all the items that the callback function returns. If the
     * callback returns _undefined_ the entry will be ignored.
     *
     * @param {string} idx The name of index
     * @param {function} func Optional. The hashing function. Default: a
     *   function that returns the property named after the index
     *
     * @see NDDB.hash
     * @see NDDB.isReservedWord
     * @see NDDB.rebuildIndexes
     */
    NDDB.prototype.view = function(idx, func) {
        var settings;
        if (('string' !== typeof idx) && ('number' !== typeof idx)) {
            this.throwErr('TypeError', 'view', 'idx must be string or number');
        }
        if (this.isReservedWord(idx)) {
            this.throwErr('TypeError', 'view', 'idx is reserved word: ' + idx);
        }
        if ('undefined' === typeof func) {
            // View checks for undefined later.
            func = function(item) { return item[idx]; };
        }
        else if ('function' !== typeof func) {
            this.throwErr('TypeError', 'view', 'func must be function or ' +
                          'undefined. Found: ' + func);
        }
        // Create a copy of the current settings, without the views and hooks
        // functions, else we create an infinite loop in the constructor or
        // hooks are executed multiple times.
        this.__V[idx] = func;
        settings = this.cloneSettings( { V: true, hooks: true} );
        settings.name = idx;
        this[idx] = new NDDB(settings);
        // Reference to this instance.
        this[idx].__parentDb = this;

        return this[idx];
    };

    /**
     * ### NDDB.hash
     *
     * Registers a new hashing function
     *
     * Hash functions create an index containing multiple sub-_views_.
     *
     * A new object `NDDB[idx]` is created, whose properties
     * are _views_ on the original dataset.
     *
     * An hashing function must return a _string_ representing the
     * view under which the entry will be added, or _undefined_ if
     * the entry does not belong to any view of the index.
     *
     * @param {string} idx The name of index
     * @param {function} func Optional. The hashing function. Default: a
     *   function that returns the property named after the index
     *
     * @see NDDB.view
     * @see NDDB.isReservedWord
     * @see NDDB.rebuildIndexes
     */
    NDDB.prototype.hash = function(idx, func) {
        if (('string' !== typeof idx) && ('number' !== typeof idx)) {
            this.throwErr('TypeError', 'hash', 'idx must be string or number');
        }
        if (this.isReservedWord(idx)) {
            this.throwErr('TypeError', 'hash', 'idx is reserved word: ' + idx);
        }
        if ('undefined' === typeof func) {
            func = function(item) { return item[idx]; };
        }
        else if ('function' !== typeof func) {
            this.throwErr('TypeError', 'hash', 'func must be function or ' +
                          'undefined. Found: ' + func);
        }
        this[idx] = {}; // new NDDBHash();
        this.__H[idx] = func;

    };

    /**
     * ### NDDB.resetIndexes
     *
     * Resets all the database indexes, hashs, and views
     *
     * @see NDDB.rebuildIndexes
     * @see NDDB.index
     * @see NDDB.view
     * @see NDDB.hash
     * @see NDDB._indexIt
     * @see NDDB._viewIt
     * @see NDDB._hashIt
     */
    NDDB.prototype.resetIndexes = function(options) {
        var key, reset;
        reset = options || J.merge({
            h: true,
            v: true,
            i: true
        }, options);

        if (reset.h) {
            for (key in this.__H) {
                if (this.__H.hasOwnProperty(key)) {
                    this[key] = {};
                }
            }
        }
        if (reset.v) {
            for (key in this.__V) {
                if (this.__V.hasOwnProperty(key)) {
                    this[key] = new this.constructor();
                }
            }
        }
        if (reset.i) {
            for (key in this.__I) {
                if (this.__I.hasOwnProperty(key)) {
                    this[key] = new NDDBIndex(key, this);
                }
            }
        }

    };

    /**
     * ### NDDB.rebuildIndexes
     *
     * Rebuilds all the database indexes, hashs, and views
     *
     * @see NDDB.resetIndexes
     * @see NDDB.index
     * @see NDDB.view
     * @see NDDB.hash
     * @see NDDB._indexIt
     * @see NDDB._viewIt
     * @see NDDB._hashIt
     */
    NDDB.prototype.rebuildIndexes = function() {
        var h, i, v, cb, idx;

        h = !(J.isEmpty(this.__H));
        i = !(J.isEmpty(this.__I));
        v = !(J.isEmpty(this.__V));

        if (!h && !i && !v) return;

        if (h && !i && !v) {
            cb = this._hashIt;
        }
        else if (!h && i && !v) {
            cb = this._indexIt;
        }
        else if (!h && !i && v) {
            cb = this._viewIt;
        }
        else if (h && i && !v) {
            cb = function(o, idx) {
                this._hashIt(o);
                this._indexIt(o, idx);
            };
        }
        else if (!h && i && v) {
            cb = function(o, idx) {
                this._indexIt(o, idx);
                this._viewIt(o);
            };
        }
        else if (h && !i && v) {
            cb = function(o) {
                this._hashIt(o);
                this._viewIt(o);
            };
        }
        else {
            cb = function(o, idx) {
                this._indexIt(o, idx);
                this._hashIt(o);
                this._viewIt(o);
            };
        }

        // Reset current indexes.
        this.resetIndexes({h: h, v: v, i: i});

        for (idx = 0 ; idx < this.db.length ; idx++) {
            // _hashIt and viewIt do not need idx, it is no harm anyway
            cb.call(this, this.db[idx], idx);
        }
    };

    /**
     * ### NDDB._indexIt
     *
     * Indexes an element
     *
     * Parameter _oldIdx_ is needed if indexing is updating a previously
     * indexed item. In fact if new index is different, the old one must
     * be deleted.
     *
     * @param {object} o The element to index
     * @param {number} dbidx The position of the element in the database array
     * @param {string} oldIdx Optional. The old index name, if any.
     */
    NDDB.prototype._indexIt = function(o, dbidx, oldIdx) {
        var func, index, key;
        if (!o || J.isEmpty(this.__I)) return;

        for (key in this.__I) {
            if (this.__I.hasOwnProperty(key)) {
                func = this.__I[key];
                index = func(o);
                // If the same object has been  previously
                // added with another index delete the old one.
                if (index !== oldIdx) {
                    if ('undefined' !== typeof oldIdx) {
                        if ('undefined' !== typeof this[key].resolve[oldIdx]) {
                            this[key]._remove(oldIdx);
                        }
                    }
                }
                if ('undefined' !== typeof index) {
                    if (!this[key]) this[key] = new NDDBIndex(key, this);
                    this[key]._add(index, dbidx);
                }
            }
        }
    };

    /**
     * ### NDDB._viewIt
     *
     * Adds an element to a view
     *
     * @param {object} o The element to index
     *
     * @see NDDB.view
     */
    NDDB.prototype._viewIt = function(o) {
        var func, index, key, settings;
        if (!o || J.isEmpty(this.__V)) return false;

        for (key in this.__V) {
            if (this.__V.hasOwnProperty(key)) {
                func = this.__V[key];
                index = func(o);
                if ('undefined' === typeof index) {
                    // Element must be deleted, if already in hash.
                    if (!this[key]) continue;
                    if ('undefined' !== typeof
                        this[key].nddbid.resolve[o._nddbid]) {

                        this[key].nddbid.remove(o._nddbid);
                    }
                    continue;
                }
                //this.__V[idx] = func, this[idx] = new this.constructor();

                // TODO: When is the view not already created? Check!
                if (!this[key]) {
                    // Create a copy of the current settings,
                    // without the views functions, otherwise
                    // we establish an infinite loop in the
                    // constructor, and the hooks.
                    settings = this.cloneSettings({ V: true, hooks: true });
                    settings.name = key;
                    // console.log('saving...', this.name, this.size());

                    this[key] = new NDDB(settings);
                    // Reference to this instance.
                    this[key].__parentDb = this;
                }
                this[key].insert(o);
            }
        }
    };

    /**
     * ### NDDB._hashIt
     *
     * Hashes an element
     *
     * @param {object} o The element to hash
     *
     * @see NDDB.hash
     */
    NDDB.prototype._hashIt = function(o) {
        var h, hash, key, settings, oldHash;
        if (!o || J.isEmpty(this.__H)) return false;

        for (key in this.__H) {
            if (this.__H.hasOwnProperty(key)) {
                h = this.__H[key];
                hash = h(o);

                if ('undefined' === typeof hash) {
                    oldHash = this.hashtray.get(key, o._nddbid);
                    if (oldHash) {
                        this[key][oldHash].nddbid.remove(o._nddbid);
                        this.hashtray.remove(key, o._nddbid);
                    }
                    continue;
                }
                if (!this[key]) this[key] = {};

                if (!this[key][hash]) {
                    // Create a copy of the current settings,
                    // without the hashing functions, otherwise
                    // we create an infinite loop at first insert,
                    // and the hooks (should be called only on main db).
                    settings = this.cloneSettings({ H: true, hooks: true });
                    settings.name = hash;
                    this[key][hash] = new NDDB(settings);
                    // Reference to this instance.
                    this[key][hash].__parentDb = this;
                }
                this[key][hash].insert(o);
                this.hashtray.set(key, o._nddbid, hash);
            }
        }
    };

    // ## Event emitter / listener

    /**
     * ### NDDB.on
     *
     * Registers an event listeners
     *
     * Available events:
     *
     *   - `insert`: each time an item is inserted
     *   - `remove`: each time an item, or a collection of items, is removed
     *   - `update`: each time an item is updated
     *
     * Examples.
     *
     * ```javascript
     * var db = new NDDB();
     *
     * var trashBin = new NDDB();
     *
     * db.on('insert', function(item) {
     *     item.id = getMyNextId();
     * });
     *
     * db.on('remove', function(array) {
     *     trashBin.importDB(array);
     * });
     * ```
     *
     * @param {string} event The name of an event
     * @param {function} func The callback function associated to the event
     * @param {boolean} shared Optional. Experimental. If TRUE, this event
     *   is shared with all nested databases. Careful! It may created
     *   infinite loops. Default: FALSE.
     *
     * @see NDDB.emit
     * @experimental shared parameter
     */
    NDDB.prototype.on = function(event, func, shared) {
        if ('string' !== typeof event) {
            this.throwErr('TypeError', 'on', 'event must be string. Found: ' +
                         event);
        }
        if ('function' !== typeof func) {
            this.throwErr('TypeError', 'on', 'func must be function. Found: ' +
                          func);
        }
        if (!this.hooks[event]) {
            this.throwErr('TypeError', 'on', 'unknown event: ' + event);
        }
        this.hooks[event].push(func);
        if (shared) this.sharedHooks[event].push(func);
    };

    /**
     * ### NDDB.off
     *
     * Deregister an event, or an event listener
     *
     * @param {string} event The event name
     * @param {function} func Optional. The specific function to deregister.
     *   If empty, all the event listensers for `event` are cleared.
     *
     * @return {boolean} TRUE, if the removal is successful
     */
    NDDB.prototype.off = function(event, func) {
        var i;
        if ('string' !== typeof event) {
            this.throwErr('TypeError', 'off', 'event must be string');
        }
        if (func && 'function' !== typeof func) {
            this.throwErr('TypeError', 'off',
                          'func must be function or undefined');
        }
        if (!this.hooks[event]) {
            this.throwErr('TypeError', 'off', 'unknown event: ' + event);
        }
        if (!this.hooks[event].length) return false;

        if (!func) {
            this.hooks[event] = [];
            this.sharedHooks[event] = [];
            return true;
        }
        for (i = 0; i < this.hooks[event].length; i++) {
            // Shared hooks contains at most as many items as hooks, but
            // probably much less.
            if (this.sharedHooks[event][i] == func) {
                this.sharedHooks[event].splice(i, 1);
            }
            if (this.hooks[event][i] == func) {
                this.hooks[event].splice(i, 1);
                return true;
            }
        }
        return false;
    };

    /**
     * ### NDDB.emit
     *
     * Fires all the listeners associated with an event (optimized)
     *
     * Accepts any number of parameters, the first one is the name
     * of the event, and the remaining will be passed to the event listeners.
     *
     * If a registered event listener returns FALSE, subsequent event
     * listeners are **not** executed, and the method returns FALSE.
     *
     * @param {string} The event type ('insert', 'delete', 'update')
     *
     * @return {boolean} TRUE under normal conditions, or FALSE if at least
     *   one callback function returned FALSE.
     */
    NDDB.prototype.emit = function() {
        var event, hooks;
        var h, h2;
        var i, len, argLen, args;
        var res;
        event = arguments[0];
        if ('string' !== typeof event) {
            this.throwErr('TypeError', 'emit', 'first argument must be string');
        }

        hooks = this.hooks[event];
        if (!hooks) {
            this.throwErr('TypeError', 'emit', 'unknown event: ' + event);
        }

        // If this is a child db (e.g. a hash or a view) must fire also the
        // parent hooks. Local hooks fire first.
        // Check: all events should be fired on the parent? E.g., setWD?
        if (this.__parentDb) {
            hooks = hooks.length ?
                    hooks.concat(this.__parentDb.sharedHooks[event]) :
                    this.__parentDb.sharedHooks[event];
        }

        len = hooks.length;
        if (!len) return true;
        argLen = arguments.length;

        switch(len) {

        case 1:
            h = hooks[0];
            if (argLen === 1) res = h.call(this);
            else if (argLen === 2) res = h.call(this, arguments[1]);
            else if (argLen === 3) {
                res = h.call(this, arguments[1], arguments[2]);
            }
            else {
                args = new Array(argLen-1);
                for (i = 0; i < argLen; i++) {
                    args[i] = arguments[i+1];
                }
                res = h.apply(this, args);
            }
            break;
        case 2:
            h = hooks[0], h2 = hooks[1];
            if (argLen === 1) {
                res = h.call(this) !== false;
                res = res && h2.call(this) !== false;
            }
            else if (argLen === 2) {
                res = h.call(this, arguments[1]) !== false;
                res = res && h2.call(this, arguments[1]) !== false;
            }
            else if (argLen === 3) {
                res = h.call(this, arguments[1], arguments[2]) !== false;
                res = res && h2.call(this, arguments[1], arguments[2])!== false;
            }
            else {
                args = new Array(argLen-1);
                for (i = 0; i < argLen; i++) {
                    args[i] = arguments[i+1];
                }
                res = h.apply(this, args) !== false;
                res = res && h2.apply(this, args) !== false;
            }
            break;
        default:
             if (argLen === 1) {
                 for (i = 0; i < len; i++) {
                     res = hooks[i].call(this) !== false;
                     if (res === false) break;
                 }
            }
            else if (argLen === 2) {
                res = true;
                for (i = 0; i < len; i++) {
                    res = hooks[i].call(this, arguments[1]) !== false;
                    if (res === false) break;
                }
            }
            else if (argLen === 3) {
                res = true;
                for (i = 0; i < len; i++) {
                    res = hooks[i].call(this, arguments[1],
                                        arguments[2]) !== false;
                    if (res === false) break;
                }
            }
            else {
                args = new Array(argLen-1);
                for (i = 0; i < argLen; i++) {
                    args[i] = arguments[i+1];
                }
                res = true;
                for (i = 0; i < len; i++) {
                    res = hooks[i].apply(this, args) !== false;
                    if (res === false) break;
                }

            }
        }
        return res;
    };

    // ## Sort and Select

    function queryError(text, d, op, value) {
        var miss, err;
        miss = '(?)';
        err = this._getConstrName() + '._analyzeQuery: ' + text +
            '. Malformed query: ' + d || miss + ' ' + op || miss +
            ' ' + value || miss + '.';
        throw new Error(err);
    }

    /**
     * ### NDDB._analyzeQuery
     *
     * Validates and prepares select queries before execution
     *
     * @api private
     * @param {string} d The dimension of comparison
     * @param {string} op The operation to perform
     * @param {string} value The right-hand element of comparison
     * @return {boolean|object} The object-query or FALSE,
     *   if an error was detected
     */
    NDDB.prototype._analyzeQuery = function(d, op, value) {
        var i, len, errText;

        if ('undefined' === typeof d) {
            queryError.call(this, 'undefined dimension', d, op, value);
        }

        // Verify input.
        if ('undefined' !== typeof op) {

            if (op === '=') {
                op = '==';
            }
            else if (op === '!==') {
                op = '!=';
            }

            if (!(op in this.filters)) {
                queryError.call(this, 'unknown operator ' + op, d, op, value);
            }

            // Range-queries need an array as third parameter instance of Array.
            if (J.inArray(op,['><', '<>', 'in', '!in'])) {

                if (!(value instanceof Array)) {
                    errText = 'range-queries need an array as third parameter';
                    queryError.call(this, errText, d, op, value);
                }
                if (op === '<>' || op === '><') {

                    // It will be nested by the comparator function.
                    if (!J.isArray(d)){
                        // TODO: when to nest and when keep the '.' in the name?
                        value[0] = J.setNestedValue(d, value[0]);
                        value[1] = J.setNestedValue(d, value[1]);
                    }
                }
            }

            else if (J.inArray(op, ['!=', '>', '==', '>=', '<', '<='])){
                // Comparison queries need a third parameter.
                if ('undefined' === typeof value) {
                    errText = 'value cannot be undefined in comparison queries';
                    queryError.call(this, errText, d, op, value);
                }
                // TODO: when to nest and when keep the '.' in the name?
                // Comparison queries need to have the same
                // data structure in the compared object
                if (J.isArray(d)) {
                    len = d.length;
                    for (i = 0; i < len; i++) {
                        J.setNestedValue(d[i],value);
                    }

                }
                else {
                    value = J.setNestedValue(d,value);
                }
            }

            // other (e.g. user-defined) operators do not have constraints,
            // e.g. no need to transform the value

        }
        else if ('undefined' !== typeof value) {
            errText = 'undefined filter and defined value';
            queryError.call(this, errText, d, op, value);
        }
        else {
            op = 'E'; // exists
            value = '';
        }

        return { d:d, op:op, value:value };
    };

    /**
     * ### NDDB.distinct
     *
     * Eliminates duplicated entries
     *
     * A new database is returned and the original stays unchanged
     *
     * @return {NDDB} A copy of the current selection without duplicated entries
     *
     * @see NDDB.select()
     * @see NDDB.fetch()
     * @see NDDB.fetchValues()
     */
    NDDB.prototype.distinct = function() {
        return this.breed(J.distinct(this.db));
    };

    /**
     * ### NDDB.select
     *
     * Initiates a new query selection procedure
     *
     * Input parameters:
     *
     * - d: string representation of the dimension used to filter. Mandatory.
     * - op: operator for selection. Allowed: >, <, >=, <=, = (same as ==),
     *   ==, ===, !=, !==, in (in array), !in, >< (not in interval),
     *   <> (in interval)
     * - value: values of comparison. The following operators require
     *   an array: in, !in, ><, <>.
     *
     * Important!! No actual selection is performed until
     * the `execute` method is called, so that further selections
     * can be chained with the `or`, and `and` methods.
     *
     * To retrieve the items use one of the fetching methods.
     *
     * @param {string} d The dimension of comparison
     * @param {string} op Optional. The operation to perform
     * @param {mixed} value Optional. The right-hand element of comparison
     *
     * @return {NDDB} A new NDDB instance with the currently
     *   selected items in memory
     *
     * @see NDDB.and
     * @see NDDB.or
     * @see NDDB.execute()
     * @see NDDB.fetch()
     */
    NDDB.prototype.select = function(d, op, value) {
        this.query.reset();
        return arguments.length ? this.and(d, op, value) : this;
    };

    /**
     * ### NDDB.and
     *
     * Chains an AND query to the current selection
     *
     * @param {string} d The dimension of comparison
     * @param {string} op Optional. The operation to perform
     * @param {mixed} value Optional. The right-hand element of comparison
     *
     * @return {NDDB} A new NDDB instance with the currently
     *   selected items in memory
     *
     * @see NDDB.select
     * @see NDDB.or
     * @see NDDB.execute()
     */
    NDDB.prototype.and = function(d, op, value) {
        // TODO: Support for nested query
        //      if (!arguments.length) {
        //              addBreakInQuery();
        //      }
        //      else {
        var q, cb;
        q = this._analyzeQuery(d, op, value);
        cb = this.filters[q.op](q.d, q.value, this.getComparator(q.d));
        this.query.addCondition('AND', cb);
        //      }
        return this;
    };

    /**
     * ### NDDB.or
     *
     * Chains an OR query to the current selection
     *
     * @param {string} d The dimension of comparison
     * @param {string} op Optional. The operation to perform
     * @param {mixed} value Optional. The right-hand element of comparison
     *
     * @return {NDDB} A new NDDB instance with the currently
     *   selected items in memory
     *
     * @see NDDB.select
     * @see NDDB.and
     * @see NDDB.execute()
     */
    NDDB.prototype.or = function(d, op, value) {
        // TODO: Support for nested query
        //      if (!arguments.length) {
        //              addBreakInQuery();
        //      }
        //      else {
        var q, cb;
        q = this._analyzeQuery(d, op, value);
        cb = this.filters[q.op](q.d, q.value, this.getComparator(q.d));
        this.query.addCondition('OR', cb);
        //this.query.addCondition('OR', condition, this.getComparator(d));
        //      }
        return this;
    };


    /**
     * ### NDDB.selexec
     *
     * Shorthand for select and execute methods
     *
     * Adds a single select condition and executes it.
     *
     * @param {string} d The dimension of comparison
     * @param {string} op Optional. The operation to perform
     * @param {mixed} value Optional. The right-hand element of comparison
     *
     * @return {NDDB} A new NDDB instance with the currently
     *   selected items in memory
     *
     * @see NDDB.select
     * @see NDDB.and
     * @see NDDB.or
     * @see NDDB.execute
     * @see NDDB.fetch
     */
    NDDB.prototype.selexec = function(d, op, value) {
        return this.select(d, op, value).execute();
    };

    /**
     * ### NDDB.execute
     *
     * Returns a new NDDB instance containing only the items currently selected
     *
     * This method is deprecated and might not longer be supported in future
     * versions of NDDB. Use NDDB.breed instead.
     *
     * Does not reset the query object, and it is possible to reuse the current
     * selection multiple times.
     *
     * @param {string} d The dimension of comparison
     * @param {string} op Optional. The operation to perform
     * @param {mixed} value Optional. The right-hand element of comparison
     *
     * @return {NDDB} A new NDDB instance with selected items in the db
     *
     * @see NDDB.select
     * @see NDDB.selexec
     * @see NDDB.and
     * @see NDDB.or
     *
     * @deprecated
     */
    NDDB.prototype.execute = function() {
        return this.filter(this.query.get.call(this.query));
    };

    /**
     * ### NDDB.exists
     *
     * Returns TRUE if a copy of the object exists in the database / selection
     *
     * @param {object} o The object to look for
     *
     * @return {boolean} TRUE, if a copy is found
     *
     * @see JSUS.equals
     * @see NDDB.fetch
     */
    NDDB.prototype.exists = function(o) {
        var i, len, db;
        if ('object' !== typeof o && 'function' !== typeof o) {
            this.throwErr('TypeError', 'exists',
                          'o must be object or function');
        }
        db = this.fetch();
        len = db.length;
        for (i = 0 ; i < len ; i++) {
            if (J.equals(db[i], o)) return true;
        }
        return false;
    };

    /**
     * ### NDDB.limit
     *
     * Breeds a new NDDB instance with only the first N entries
     *
     * If a selection is active it will apply the limit to the
     * current selection only.
     *
     * If limit is a negative number, selection is made starting
     * from the end of the database.
     *
     * @param {number} limit The number of entries to include
     *
     * @return {NDDB} A "limited" copy of the current instance of NDDB
     *
     * @see NDDB.breed
     * @see NDDB.first
     * @see NDDB.last
     */
    NDDB.prototype.limit = function(limit) {
        var db;
        if ('number' !== typeof limit) {
            this.throwErr('TypeError', 'exists', 'limit must be number');
        }
        db = this.fetch();
        if (limit !== 0) {
            db = (limit > 0) ? db.slice(0, limit) : db.slice(limit);
        }
        return this.breed(db);
    };

    /**
     * ### NDDB.reverse
     *
     * Reverses the order of all the entries in the database / selection
     *
     * @see NDDB.sort
     */
    NDDB.prototype.reverse = function() {
        this.db.reverse();
        return this;
    };

    /**
     * ### NDDB.sort
     *
     * Sort the db according to one of the several criteria.
     *
     * Available sorting options:
     *
     *  - globalCompare function, if no parameter is passed
     *  - one of the dimension, if a string is passed
     *  - a custom comparator function
     *
     * A reference to the current NDDB object is returned, so that
     * further methods can be chained.
     *
     * Notice: the order of entries is changed.
     *
     * @param {string|array|function} d Optional. The criterium of sorting
     *
     * @return {NDDB} A sorted copy of the current instance of NDDB
     *
     * @see NDDB.globalCompare
     */
    NDDB.prototype.sort = function(d) {
        var func, that;

        // Global compare.
        if (!d) {
            func = this.globalCompare;
        }
        // User-defined function.
        else if ('function' === typeof d) {
            func = d;
        }
        // Array of dimensions.
        else if (d instanceof Array) {
            that = this;
            func = function(a,b) {
                var i, result;
                for (i = 0; i < d.length; i++) {
                    result = that.getComparator(d[i]).call(that, a, b);
                    if (result !== 0) return result;
                }
                return result;
            };
        }
        // Single dimension.
        else {
            func = this.getComparator(d);
        }

        this.db.sort(func);
        return this;
    };

    /**
     * ### NDDB.shuffle
     *
     * Returns a copy of the current database with randomly shuffled items
     *
     * @param {boolean} update Optional. If TRUE, items in the current database
     *   are also shuffled. Defaults, FALSE.
     *
     * @return {NDDB} A new instance of NDDB with the shuffled entries
     */
    NDDB.prototype.shuffle = function(update) {
        var shuffled;
        shuffled = J.shuffle(this.db);
        if (update) {
            this.db = shuffled;
            this.rebuildIndexes();
        }
        return this.breed(shuffled);
    };

    /**
     * ### NDDB.random
     *
     * Breeds a new database with N randomly selected items
     *
     * @param {number} N How many random items to include
     *
     * @return {NDDB} A new instance of NDDB with the shuffled entries
     */
    NDDB.prototype.random = function(N, strict) {
        var i, len, used, out, idx;
        if ('number' !== typeof N) {
            this.throwErr('TypeError', 'random',
                          'N must be number Found: ' + N);
        }
        if (N < 1) {
            this.throwErr('Error', 'random', 'N must be > 0. Found: ' + N);
        }
        len = this.db.length;
        if (N > len && strict !== false) {
            this.throwErr('Error', 'random', 'not enough items in db. Found: ' +
                          len + '. Requested: ' + N);
        }
        // Heuristic.
        if (N < (len/3)) {
            i = 0;
            out = new Array(N);
            used = {};
            while (i < N) {
                idx = J.randomInt(0, len)-1;
                if ('undefined' === typeof used[idx]) {
                    used[idx] = true;
                    out[i] = this.db[idx];
                    i++;
                }
            }
        }
        else {
            out = J.shuffle(this.db);
            out = out.slice(0, N);
        }
        return this.breed(out);
    };

    // ## Custom callbacks

    /**
     * ### NDDB.table
     *
     * Returns the frequency table for the specified indexes
     *
     * TODO: support multiple indexes, at least two.
     * TODO: support returning a sorted array.
     * TODO: keep table in memory if key is already an index
     *
     * @param {string} idx The name of first index
     *
     * @return {object} res An object containing the frequency table
     */
    NDDB.prototype.table = function(idx) {
        var res, db, i, v;
        db = this.fetch();
        res = {};
        for (i = 0; i < db.length; i++) {
            v = db[i][idx];
            if ('undefined' !== typeof v) {
                if ('undefined' === typeof res[v]) res[v] = 1;
                else res[v]++;
            }
        }
        return res;
    };

    /**
     * ### NDDB.filter
     *
     * Filters the entries according to a user-defined function
     *
     * If a selection is active it will filter items only within the
     * current selection.
     *
     * A new NDDB instance is breeded.
     *
     * @param {function} func The filtering function
     *
     * @return {NDDB} A new instance of NDDB containing the filtered entries
     *
     * @see NDDB.breed
     */
    NDDB.prototype.filter = function(func) {
        return this.breed(this.fetch().filter(func));
    };

    /**
     * ### NDDB.each || NDDB.forEach (optimized)
     *
     * Applies a callback function to each element in the db
     *
     * If a selection is active, the callback will be applied to items
     * within the current selection only.
     *
     * It accepts a variable number of input arguments, but the first one
     * must be a valid callback, and all the following are passed as parameters
     * to the callback
     *
     * @see NDDB.map
     */
    NDDB.prototype.each = NDDB.prototype.forEach = function() {
        var func, i, db, len, args, argLen;
        func = arguments[0];
        if ('function' !== typeof func) {
            this.throwErr('TypeError', 'each',
                          'first argument must be function');
        }
        db = this.fetch();
        len = db.length;
        argLen = arguments.length;
        switch(argLen) {
        case 1:
            for (i = 0 ; i < len ; i++) {
                func.call(this, db[i]);
            }
            break;
        case 2:
            for (i = 0 ; i < len ; i++) {
                func.call(this, db[i], arguments[1]);
            }
            break;
        case 3:
            for (i = 0 ; i < len ; i++) {
                func.call(this, db[i], arguments[1], arguments[2]);
            }
            break;
        default:
            args = new Array(argLen+1);
            args[0] = null;
            for (i = 1; i < argLen; i++) {
                args[i] = arguments[i];
            }
            for (i = 0 ; i < len ; i++) {
                args[0] = db[i];
                func.apply(this, args);
            }
        }
    };

    /**
     * ### NDDB.map
     *
     * Maps a callback to each element of the db and returns an array
     *
     * It accepts a variable number of input arguments, but the first one
     * must be a valid callback, and all the following are passed as
     * parameters to the callback.
     *
     * @return {array} out The result of the mapping
     *
     * @see NDDB.each
     */
    NDDB.prototype.map = function() {
        var func, i, db, len, out, o;
        var args, argLen;
        func = arguments[0];
        if ('function' !== typeof func) {
            this.throwErr('TypeError', 'map',
                          'first argument must be function');
        }
        db = this.fetch();
        len = db.length;
        argLen = arguments.length;
        out = [];
        switch(argLen) {
        case 1:
            for (i = 0 ; i < len ; i++) {
                o = func.call(this, db[i]);
                if ('undefined' !== typeof o) out.push(o);
            }
            break;
        case 2:
            for (i = 0 ; i < len ; i++) {
                o = func.call(this, db[i], arguments[1]);
                if ('undefined' !== typeof o) out.push(o);
            }
            break;
        case 3:
            for (i = 0 ; i < len ; i++) {
                o = func.call(this, db[i], arguments[1], arguments[2]);
                if ('undefined' !== typeof o) out.push(o);
            }
            break;
        default:
            args = new Array(argLen+1);
            args[0] = null;
            for (i = 1; i < argLen; i++) {
                args[i] = arguments[i];
            }
            for (i = 0 ; i < len ; i++) {
                args[0] = db[i];
                o = func.apply(this, args);
                if ('undefined' !== typeof o) out.push(o);
            }
        }
        return out;
    };

    // ## Update

    /**
     * ### NDDB.update
     *
     * Updates all selected entries
     *
     * Mixins the properties of the _update_ object in each of the
     * selected items.
     *
     * Some selected items can be skipped from update if a callback
     * on('update') returns FALSE.
     *
     * @param {object} update An object containing the properties
     *  that will be updated.
     * @param {object} updateRules Optional. Update rules to overwrite
     *   system-wide settings stored in `this.__update`
     *
     * @return {NDDB} A new instance of NDDB with updated entries
     *
     * @see JSUS.mixin
     * @see NDDB.emit
     */
    NDDB.prototype.update = function(update, updateRules) {
        var i, len, db, res;
        if ('object' !== typeof update) {
            this.throwErr('TypeError', 'update',
                          'update must be object. Found: ', update);
        }
        if ('undefined' === typeof updateRules) {
            updateRules = this.__update;
        }
        else if ('object' !== typeof updateRules) {
            this.throwErr('TypeError', 'update',
                          'updateRules must be object or undefined. Found: ',
                          updateRules);
        }
        // Gets items and resets the current selection.
        db = this.fetch();
        len = db.length;
        if (len) {
            for (i = 0; i < len; i++) {
                res = this.emit('update', db[i], update, i);
                if (res === true) {
                    J.mixin(db[i], update);
                    if (updateRules.indexes) {
                        this._indexIt(db[i]);
                        this._hashIt(db[i]);
                        this._viewIt(db[i]);
                    }
                }
            }
            // If updateRules.indexes is false, then we do not want to do it.
            // If it was true, we did it already
            this._autoUpdate({
                indexes: false,
                pointer: updateRules.pointer,
                sort: updateRules.sort
            });
        }
        return this;
    };

    // ## Deletion

    /**
     * ### NDDB.removeAllEntries
     *
     * Removes all entries from the database
     *
     * @return {NDDB} A new instance of NDDB with no entries
     */
    NDDB.prototype.removeAllEntries = function() {
        console.log('***NDDB.removeAllEntries is deprecated. Use ' +
                    'NDDB.clear instead***');
        if (!this.db.length) return this;
        this.emit('remove', this.db);
        this.nddbid.resolve = {};
        this.db = [];
        this._autoUpdate();
        return this;
    };

    /**
     * ### NDDB.clear
     *
     * Removes all volatile data
     *
     * Removes all entries, indexes, hashes, views, and tags,
     * and resets the current query selection
     *
     * Hooks, indexing, comparator, views, and hash functions are not deleted.
     */
    NDDB.prototype.clear = function() {
        var i;

        this.db = [];
        this.nddbid.resolve = {};
        this.tags = {};
        this.query.reset();
        this.nddb_pointer = 0;
        this.lastSelection = [];
        this.hashtray.clear();

        for (i in this.__H) {
            if (this[i]) this[i] = null;
        }
        for (i in this.__C) {
            if (this[i]) this[i] = null;
        }
        for (i in this.__I) {
            if (this[i]) this[i] = null;
        }
    };


    // ## Advanced operations

    /**
     * ### NDDB.join
     *
     * Performs a *left* join across all the entries of the database
     *
     * @param {string} key1 First property to compare
     * @param {string} key2 Second property to compare
     * @param {string} pos Optional. The property under which the join
     *   is performed. Defaults 'joined'
     * @param {string|array} select Optional. The properties to copy
     *   in the join. Defaults undefined
     *
     * @return {NDDB} A new database containing the joined entries
     *
     * @see NDDB._join
     * @see NDDB.breed
     *
     * TODO: allow join on multiple properties.
     */
    NDDB.prototype.join = function(key1, key2, pos, select) {
        // <!--
        // Construct a better comparator function
        // than the generic JSUS.equals
        //        if (key1 === key2 && 'undefined' !== typeof this.__C[key1]) {
        //            var comparator = function(o1,o2) {
        //                if (this.__C[key1](o1,o2) === 0) return true;
        //                return false;
        //            }
        //        }
        //        else {
        //            var comparator = JSUS.equals;
        //        }
        // -->
        return this._join(key1, key2, J.equals, pos, select);
    };

    /**
     * ### NDDB.concat
     *
     * Copies the (sub)entries with 'key2' in all the entries with 'key1'
     *
     * Nested properties can be accessed with '.'.
     *
     * @param {string} key1 First property to compare
     * @param {string} key2 Second property to compare
     * @param {string} pos Optional. The property under which the join is
     *   performed. Defaults 'joined'
     * @param {string|array} select Optional. The properties to copy in
     *   the join. Defaults undefined
     *
     * @return {NDDB} A new database containing the concatenated entries
     *
     *  @see NDDB._join
     *  @see JSUS.join
     */
    NDDB.prototype.concat = function(key1, key2, pos, select) {
        return this._join(key1, key2, function(){ return true; }, pos, select);
    };

    /**
     * ### NDDB._join
     *
     * Performs a *left* join across all the entries of the database
     *
     * The values of two keys (also nested properties are accepted) are compared
     * according to the specified comparator callback, or using `JSUS.equals`.
     *
     * If the comparator function returns TRUE, matched entries are appended
     * as a new property of the matching one.
     *
     * By default, the full object is copied in the join, but it is possible to
     * specify the name of the properties to copy as an input parameter.
     *
     * A new NDDB object breeded, so that further methods can be chained.
     *
     * @param {string} key1 First property to compare
     * @param {string} key2 Second property to compare
     * @param {function} comparator Optional. A comparator function.
     *   Defaults, `JSUS.equals`
     * @param {string} pos Optional. The property under which the join
     *   is performed. Defaults 'joined'
     * @param {string|array} select Optional. The properties to copy
     *   in the join. Defaults undefined
     *
     * @return {NDDB} A new database containing the joined entries
     *
     * @see NDDB.breed
     *
     * @api private
     */
    NDDB.prototype._join = function(key1, key2, comparator, pos, select) {
        var out, foreign_key, key;
        var i, j, o, o2;
        if (!key1 || !key2) return this.breed([]);

        comparator = comparator || J.equals;
        pos = ('undefined' !== typeof pos) ? pos : 'joined';
        if (select) {
            select = (select instanceof Array) ? select : [select];
        }

        out = [];
        for (i = 0; i < this.db.length; i++) {

            foreign_key = J.getNestedValue(key1, this.db[i]);
            if ('undefined' !== typeof foreign_key) {
                for (j = i+1; j < this.db.length; j++) {

                    key = J.getNestedValue(key2, this.db[j]);

                    if ('undefined' !== typeof key) {
                        if (comparator(foreign_key, key)) {
                            // Inject the matched obj into the reference one.
                            o = J.clone(this.db[i]);
                            o2 = select ?
                                J.subobj(this.db[j], select) : this.db[j];
                            o[pos] = o2;
                            out.push(o);
                        }
                    }
                }
            }
        }
        return this.breed(out);
    };

    /**
     * ### NDDB.split
     *
     * Splits recursively all the entries containing the specified dimension
     *
     * If a active selection if found, operation is applied only to the subset.
     *
     * A NDDB object is breeded containing all the split items.
     *
     * @param {string} key The dimension along which items will be split
     * @param {number} level Optional. Limits how deep to perform the split.
     *   Value equal to 0 means no limit in the recursive split.
     * @param {boolean} positionAsKey Optional. If TRUE, when splitting an
     *   array the position of an element is used as key. Default: FALSE.
     *
     * @return {NDDB} A new database containing the split entries
     *
     * @see JSUS.split
     */
    NDDB.prototype.split = function(key, level, positionAsKey) {
        var out, i, db, len;
        if ('string' !== typeof key) {
            this.throwErr('TypeError', 'split', 'key must be string');
        }
        db = this.fetch();
        len = db.length;
        out = [];
        for (i = 0; i < len; i++) {
            out = out.concat(J.split(db[i], key, level, positionAsKey));
        }
        return this.breed(out);
    };

    // ## Fetching

    /**
     * ### NDDB.fetch
     *
     * Returns array of selected entries in the database
     *
     * If no selection criteria is specified returns all entries.
     *
     * By default, it resets the current selection, and further calls to
     * `fetch` will return the full database.
     *
     * It stores a reference to the most recent array of selected items
     * under `this.lastSelection`.
     *
     * Examples:
     *
     * ```javascript
     * var db = new NDDB();
     * db.importDB([ { a: 1, b: {c: 2}, d: 3 } ]);
     *
     * db.fetch();    // [ { a: 1, b: {c: 2}, d: 3 } ]
     *
     * db.select('a', '=', 1);
     *
     * db.fetch(); // [ { a: 1 } ]
     * ```
     *
     * No further chaining is permitted after fetching.
     *
     * @param {boolean} doNotReset Optional. If TRUE, it does not reset
     *   the current selection. Default, TRUE
     *
     * @return {array} out The fetched values
     *
     * @see NDDB.fetchValues
     * @see NDDB.fetchArray
     * @see NDDB.fetchKeyArray
     * @see NDDB.fetchSubObj
     * @see NDDB.lastSelection
     */
    NDDB.prototype.fetch = function(doNotReset) {
        var db;
        if (this.db.length && this.query.query.length) {
            if (doNotReset && 'boolean' !== typeof doNotReset) {
                this.throwErr('TypeError', 'fetch',
                              'doNotReset must be undefined or boolean');
            }
            db = this.db.filter(this.query.get.call(this.query));
            if (!doNotReset) this.query.reset();
        }
        else {
            db = this.db;
        }
        this.lastSelection = db;
        return db;
    };

    /**
     * ### NDDB.fetchSubObj
     *
     * Fetches all the entries in the database and trims out unwanted properties
     *
     * Examples
     *
     * ```javascript
     * var db = new NDDB();
     * db.insert([ { a:1, b:{c:2}, d:3 } ]);
     * db.insert([ { a:4, b:{c:5}, d:6 } ]);
     *
     * db.fetchSubObj('a'); // [ { a: 1} , {a: 4}]
     * ```
     *
     * No further chaining is permitted after fetching.
     *
     * @param {string|array} key Optional. If set, returned objects will
     *   have only such properties
     *
     * @return {array} out The fetched objects
     *
     * @see NDDB.fetch
     * @see NDDB.fetchValues
     * @see NDDB.fetchArray
     * @see NDDB.fetchKeyArray
     */
    NDDB.prototype.fetchSubObj= function(key) {
        var i, el, db, out;
        if (!key) return [];
        db = this.fetch(), out = [];
        for (i = 0; i < db.length; i++) {
            el = J.subobj(db[i], key);
            if (!J.isEmpty(el)) out.push(el);
        }
        return out;
    };


    /**
     * ### NDDB.fetchValues
     *
     * Fetches all the values of the entries in the database
     *
     * The type of the input parameter determines the return value:
     *  - `string`: returned value is a one-dimensional array.
     *  - `array`: returned value is an object whose properties
     *    are arrays containing all the values found for those keys.
     *
     * Nested properties can be specified too.
     *
     * Examples
     *
     * ```javascript
     * var db = new NDDB();
     * db.insert([ { a:1, b:{c:2}, d:3 } ]);
     *
     * db.fetchValues();    // [ [ 1, 2, 3 ] ]
     * db.fetchValues('b'); // { b: [ {c: 2} ] }
     * db.fetchValues('d'); // { d: [ 3 ] };
     *
     * db.insert([ { a:4, b:{c:5}, d:6 } ]);
     *
     * db.fetchValues([ 'a', 'd' ]); // { a: [ 1, 4] , d: [ 3, 6] };
     * ```
     *
     * No further chaining is permitted after fetching.
     *
     * @param {string|array} key Optional. If set, returns only
     *   the value from the specified property
     *
     * @return {array} out The fetched values
     *
     * @see NDDB.fetch
     * @see NDDB.fetchArray
     * @see NDDB.fetchKeyArray
     * @see NDDB.fetchSubObj
     */
    NDDB.prototype.fetchValues = function(key) {
        var db, el, i, out, typeofkey;

        db = this.fetch();

        typeofkey = typeof key, out = {};

        if (typeofkey === 'undefined') {
            for (i=0; i < db.length; i++) {
                J.augment(out, db[i], J.keys(db[i]));
            }
        }

        else if (typeofkey === 'string') {
            out[key] = [];
            for (i=0; i < db.length; i++) {
                el = J.getNestedValue(key, db[i]);
                if ('undefined' !== typeof el) {
                    out[key].push(el);
                }
            }
        }

        else if (J.isArray(key)) {
            out = J.melt(key, J.rep([], key.length)); // object not array
            for ( i = 0 ; i < db.length ; i++) {
                el = J.subobj(db[i], key);
                if (!J.isEmpty(el)) {
                    J.augment(out, el);
                }
            }
        }

        return out;
    };

    function getValuesArray(o) {
        return J.obj2Array(o, 1);
    }

    function getKeyValuesArray(o) {
        return J.obj2KeyedArray(o, 1);
    }


    function getValuesArray_KeyString(o, key) {
        var el = J.getNestedValue(key, o);
        if ('undefined' !== typeof el) {
            return J.obj2Array(el, 1);
        }
    }

    function getValuesArray_KeyArray(o, key) {
        var el = J.subobj(o, key);
        if (!J.isEmpty(el)) {
            return J.obj2Array(el, 1);
        }
    }


    function getKeyValuesArray_KeyString(o, key) {
        var el = J.getNestedValue(key, o);
        if ('undefined' !== typeof el) {
            return key.split('.').concat(J.obj2KeyedArray(el));
        }
    }

    function getKeyValuesArray_KeyArray(o, key) {
        var el = J.subobj(o, key);
        if (!J.isEmpty(el)) {
            return J.obj2KeyedArray(el);
        }
    }

    /**
     * ### NDDB._fetchArray
     *
     * Low level primitive for fetching the entities as arrays
     *
     * Examples
     *
     * ```javascript
     * var db = new NDDB();
     * var items = [{a:1, b:2}, {a:3, b:4}, {a:5, c:6}];
     * db.importDB(items);
     *
     * db._fetch(null, 'VALUES');
     * // [ [ 1, 2 ], [ 3, 4 ], [ 5, 6] ]
     *
     * db._fetch(null, 'KEY_VALUES');
     * // [ [ 'a', 1, 'b', 2 ], [ 'a', 3, 'b', 4 ], [ 'a', 5, 'c', 6 ] ]
     *
     * db._fetch('a', 'VALUES');
     * //  [ [ 1 ], [ 3 ], [ 5 ] ]
     *
     * db._fetch('a', 'KEY_VALUES');
     * // [ [ 'a', 1 ], [ 'a', 3 ], [ 'a', 5 ] ]
     *
     * db._fetch(['a','b'], 'VALUES');
     * //  [ [ 1 , 2], [ 3, 4 ], [ 5 ] ]
     *
     * db._fetch([ 'a', 'c'] 'KEY_VALUES');
     * // [ [ 'a', 1 ], [ 'a', 3 ], [ 'a', 5, 'c', 6 ] ]
     * ```
     *
     * No further chaining is permitted after fetching.
     *
     * @api private
     * @param {string|array} key Optional. If set, returns key/values only
     *   from the specified property
     * @param {boolean} keyed. Optional. If set, also the keys are returned
     *
     * @return {array} out The fetched values
     */
    NDDB.prototype._fetchArray = function(key, keyed) {
        var db, cb, out, el, i;

        if (keyed) {

            if (!key) cb = getKeyValuesArray;

            else if ('string' === typeof key) {
                cb = getKeyValuesArray_KeyString;
            }
            else {
                cb = getKeyValuesArray_KeyArray;
            }
        }
        else {
            if (!key) cb = getValuesArray;

            else if ('string' === typeof key) {
                cb = getValuesArray_KeyString;
            }
            else {
                cb = getValuesArray_KeyArray;
            }
        }

        db = this.fetch(), out = [];
        for (i = 0; i < db.length; i++) {
            el = cb.call(db[i], db[i], key);
            if ('undefined' !== typeof el) out.push(el);
        }

        return out;
    };

    /**
     * ### NDDB.fetchArray
     *
     * Fetches the entities in the database as arrays instead of objects
     *
     * Examples
     *
     * ```javascript
     * var db = new NDDB();
     * db.insert([ { a:1, b:{c:2}, d:3 } ]);
     * db.insert([ { a:4, b:{c:5}, d:6 } ]);
     *
     * db.fetchArray();     // [ [ 1, 'c', 2, 3 ],  ]
     * db.fetchArray('b');  // [ [ 'c', 2 ] ]
     * db.fetchArray('d');  // [ [ 3 ] ]
     * ```
     *
     * No further chaining is permitted after fetching.
     *
     * @see NDDB._fetchArray
     * @see NDDB.fetchValues
     * @see NDDB.fetchKeyArray
     * @see NDDB.fetchSubObj
     */
    NDDB.prototype.fetchArray = function(key) {
        return this._fetchArray(key);
    };

    /**
     * ### NDDB.fetchKeyArray
     *
     * Like NDDB.fetchArray, but also the keys are added
     *
     * Examples
     *
     * ```javascript
     * var db = new NDDB();
     * db.insert([ { a:1, b:{c:2}, d:3 } ]);
     *
     * db.fetchKeyArray();       // [ [ 'a', 1, 'c', 2, 'd', 3 ] ]
     * db.fetchKeyArray('b'); // [ [ 'b', 'c', 2 ] ]
     * db.fetchKeyArray('d');    // [ [ 'd', 3 ] ]
     * ```
     *
     * No further chaining is permitted after fetching.
     *
     * @param {string} key Optional. If set, returns only the value
     *   from the specified property
     *
     * @return {array} out The fetched values
     *
     * @see NDDB._fetchArray
     * @see NDDB.fetchArray
     * @see NDDB.fetchValues
     * @see NDDB.fetchSubObj
     */
    NDDB.prototype.fetchKeyArray = function(key) {
        return this._fetchArray(key, true);
    };

    /**
     * ### NDDB.groupBy
     *
     * Splits the entries in the database in subgroups
     *
     * Each subgroup is formed up by elements which have the
     * same value along the specified dimension.
     *
     * An array of NDDB instances is returned, therefore no direct
     * method chaining is allowed afterwards.
     *
     * Entries containing undefined values in the specified
     * dimension will be skipped
     *
     * Examples
     *
     * ```javascript
     * var db = new NDDB();
     * var items = [{a:1, b:2}, {a:3, b:4}, {a:5}, {a:6, b:2}];
     * db.importDB(items);
     *
     * var groups = db.groupBy('b');
     * groups.length; // 2
     *
     * groups[0].fetch(); // [ { a: 1, b: 2 }, { a: 6, b: 2 } ]
     *
     * groups[1].fetch(); // [ { a: 3, b: 4 } ]
     * ```
     *
     * @param {string} key The dimension for grouping
     *
     * @return {array} outs The array of NDDB (or constructor) groups
     */
    NDDB.prototype.groupBy = function(key) {
        var groups, outs, i, el, out, db;
        db = this.fetch();
        if (!key) return db;

        groups = [], outs = [];
        for (i = 0 ; i < db.length ; i++) {
            el = J.getNestedValue(key, db[i]);
            if ('undefined' === typeof el) continue;
            // Creates a new group and add entries to it.
            if (!J.inArray(el, groups)) {
                groups.push(el);
                out = this.filter(function(elem) {
                    if (J.equals(J.getNestedValue(key, elem), el)) {
                        return elem;
                    }
                });
                // Reset nddb_pointer in subgroups.
                out.nddb_pointer = 0;
                outs.push(out);
            }
        }
        return outs;
    };

    // ## Statistics

    /**
     * ### NDDB.count
     *
     * Counts the entries containing the specified key
     *
     * If key is undefined, the size of the databse is returned.
     *
     * @param {string} key The dimension to count
     *
     * @return {number} count The number of items along the specified dimension
     *
     * @see NDDB.size
     */
    NDDB.prototype.count = function(key) {
        var i, count, len, db;
        db = this.fetch();
        len = db.length;
        if ('undefined' === typeof key) return len;
        if ('string' !== typeof key) {
            this.throwErr('TypeError', 'count',
                          'key must be string or undefined');
        }
        count = 0;
        for (i = 0; i < len; i++) {
            if (J.hasOwnNestedProperty(key, db[i])){
                count++;
            }
        }
        return count;
    };

    /**
     * ### NDDB.sum
     *
     * Returns the sum of the values of all the entries with the specified key
     *
     * Non numeric values are ignored.
     *
     * @param {string} key The dimension to sum
     *
     * @return {number} sum The sum of the values for the dimension,
     *   or NaN if it does not exist
     */
    NDDB.prototype.sum = function(key) {
        var sum, i, len, tmp, db;
        if ('string' !== typeof key) {
            this.throwErr('TypeError', 'sum', 'key must be string');
        }
        db = this.fetch(), len = db.length, sum = NaN;
        for (i = 0; i < len; i++) {
            tmp = J.getNestedValue(key, db[i]);
            if (!isNaN(tmp)) {
                if (isNaN(sum)) sum = 0;
                sum += tmp;
            }
        }
        return sum;
    };

    /**
     * ### NDDB.mean
     *
     * Returns the mean of the values of all the entries with the specified key
     *
     * Entries with non numeric values are ignored, and excluded
     * from the computation of the mean.
     *
     * @param {string} key The dimension to average
     *
     * @return {number} The mean of the values for the dimension,
     *   or NaN if it does not exist
     */
    NDDB.prototype.mean = function(key) {
        var sum, count, tmp, db;
        var i, len;
        if ('string' !== typeof key) {
            this.throwErr('TypeError', 'mean', 'key must be string');
        }
        db = this.fetch();
        len = db.length;
        sum = 0, count = 0;
        for (i = 0; i < len; i++) {
            tmp = J.getNestedValue(key, db[i]);
            if (!isNaN(tmp)) {
                sum += tmp;
                count++;
            }
        }
        return (count === 0) ? NaN : sum / count;
    };

    /**
     * ### NDDB.stddev
     *
     * Returns the std. dev. of the values of the entries with the specified key
     *
     * It uses the computational formula for sample standard deviation,
     * using N - 1 at the denominator of the sum of squares.
     *
     * Entries with non numeric values are ignored, and excluded
     * from the computation of the standard deviation.
     *
     * @param {string} key The dimension to average
     *
     * @return {number} The standard deviations of the values for the dimension,
     *   or NaN if it does not exist
     */
    NDDB.prototype.stddev = function(key) {
        var count, tmp, db, i, len;
        var sum, sumSquared;
        if ('string' !== typeof key) {
            this.throwErr('TypeError', 'stddev', 'key must be string');
        }
        db = this.fetch();
        len = db.length;
        if (!len || len === 1) return NaN;
        i = -1;
        sum = 0, sumSquared = 0, count = 0;
        for ( ; ++i < len ; ) {
            tmp = J.getNestedValue(key, db[i]);
            if (!isNaN(tmp)) {
                count++;
                sum += tmp;
                sumSquared += Math.pow(tmp, 2);
            }
        }
        tmp = sumSquared - (Math.pow(sum, 2) / count);
        return Math.sqrt( tmp / (count - 1) );
    };

    /**
     * ### NDDB.min
     *
     * Returns the min of the values of all the entries
     * in the database containing the specified key.
     *
     * Entries with non numeric values are ignored.
     *
     * @param {string} key The dimension of which to find the min
     *
     * @return {number} The smallest value for the dimension,
     *   or NaN if it does not exist
     *
     * @see NDDB.max
     */
    NDDB.prototype.min = function(key) {
        var min, tmp, db, i, len;
        if ('string' !== typeof key) {
            this.throwErr('TypeError', 'min', 'key must be string');
        }
        db = this.fetch();
        len = db.length;
        min = NaN;
        for (i = 0; i < len; i++) {
            tmp = J.getNestedValue(key, db[i]);
            if (!isNaN(tmp) && (tmp < min || isNaN(min))) {
                min = tmp;
            }
        }
        return min;
    };

    /**
     * ### NDDB.max
     *
     * Returns the max of the values of all the entries
     * in the database containing the specified key.
     *
     * Entries with non numeric values are ignored.
     *
     * @param {string} key The dimension of which to find the max
     *
     * @return {number} The biggest value for the dimension,
     *   or NaN if it does not exist
     *
     * @see NDDB.min
     */
    NDDB.prototype.max = function(key) {
        var max, i, len, tmp, db;
        if ('string' !== typeof key) {
            this.throwErr('TypeError', 'max', 'key must be string');
        }
        db = this.fetch();
        len = db.length;
        max = NaN;
        for (i = 0; i < len; i++) {
            tmp = J.getNestedValue(key, db[i]);
            if (!isNaN(tmp) && (tmp > max || isNaN(max))) {
                max = tmp;
            }
        }
        return max;
    };

    // ## Skim

    /**
     * ### NDDB.skim
     *
     * Removes the specified properties from the items
     *
     * If a active selection if found, operation is applied only to the subset.
     *
     * Use '.' (dot) to point to a nested property.
     *
     * Items with no property are automatically removed.
     *
     * @param {string|array} skim The selection of properties to remove
     *
     * @return {NDDB} A new database containing the result of the skim
     *
     * @see NDDB.keep
     * @see JSUS.skim
     */
    NDDB.prototype.skim = function(skim) {
        if ('string' !== typeof skim && !J.isArray(skim)) {
            this.throwErr('TypeError', 'skim', 'skim must be string or array');
        }
        return this.breed(this.map(function(e){
            var skimmed = J.skim(e, skim);
            if (!J.isEmpty(skimmed)) {
                return skimmed;
            }
        }));
    };

    /**
     * ### NDDB.keep
     *
     * Removes all the properties that are not specified from the items
     *
     * If a active selection if found, operation is applied only to the subset.
     *
     * Use '.' (dot) to point to a nested property.
     *
     * Items with no property are automatically removed.
     *
     * @param {string|array} skim The selection of properties to keep

     * @return {NDDB} A new database containing the result of the keep operation
     *
     * @see NDDB.skim
     * @see JSUS.keep
     */
    NDDB.prototype.keep = function(keep) {
        if ('string' !== typeof keep && !J.isArray(keep)) {
            this.throwErr('TypeError', 'keep', 'keep must be string or array');
        }
        return this.breed(this.map(function(e){
            var subobj = J.subobj(e, keep);
            if (!J.isEmpty(subobj)) {
                return subobj;
            }
        }));
    };

    // ## Diff


    /**
     * ### NDDB.diff
     *
     * Performs a diff of the entries of a specified databases
     *
     * Returns a new NDDB instance containing all the entries that
     * are present in the current instance, and *not* in the
     * database obj passed as parameter.
     *
     * @param {NDDB|array} nddb The external database to compare
     *
     * @return {NDDB} A new database containing the result of the diff
     *
     * @see NDDB.intersect
     * @see JSUS.arrayDiff
     */
    NDDB.prototype.diff = function(nddb) {
        if (!J.isArray(nddb)) {
            if ('object' !== typeof nddb || !J.isArray(nddb.db)) {
                this.throwErr('TypeError', 'diff',
                              'nddb must be array or NDDB');
            }
            nddb = nddb.db;
        }
        if (!nddb.length) {
            return this.breed([]);
        }
        return this.breed(J.arrayDiff(this.fetch(), nddb));
    };

    /**
     * ### NDDB.intersect
     *
     * Finds the entries in common with a specified database
     *
     * Returns a new NDDB instance containing all the entries that
     * are present both in the current instance of NDDB and in the
     * database obj passed as parameter.
     *
     * @param {NDDB|array} nddb The external database to compare
     *
     * @return {NDDB} A new database containing the result of the intersection
     *
     * @see NDDB.diff
     * @see JSUS.arrayIntersect
     */
    NDDB.prototype.intersect = function(nddb) {
        if (!J.isArray(nddb)) {
            if ('object' !== typeof nddb || !J.isArray(nddb.db)) {
                this.throwErr('TypeError', 'intersect',
                              'nddb must be array or NDDB');
            }
            nddb = nddb.db;
        }
        if (!nddb.length) {
            return this.breed([]);
        }
        return this.breed(J.arrayIntersect(this.fetch(), nddb));
    };


    // ## Iterator

    /**
     * ### NDDB.get
     *
     * Returns the entry at the given numerical position
     *
     * @param {number} pos The position of the entry
     *
     * @return {object|undefined} The requested item, or undefined if
     *  the index is invalid
     */
    NDDB.prototype.get = function(pos) {
        if ('number' !== typeof pos) {
            this.throwErr('TypeError', 'get', 'pos must be number');
        }
        return this.db[pos];
    };

    /**
     * ### NDDB.current
     *
     * Returns the entry at which the iterator is currently pointing
     *
     * The pointer is *not* updated.
     *
     * @return {object|undefined} The current entry, or undefined if the
     *   pointer is at an invalid position
     */
    NDDB.prototype.current = function() {
        return this.db[this.nddb_pointer];
    };

    /**
     * ### NDDB.next
     *
     * Moves the pointer to the next entry in the database and returns it
     *
     * @return {object|undefined} The next entry, or undefined
     *   if none is found
     *
     * @see NDDB.previous
     */
    NDDB.prototype.next = function() {
        var el;
        this.nddb_pointer++;
        el = NDDB.prototype.current.call(this);
        if (!el) this.nddb_pointer--;
        return el;
    };

    /**
     * ### NDDB.previous
     *
     * Moves the pointer to the previous entry in the database and returns it
     *
     * @return {object|undefined} The previous entry, or undefined
     *   if none is found
     *
     * @see NDDB.next
     */
    NDDB.prototype.previous = function() {
        var el;
        this.nddb_pointer--;
        el = NDDB.prototype.current.call(this);
        if (!el) this.nddb_pointer++;
        return el;
    };

    /**
     * ### NDDB.first
     *
     * Returns the last entry in the current selection / database
     *
     * Returns undefined if the current selection / database is empty.
     *
     * @param {string} updatePointer Optional. If set, the pointer
     *   is not moved to the first entry (if any)
     *
     * @return {object} The first entry found
     *
     * @see NDDB.last
     * @see NDDB.fetch
     * @see NDDB.nddb_pointer
     */
    NDDB.prototype.first = function(doNotUpdatePointer) {
        var db = this.fetch();
        if (db.length) {
            if (!doNotUpdatePointer) this.nddb_pointer = 0;
            return db[0];
        }
        return undefined;
    };

    /**
     * ### NDDB.last
     *
     * Returns the last entry in the current selection / database
     *
     * Returns undefined if the current selection / database is empty.
     *
     * @param {string} doNotUpdatePointer Optional. If set, the pointer is not
     *   moved to the last entry (if any)
     *
     * @return {object} The last entry found
     *
     * @see NDDB.first
     * @see NDDB.fetch
     * @see NDDB.nddb_pointer
     */
    NDDB.prototype.last = function(doNotUpdatePointer) {
        var db = this.fetch();
        if (db.length) {
            if (!doNotUpdatePointer) this.nddb_pointer = db.length-1;
            return db[db.length-1];
        }
        return undefined;
    };

    // ## Tagging


    /**
     * ### NDDB.tag
     *
     * Registers a tag associated to an object
     *
     * The second parameter can be the index of an object
     * in the database, the object itself, or undefined. In
     * the latter case, the current value of `nddb_pointer`
     * is used to create the reference.
     *
     * The tag is independent from sorting and deleting operations,
     * but changes on update of the elements of the database.
     *
     * @param {string|number} tag An alphanumeric id
     * @param {mixed} idx Optional. The reference to the object.
     *   Defaults, last element in db
     * @return {object} ref A reference to the tagged object
     *
     * @see NDDB.resolveTag
     */
    NDDB.prototype.tag = function(tag, idx) {
        var ref, typeofIdx;
        if ('string' !== typeof tag && 'number' !== typeof tag) {
            this.throwErr('TypeError', 'tag', 'tag must be string or number');
        }

        ref = null, typeofIdx = typeof idx;

        if (typeofIdx === 'undefined') {
            ref = this.db[this.db.length-1];
        }
        else if (typeofIdx === 'number') {

            if (idx > this.length || idx < 0) {
                this.throwErr('Error', 'tag', 'invalid index provided: ' + idx);
            }
            ref = this.db[idx];
        }
        else {
            ref = idx;
        }

        this.tags[tag] = ref;
        return ref;
    };

    /**
     * ### NDDB.resolveTag
     *
     * Returns the element associated with the given tag.
     *
     * @param {string} tag An alphanumeric id
     *
     * @return {object} The object associated with the tag
     *
     * @see NDDB.tag
     */
    NDDB.prototype.resolveTag = function(tag) {
        if ('string' !== typeof tag) {
            this.throwErr('TypeError', 'resolveTag', 'tag must be string');
        }
        return this.tags[tag];
    };

    // ## Save/Load.


    /**
     * ### NDDB.load
     *
     * Reads items in the specified format and loads them into db asynchronously
     *
     * @param {string} file The name of the file or other persistent storage
     * @param {object} opts Optional. A configuration object. Available
     *    options are format-dependent.
     * @param {function} cb Optional. A callback function to execute at
     *    the end of the operation. If options is not specified,
     *    cb is the second parameter.
     *
     * @see NDDB.loadSync
     */
    NDDB.prototype.load = function(file, opts, cb) {
        return executeSaveLoad(this, 'load', file, cb, opts);
    };

    /**
     * ### NDDB.save
     *
     * Saves items in the specified format asynchronously
     *
     * @see NDDB.saveSync
     */
    NDDB.prototype.save = function(file, opts, cb) {
        return executeSaveLoad(this, 'save', file, cb, opts);
    };

    /**
     * ### NDDB.loadSync
     *
     * Reads items in the specified format and loads them into db synchronously
     *
     * @see NDDB.load
     */
    NDDB.prototype.loadSync = function(file, opts, cb) {
        return executeSaveLoad(this, 'loadSync', file, cb, opts);
    };

    /**
     * ### NDDB.saveSync
     *
     * Saves items in the specified format synchronously
     *
     * @see NDDB.save
     */
    NDDB.prototype.saveSync = function(file, opts, cb) {
        return executeSaveLoad(this, 'saveSync', file, cb, opts);
    };

    // ## Formats.

    /**
     * ### NDDB.addFormat
     *
     * Registers a _format_ function
     *
     * The format object is of the type:
     *
     *     {
     *       load:     function() {}, // Async
     *       save:     function() {}, // Async
     *       loadSync: function() {}, // Sync
     *       saveSync: function() {}  // Sync
     *     }
     *
     * @param {string|array} format The format name/s
     * @param {object} The format object containing at least one
     *   pair of save/load functions (sync and async)
     */
    NDDB.prototype.addFormat = function(format, obj) {
        var f, i, len;
        validateFormatParameters(this, format, obj);
        if (!J.isArray(format)) format = [format];
        i = -1, len = format.length;
        for ( ; ++i < len ; ) {
            f = format[i];
            if ('string' !== typeof f || f.trim() === '') {
                this.throwErr('TypeError', 'addFormat', 'format must be ' +
                              'a non-empty string');
            }
            this.__formats[f] = obj;
        }
    };

    /**
     * ### NDDB.getFormat
     *
     * Returns the requested  _format_ function
     *
     * @param {string} format The format name
     * @param {string} method Optional. One of:
     *   `save`,`load`,`saveString`,`loadString`.
     *
     * @return {function|object} Format object or function or NULL if not found.
     */
    NDDB.prototype.getFormat = function(format, method) {
        var f;

        f = this.__formats[format];
        if (f && method) f = f[method];
        return f || null;
    };

    /**
     * ### NDDB.setDefaultFormat
     *
     * Sets the default format
     *
     * @param {string} format The format name or null
     *
     * @see NDDB.getDefaultFormat
     */
    NDDB.prototype.setDefaultFormat = function(format) {
         if (format !== null &&
            ('string' !== typeof format || format.trim() === '')) {

            this.throwErr('TypeError', 'setDefaultFormat', 'format must be ' +
                          'a non-empty string or null');
        }
        if (format && !this.__formats[format]) {
            this.throwErr('Error', 'setDefaultFormat', 'unknown format: ' +
                          format);
        }
        this.__defaultFormat = format;
    };

    /**
     * ### NDDB.getDefaultFormat
     *
     * Returns the default format
     *
     * @see NDDB.setDefaultFormat
     */
    NDDB.prototype.getDefaultFormat = function() {
        return this.__defaultFormat;
    };

    /**
     * ### NDDB.addDefaultFormats
     *
     * Dummy property. If overwritten it will be invoked by constructor
     */
    NDDB.prototype.addDefaultFormats = null;

    // ## Helper Methods

    /**
     * ### nddb_insert
     *
     * Insert an item into db and performs update operations
     *
     * A new property `.nddbid` is created in the object, and it will be
     * used to add the element into the global index: `NDDB.nddbid`.
     *
     * Emits the 'insert' event, and updates indexes, hashes and views
     * accordingly.
     *
     * @param {object|function} o The item to add to database
     * @param {boolean} doUpdate Optional. If TRUE, updates indexes, hashes,
     *    and views. Default, FALSE
     *
     * @return {boolean} TRUE, if item was inserted, FALSE otherwise, e.g.
     *   if a callback on('insert') returned FALSE.
     *
     * @see NDDB.nddbid
     * @see NDDB.emit
     *
     * @api private
     */
    function nddb_insert(o, doUpdate) {
        var nddbid, res;
        if (('object' !== typeof o) && ('function' !== typeof o)) {
            this.throwErr('TypeError', 'insert', 'object or function ' +
                          'expected, ' + typeof o + ' received');
        }

        // Check / create a global index.
        if ('undefined' === typeof o._nddbid) {
            // Create internal idx.
            nddbid = J.uniqueKey(this.nddbid.resolve);
            if (!nddbid) {
                this.throwErr('Error', 'insert',
                              'failed to create index: ' + o);
            }
            if (df) {
                Object.defineProperty(o, '_nddbid', { value: nddbid });
            }
            else {
                o._nddbid = nddbid;
            }
        }
        // Add to index directly (bypass api).
        this.nddbid.resolve[o._nddbid] = this.db.length;
        // End create index.
        res = this.emit('insert', o, this.db.length);
        // Stop inserting elements if one callback returned FALSE.
        if (res === false) return false;
        this.db.push(o);
        if (doUpdate) {
            this._indexIt(o, (this.db.length-1));
            this._hashIt(o);
            this._viewIt(o);
        }
        return true
    }

    /**
     * ### validateSaveLoadParameters
     *
     * Validates the parameters of a call to save, saveSync, load, loadSync
     *
     * @param {NDDB} that The reference to the current instance
     * @param {string} method The name of the method invoking validation
     * @param {string} file The file parameter
     * @param {function} cb The callback parameter
     * @param {object} The options parameter
     */
    function validateSaveLoadParameters(that, method, file, cb, options) {
        if ('string' !== typeof file || file.trim() === '') {
            that.throwErr('TypeError', method, 'file must be ' +
                          'a non-empty string. Found: ' + file);
        }
        if (cb && 'function' !== typeof cb) {
            that.throwErr('TypeError', method, 'cb must be function ' +
                          'or undefined. Found: ' + cb);
        }
        if (options && 'object' !== typeof options) {
            if ('function' !== typeof options || 'undefined' !== typeof cb) {
                that.throwErr('TypeError', method, 'options must be object ' +
                    'or undefined. Found: ' + options);
            }
        }
    }

    /**
     * ### getExtension
     *
     * Extracts the extension from a file name
     *
     * @param {string} file The filename
     *
     * @return {string} The extension or NULL if not found
     */
    function getExtension(file) {
        var format;
        format = file.lastIndexOf('.');
        return format < 0 ? null : file.substr(format+1);
    }

    /**
     * ### executeSaveLoad
     *
     * Executes save, saveSync, load, or loadSync for the requested format
     *
     * Evaluates pending queries with `fetch`.
     * Technical note: for the JSON format, queries are fetched by
     * the `stringify` method, for the CSV format, by the `saveCsv`.
     *
     * @param {NDDB} that The reference to the current instance
     * @param {string} method The name of the method invoking validation
     * @param {string} file The file parameter
     * @param {function} cb The callback parameter
     * @param {object} options The options parameter
     *
     * @return {NDDB} that The current instance for chaining
     */
    function executeSaveLoad(that, method, file, cb, options) {
        var ff, format;
        if (!that.storageAvailable()) {
            that.throwErr('Error', 'save', 'no persistent storage available');
        }
        // Cb not specified.
        if ('undefined' === typeof options && 'object' === typeof cb) {
            options = cb;
            cb = undefined;
        }
        else if ('undefined' === typeof cb && 'function' === typeof options) {
            cb = options;
            options = undefined;
        }
        validateSaveLoadParameters(that, method, file, cb, options);
        options = options || {};
        format = options.format || getExtension(file);
        // Try to get the format function based on the extension,
        // otherwise try to use the default one. Throws errors.
        ff = findFormatFunction(that, method, format);
        // Emit save or load. Options can be modified.
        that.emit(method.charAt(0) === 's' ? 'save' : 'load', options, {
            file: file,
            format: format,
            cb: cb
        });
        ff(that, file, cb, options);

        return that;
    }

    /**
     * ### findFormatFunction
     *
     * Returns the requested format function or the default one
     *
     * Throws errors.
     *
     * @param {NDDB} that The reference to the current instance
     * @param {string} method The name of the method invoking validation
     * @param {string} format The requested parameter
     *
     * @return {function} The requested format function
     */
    function findFormatFunction(that, method, format) {
        var ff, defFormat;
        if (format) ff = that.getFormat(format);
        if (ff) {
            if (!ff[method]) {
                that.throwErr('Error', method, 'format ' + format + ' found, ' +
                              'but method ' + method + ' not available');
            }
            ff = ff[method];
        }
        // Try to get default format, if the extension is not recognized.
        if (!ff) {
            defFormat = that.getDefaultFormat();
            if (!defFormat) {
                that.throwErr('Error', method, 'format ' + format + ' not ' +
                              'found and no default format specified');
            }
            ff = that.getFormat(defFormat, method);
            if (!ff) {
                that.throwErr('Error', method, 'format ' + format + ' not ' +
                              'found, but default format has no method ' +
                              method);
            }
        }
        return ff;
    }

    /**
     * ### validateFormatParameters
     *
     * Validates the parameters of a call to save, saveSync, load, loadSync
     *
     * @param {NDDB} that The reference to the current instance
     * @param {string|array} method The name/s of format/s
     * @param {object} obj The format object
     */
    function validateFormatParameters(that, format, obj) {
        if ('string' !== typeof format &&
            !J.isArray(format) && !format.length) {

            that.throwErr('TypeError', 'addFormat', 'format must be ' +
                            'a non-empty string or array');
        }
        if ('object' !== typeof obj) {
            that.throwErr('TypeError', 'addFormat', 'obj must be object');
        }
        if (!obj.save && !obj.saveSync) {
            that.throwErr('Error', 'addFormat', 'format must ' +
                          'at least one save function: sync or async');
        }
        if (!obj.load && !obj.loadSync) {
            that.throwErr('Error', 'addFormat', 'format must ' +
                          'at least one load function: sync or async');
        }
        if (obj.save || obj.load) {
            if ('function' !== typeof obj.save) {
                that.throwErr('TypeError', 'addFormat',
                              'save function is not a function');
            }
            if ('function' !== typeof obj.load) {
                that.throwErr('TypeError', 'addFormat',
                              'load function is not a function');
            }
        }
        if (obj.saveSync || obj.loadSync) {
            if ('function' !== typeof obj.saveSync) {
                that.throwErr('TypeError', 'addFormat',
                              'saveSync function is not a function');
            }
            if ('function' !== typeof obj.loadSync) {
                that.throwErr('TypeError', 'addFormat',
                              'loadSync function is not a function');
            }
        }
    }

    /**
     * # QueryBuilder
     *
     * MIT Licensed
     *
     * Helper class for NDDB query selector
     *
     * ---
     */

    /**
     * ## QueryBuilder Constructor
     *
     * Manages the _select_ queries of NDDB
     */
    function QueryBuilder() {
        // Creates the query array and internal pointer.
        this.reset();
    }

    /**
     * ### QueryBuilder.addCondition
     *
     * Adds a new _select_ condition
     *
     * @param {string} type. The type of the operation (e.g. 'OR', or 'AND')
     * @param {function} filter. The filter callback
     */
    QueryBuilder.prototype.addCondition = function(type, filter) {
        this.query[this.pointer].push({
            type: type,
            cb: filter
        });
    };

    /**
     * ### QueryBuilder.addBreak
     *
     * undocumented
     */
    QueryBuilder.prototype.addBreak = function() {
        this.pointer++;
        this.query[this.pointer] = [];
    };

    /**
     * ### QueryBuilder.reset
     *
     * Resets the current query selection
     */
    QueryBuilder.prototype.reset = function() {
        this.query = [];
        this.pointer = 0;
        this.query[this.pointer] = [];
    };


    function findCallback(obj) {
        return obj.cb;
    }

    /**
     * ### QueryBuilder.get
     *
     * Builds up the select function
     *
     * Up to three conditions it builds up a custom function without
     * loop. For more than three conditions, a loop is created.
     *
     * Expressions are evaluated from right to left, so that the last one
     * always decides the overall logic value. E.g. :
     *
     *  true AND false OR true => false OR true => TRUE
     *  true AND true OR false => true OR false => TRUE
     *
     * @return {function} The select function containing all the specified
     *   conditions
     */
    QueryBuilder.prototype.get = function() {
        var line, lineLen, f1, f2, f3, type1, type2;
        var query = this.query, pointer = this.pointer;

        // Ready to support nested queries, not yet implemented.
        if (pointer === 0) {
            line = query[pointer];
            lineLen = line.length;

            if (lineLen === 1) {
                return findCallback(line[0]);
            }

            else if (lineLen === 2) {
                f1 = findCallback(line[0]);
                f2 = findCallback(line[1]);
                type1 = line[1].type;

                switch (type1) {
                case 'OR':
                    return function(elem) {
                        if ('undefined' !== typeof f1(elem)) return elem;
                        if ('undefined' !== typeof f2(elem)) return elem;
                    };
                case 'AND':
                    return function(elem) {
                        if ('undefined' !== typeof f1(elem) &&
                            'undefined' !== typeof f2(elem)) return elem;
                    };

                case 'NOT':
                    return function(elem) {
                        if ('undefined' !== typeof f1(elem) &&
                            'undefined' === typeof f2(elem)) return elem;
                    };
                }
            }

            else if (lineLen === 3) {
                f1 = findCallback(line[0]);
                f2 = findCallback(line[1]);
                f3 = findCallback(line[2]);
                type1 = line[1].type;
                type2 = line[2].type;
                type1 = type1 + '_' + type2;
                switch (type1) {
                case 'OR_OR':
                    return function(elem) {
                        if ('undefined' !== typeof f1(elem)) return elem;
                        if ('undefined' !== typeof f2(elem)) return elem;
                        if ('undefined' !== typeof f3(elem)) return elem;
                    };

                case 'OR_AND':
                    return function(elem) {

                        if ('undefined' === typeof f3(elem)) return;
                        if ('undefined' !== typeof f2(elem)) return elem;
                        if ('undefined' !== typeof f1(elem)) return elem;
                    };

                case 'AND_OR':
                    return function(elem) {
                        if ('undefined' !== typeof f3(elem)) return elem;
                        if ('undefined' === typeof f2(elem)) return;
                        if ('undefined' !== typeof f1(elem)) return elem;
                    };

                case 'AND_AND':
                    return function(elem) {
                        if ('undefined' === typeof f3(elem)) return;
                        if ('undefined' === typeof f2(elem)) return;
                        if ('undefined' !== typeof f1(elem)) return elem;
                    };
                }
            }

            else {
                return function(elem) {
                    var i, f, type, resOK;
                    var prevType = 'OR', prevResOK = true;
                    for (i = lineLen-1 ; i > -1 ; i--) {
                        f = findCallback(line[i]);
                        type = line[i].type,
                        resOK = 'undefined' !== typeof f(elem);

                        if (type === 'OR') {
                            // Current condition is TRUE OR
                            if (resOK) return elem;
                        }

                        // Current condition is FALSE AND
                        else if (type === 'AND') {
                            if (!resOK) {
                                return;
                            }
                            // Previous check was an AND or a FALSE OR
                            else if (prevType === 'OR' && !prevResOK) {
                                return;
                            }
                        }
                        prevType = type;
                        // A previous OR is TRUE also if follows a TRUE AND
                        prevResOK = type === 'AND' ? resOK : resOK || prevResOK;

                    }
                    return elem;
                };

            }

        }
    };

    /**
     * # NDDBHashtray
     *
     * MIT Licensed
     *
     * Helper class for NDDB hash management
     *
     * ---
     */

    /**
     * ## NDDBHashtray constructor
     *
     * Creates an hashtray object to manage maps item-hashes
     *
     * @param {string} The name of the index
     * @param {array} The reference to the original database
     */
    function NDDBHashtray() {
        this.resolve = {};
    }

    NDDBHashtray.prototype.set = function(key, nddbid, hash) {
        this.resolve[key + '_' + nddbid] = hash;
    };

    NDDBHashtray.prototype.get = function(key, nddbid) {
        return this.resolve[key + '_' + nddbid];
    };

    NDDBHashtray.prototype.remove = function(key, nddbid) {
        delete this.resolve[key + '_' + nddbid];
    };

    NDDBHashtray.prototype.clear = function() {
        this.resolve = {};
    };


    // Inheriting from NDDB.

    // function NDDBHash(conf) {
    //
    //     var len = 0;
    //
    //     this.__add = function(key, nddb) {
    //         this[key] = nddb;
    //
    //         if (conf) nddb.init(conf);
    //
    //         len++;
    //     };
    //
    //     this.__size = function() { return len; };
    //
    // }







    /**
     * # NDDBIndex
     *
     * MIT Licensed
     *
     * Helper class for NDDB indexing
     *
     * ---
     */

    /**
     * ## NDDBIndex Constructor
     *
     * Creates direct access index objects for NDDB
     *
     * @param {string} The name of the index
     * @param {array} The reference to the original database
     */
    function NDDBIndex(idx, nddb) {
        // The name of the index.
        this.idx = idx;
        // Reference to the whole nddb database.
        this.nddb = nddb;
        // Map indexed-item to a position in the original database.
        this.resolve = {};
        // List of all keys in `resolve` object.
        this.keys = [];
        // Map indexed-item to a position in `keys` array (for fast deletion).
        this.resolveKeys = {};
    }

    /**
     * ### NDDBIndex._add
     *
     * Adds an item to the index
     *
     * @param {mixed} idx The id of the item
     * @param {number} dbidx The numerical id of the item in the original array
     */
    NDDBIndex.prototype._add = function(idx, dbidx) {
        this.resolve[idx] = dbidx;
        // We add it to the keys array only if it a new index.
        // If it is an already existing element, we don't care
        // if it changing position in the original db.
        if ('undefined' === typeof this.resolveKeys[idx]) {
            this.resolveKeys[idx] = this.keys.length;
            this.keys.push('' + idx);
        }
    };

    /**
     * ### NDDBIndex._remove
     *
     * Removes an item from index
     *
     * @param {mixed} idx The id to remove from the index
     */
    NDDBIndex.prototype._remove = function(idx) {
        delete this.resolve[idx];
        this.keys.splice(this.resolveKeys[idx], 1);
        delete this.resolveKeys[idx];
    };

    /**
     * ### NDDBIndex.size
     *
     * Returns the size of the index
     *
     * @return {number} The number of elements in the index
     */
    NDDBIndex.prototype.size = function() {
        return this.keys.length;
    };

    /**
     * ### NDDBIndex.get
     *
     * Gets the entry from database with the given id
     *
     * @param {mixed} idx The id of the item to get
     * @return {object|boolean} The indexed entry, or FALSE if index is invalid
     *
     * @see NDDB.index
     * @see NDDBIndex.remove
     * @see NDDBIndex.update
     */
    NDDBIndex.prototype.get = function(idx) {
        if ('undefined' === typeof this.resolve[idx]) return false;
        return this.nddb.db[this.resolve[idx]];
    };


    /**
     * ### NDDBIndex.remove
     *
     * Removes and entry from the database with the given id and returns it
     *
     * @param {mixed} idx The id of item to remove
     *
     * @return {object|boolean} The removed item, or FALSE if the
     *   index is invalid or if the object could not be removed,
     *   e.g. if a on('remove') callback returned FALSE.
     *
     * @see NDDB.index
     * @see NDDB.emit
     * @see NDDBIndex.get
     * @see NDDBIndex.update
     */
    NDDBIndex.prototype.remove = function(idx) {
        var o, dbidx, res;
        dbidx = this.resolve[idx];
        if ('undefined' === typeof dbidx) return false;
        o = this.nddb.db[dbidx];
        if ('undefined' === typeof o) return false;
        res = this.nddb.emit('remove', o, dbidx);
        if (res === false) return false;
        this.nddb.db.splice(dbidx, 1);
        this._remove(idx);
        this.nddb._autoUpdate();
        return o;
    };

    // ### NDDBIndex.pop
    // @deprecated
    NDDBIndex.prototype.pop = NDDBIndex.prototype.remove;

    /**
     * ### NDDBIndex.update
     *
     * Updates an entry with the given id
     *
     * @param {mixed} idx The id of item to update
     *
     * @return {object|boolean} The updated item, or FALSE if
     *   index is invalid, or a callback on('update') returned FALSE.
     *
     * @see NDDB.index
     * @see NDDBIndex.get
     * @see NDDBIndex.remove
     */
    NDDBIndex.prototype.update = function(idx, update) {
        var o, dbidx, nddb, res;
        if ('undefined' === typeof update) return false;
        dbidx = this.resolve[idx];
        if ('undefined' === typeof dbidx) return false;
        nddb = this.nddb;
        o = nddb.db[dbidx];
        res = nddb.emit('update', o, update, dbidx);
        if (res === false) return false;
        J.mixin(o, update);
        // We do indexes separately from the other components of _autoUpdate
        // to avoid looping through all the other elements that are unchanged.
        if (nddb.__update.indexes) {
            nddb._indexIt(o, dbidx, idx);
            nddb._hashIt(o);
            nddb._viewIt(o);
        }
        nddb._autoUpdate({indexes: false});
        return o;
    };

    /**
     * ### NDDBIndex.getAllKeys
     *
     * Returns the list of all keys in the index
     *
     * @return {array} The array of alphanumeric keys in the index
     *
     * @see NDDBIndex.getAllKeyElements
     */
    NDDBIndex.prototype.getAllKeys = function() {
        return this.keys.slice(0);
    };

    /**
     * ### NDDBIndex.getAllKeyElements
     *
     * Returns all the elements indexed by their key in one object
     *
     * @return {object} The object of key-elements
     *
     * @see NDDBIndex.getAllKeys
     */
    NDDBIndex.prototype.getAllKeyElements = function() {
        var out, idx, i, len;
        out = {};
        i = -1, len = this.keys.length;
        for ( ; ++i < len ; ) {
            idx = this.keys[i];
            out[idx] = this.nddb.db[this.resolve[idx]];
        }
        return out;
    };

})();

/**
 * # nodeGame: Social Experiments in the Browser
 * Copyright(c) 2015 Stefano Balietti
 * MIT Licensed
 *
 * nodeGame is a free, open source, event-driven javascript framework,
 * for real-time multiplayer games in the browser.
 */
(function(window) {
    if ('undefined' !== typeof window.node) {
        throw new Error('nodegame-client: a global node variable is already ' +
                        'defined. Aborting...');
    }

    // Defining an empty node object. Will be overwritten later on.
    var node = window.node = {};

    if ('undefined' !== typeof JSUS) node.JSUS = JSUS;
    if ('undefined' !== typeof NDDB) node.NDDB = NDDB;
    if ('undefined' !== typeof store) node.store = store;
    node.support = JSUS.compatibility();

    // Auto-Generated.
    node.version = '7.1.0';

})(window);

/**
 * # Variables
 * Copyright(c) 2017 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * `nodeGame` variables and constants module
 */
(function(node) {

    "use strict";

    // ## Constants

    var k;
    k = node.constants = {};

    /**
     * ### node.constants.nodename
     *
     * Default nodename if none is specified
     *
     * @see node.setup.nodename
     */
    k.nodename = 'ng';

    /**
     * ### node.constants.verbosity_levels
     *
     * ALWAYS, ERR, WARN, INFO, DEBUG
     */
    k.verbosity_levels = {
        ALWAYS: -Number.MAX_VALUE,
        error: -1,
        warn: 0,
        info: 1,
        silly: 10,
        debug: 100,
        NEVER: Number.MAX_VALUE
    };

    /**
     * ### node.constants.actions
     *
     * Collection of available nodeGame actions
     *
     * The action adds an initial semantic meaning to the
     * message. It specify the nature of requests
     * "Why the message was sent?"
     *
     * Semantics:
     *
     * - SET: Store / changes the value of a property in the receiver of the msg
     * - GET: Asks the value value of a property to the receiver of the msg
     * - SAY: Announces a change of state or property in the sender of the msg
     */
    k.action = {};

    k.action.SET = 'set';
    k.action.GET = 'get';
    k.action.SAY = 'say';

    /**
     * ### node.constants.target
     *
     * Collection of available nodeGame targets
     *
     * The target adds an additional level of semantic
     * for the message, and specifies the nature of the
     * information carried in the message.
     *
     * It answers the question: "What is the content of the message?"
     */
    k.target = {};

    // #### target.DATA
    // Generic identifier for any type of data
    k.target.DATA = 'DATA';

    // #### target.HI
    // A client is connecting for the first time
    k.target.HI = 'HI';

    // #### target.PCONNECT
    // A new client just connected to the player endpoint
    k.target.PCONNECT = 'PCONNECT';

    // #### target.PDISCONNECT
    // A client that just disconnected from the player endpoint
    k.target.PDISCONNECT = 'PDISCONNECT';

    // #### target.PRECONNECT
    // A previously disconnected client just re-connected to the player endpoint
    k.target.PRECONNECT = 'PRECONNECT';

    // #### target.MCONNECT
    // A client that just connected to the admin (monitor) endpoint
    k.target.MCONNECT = 'MCONNECT';

    // #### target.MDISCONNECT
    // A client just disconnected from the admin (monitor) endpoint
    k.target.MDISCONNECT = 'MDISCONNECT';

    // #### target.MRECONNECT
    // A previously disconnected client just re-connected to the admin endpoint
    k.target.MRECONNECT = 'MRECONNECT';

    // #### target.PLIST
    // The list of clients connected to the player endpoint was updated
    k.target.PLIST = 'PLIST';

    // #### target.MLIST
    // The list of clients connected to the admin (monitor) endpoint was updated
    k.target.MLIST = 'MLIST';

    // #### target.PLAYER_UPDATE
    // A client updates his Player object
    k.target.PLAYER_UPDATE = 'PLAYER_UPDATE';

    // #### target.REDIRECT
    // Redirects a client to a new uri
    k.target.REDIRECT = 'REDIRECT';

    // #### target.LANG
    // Requests language information
    k.target.LANG = 'LANG';

    // #### target.SETUP
    // Asks a client update its configuration
    k.target.SETUP = 'SETUP';

    // #### target.GAMECOMMAND
    // Ask a client to start/pause/stop/resume the game
    k.target.GAMECOMMAND = 'GAMECOMMAND';

    // #### target.SERVERCOMMAND
    // Ask a server to execute a command
    k.target.SERVERCOMMAND = 'SERVERCOMMAND';

    // #### target.ALERT
    // Displays an alert message in the receiving client (if in the browser)
    k.target.ALERT = 'ALERT';

    // #### target.LOG
    // A generic log message used to send info to the server
    // @see NodeGameClient.remoteVerbosity
    k.target.LOG = 'LOG';

    // #### target.BYE
    // Force disconnection upon reception.
    k.target.BYE  = 'BYE';

    // #### target.SESSION
    // Stores the value of the message in the session.
    k.target.SESSION  = 'SESSION';

    //#### not used targets (for future development)


    k.target.JOIN = 'JOIN';   // Asks a client to join another channel

    k.target.TXT  = 'TXT';    // Text msg

    k.target.ACK  = 'ACK';    // A reliable msg was received correctly

    k.target.WARN = 'WARN';   // To do.
    k.target.ERR  = 'ERR';    // To do.

    // Old targets.

    // #### target.STAGE
    // A client notifies his own stage
    // k.target.STAGE = 'STAGE';

    // #### target.STAGE_LEVEL
    // A client notifies his own stage level
    // k.target.STAGE_LEVEL = 'STAGE_LEVEL';


    // ### node.constants.gamecommands
    k.gamecommands = {
        start: 'start',
        pause: 'pause',
        resume: 'resume',
        stop: 'stop',
        restart: 'restart',
        step: 'step',
        push_step: 'push_step',
        goto_step: 'goto_step',
        clear_buffer: 'clear_buffer',
        erase_buffer: 'erase_buffer'
    };

    /**
     * ### Direction
     *
     * Distiguishes between incoming and outgoing messages
     *
     * - node.constants.IN
     * - node.constants.OUT
     */
    k.IN  = 'in.';
    k.OUT = 'out.';

    /**
     * ### node.constants.stateLevels
     *
     * Levels associated with the states of the nodeGame engine.
     */
    k.stateLevels = {
        UNINITIALIZED:  0,  // creating the game object
        STARTING:       1,  // constructor executed
        INITIALIZING:   2,  // calling game's init
        INITIALIZED:    5,  // init executed
        STAGE_INIT:    10,  // calling stage's init
        STEP_INIT:     20,  // calling step's init
        PLAYING_STEP:  30,  // executing step
        STAGE_EXIT:    50,  // calling stage's cleanup
        STEP_EXIT:     60,  // calling step's clenaup
        FINISHING:     70,  // calling game's gameover
        GAMEOVER:     100,  // game complete
        RUNTIME_ERROR: -1
    };

    /**
     * ### node.constants.stageLevels
     *
     * Levels associated with the states of the stages of a game.
     */
    k.stageLevels = {

        UNINITIALIZED:       0,  // Constructor called.

        INITIALIZING:        1,  // Executing init.

        INITIALIZED:         5,  // Init executed.

        LOADING_FRAME:       20, // A frame is being loaded (only in browser).

        FRAME_LOADED:        25, // The frame has been loaded (only in browser).

        EXECUTING_CALLBACK:  30, // Executing the stage callback.

        CALLBACK_EXECUTED:   40, // Stage callback executed.

        LOADED:              45, // Both GameWindow loaded and cb executed.

        PLAYING:             50, // Player playing.

        PAUSING:             55, // TODO: to be removed?

        PAUSED:              60, // TODO: to be removed?

        RESUMING:            65, // TODO: to be removed?

        RESUMED:             70, // TODO: to be removed?

        DONE_CALLED:         80, // Done is called,
                                 // will be asynchronously evaluated.

        GETTING_DONE:        90, // Done is being called,
                                 // and the step rule evaluated.

        DONE:               100, // Player completed the stage

        EXITING:            110, // Cleanup function being called (if found)
    };

    /**
     * ### node.constants.windowLevels
     *
     * Levels associated with the loading of the GameWindow object.
     *
     * @see GameWindow
     * @see GameWindow.state
     */
    k.windowLevels = {
        UNINITIALIZED:  0, // GameWindow constructor called
        INITIALIZING:   1, // Executing init.
        INITIALIZED:    5, // Init executed.
        LOADING:       30, // Loading a new Frame.
        LOADED:        40  // Frame Loaded.
    };

    /**
     * ### node.constants.screenState
     *
     * Levels describing whether the user can interact with the screen.
     *
     * @see GameWindow.screenState
     * @see GameWindow.lockFrame
     */
    k.screenLevels = {
        ACTIVE:        1,  // User can interact with screen (if LOADED)
        UNLOCKING:     -1,  // The screen is about to be unlocked.
        LOCKING:       -2, // The screen is about to be locked.
        LOCKED:        -3  // The screen is locked.
    };

    /**
     * ### node.constants.UNDEFINED_PLAYER
     *
     * Undefined player ID
     */
    k.UNDEFINED_PLAYER = -1;

    /**
     * ### node.constants.UNAUTH_PLAYER
     *
     * Unauthorized player ID
     *
     * This string is returned by the server if authentication fails.
     */
    k.UNAUTH_PLAYER = 'unautorized_player';


     /**
     * ### node.constants.publishLevels
     *
     * The level of updates that the server receives about the state of a game
     *
     * - ALL: all stateLevel, stageLevel, and gameStage updates
     * - MOST: all stageLevel and gameStage updates
     * - REGULAR: only stageLevel PLAYING and DONE, and all gameStage updates
     * - FEW: only gameStage updates (might not work for multiplayer games)
     * - NONE: no updates. The same as observer.
     */
    k.publishLevels = {
        ALL: 4,
        MOST: 3,
        REGULAR: 2,
        FEW: 1,
        NONE: 0
    };

})('undefined' != typeof node ? node : module.exports);

/**
 * # Stepping Rules
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Collections of rules to determine whether the game should step forward.
 */
(function(exports, parent) {

    "use strict";

    exports.stepRules = {};

    // Renaming parent to node, so that functions can be executed
    // context-less in the browser too.
    var node = parent;

    // Important! Cannot define DONE = node.constants.stageLevels.DONE;
    // It is not defined on browsers then.

    // ## SOLO
    //
    // Always steps when current step is DONE
    //
    exports.stepRules.SOLO = function(stage, myStageLevel, pl, game) {
        return myStageLevel === node.constants.stageLevels.DONE;
    };

    // ## SOLO_STEP
    //
    // Steps when current step is DONE, but only if it is not last step in stage
    //
    // When the last step in current stage is done, then it waits
    // for an explicit step command.
    //
    exports.stepRules.SOLO_STEP = function(stage, myStageLevel, pl, game) {
        // If next step is going to be a new stage, then wait.
        if (game.plot.stepsToNextStage(stage, true) === 1) return false;
        else return myStageLevel === node.constants.stageLevels.DONE;
    };

    // ## WAIT
    //
    // Always waits for explicit step command
    //
    exports.stepRules.WAIT = function(stage, myStageLevel, pl, game) {
        return false;
    };

    // ## SYNC_STEP
    //
    // Steps when current step is DONE for all clients (including itself)
    //
    // If no other clients are connected, then it behaves like SOLO.
    //
    exports.stepRules.SYNC_STEP = function(stage, myStageLevel, pl, game) {
        return myStageLevel === node.constants.stageLevels.DONE &&
            pl.isStepDone(stage);
    };

    // ## SYNC_STAGE
    //
    // Like SOLO, but in the last step of a stage behaves like SYNC_STEP
    //
    // If no other clients are connected, then it behaves like SOLO also
    // in the last step.
    //
    // Important: it assumes that the number of steps in current
    // stage is the same in all clients (including this one).
    //
    exports.stepRules.SYNC_STAGE = function(stage, myStageLevel, pl, game) {
        var iamdone;
        iamdone = myStageLevel === node.constants.stageLevels.DONE;
        // If next step is going to be a new stage, wait for others.
        if (game.plot.stepsToNextStage(stage) > 1) return iamdone;
        else return iamdone && pl.isStepDone(stage, 'STAGE_UPTO');
    };

    // ## OTHERS_SYNC_STEP
    //
    // Like SYNC_STEP, but does not look at own stage level
    //
    // If no other clients are connected, then it behaves like WAIT.
    //
    exports.stepRules.OTHERS_SYNC_STEP = function(stage, myStageLevel, pl) {
        if (!pl.size()) return false;
        stage = pl.first().stage;
        return pl.arePlayersSync(stage, node.constants.stageLevels.DONE,
                                 'EXACT');
    };

    // ## OTHERS_SYNC_STAGE
    //
    // Like SYNC_STAGE, but does not look at own stage level
    //
    // If no other clients are connected, then it behaves like WAIT.
    //
    // Important: it assumes that the number of steps in current
    // stage is the same in all clients (including this one).
    //
    exports.stepRules.OTHERS_SYNC_STAGE = function(stage, myStageLevel, pl,
                                                   game) {

        var nSteps;
        if (!pl.size()) return false;
        stage = pl.first().stage;
        nSteps = game.plot.stepsToNextStage(stage);
        // Manual clone in case there are more steps to go.
        if (nSteps !== 1) {
            stage = {
                stage: stage.stage,
                step: stage.step + (nSteps - 1),
                round: stage.round
            };
        }
        return pl.arePlayersSync(stage, node.constants.stageLevels.DONE,
                                 'EXACT', true);
    };

    // ## Closure
})(
    'undefined' != typeof node ? node : module.exports
  , 'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # ErrorManager
 * Copyright(c) 2017 Stefano Balietti
 * MIT Licensed
 *
 * Handles runtime errors
 */
(function(exports, parent) {

    "use strict";

    // ## Global scope
    var J = parent.JSUS;

    parent.ErrorManager = ErrorManager;

    /**
     * ## ErrorManager constructor
     *
     * Creates a new instance of ErrorManager
     *
     * @param {NodeGameClient} node Reference to the active node object.
     */
    function ErrorManager(node) {

        /**
         * ### ErrorManager.lastError
         *
         * Reference to the last error occurred
         */
        this.lastError = null;

        this.init(node);
    }

    // ## ErrorManager methods

    /**
     * ### ErrorManager.init
     *
     * Starts catching run-time errors
     *
     * Only active in the browser's window.
     * In node.js, the ServerNode Error Manager is active.
     *
     * @param {NodeGameClient} node Reference to the active node object.
     */
    ErrorManager.prototype.init = function(node) {
        var that;
        that = this;
        if (!J.isNodeJS()) {
            window.onerror = function(msg, url, lineno, colno, error) {
                var str;
                msg = node.game.getCurrentGameStage().toString() +
                    '@' + J.getTime() + '> ' +
                    url + ' ' + lineno + ',' + colno + ': ' + msg;
                if (error) msg + ' - ' + JSON.stringify(error);
                that.lastError = msg;
                node.err(msg);
                if (node.debug) {
                    W.init({ waitScreen: true });
                    str = '<strong>DEBUG mode: client-side error ' +
                          'detected.</strong><br/><br/>';
                    str += msg;
                    str += '</br></br>Open the DevTools in your browser ' +
                    'for details.</br><em style="font-size: smaller">' +
                    'This message will not be shown in production mode.</em>';
                    W.lockScreen(str);
                }
                return !node.debug;
            };
        }
    };


// ## Closure
})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # EventEmitter
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Event emitter engine for `nodeGame`
 *
 * Keeps a register of events listeners.
 */
(function(exports, parent) {

    "use strict";

    // ## Global scope
    var J = parent.JSUS,
    NDDB = parent.NDDB,
    GameStage = parent.GameStage;

    exports.EventEmitter = EventEmitter;
    exports.EventEmitterManager = EventEmitterManager;

    /**
     * ## EventEmitter constructor
     *
     * Creates a new instance of EventEmitter
     */
    function EventEmitter(name, node) {
        if ('string' !== typeof name) {
            throw new TypeError('EventEmitter constructor: name must be ' +
                                'string. Found: ' + name);
        }

        this.node = node;

        // ## Public properties

        this.name = name;

        /**
         * ### EventEmitter.listeners
         *
         * Event listeners collection
         */
        this.events = {};

        /**
         * ## EventEmitter.recordChanges
         *
         * If TRUE, keeps tracks of addition and deletion of listeners
         *
         * @see EventEmitter.changes
         */
        this.recordChanges = false;

        /**
         * ## EventEmitter.changes
         *
         * If TRUE, keeps tracks of addition and deletion of listeners
         *
         * @see EventEmitter.recordChanges
         */
        this.changes = {
            added: [],
            removed: []
        };

        /**
         * ## EventEmitter.labels
         *
         * List of labels associated to an event listener
         *
         * @see EventEmitter.on
         */
        this.labels = {};

        /**
         * ### EventEmitter.history
         *
         * Database of emitted events
         *
         * @experimental
         *
         * @see NDDB
         * @see EventEmitter.EventHistory
         * @see EventEmitter.store
         */
        this.history = new EventHistory(this.node);
    }

    // ## EventEmitter methods

    /**
     * ### EventEmitter.on
     *
     * Registers a callback function for an event (event listener)
     *
     * @param {string} type The event name
     * @param {function} listener The function to emit
     * @param {string|number} label Optional. If set, it flags the listener with
     *    the property .__ngid = label. It will be then possible to remove
     *    the listener using the label
     *
     * @see EventEmitter.off
     */
    EventEmitter.prototype.on = function(type, listener, label) {
        if ('string' !== typeof type || type === '') {
            throw new TypeError('EventEmitter.on: type must be a non-empty ' +
                                'string. Found: ' + type);
        }
        if ('function' !== typeof listener) {
            throw new TypeError('EventEmitter.on: listener must be function.' +
                                'Found: ' + listener);
        }
        if (label) checkAndAddLabel(this, listener, label, 'on');

        if (!this.events[type]) {
            // Optimize the case of one listener.
            // Don't need the extra array object.
            this.events[type] = listener;
        }
        else if (typeof this.events[type] === 'object') {
            // If we've already got an array, just append.
            this.events[type].push(listener);
        }
        else {
            // Adding the second element, need to change to array.
            this.events[type] = [this.events[type], listener];
        }

        // Storing changes if necessary.
        if (this.recordChanges) {
            this.changes.added.push({type: type, listener: listener});
        }

        this.node.silly(this.name + '.on: added: ' + type);
    };

    /**
     * ### EventEmitter.once
     *
     * Registers an event listener that will be removed after its first call
     *
     * @param {string} event The name of the event
     * @param {function} listener The callback function
     * @param {string|number} label Optional. If set, it flags the listener with
     *    the property .__ngid = label. It will be then possible to remove
     *    the listener using the label
     *
     * @see EventEmitter.on
     * @see EventEmitter.off
     */
    EventEmitter.prototype.once = function(type, listener, label) {
        var that = this;
        if (!label) label = J.uniqueKey(this.labels, type);
        function g() {
            var i, len, args;
            args = [];
            i = -1, len = arguments.length;
            for ( ; ++i < len ; ) {
                args[i] = arguments[i];
            }
            that.off(type, label);
            listener.apply(that.node.game, args);
        }
        this.on(type, g, label);
    };

    /**
     * ### EventEmitter.emit
     *
     * Fires all the listeners associated with an event
     *
     * The first parameter is the name of the event as _string_,
     * followed by any number of parameters that will be passed to the
     * callback.
     *
     * Return values of each callback are aggregated and returned as
     * an array. If the array contains less than 2 elements, only
     * element or _undefined_ is returned.
     *
     * @return {mixed} The return value of the callback/s
     */
    EventEmitter.prototype.emit = function() {
        var handler, len, args, i, listeners, type, ctx, node;
        var res, tmpRes;

        type = arguments[0];
        handler = this.events[type];
        if ('undefined' === typeof handler) return;

        node = this.node;
        ctx = node.game;

        // Useful for debugging.
        if (this.node.conf.events && this.node.conf.events.dumpEvents) {
            this.node.info('F: ' + this.name + ': ' + type);
        }

        if ('function' === typeof handler) {

            switch (arguments.length) {
                // fast cases
            case 1:
                res = handler.call(ctx);
                break;
            case 2:
                res = handler.call(ctx, arguments[1]);
                break;
            case 3:
                res = handler.call(ctx, arguments[1], arguments[2]);
                break;
            case 4:
                res = handler.call(ctx, arguments[1], arguments[2],
                                   arguments[3]);
                break;

            default:
                len = arguments.length;
                args = new Array(len - 1);
                for (i = 1; i < len; i++) {
                    args[i - 1] = arguments[i];
                }
                res = handler.apply(ctx, args);
            }
        }
        else if (handler && 'object' === typeof handler) {
            len = arguments.length;
            args = new Array(len - 1);
            for (i = 1; i < len; i++) {
                args[i - 1] = arguments[i];
            }
            listeners = handler.slice();
            len = listeners.length;
            // If more than one event listener is registered,
            // we will return an array.
            res = [];
            for (i = 0; i < len; i++) {
                tmpRes = listeners[i].apply(node.game, args);
                if ('undefined' !== typeof tmpRes)
                res.push(tmpRes);
            }
            // If less than 2 listeners returned a value, compact the result.
            if (!res.length) res = undefined;
            else if (res.length === 1) res = res[0];
        }

        // Log the event into node.history object, if present.
        if (node.conf && node.conf.events &&
            node.conf.events.history) {

            len = arguments.length;
            args = new Array(len);
            for (i = -1 ; ++i < len ; ) {
                args[i] = arguments[i];
            }

            this.history.insert({
                stage: node.game.getCurrentGameStage(),
                args: args
            });
        }

        return res;
    };

    /**
     * ### EventEmitter.emitAsync
     *
     * Fires all the listeners associated with an event asynchronously
     *
     * The event must be already existing, cannot be added after the call.
     *
     * Unlike normal emit, it does not return a value.
     *
     * @see EventEmitter.emit
     */
    EventEmitter.prototype.emitAsync = function() {
        var that, len, args, i;
        var arg1, arg2, arg3;
        arg1 = arguments[0];

        if (!this.events[arg1]) return;

        len = arguments.length;
        that = this;

        // The arguments object must not be passed or leaked anywhere.
        // Therefore, we recreate an args array here. We have a different
        // timeout in a different branch for optimization.
        switch(len) {

        case 1:
            setTimeout(function() { that.emit(arg1); }, 0);
            break;
        case 2:
            arg2 = arguments[1];
            setTimeout(function() { that.emit(arg1, arg2); }, 0);
            break;
        case 3:
            arg2 = arguments[1], arg3 = arguments[2];
            setTimeout(function() { that.emit(arg1, arg2, arg3); }, 0);
            break;
        default:
            args = new Array(len);
            for (i = -1 ; ++i < len ; ) {
                args[i] = arguments[i];
            }
            setTimeout(function() { that.emit.apply(that, args); }, 0);
        }
    };

    /**
     * ### EventEmitter.off || remove
     *
     * Deregisters one or multiple event listeners
     *
     * If the listener is specified as a string, the first function
     * with either the name or the label equal to listener will be removed.
     *
     * @param {string} type The event name
     * @param {mixed} listener Optional. The specific function
     *   to deregister, its name, the label as specified during insertion,
     *   or undefined to remove all listeners
     *
     * @return {array} The array of removed listener/s
     *
     * @see node.on
     */
    EventEmitter.prototype.remove = EventEmitter.prototype.off =
    function(type, listener) {

        var listeners, len, i, node, found, oneFound, removed;

        removed = [];
        node = this.node;

        if ('string' !== typeof type) {
            throw new TypeError('EventEmitter.remove (' + this.name +
                      '): type must be string. Found: ' + type);
        }

        if (listener &&
            ('function' !== typeof listener && 'string' !== typeof listener)) {
            throw new TypeError('EventEmitter.remove (' + this.name +
                                '): listener must be function, string, or ' +
                                'undefined. Found: ' + listener);
        }

        if ('string' === typeof listener && listener.trim() === '') {
            throw new Error('EventEmitter.remove (' + this.name + '): ' +
                            'listener cannot be an empty string');
        }

        if (this.events[type]) {

            if (!listener) {
                oneFound = true;
                i = -1, len = this.events[type].length;
                for ( ; ++i < len ; ) {
                    removed.push(this.events[type][i]);
                }
                // Null instead of delete for optimization.
                this.events[type] = null;
            }

            else {
                // Handling multiple cases:
                // this.events[type] can be array or function,
                // and listener can be function or string.

                if ('function' === typeof this.events[type]) {

                    if ('function' === typeof listener) {
                        if (listener == this.events[type]) oneFound = true;
                    }
                    else {
                        // String.
                        if (listener === this.events[type].__ngid) {
                            this.labels[listener] = null;
                            oneFound = true;
                        }
                        else if (listener === J.funcName(this.events[type])) {
                            oneFound = true;
                        }
                    }

                    if (oneFound) {
                        removed.push(this.events[type]);
                        // Null instead of delete for optimization.
                        this.events[type] = null;
                    }
                }
                // this.events[type] is an array.
                else {
                    listeners = this.events[type];
                    len = listeners.length;
                    for (i = 0; i < len; i++) {
                        found = false;
                        if ('function' === typeof listener) {
                            if (listeners[i] == listener) found = true;
                        }
                        else {
                            // String.
                            if (listener === listeners[i].__ngid) {
                                this.labels[listener] = null;
                                found = true;
                            }
                            else if (listener === J.funcName(listeners[i])) {
                                found = true;
                            }
                        }

                        if (found) {
                            oneFound = true;
                            removed.push(listeners[i]);
                            if (len === 1) {
                                // Null instead of delete for optimization.
                                this.events[type] = null;
                            }
                            else {
                                listeners.splice(i, 1);
                                // Update indexes,
                                // because array size has changed.
                                len--;
                                i--;
                            }
                        }
                    }
                }
            }
        }

        if (oneFound) {
            // Storing changes if necessary.
            if (this.recordChanges) {
                i = -1, len = removed.length;
                for ( ; ++i < len ; ) {
                    this.changes.removed.push({
                        type: type,
                        listener: removed[i]
                    });
                }
            }
            node.silly('ee.' + this.name + ' removed listener: ' + type);
        }
        else {
            node.warn('EventEmitter.remove (' + this.name + '): requested ' +
                      'listener was not found for event ' + type);
        }

        return removed;
    };

    /**
     * ### EventEmitter.clear
     *
     * Removes all registered event listeners
     *
     * Clears the labels and store changes, if requested
     *
     * @see EventEmitter.labels
     * @see EventEmitter.setRecordChanges
     */
    EventEmitter.prototype.clear = function() {
        var event, i, len;
        if (this.recordChanges) {
            for (event in this.events) {
                if ('function' === typeof this.events[event]) {
                    this.changes.removed.push({
                        type: event,
                        listener: this.events[event]
                    });
                }
                else if (J.isArray(this.events[event])) {
                    i = -1, len = this.events[event].length;
                    for ( ; ++i < len ; ) {
                        this.changes.removed.push({
                            type: event,
                            listener: this.events[event][i]
                        });
                    }
                }
            }
        }
        this.events = {};
        this.labels = {};
    };

    /**
     * ### EventEmitter.size
     *
     * Returns the number of registered events / event listeners
     *
     * @param {mixed} Optional. Modifier controlling the return value
     *
     * @return {number} Depending on the value of the modifier returns
     *   the total number of:
     *
     *    - Not set:  events registered
     *    - String:   event listeners for the specified event
     *    - true:     event listeners for all events
     */
    EventEmitter.prototype.size = function(mod) {
        var count;
        count = 0;
        if (!mod) {
            for (mod in this.events) {
                if (this.events.hasOwnProperty(mod)) {
                    // Not null (delete events).
                    if (this.events[mod]) count++;
                }
            }
            return count;
        }
        if ('string' === typeof mod) {
            if (!this.events[mod]) return 0;
            if ('function' === typeof this.events[mod]) return 1;
            return this.events[mod].length;
        }
        for (mod in this.events) {
            count += this.size(mod);
        }
        return count;
    };

    /**
     * ### EventEmitter.printAll
     *
     * Prints to console all the registered functions
     *
     * @return {number} The total number of registered functions
     */
    EventEmitter.prototype.printAll = function() {
        var i, len, totalLen, str;
        totalLen = 0, str = '';
        for (i in this.events) {
            if (this.events.hasOwnProperty(i)) {
                len = this.size(i);
                str += i + ': ' + len + "\n";
                totalLen += len;
            }
        }
        console.log('[' + this.name + '] ' + totalLen + ' listener/s.');
        if (str) console.log(str);
        return totalLen;
    };

    /**
     * ### EventEmitter.getChanges
     *
     * Returns the list of added and removed event listeners
     *
     * @param {boolean} clear Optional. If TRUE, the list of current changes
     *   is cleared. Default FALSE
     *
     * @return {object} Object containing list of additions and deletions,
     *   or null if no changes have been recorded
     */
    EventEmitter.prototype.getChanges = function(clear) {
        var changes;
        if (this.changes.added.length || this.changes.removed.length) {
            changes = this.changes;
            if (clear) {
                this.changes = {
                    added: [],
                    removed: []
                };
            }
        }
        return changes;
    };

    /**
     * ### EventEmitter.setRecordChanges
     *
     * Sets the value of recordChanges and returns it
     *
     * If called with undefined, just returns current value.
     *
     * @param {boolean} record If TRUE, starts recording changes. Default FALSE
     *
     * @return {boolean} Current value of recordChanges
     *
     * @see EventEmitter.recordChanges
     */
    EventEmitter.prototype.setRecordChanges = function(record) {
        if ('boolean' === typeof record) this.recordChanges = record;
        else if ('undefined' !== typeof record) {
            throw new TypeError('EventEmitter.setRecordChanged: record must ' +
                                'be boolean or undefined. Found: ' + record);
        }
        return this.recordChanges;
    };

    // ### Helper functions

    /**
     * #### checkAndAddLabel
     *
     * If label is valid, adds it to the labels object and marks the listener
     *
     * @param {EventEmitter} that The instance of event emitter
     * @param {function} listener The listener function
     * @param {string|number} label The label to check
     * @param {string} method The invoking method (on or once)
     */
    function checkAndAddLabel(that, listener, label, method) {
        if ('string' === typeof label || 'number' === typeof label) {
            if (that.labels[label]) {
                throw new Error('EventEmitter.' + method +
                                ': label is not unique: ' + label);
            }
            that.labels[label] = true;
            listener.__ngid = '' + label;
        }
        else {
            throw new TypeError('EventEmitter.' + method + ': label must be ' +
                                'string or undefined. Found: ' + label);
        }
    }


    /**
     * ## EventEmitterManager constructor
     *
     * @param {NodeGameClient} node A reference to the node object
     */
    function EventEmitterManager(node) {

        this.node = node;

        this.ee = {};

        this.createEE('ng');
        this.createEE('game');
        this.createEE('stage');
        this.createEE('step');
    }

    // ## EventEmitterManager methods

    /**
     * ### EventEmitterManager.createEE
     *
     * Creates and registers an event emitter
     *
     * A double reference is added to _this.ee_ and to _this_.
     *
     * @param {string} name The name of the event emitter
     *
     * @return {EventEmitter} A reference to the newly created event emitter
     *
     * @see EventEmitter constructor
     */
    EventEmitterManager.prototype.createEE = function(name) {
        this.ee[name] = new EventEmitter(name, this.node);
        this[name] = this.ee[name];
        return this.ee[name];
    };

    /**
     * ### EventEmitterManager.destroyEE
     *
     * Removes an existing event emitter
     *
     * @param {string} name The name of the event emitter
     *
     * @return {boolean} TRUE, on success
     *
     * @see EventEmitterManager.createEE
     */
    EventEmitterManager.prototype.destroyEE = function(name) {
        if ('string' !== typeof name) {
            throw new TypeError('EventEmitterManager.destroyEE: name must be ' +
                                'string. Found: ' + name);
        }
        if (!this.ee[name]) return false;
        delete this[name];
        delete this.ee[name];
        return true;
    };

    /**
     * ### EventEmitterManager.clear
     *
     * Removes all registered event listeners from all event emitters
     */
    EventEmitterManager.prototype.clear = function() {
        this.ng.clear();
        this.game.clear();
        this.stage.clear();
        this.step.clear();
    };

    /**
     * ### EventEmitterManager.emit
     *
     * Emits an event on all registered event emitters
     *
     * Accepts a variable number of input parameters.
     *
     * @param {string} eventName The name of the event
     *
     * @return {mixed} The values returned by all fired event listeners
     *
     * @see EventEmitterManager.emit
     */
    EventEmitterManager.prototype.emit = function(eventName) {
        var i, tmpRes, res, args, len, ees;

        if ('string' !== typeof eventName) {
            throw new TypeError(
                'EventEmitterManager.emit: eventName must be string. Found: ' +
                    eventName);
        }
        res = [];

        len = arguments.length;

        // The scope might `node` if this method is invoked from `node.emit`.
        ees = this.ee || this.events.ee;

        // The arguments object must not be passed or leaked anywhere.
        switch(len) {

        case 1:
            tmpRes = ees.ng.emit(eventName);
            if ('undefined' !== typeof tmpRes) res.push(tmpRes);
            tmpRes = ees.game.emit(eventName);
            if ('undefined' !== typeof tmpRes) res.push(tmpRes);
            tmpRes = ees.stage.emit(eventName);
            if ('undefined' !== typeof tmpRes) res.push(tmpRes);
            tmpRes = ees.step.emit(eventName);
            if ('undefined' !== typeof tmpRes) res.push(tmpRes);
            break;
        case 2:
            tmpRes = ees.ng.emit(eventName, arguments[1]);
            if ('undefined' !== typeof tmpRes) res.push(tmpRes);
            tmpRes = ees.game.emit(eventName, arguments[1]);
            if ('undefined' !== typeof tmpRes) res.push(tmpRes);
            tmpRes = ees.stage.emit(eventName, arguments[1]);
            if ('undefined' !== typeof tmpRes) res.push(tmpRes);
            tmpRes = ees.step.emit(eventName, arguments[1]);
            if ('undefined' !== typeof tmpRes) res.push(tmpRes);
            break;
        case 3:
            tmpRes = ees.ng.emit(eventName, arguments[1], arguments[2]);
            if ('undefined' !== typeof tmpRes) res.push(tmpRes);
            tmpRes = ees.game.emit(eventName, arguments[1], arguments[2]);
            if ('undefined' !== typeof tmpRes) res.push(tmpRes);
            tmpRes = ees.stage.emit(eventName, arguments[1], arguments[2]);
            if ('undefined' !== typeof tmpRes) res.push(tmpRes);
            tmpRes = ees.step.emit(eventName, arguments[1], arguments[2]);
            if ('undefined' !== typeof tmpRes) res.push(tmpRes);
            break;
        default:
            args = new Array(len);
            for (i = -1 ; ++i < len ; ) {
                args[i] = arguments[i];
            }
            tmpRes = ees.ng.emit.apply(ees.ng, args);
            if ('undefined' !== typeof tmpRes) res.push(tmpRes);
            tmpRes = ees.game.emit.apply(ees.game, args);
            if ('undefined' !== typeof tmpRes) res.push(tmpRes);
            tmpRes = ees.stage.emit.apply(ees.stage, args);
            if ('undefined' !== typeof tmpRes) res.push(tmpRes);
            tmpRes = ees.step.emit.apply(ees.step, args);
            if ('undefined' !== typeof tmpRes) res.push(tmpRes);
        }

        // If there are less than 2 elements, unpack the array.
        // res[0] is either undefined or some value.
        return res.length < 2 ? res[0] : res;
    };

    /**
     * ### EventEmitterManager.emitAsync
     *
     * Emits an event on all registered event emitters asynchrounsly
     *
     * Accepts a variable number of input parameters.
     *
     * @param {string} eventName The name of the event
     *
     * @see EventEmitterManager.emit
     */
    EventEmitterManager.prototype.emitAsync = function(eventName) {
        var i, len, args, ees;

        if ('string' !== typeof eventName) {
            throw new TypeError(
                'EventEmitterManager.emit: eventName must be string. Found: ' +
                    eventName);
        }

        len = arguments.length;

        // The scope might `node` if this method is invoked from `node.emit`.
        ees = this.ee || this.events.ee;

        // The arguments object must not be passed or leaked anywhere.
        switch(len) {

        case 1:
            ees.ng.emitAsync(eventName);
            ees.game.emitAsync(eventName);
            ees.stage.emitAsync(eventName);
            ees.step.emitAsync(eventName);
            break;
        case 2:
            ees.ng.emitAsync(eventName, arguments[1]);
            ees.game.emitAsync(eventName, arguments[1]);
            ees.stage.emitAsync(eventName, arguments[1]);
            ees.step.emitAsync(eventName, arguments[1]);
            break;
        case 3:
            ees.ng.emitAsync(eventName, arguments[1], arguments[2]);
            ees.game.emitAsync(eventName, arguments[1], arguments[2]);
            ees.stage.emitAsync(eventName, arguments[1], arguments[2]);
            ees.step.emitAsync(eventName, arguments[1], arguments[2]);
            break;
        default:
            args = new Array(len);
            for (i = -1 ; ++i < len ; ) {
                args[i] = arguments[i];
            }
            ees.ng.emitAsync.apply(ees.ng, args);
            ees.game.emitAsync.apply(ees.game, args);
            ees.stage.emitAsync.apply(ees.stage, args);
            ees.step.emitAsync.apply(ees.step, args);
        }
    };

    /**
     * ### EventEmitterManager.remove
     *
     * Removes an event / event listener from all registered event emitters
     *
     * @param {string} eventName The name of the event
     * @param {function|string} listener Optional A reference to the
     *   function to remove, or its name
     *
     * @return {object} Object containing removed listeners by event emitter
     */
    EventEmitterManager.prototype.remove = function(eventName, listener) {
        var res;
        if ('string' !== typeof eventName) {
            throw new TypeError('EventEmitterManager.remove: eventName ' +
                                'must be string. Found: ' + eventName);
        }
        if (listener &&
            ('function' !== typeof listener && 'string' !== typeof listener)) {
            throw new TypeError('EventEmitter.remove (' + this.name +
                                '): listener must be function, string, or ' +
                                'undefined. Found: ' + listener);
        }
        res = {};
        res.ng = this.ng.remove(eventName, listener);
        res.game = this.game.remove(eventName, listener);
        res.stage = this.stage.remove(eventName, listener);
        res.step = this.step.remove(eventName, listener);
        return res;
    };

    /**
     * ### EventEmitterManager.printAll
     *
     * Prints all registered events
     *
     * @param {string} eventEmitterName Optional The name of the event emitter
     */
    EventEmitterManager.prototype.printAll = function(eventEmitterName) {
        var total;
        if (eventEmitterName && 'string' !== typeof eventEmitterName) {
            throw new TypeError('EventEmitterManager.printAll: ' +
                                'eventEmitterName must be string or ' +
                                'undefined. Found: ' + eventEmitterName);
        }
        if (eventEmitterName && !this.ee[eventEmitterName]) {
            throw new TypeError('EventEmitterManager.printAll: event' +
                                'emitter not found: ' + eventEmitterName);
        }
        if (eventEmitterName) {
            total = this.ee[eventEmitterName].printAll();
        }
        else {
            total = 0;
            total += this.ng.printAll();
            total += this.game.printAll();
            total += this.stage.printAll();
            total += this.step.printAll();

            console.log('Total number of registered listeners: ' + total);
        }
        return total;
    };

    /**
     * ### EventEmitterManager.getAll
     *
     * Returns all registered events
     *
     * @param {string} eventEmitterName Optional The name of the event emitter
     */
    EventEmitterManager.prototype.getAll = function(eventEmitterName) {
        var events;
        if (eventEmitterName && 'string' !== typeof eventEmitterName) {
            throw new TypeError('EventEmitterManager.getAll: ' +
                                'eventEmitterName must be string or ' +
                                'undefined. Found: ' + eventEmitterName);
        }
        if (eventEmitterName && !this.ee[eventEmitterName]) {
            throw new TypeError('EventEmitterManager.getAll: event' +
                                'emitter not found: ' + eventEmitterName);
        }
        if (eventEmitterName) {
            events = this.ee[eventEmitterName].events;
        }
        else {
            events = {
                ng: this.ng.events,
                game: this.game.events,
                stage: this.stage.events,
                step: this.step.events
            };
        }
        return events;
    };

    /**
     * ### EventEmitterManager.getChanges
     *
     * Returns the list of changes from all event emitters
     *
     * Considered event emitters: ng, game, stage, step.
     *
     * @param {boolean} clear Optional. If TRUE, the list of current changes
     *   is cleared. Default FALSE
     *
     * @return {object} Object containing changes for all event emitters, or
     *   null if no changes have been recorded
     *
     * @see EventEmitter.getChanges
     */
    EventEmitterManager.prototype.getChanges = function(clear) {
        var changes, tmp;
        changes = {};
        tmp = this.ee.ng.getChanges(clear);
        if (tmp) changes.ng = tmp;
        tmp = this.ee.game.getChanges(clear);
        if (tmp) changes.game = tmp;
        tmp = this.ee.stage.getChanges(clear);
        if (tmp) changes.stage = tmp;
        tmp = this.ee.step.getChanges(clear);
        if (tmp) changes.step = tmp;
        return J.isEmpty(changes) ? null : changes;
    };

    /**
     * ### EventEmitterManager.setRecordChanges
     *
     * Sets the value of recordChanges for all event emitters and returns it
     *
     * If called with undefined, just returns current value.
     *
     * @param {boolean} record If TRUE, starts recording changes. Default FALSE
     *
     * @return {object} Current values of recordChanges for all event emitters
     *
     * @see EventEmitter.recordChanges
     */
    EventEmitterManager.prototype.setRecordChanges = function(record) {
        var out;
        out = {};
        out.ng = this.ee.ng.setRecordChanges(record);
        out.game = this.ee.game.setRecordChanges(record);
        out.stage = this.ee.stage.setRecordChanges(record);
        out.step = this.ee.step.setRecordChanges(record);
        return out;
    };

    /**
     * ### EventEmitterManager.size
     *
     * Returns the number of registered events / event listeners
     *
     * Calls the `size` method of each event emitter.
     *
     * @param {mixed} Optional. Modifier controlling the return value
     *
     * @return {number} Total number of registered events / event listeners
     *
     * @see EventEmitter.size
     */
    EventEmitterManager.prototype.size = function(mod) {
        var count;
        count = this.ng.size(mod);
        count += this.game.size(mod);
        count += this.stage.size(mod);
        count += this.step.size(mod);
        return count;
    };

    /**
     * ## EventHistory constructor
     *
     * TODO: might require updates.
     */
    function EventHistory(node) {

        this.node = node;

        /**
         * ### EventHistory.history
         *
         * Database of emitted events
         *
         * @see NDDB
         * @see EventEmitter.store
         *
         */
        this.history = new NDDB();

        this.history.hash('stage', function(e) {
            var stage;
            if (!e) return;
            stage = 'object' === typeof e.stage ?
                e.stage : this.node.game.stage;
            return node.GameStage.toHash(stage, 'S.s.r');
        });

    }

    EventHistory.prototype.remit = function(stage, discard, keep) {
        var hash, db, remit, node;
        node = this.node;
        if (!this.history.count()) {
            node.warn('no event history was found to remit');
            return false;
        }

        node.silly('remitting ' + node.events.history.count() + ' events');

        if (stage) {

            this.history.rebuildIndexes();

            hash = new GameStage.toHash(stage, 'S.s.r');

            if (!this.history.stage) {
                node.silly('No past events to re-emit found.');
                return false;
            }
            if (!this.history.stage[hash]){
                node.silly('Current stage ' + hash + ' has no events ' +
                           'to re-emit');
                return false;
            }

            db = this.history.stage[hash];
        }
        else {
            db = this.history;
        }

        // cleaning up the events to remit
        // TODO NDDB commands have changed, update
        if (discard) {
            db.select('event', 'in', discard).remove();
        }

        if (keep) {
            db = db.select('event', 'in', keep);
        }

        if (!db.count()){
            node.silly('no valid events to re-emit after cleanup');
            return false;
        }

        remit = function() {
            node.silly('re-emitting ' + db.count() + ' events');
            // We have events that were fired at the stage when
            // disconnection happened. Let's fire them again
            db.each(function(e) {
                node.emit(e.event, e.p1, e.p2, e.p3);
            });
        };

        if (node.game.isReady()) {
            remit.call(node.game);
        }
        else {
            node.on('LOADED', function(){
                remit.call(node.game);
            });
        }

        return true;
    };

    // ## Closure

})(
    'undefined' !== typeof node ? node : module.exports
  , 'undefined' !== typeof node ? node : module.parent.exports
);

/**
 * # GameStage
 *
 * Copyright(c) 2018 Stefano Balietti
 * MIT Licensed
 *
 * Representation of the stage of a game:
 *
 * - `stage`: the higher-level building blocks of a game
 * - `step`: the sub-unit of a stage
 * - `round`: the number of repetition for a stage. Defaults round = 1
 *
 * @see GamePlot
 */
(function(exports, parent) {

    "use strict";

    // ## Global scope

    // Expose constructor
    exports.GameStage = GameStage;

    GameStage.defaults = {};

    /**
     * ### GameStage.defaults.hash
     *
     * Default hash string for game-stages
     *
     *  @see GameStage.toHash
     */
    GameStage.defaults.hash = 'S.s.r';

    /**
     * ## GameStage constructor
     *
     * Creates an instance of a GameStage
     *
     * It accepts an object literal, a number, or an hash string as defined in
     * `GameStage.defaults.hash`.
     *
     * The stage and step can be either an integer (1-based index) or a string
     * (valid stage/step name). The round must be an integer.
     *
     * If no parameter is passed, all the properties of the GameStage
     * object are set to 0
     *
     * @param {object|string|number} gameStage Optional. The game stage
     *
     * @see GameStage.defaults.hash
     */
    function GameStage(gameStage) {
        var tokens, stageNum, stepNum, roundNum, err;

        // ## Public properties

        /**
         * ### GameStage.stage
         *
         * The N-th game-block (stage) in the game-plot currently being executed
         */
        this.stage = 0;

        /**
         * ### GameStage.step
         *
         * The N-th game-block (step) nested in the current stage
         */
        this.step = 0;

        /**
         * ### GameStage.round
         *
         * The number of times the current stage was repeated
         */
        this.round = 0;

        // String.
        if ('string' === typeof gameStage) {
            if (gameStage === '') {
                throw new Error('GameStage constructor: gameStage name ' +
                                'cannot be an empty string.');
            }
            if (gameStage.charAt(0) === '.') {
                throw new Error('GameStage constructor: gameStage name ' +
                                'cannot start with a dot. Name: ' + gameStage);
            }

            tokens = gameStage.split('.');

            stageNum = parseInt(tokens[0], 10);
            this.stage = !isNaN(stageNum) ? stageNum : tokens[0];

            if ('string' === typeof tokens[1]) {
                if (!tokens[1].length) {
                    throw new Error('GameStage constructor: gameStage ' +
                                    'contains empty step: ' + gameStage);
                }
                stepNum = parseInt(tokens[1], 10);
                this.step = !isNaN(stepNum) ? stepNum : tokens[1];
            }
            else if (this.stage !== 0) {
                this.step = 1;
            }
            if ('string' === typeof tokens[2]) {
                if (!tokens[2].length) {
                    throw new Error('GameStage constructor: gameStage ' +
                                    'contains empty round: ' + gameStage);
                }
                roundNum = parseInt(tokens[2], 10);
                this.round = roundNum;
            }
            else if (this.stage !== 0) {
                this.round = 1;
            }
        }
        // Not null object.
        else if (gameStage && 'object' === typeof gameStage) {
            this.stage = gameStage.stage;
            this.step = 'undefined' !== typeof gameStage.step ?
                gameStage.step : this.stage === 0 ? 0 : 1;
            this.round = 'undefined' !== typeof gameStage.round ?
                gameStage.round : this.stage === 0 ? 0 : 1;
        }
        // Number.
        else if ('number' === typeof gameStage) {
            if (gameStage % 1 !== 0) {
               throw new TypeError('GameStage constructor: gameStage ' +
                                   'cannot be a non-integer number. Found: ' +
                                   gameStage);
            }
            this.stage = gameStage;
            if (this.stage === 0) {
                this.step = 0;
                this.round = 0;
            }
            else {
                this.step = 1;
                this.round = 1;
            }
        }
        // Defaults or error.
        else if (gameStage !== null && 'undefined' !== typeof gameStage) {
            throw new TypeError('GameStage constructor: gameStage must be ' +
                                'string, object, number, undefined, or null. ' +
                                'Found: ' + gameStage);
        }

        // At this point we must have positive numbers, or strings for step
        // and stage, round can be only a positive number, or 0.0.0.
        if ('number' === typeof this.stage) {
            if (this.stage < 0) err = 'stage';
        }
        else if ('string' !== typeof this.stage) {
            throw new Error('GameStage constructor: gameStage.stage must be ' +
                            'number or string: ' + typeof this.stage);
        }

        if ('number' === typeof this.step) {
            if (this.step < 0) err = err ? err + ', step' : 'step';
        }
        else if ('string' !== typeof this.step) {
            throw new Error('GameStage constructor: gameStage.step must be ' +
                            'number or string: ' + typeof this.step);
        }

        if ('number' === typeof this.round) {
            if (this.round < 0) err = err ? err + ', round' : 'round';
        }
        else {
            throw new Error('GameStage constructor: gameStage.round must ' +
                            'be number. Found: ' + this.round);
        }

        if (err) {
            throw new TypeError('GameStage constructor: ' + err + ' field/s ' +
                                'contain/s negative numbers.');
        }

        // Either 0.0.0 or no 0 is allowed.
        if (!(this.stage === 0 && this.step === 0 && this.round === 0)) {
            if (this.stage === 0 || this.step === 0 || this.round === 0) {
                throw new Error('GameStage constructor: malformed game ' +
                                'stage: ' + this.toString());
            }
        }
    }

    // ## GameStage methods

    /**
     * ### GameStage.toString
     *
     * Converts the current instance of GameStage to a string
     *
     * @return {string} out The string representation of game stage
     */
    GameStage.prototype.toString = function() {
        return this.stage + '.' + this.step + '.' + this.round;
    };

    // ## GameStage Static Methods

    /**
     * ### GameStage.toHash
     *
     * Returns a simplified hash of the stage of the GameStage
     *
     * The following characters are valid to determine the hash string
     *
     * - S: stage
     * - s: step
     * - r: round
     *
     * E.g.
     *
     * ```javascript
     *      var gs = new GameStage({
     *          round: 1,
     *          stage: 2,
     *          step: 1
     *      });
     *
     *      gs.toHash('(R) S.s'); // (1) 2.1
     * ```
     *
     * @param {GameStage} gs The game stage to hash
     * @param {string} str Optional. The hash code. Default: S.s.r
     *
     * @return {string} hash The hashed game stages
     */
    GameStage.toHash = function(gs, str) {
        var hash, i, idx, properties, symbols;
        if (!gs || 'object' !== typeof gs) {
            throw new TypeError('GameStage.toHash: gs must be object. Found: ' +
                                gs);
        }
        if (!str || !str.length) {
            return gs.stage + '.' + gs.step + '.' + gs.round;
        }

        hash = '',
        symbols = 'Ssr',
        properties = ['stage', 'step', 'round'];

        for (i = 0; i < str.length; i++) {
            idx = symbols.indexOf(str.charAt(i));
            hash += (idx < 0) ? str.charAt(i) : gs[properties[idx]];
        }
        return hash;
    };

    /**
     * ### GameStage.toObject
     *
     * Returns a clone of the game stage with Object as prototype
     *
     * @return {object} A new object
     */
    GameStage.toObject = function() {
        return {
            stage: this.stage,
            step: this.step,
            round: this.round
        };
    };

    /**
     * ### GameStage.compare
     *
     * Converts inputs to GameStage objects and sort them by sequence order
     *
     * Returns value is:
     *
     * - 0 if they represent the same game stage
     * - -1 if gs1 is ahead of gs2
     * - +1 if gs2 is ahead of gs1
     *
     * The accepted hash string format is the following:
     *
     *   - 'S.s.r' (stage.step.round)
     *
     * When comparison contains a missing value or a string (e.g. a step id),
     * the object is placed ahead.
     *
     * @param {mixed} gs1 The first game stage to compare
     * @param {mixed} gs2 The second game stage to compare
     *
     * @return {number} result The result of the comparison
     *
     * @see GameStage constructor
     * @see GameStage.toHash (static)
     */
    GameStage.compare = function(gs1, gs2) {
        var result;
        // null, undefined, 0.
        if (!gs1 && !gs2) return 0;
        if (!gs2) return -1;
        if (!gs1) return 1;

        gs1 = new GameStage(gs1);
        gs2 = new GameStage(gs2);

        if ('number' === typeof gs1.stage) {
            if ('number' === typeof gs2.stage) {
                result = gs2.stage - gs1.stage;
            }
            else {
                result = -1;
            }
        }
        else if ('number' === typeof gs2.stage) {
            result = 1;
        }

        if (result === 0) {
            if ('number' === typeof gs1.round) {
                if ('number' === typeof gs2.round) {
                    result = gs2.round - gs1.round;
                }
                else {
                    result = -1;
                }

            }
            else if ('number' === typeof gs2.round) {
                result = 1;
            }
        }

        if (result === 0) {
            if ('number' === typeof gs1.step) {
                if ('number' === typeof gs2.step) {
                    result = gs2.step - gs1.step;
                }
                else {
                    result = -1;
                }

            }
            else if ('number' === typeof gs2.step) {
                result = 1;
            }
        }

        return result > 0 ? 1 : result < 0 ? -1 : 0;
    };

    // ## Closure
})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # PlayerList
 * Copyright(c) 2016 Stefano Balietti
 * MIT Licensed
 *
 * Handles a collection of `Player` objects
 *
 * Offers methods to update, search and retrieve players.
 *
 * It extends the NDDB class.
 */
(function(exports, parent) {

    "use strict";

    // ## Global scope

    // Exposing constructor
    exports.PlayerList = PlayerList;

    // Setting up global scope variables
    var J = parent.JSUS,
        NDDB = parent.NDDB,
        GameStage = parent.GameStage;

    var stageLevels = parent.constants.stageLevels;
    var stateLevels = parent.constants.stateLevels;

    // Inheriting from NDDB
    PlayerList.prototype = new NDDB();
    PlayerList.prototype.constructor = PlayerList;

    // Sync types used by PlayerList.arePlayersSync
    var syncTypes;

    /**
     * ## PlayerList.comparePlayers
     *
     * Comparator functions between two players
     *
     * @param {Player} p1 The first player
     * @param {Player} p2 The second player
     * @return {number} The result of the comparison
     *
     * @see NDDB.globalCompare
     */
    PlayerList.comparePlayers = function(p1, p2) {
        if (p1.id === p2.id) return 0;
        if (p1.count < p2.count) return 1;
        if (p1.count > p2.count) return -1;
        return 0;
    };

    /**
     * ## PlayerList constructor
     *
     * Creates an instance of PlayerList
     *
     * The class inherits his prototype from `node.NDDB`.
     *
     * It indexes players by their _id_.
     *
     * @param {object} options Optional. Configuration object
     * @param {array} db Optional. An initial set of players to import
     * @param {PlayerList} parent Optional. A parent object for the instance
     *
     * @see NDDB.constructor
     */
    function PlayerList(options, db) {
        options = options || {};

        options.name = options.name || 'plist';

        // Updates indexes on the fly.
        if (!options.update) options.update = {};
        if ('undefined' === typeof options.update.indexes) {
            options.update.indexes = true;
        }

        // The internal counter that will be used to assing the `count`
        // property to each inserted player.
        this.pcounter = 0;

        // Invoking NDDB constructor.
        NDDB.call(this, options);

        // We check if the index are not existing already because
        // it could be that the constructor is called by the breed function
        // and in such case we would duplicate them.
        if (!this.id) {
            this.index('id', function(p) {
                return p.id;
            });
        }

        // Importing initial items
        // (should not be done in constructor of NDDB)
        if (db) this.importDB(db);

        // Assigns a global comparator function.
        this.globalCompare = PlayerList.comparePlayers;
    }

    // ## PlayerList methods

    /**
     * ### PlayerList.importDB
     *
     * Adds an array of players to the database at once
     *
     * Overrides NDDB.importDB
     *
     * @param {array} db The array of player to import at once
     */
    PlayerList.prototype.importDB = function(db) {
        var i, len;
        if (!J.isArray(db)) {
            throw new TypeError('PlayerList.importDB: db must be array.');
        }
        i = -1, len = db.length;
        for ( ; ++i < len ; ) {
            this.add(db[i]);
        }
    };

    /**
     * ### PlayerList.add
     *
     * Adds a new player to the database
     *
     * Before insertion, objects are checked to be valid `Player` objects,
     * that is they must have a unique player id. Objects will then
     * automatically casted to type Player.
     *
     * The `count` property is added to the player object, and
     * the internal `pcounter` variable is incremented.
     *
     * @param {Player} player The player object to add to the database
     * @param {object} updateRules Optional. Update rules overwriting
     *   `this.__update`
     *
     * @return {player} The inserted player
     */
    PlayerList.prototype.add = function(player, updateRules) {
        if (!(player instanceof Player)) {
            if ('object' !== typeof player) {
                throw new TypeError('PlayerList.add: player must be object. ' +
                                    'Found: ' + player);
            }
            if ('string' !== typeof player.id) {
                throw new TypeError('PlayerList.add: player.id must be ' +
                                    'string. Found: ' + player.id);
            }
            player = new Player(player);
        }

        if (this.exist(player.id)) {
            throw new Error('PlayerList.add: player already existing: ' +
                            player.id + '.');
        }
        this.insert(player, updateRules);
        player.count = this.pcounter;
        this.pcounter++;
        return player;
    };

// NEW GET AND REMOVE (no errors are thrown)

//     /**
//      * ### PlayerList.get
//      *
//      * Retrieves a player with the given id
//      *
//      * @param {number} id The client id of the player to retrieve
//      *
//      * @return {Player} The player with the speficied id
//      */
//     PlayerList.prototype.get = function(id) {
//         if ('string' !== typeof id) {
//             throw new TypeError('PlayerList.get: id must be string.');
//         }
//         return this.id.get(id);
//     };
//
//     /**
//      * ### PlayerList.remove
//      *
//      * Removes the player with the given id
//      *
//      * Notice: this operation cannot be undone
//      *
//      * @param {number} id The id of the player to remove
//      *
//      * @return {object} The removed player object
//      */
//     PlayerList.prototype.remove = function(id) {
//         if ('string' !== typeof id) {
//             throw new TypeError('PlayerList.remove: id must be string.');
//         }
//         return this.id.remove(id);
//     };

// OLD GET AND REMOVE: throw errors

    /**
     * ### PlayerList.get
     *
     * Retrieves a player with the given id
     *
     * @param {number} id The id of the player to retrieve
     *
     * @return {Player} The player with the speficied id
     */
    PlayerList.prototype.get = function(id) {
        var player;
        if ('string' !== typeof id) {
            throw new TypeError('PlayerList.get: id must be string');

        }
        player = this.id.get(id);
        if (!player) {
            throw new Error('PlayerList.get: Player not found: ' + id);
        }
        return player;
    };

    /**
     * ### PlayerList.remove
     *
     * Removes the player with the given id
     *
     * Notice: this operation cannot be undone
     *
     * @param {number} id The id of the player to remove
     *
     * @return {object} The removed player object
     */
    PlayerList.prototype.remove = function(id) {
        var player;
        if ('string' !== typeof id) {
            throw new TypeError('PlayerList.remove: id must be string. ' +
                                'Found: ' + id);
        }
        player = this.id.remove(id);
        if (!player) {
            throw new Error('PlayerList.remove: player not found: ' + id);
        }
        return player;
    };

    // ### PlayerList.pop
    // @deprecated
    // TODO remove after transition is complete
    PlayerList.prototype.pop = PlayerList.prototype.remove;

    /**
     * ### PlayerList.exist
     *
     * Checks whether a player with the given id already exists
     *
     * @param {string} id The id of the player
     *
     * @return {boolean} TRUE, if a player with the specified id is found
     */
    PlayerList.prototype.exist = function(id) {
        return this.id.get(id) ? true : false;
    };

     /**
      * ### PlayerList.clear
      *
      * Clears the PlayerList and rebuilds the indexes
      */
     PlayerList.prototype.clear = function() {
         NDDB.prototype.clear.call(this);
         // We need this to recreate the (empty) indexes.
         this.rebuildIndexes();
     };

    /**
     * ### PlayerList.updatePlayer
     *
     * Updates the state of a player
     *
     * @param {number} id The id of the player
     * @param {object} playerState An update with fields to update in the player
     *
     * @return {object} The updated player object
     */
    PlayerList.prototype.updatePlayer = function(id, update) {
        var player;
        if ('string' !== typeof id) {
            throw new TypeError(
                'PlayerList.updatePlayer: id must be string. Found: ' + id);
        }
        if ('object' !== typeof update) {
            throw new TypeError(
                'PlayerList.updatePlayer: update must be object. Found: ' +
                    update);
        }

        if ('undefined' !== typeof update.id) {
            throw new Error('PlayerList.updatePlayer: update cannot change ' +
                            'the player id.');
        }

        player = this.id.update(id, update);

        if (!player) {
            throw new Error(
                'PlayerList.updatePlayer: player not found: ' + id);
        }

        return player;
    };

    /**
     * ### PlayerList.isStepDone
     *
     * Checks whether all players have terminated the specified game step
     *
     * A stage is considered _DONE_ if all players that are found playing
     * that game step have the property `stageLevel` equal to:
     *
     * `node.constants.stageLevels.DONE`.
     *
     * By default, players at other steps are ignored.
     *
     * If no player is found at the desired step, it returns TRUE
     *
     * @param {GameStage} gameStage The GameStage of reference
     * @param {string} type Optional. The type of checking. Default 'EXACT'
     * @param {boolean} checkOutliers Optional. If TRUE, players at other
     *   steps are also checked. Default FALSE
     *
     * @return {boolean} TRUE, if all checked players have terminated the stage
     *
     * @see PlayerList.arePlayersSync
     */
    PlayerList.prototype.isStepDone = function(gameStage, type, checkOutliers) {
        return this.arePlayersSync(gameStage, stageLevels.DONE, type,
                                   checkOutliers);
    };

    /**
     * ### PlayerList.isStepLoaded
     *
     * Checks whether all players have loaded the specified game step
     *
     * A stage is considered _LOADED_ if all players that are found playing
     * that game step have the property `stageLevel` equal to:
     *
     * `node.constants.stageLevels.LOADED`.
     *
     * By default, players at other steps are ignored.
     *
     * If no player is found at the desired step, it returns TRUE.
     *
     * @param {GameStage} gameStage The GameStage of reference
     *
     * @return {boolean} TRUE, if all checked players have loaded the stage
     *
     * @see PlayerList.arePlayersSync
     */
    PlayerList.prototype.isStepLoaded = function(gameStage) {
        return this.arePlayersSync(gameStage, stageLevels.LOADED, 'EXACT');
    };

    /**
     * ### PlayerList.arePlayersSync
     *
     * Verifies that all players in the same stage are at the same stageLevel
     *
     * Players at other game steps are ignored, unless the
     * `checkOutliers` parameter is set. In this case, if players are
     * found in earlier game steps, the method will return
     * false. Players at later game steps will still be ignored.
     *
     * The `type` parameter can assume one of the following values:
     *
     *  - 'EXACT': same stage, step, round
     *  - 'STAGE': same stage, but different steps and rounds are accepted
     *  - 'STAGE_UPTO': up to the same stage is ok
     *
     * Finally, if `stageLevel` is set, it even checks for the stageLevel,
     * for example: PLAYING, DONE, etc.
     *
     * TODO: see the checkOutliers param, if it is needed after all.
     *
     * @param {GameStage} gameStage The GameStage of reference
     * @param {number} stageLevel The stageLevel of reference
     * @param {string} type Optional. Flag to say what players will be checked
     * @param {boolean} checkOutliers Optional. Whether to check for outliers.
     *   Can't be TRUE if type is 'exact'
     *
     * @return {boolean} TRUE, if all checked players are sync
     */
    PlayerList.prototype.arePlayersSync = function(gameStage, stageLevel, type,
                                                   checkOutliers) {

        var p, i, len, cmp, outlier;

        // Cast the gameStage to object. It can throw errors.
        gameStage = new GameStage(gameStage);

        if ('undefined' !== typeof stageLevel &&
            'number'    !== typeof stageLevel) {

            throw new TypeError('PlayerList.arePlayersSync: stagelevel must ' +
                                'be number or undefined.');
        }

        type = type || 'EXACT';
        if ('string' !== typeof type) {
            throw new TypeError('PlayerList.arePlayersSync: type must be ' +
                                'string or undefined.');
        }

        if ('undefined' === typeof syncTypes[type]) {
            throw new Error('PlayerList.arePlayersSync: unknown type: ' +
                            type + '.');
        }

        checkOutliers = 'undefined' === typeof checkOutliers ?
            true : !!checkOutliers;

        if (!checkOutliers && type === 'EXACT') {
            throw new Error('PlayerList.arePlayersSync: incompatible options:' +
                            ' type=EXACT and checkOutliers=FALSE.');
        }

        i = -1, len = this.db.length;
        for ( ; ++i < len ; ) {

            p = this.db[i];

            switch(type) {

            case 'EXACT':
                // Players in same stage, step and round.
                cmp = GameStage.compare(gameStage, p.stage);
                if (cmp !== 0) return false;
                break;

            case 'STAGE':
                if (gameStage.stage !== p.stage.stage) {
                    outlier = true;
                }
                break;

             case 'STAGE_UPTO':
                // Players in current stage up to the reference step.
                cmp = GameStage.compare(gameStage, p.stage);
                // Player in another stage or in later step.
                if (gameStage.stage !== p.stage.stage || cmp < 0) {
                    outlier = true;
                    break;
                }
                // Player before given step.
                if (cmp > 0) return false;

                break;
            }

            // If outliers are not allowed returns false if one was found.
            if (checkOutliers && outlier) return false;

            // If the stageLevel check is required let's do it!
            if ('undefined' !== typeof stageLevel &&
                p.stageLevel !== stageLevel) {

                return false;
            }
        }
        return true;
    };

    /**
     * ### PlayerList.toString
     *
     * Returns a string representation of the PlayerList
     *
     * @param {string} eol Optional. End of line separator between players
     *
     * @return {string} out The string representation of the PlayerList
     */
    PlayerList.prototype.toString = function(eol) {
        var out, EOL;
        out = '', EOL = eol || '\n';
        this.each(function(p) {
            var stage;
            out += p.id + ': ' + p.name;
            stage = new GameStage(p.stage);
            out += ': ' + stage + EOL;
        });
        return out;
    };

    /**
     * ### PlayerList.getNGroups
     *
     * Creates N random groups of players
     *
     * @param {number} N The number of groups
     *
     * @return {array} Array containing N `PlayerList` objects
     *
     * @see JSUS.getNGroups
     */
    PlayerList.prototype.getNGroups = function(N) {
        var groups;
        if ('number' !== typeof N || isNaN(N) || N < 1) {
            throw new TypeError('PlayerList.getNGroups: N must be a number ' +
                                '> 0: ' + N);
        }
        groups = J.getNGroups(this.db, N);
        return array2Groups.call(this, groups);
    };

    /**
     * ### PlayerList.getGroupsSizeN
     *
     * Creates random groups of N players
     *
     * @param {number} N The number player per group
     *
     * @return {array} Array containing N `PlayerList` objects
     *
     * @see JSUS.getGroupsSizeN
     */
    PlayerList.prototype.getGroupsSizeN = function(N) {
        var groups;
        if ('number' !== typeof N || isNaN(N) || N < 1) {
            throw new TypeError('PlayerList.getNGroups: N must be a number ' +
                                '> 0: ' + N);
        }
        groups = J.getGroupsSizeN(this.db, N);
        return array2Groups.call(this, groups);
    };

    /**
     * ### PlayerList.getRandom
     *
     * Returns a set of N random players
     *
     * @param {number} N The number of players in the random set. Defaults N = 1
     *
     * @return {Player|array} A single player object or an array of
     */
    PlayerList.prototype.getRandom = function(N) {
        var shuffled;
        if ('undefined' === typeof N) N = 1;
        if ('number' !== typeof N || isNaN(N) || N < 1) {
            throw new TypeError('PlayerList.getRandom: N must be a number ' +
                                '> 0 or undefined: ' + N + '.');
        }
        shuffled = this.shuffle();
        return N === 1 ? shuffled.first() : shuffled.limit(N).fetch();
    };


    // ## Helper Methods and Objects

    /**
     * ### array2Groups
     *
     * Transforms an array of array (of players) into an
     * array of PlayerList instances and returns it.
     *
     * The original array is modified.
     *
     * @param {array} array The array to transform
     *
     * @return {array} array The array of `PlayerList` objects
     */
    function array2Groups(array) {
        var i, len, settings;
        settings = this.cloneSettings();
        i = -1, len = array.length;
        for ( ; ++i < len ; ) {
            array[i] = new PlayerList(settings, array[i]);
        }
        return array;
    }

    syncTypes = {STAGE: '', STAGE_UPTO: '', EXACT: ''};

    /**
     * # Player
     *
     * Wrapper for a number of properties for players
     *
     *  `sid`: The Socket.io session id associated to the player
     *  `id`: The nodeGame session id associate to the player
     *  `count`: The id of the player within a PlayerList object
     *  `admin`: Whether the player is an admin
     *  `disconnected`: Whether the player has disconnected
     *  `lang`: the language chosen by player (default English)
     *  `name`: An alphanumeric name associated to the player
     *  `stage`: The current stage of the player as relative to a game
     *  `ip`: The ip address of the player
     *
     */

    // Expose Player constructor
    exports.Player = Player;

    /**
     * ## Player constructor
     *
     * Creates an instance of Player
     *
     * @param {object} player The object literal representing the player.
     *   Must contain at very least the `id` property
     */
    function Player(player) {
        var key;

        if ('object' !== typeof player) {
            throw new TypeError('Player constructor: player must be object. ' +
                               'Found: ' + player);
        }
        if ('string' !== typeof player.id) {
            throw new TypeError('Player constructor: id must be string. ' +
                                'Found: ' + player.id);
        }

        // ## Default properties

        /**
         * ### Player.id
         *
         * The nodeGame session id associate to the player
         *
         * Usually it is the same as the Socket.io id, but in
         * case of reconnections it can change
         */
        this.id = player.id;

        /**
         * ### Player.sid
         *
         * The session id received from the nodeGame server
         */
        this.sid = player.sid;

        /**
         * ### Player.clientType
         *
         * The client type (e.g. player, admin, bot, ...)
         */
        this.clientType = player.clientType || null;

        /**
         * ### Player.group
         *
         * The group to which the player belongs
         */
        this.group = player.group || null;

        /**
         * ### Player.role
         *
         * The role of the player
         */
        this.role = player.role || null;

        /**
         * ### Player.partner
         *
         * The partner of the player
         */
        this.partner = player.partner || null;

        /**
         * ### Player.count
         *
         * The ordinal position of the player in a PlayerList object
         *
         * @see PlayerList
         */
        this.count = 'undefined' === typeof player.count ? null : player.count;

        /**
         * ### Player.admin
         *
         * The admin status of the client
         */
        this.admin = !!player.admin;

        /**
         * ### Player.disconnected
         *
         * The connection status of the client
         */
        this.disconnected = !!player.disconnected;

        /**
         * ### Player.ip
         *
         * The ip address of the player
         *
         * Note: this can change in mobile networks
         */
        this.ip = player.ip || null;

        /**
         * ### Player.name
         *
         * An alphanumeric name associated with the player
         */
        this.name = player.name || null;

        /**
         * ### Player.stage
         *
         * Reference to the game-stage the player currently is
         *
         * @see node.game.stage
         * @see GameStage
         */
        this.stage = player.stage || new GameStage();

        /**
         * ### Player.stageLevel
         *
         * The current stage level of the player in the game
         *
         * @see node.stageLevels
         */
        this.stageLevel = player.stageLevel || stageLevels.UNINITIALIZED;

        /**
         * ### Player.stateLevel
         *
         * The current state level of the player in the game
         *
         * @see node.stateLevels
         */
        this.stateLevel = player.stateLevel || stateLevels.UNINITIALIZED;

        /**
         * ### Player.lang
         *
         * The current language used by the player
         *
         * Default language is English with the default path `en/`.
         */
        this.lang = {
            name: 'English',
            shortName: 'en',
            nativeName: 'English',
            path: 'en/'
        };

        /**
         * ## Extra properties
         *
         * For security reasons, they cannot be of type function, and they
         * cannot overwrite any previously defined variable
         */
        for (key in player) {
            if (player.hasOwnProperty(key)) {
                if ('function' !== typeof player[key]) {
                    if (!this.hasOwnProperty(key)) {
                        this[key] = player[key];
                    }
                }
            }
        }
    }

    // ## Player methods

    /**
     * ### Player.toString
     *
     * Returns a string representation of a player
     *
     * @return {string} The string representation of a player
     */
    Player.prototype.toString = function() {
        return (this.name || '' ) + ' (' + this.id + ') ' +
            new GameStage(this.stage);
    };

    // ## Closure
})(
    'undefined' != typeof node ? node : module.exports
 ,  'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # GameMsg
 *
 * Copyright(c) 2018 Stefano Balietti
 * MIT Licensed
 *
 * `nodeGame` exchangeable data format
 */
(function(exports, node) {

    "use strict";

    // ## Global scope
    var GameStage = node.GameStage,
    J = node.JSUS;

    exports.GameMsg = GameMsg;

    /**
     * ### GameMSg.clone (static)
     *
     * Returns a perfect copy of a game-message
     *
     * @param {GameMsg} gameMsg The message to clone
     * @return {GameMsg} The cloned messaged
     */
    GameMsg.clone = function(gameMsg) {
        return new GameMsg(gameMsg);
    };

    /**
     * ## GameMsg constructor
     *
     * Creates an instance of GameMsg
     *
     * @param {object} gm Optional. Initial values for the game message fields
     */
    function GameMsg(gm) {
        gm = gm || {};

        /**
         * ### GameMsg.id
         *
         * A randomly generated unique id
         */
        this.id = 'undefined' === typeof gm.id ?
            Math.floor(Math.random()*1000000) : gm.id;

        /**
         * ### GameMsg.sid
         *
         * The socket id, if provided
         *
         * Used by SocketIO to prevent spoofing, not used by other sockets
         * TODO: could this be session instead?
         */
        this.sid = gm.sid;

        /**
         * ### GameMsg.session
         *
         * The session id in which the message was generated
         */
        this.session = gm.session;

        /**
         * ### GameMsg.stage
         *
         * The game-stage in which the message was generated
         *
         * @see GameStage
         */
        this.stage = gm.stage;

        /**
         * ### GameMsg.action
         *
         * The action of the message
         *
         * @see node.constants.action
         */
        this.action = gm.action;

        /**
         * ### GameMsg.target
         *
         * The target of the message
         *
         * @see node.constants.target
         */
        this.target = gm.target;

        /**
         * ### GameMsg.from
         *
         * The id of the sender of the message
         *
         * @see Player.id
         * @see node.player.id
         */
        this.from = gm.from;

        /**
         * ### GameMsg.to
         *
         * The id of the receiver of the message
         *
         * @see Player.id
         * @see node.player.id
         */
        this.to = gm.to;

        /**
         * ### GameMsg.text
         *
         * An optional text adding a description for the message
         */
        this.text = gm.text;

        /**
         * ### GameMsg.data
         *
         * An optional payload field for the message
         */
        this.data = gm.data;

        /**
         * ### GameMsg.priority
         *
         * A priority index associated to the message
         */
        this.priority = gm.priority;

        /**
         * ### GameMsg.reliable
         *
         * Experimental. Disabled for the moment
         *
         * If set, requires ackwnoledgment of delivery
         */
        this.reliable = gm.reliable;

        /**
         * ### GameMsg.created
         *
         * A timestamp of the date of creation
         */
        this.created = J.getDate();

        /**
         * ### GameMsg.forward
         *
         * If TRUE, the message is a forward.
         *
         * E.g. between nodeGame servers
         */
        this.forward = 0;
    }

    /**
     * ### GameMsg.stringify
     *
     * Calls JSON.stringify on the message
     *
     * @return {string} The stringified game-message
     *
     * @see GameMsg.toString
     */
    GameMsg.prototype.stringify = function() {
        return JSON.stringify(this);
    };

    // ## GameMsg methods

    /**
     * ### GameMsg.toString
     *
     * Creates a human readable string representation of the message
     *
     * @return {string} The string representation of the message
     * @see GameMsg.stringify
     */
    GameMsg.prototype.toString = function() {
        var SPT, TAB, DLM, line, UNKNOWN, tmp;
        SPT = ",\t";
        TAB = "\t";
        DLM = "\"";
        UNKNOWN = "\"unknown\"\t";
        line  = this.created + SPT;
        line += this.id + SPT;
        line += this.session + SPT;
        line += this.action + SPT;

        line += this.target ?
            this.target.length < 6  ?
            this.target + SPT + TAB : this.target + SPT : UNKNOWN;
        line += this.from ?
            this.from.length < 6  ?
            this.from + SPT + TAB : this.from + SPT : UNKNOWN;
        line += this.to ?
            this.to.length < 6  ?
            this.to + SPT + TAB : this.to + SPT : UNKNOWN;

        if (this.text === null || 'undefined' === typeof this.text) {
            line += "\"no text\"" + SPT;
        }
        else if ('number' === typeof this.text) {
            line += "" + this.text;
        }
        else {
            tmp = this.text.toString();

            if (tmp.length > 12) {
                line += DLM + tmp.substr(0,9) + "..." + DLM + SPT;
            }
            else if (tmp.length < 6) {
                line += DLM + tmp + DLM + SPT + TAB;
            }
            else {
                line += DLM + tmp + DLM + SPT;
            }
        }

        if (this.data === null || 'undefined' === typeof this.data) {
            line += "\"no data\"" + SPT;
        }
        else if ('number' === typeof this.data) {
            line += "" + this.data;
        }
        else {
            tmp = this.data.toString();
            if (tmp.length > 12) {
                line += DLM + tmp.substr(0,9) + "..." + DLM + SPT;
            }
            else if (tmp.length < 9) {
                line += DLM + tmp + DLM + SPT + TAB;
            }
            else {
                line += DLM + tmp + DLM + SPT;
            }
        }

        line += new GameStage(this.stage) + SPT;
        line += this.reliable + SPT;
        line += this.priority;
        return line;
    };

    /**
     * ### GameMSg.toSMS
     *
     * Creates a compact visualization of the most important properties
     *
     * @return {string} A compact string representing the message
     *
     * TODO: Create an hash method as for GameStage
     */
    GameMsg.prototype.toSMS = function() {
        var line = '[' + this.from + ']->[' + this.to + ']\t';
        line += '|' + this.action + '.' + this.target + '|'+ '\t';
        line += ' ' + this.text + ' ';
        return line;
    };

    /**
     * ### GameMsg.toInEvent
     *
     * Hashes the action and target properties of an incoming message
     *
     * @return {string} The hash string
     * @see GameMsg.toEvent
     */
    GameMsg.prototype.toInEvent = function() {
        return 'in.' + this.toEvent();
    };

    /**
     * ### GameMsg.toOutEvent
     *
     * Hashes the action and target properties of an outgoing message
     *
     * @return {string} The hash string
     * @see GameMsg.toEvent
     */
    GameMsg.prototype.toOutEvent = function() {
        return 'out.' + this.toEvent();
    };

    /**
     * ### GameMsg.toEvent
     *
     * Hashes the action and target properties of the message
     *
     * @return {string} The hash string
     */
    GameMsg.prototype.toEvent = function() {
        return this.action + '.' + this.target;
    };

    // ## Closure
})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # GamePlot
 * Copyright(c) 2020 Stefano Balietti
 * MIT Licensed
 *
 * Wraps a stager and exposes methods to navigate through the sequence
 *
 * TODO: previousStage
 */
(function(exports, parent) {

    "use strict";

    // ## Global scope
    exports.GamePlot = GamePlot;

    var GameStage = parent.GameStage;
    var J = parent.JSUS;

    // ## Constants
    GamePlot.GAMEOVER = 'NODEGAME_GAMEOVER';
    GamePlot.END_SEQ  = 'NODEGAME_END_SEQ';
    GamePlot.NO_SEQ   = 'NODEGAME_NO_SEQ';

    /**
     * ## GamePlot constructor
     *
     * Creates a new instance of GamePlot
     *
     * Takes a sequence object created with Stager.
     *
     * If the Stager parameter has an empty sequence, flexible mode is assumed
     * (used by e.g. GamePlot.next).
     *
     * @param {NodeGameClient} node Reference to current node object
     * @param {Stager} stager Optional. The Stager object.
     *
     * @see Stager
     */
    function GamePlot(node, stager) {

        // ## GamePlot Properties

        /**
         * ### GamePlot.node
         *
         * Reference to the node object
         */
        this.node = node;

        /**
         * ### GamePlot.stager
         *
         * The stager object used to perform stepping operations
         */
        this.stager = null;

        /**
         * ### GamePlot.cache
         *
         * Caches the value of previously fetched properties per game stage
         */
        this.cache = {};

        /**
         * ### GamePlot.tmpCache
         *
         * Handles a temporary cache for properties of current step
         *
         * If set, properties are served first by the `getProperty` method.
         * This cache is deleted each time a step is done.
         * Used, for example, to reset some properties upon reconnect.
         *
         * Defined two additional methods:
         *
         *   - tmpCache.hasOwnProperty
         *   - tmpCache.clear
         *
         * @param {string} prop the name of the property to retrieve or set
         * @param {mixed} value The value of property to set
         *
         * @return {mixed} The current value of the property
         */
        this.tmpCache = (function() {
            var tmpCache, handler;
            tmpCache = {};
            handler = function(prop, value) {
                if ('undefined' === typeof prop) {
                    return tmpCache;
                }
                else if ('string' === typeof prop) {
                    if (arguments.length === 1) return tmpCache[prop];
                    tmpCache[prop] = value;
                    return value;
                }

                throw new TypeError('GamePlot.tmpCache: prop must be ' +
                                    'string. Found: ' + prop);
            };

            handler.clear = function() {
                var tmp;
                tmp = tmpCache;
                tmpCache = {};
                return tmp;
            };

            handler.hasOwnProperty = function(prop) {
                if ('string' !== typeof prop) {
                    throw new TypeError('GamePlot.tmpCache.hasProperty: ' +
                                        'prop must be string. Found: ' +
                                        prop);
                }
                return tmpCache.hasOwnProperty(prop);
            };

            return handler;
        })();

        /**
        * ### GamePlot._normalizedCache
        *
        * Caches the value of previously normalized Game Stages objects.
        *
        * @api private
        */
        this._normalizedCache = {};

        this.init(stager);
    }

    // ## GamePlot methods

    /**
     * ### GamePlot.init
     *
     * Initializes the GamePlot with a stager
     *
     * Clears the cache also.
     *
     * @param {Stager} stager Optional. The Stager object.
     *
     * @see Stager
     */
    GamePlot.prototype.init = function(stager) {
        if (stager) {
            if ('object' !== typeof stager) {
                throw new Error('GamePlot.init: called with invalid stager.');
            }
            this.stager = stager;
        }
        else {
            this.stager = null;
        }
        this.cache = {};
        this.tmpCache.clear();
    };

    /**
     * ### GamePlot.next
     *
     * Returns the next step in the sequence
     *
     * If the step in `curStage` is an integer and out of bounds,
     * that bound is assumed.
     *
     * // TODO: previousStage
     *
     * @param {GameStage} curStage The GameStage of reference
     * @param {bolean} execLoops Optional. If true, loop and doLoop
     *   conditional function will be executed to determine next stage.
     *   If false, null will be returned if the next stage depends
     *   on the execution of the loop/doLoop conditional function.
     *   Default: true.
     *
     * @return {GameStage|string} The GameStage after _curStage_
     *
     * @see GameStage
     */
    GamePlot.prototype.nextStage = function(curStage, execLoops) {
        var seqObj, stageObj;
        var stageNo, stepNo, steps;
        var normStage, nextStage;
        var flexibleMode;

        // GamePlot was not correctly initialized.
        if (!this.stager) return GamePlot.NO_SEQ;

        flexibleMode = this.isFlexibleMode();
        if (flexibleMode) {
            // TODO. What does next stage mean in flexible mode?
            // Calling the next cb of the last step? A separate cb?
            console.log('***GamePlot.nextStage: method not available in ' +
                        'flexible mode.***');
            return null;
        }

        // Standard Mode.
        else {
            // Get normalized GameStage:
            // makes sures stage is with numbers and not strings.
            normStage = this.normalizeGameStage(curStage);
            if (normStage === null) {
                this.node.silly('GamePlot.nextStage: invalid stage: ' +
                               curStage);
                return null;
            }

            stageNo = normStage.stage;

            if (stageNo === 0) {
                return new GameStage({
                    stage: 1,
                    step:  1,
                    round: 1
                });
            }
            seqObj = this.stager.sequence[stageNo - 1];

            if (seqObj.type === 'gameover') return GamePlot.GAMEOVER;

            execLoops = 'undefined' === typeof execLoops ? true : execLoops;

            // Get stage object.
            stageObj = this.stager.stages[seqObj.id];

            // Go to next stage.
            if (stageNo < this.stager.sequence.length) {
                seqObj = this.stager.sequence[stageNo];

                // Return null if a loop is found and can't be executed.
                if (!execLoops && seqObj.type === 'loop') return null;

                // Skip over loops if their callbacks return false:
                while (seqObj.type === 'loop' &&
                       !seqObj.cb.call(this.node.game)) {

                    stageNo++;
                    if (stageNo >= this.stager.sequence.length) {
                        return GamePlot.END_SEQ;
                    }
                    // Update seq object.
                    seqObj = this.stager.sequence[stageNo];
                }

                // Handle gameover:
                if (this.stager.sequence[stageNo].type === 'gameover') {
                    return GamePlot.GAMEOVER;
                }

                return new GameStage({
                    stage: stageNo + 1,
                    step:  1,
                    round: 1
                });
            }

            // No more stages remaining:
            return GamePlot.END_SEQ;
        }
    };

    /**
     * ### GamePlot.next
     *
     * Returns the next step in the sequence
     *
     * If the step in `curStage` is an integer and out of bounds,
     * that bound is assumed.
     *
     * @param {GameStage} curStage The GameStage of reference
     * @param {bolean} execLoops Optional. If true, loop and doLoop
     *   conditional function will be executed to determine next stage.
     *   If false, null will be returned if the next stage depends
     *   on the execution of the loop/doLoop conditional function.
     *   Default: true.
     *
     * @return {GameStage|string} The GameStage after _curStage_
     *
     * @see GameStage
     */
    GamePlot.prototype.next = function(curStage, execLoops) {
        var seqObj, stageObj;
        var stageNo, stepNo, steps;
        var normStage, nextStage;
        var flexibleMode;

        // GamePlot was not correctly initialized.
        if (!this.stager) return GamePlot.NO_SEQ;

        // Init variables.
        seqObj = null, stageObj = null, normStage = null, nextStage = null;
        // Find out flexibility mode.
        flexibleMode = this.isFlexibleMode();

        if (flexibleMode) {
            curStage = new GameStage(curStage);

            if (curStage.stage === 0) {
                // Get first stage:
                if (this.stager.generalNextFunction) {
                    nextStage = this.stager.generalNextFunction();
                }

                if (nextStage) {
                    return new GameStage({
                        stage: nextStage,
                        step:  1,
                        round: 1
                    });
                }

                return GamePlot.END_SEQ;
            }

            // Get stage object:
            stageObj = this.stager.stages[curStage.stage];

            if ('undefined' === typeof stageObj) {
                throw new Error('Gameplot.next: received non-existent stage: ' +
                                curStage.stage);
            }

            // Find step number:
            if ('number' === typeof curStage.step) {
                stepNo = curStage.step;
            }
            else {
                stepNo = stageObj.steps.indexOf(curStage.step) + 1;
            }
            if (stepNo < 1) {
                throw new Error('GamePlot.next: received non-existent step: ' +
                                stageObj.id + '.' + curStage.step);
            }

            // Handle stepping:
            if (stepNo + 1 <= stageObj.steps.length) {
                return new GameStage({
                    stage: stageObj.id,
                    step:  stepNo + 1,
                    round: 1
                });
            }

            // Get next stage:
            if (this.stager.nextFunctions[stageObj.id]) {
                nextStage = this.stager.nextFunctions[stageObj.id]();
            }
            else if (this.stager.generalNextFunction) {
                nextStage = this.stager.generalNextFunction();
            }

            // If next-deciding function returns GamePlot.GAMEOVER,
            // consider it game over.
            if (nextStage === GamePlot.GAMEOVER)  {
                return GamePlot.GAMEOVER;
            }
            else if (nextStage) {
                return new GameStage({
                    stage: nextStage,
                    step:  1,
                    round: 1
                });
            }

            return GamePlot.END_SEQ;
        }

        // Standard Mode.
        else {
            // Get normalized GameStage:
            // makes sures stage is with numbers and not strings.
            normStage = this.normalizeGameStage(curStage);
            if (normStage === null) {
                this.node.silly('GamePlot.next: invalid stage: ' + curStage);
                return null;
            }

            stageNo = normStage.stage;

            if (stageNo === 0) {
                return new GameStage({
                    stage: 1,
                    step:  1,
                    round: 1
                });
            }

            stepNo = normStage.step;
            seqObj = this.stager.sequence[stageNo - 1];

            if (seqObj.type === 'gameover') return GamePlot.GAMEOVER;

            execLoops = 'undefined' === typeof execLoops ? true : execLoops;

            // Get stage object.
            stageObj = this.stager.stages[seqObj.id];

            steps = seqObj.steps;

            // Handle stepping:
            if (stepNo + 1 <= steps.length) {
                return new GameStage({
                    stage: stageNo,
                    step:  stepNo + 1,
                    round: normStage.round
                });
            }

            // Handle repeat block:
            if (seqObj.type === 'repeat' && normStage.round + 1 <= seqObj.num) {
                return new GameStage({
                    stage: stageNo,
                    step:  1,
                    round: normStage.round + 1
                });
            }

            // Handle looping blocks:
            if (seqObj.type === 'doLoop' || seqObj.type === 'loop') {

                // Return null if a loop is found and can't be executed.
                if (!execLoops) return null;

                // Call loop function. True means continue loop.
                if (seqObj.cb.call(this.node.game)) {
                    return new GameStage({
                        stage: stageNo,
                        step:  1,
                        round: normStage.round + 1
                    });
                }
            }

            // Go to next stage.
            if (stageNo < this.stager.sequence.length) {
                seqObj = this.stager.sequence[stageNo];

                // Return null if a loop is found and can't be executed.
                if (!execLoops && seqObj.type === 'loop') return null;

                // Skip over loops if their callbacks return false:
                while (seqObj.type === 'loop' &&
                       !seqObj.cb.call(this.node.game)) {

                    stageNo++;
                    if (stageNo >= this.stager.sequence.length) {
                        return GamePlot.END_SEQ;
                    }
                    // Update seq object.
                    seqObj = this.stager.sequence[stageNo];
                }

                // Handle gameover:
                if (this.stager.sequence[stageNo].type === 'gameover') {
                    return GamePlot.GAMEOVER;
                }

                return new GameStage({
                    stage: stageNo + 1,
                    step:  1,
                    round: 1
                });
            }

            // No more stages remaining:
            return GamePlot.END_SEQ;
        }
    };

    /**
     * ### GamePlot.previous
     *
     * Returns the previous step in the sequence
     *
     * Works only in simple mode.
     *
     * Previous of 0.0.0 is 0.0.0.
     *
     * @param {GameStage} curStage The GameStage of reference
     * @param {bolean} execLoops Optional. If true, loop and doLoop
     *   conditional function will be executed to determine previous stage.
     *   If false, null will be returned if the previous stage depends
     *   on the execution of the loop/doLoop conditional function.
     *   Default: true.
     *
     * @return {GameStage|null} The GameStage before _curStage_, or null
     *   if _curStage_ is invalid.
     *
     * @see GameStage
     */
    GamePlot.prototype.previous = function(curStage, execLoops) {
        var normStage;
        var seqObj, stageObj;
        var prevSeqObj;
        var stageNo, stepNo, prevStepNo;

        // GamePlot was not correctly initialized.
        if (!this.stager) return GamePlot.NO_SEQ;

        seqObj = null, stageObj = null;

        // Get normalized GameStage (calls GameStage constructor).
        normStage = this.normalizeGameStage(curStage);
        if (normStage === null) {
            this.node.warn('GamePlot.previous: invalid stage: ' + curStage);
            return null;
        }
        stageNo = normStage.stage;

        // Already 0.0.0, there is nothing before.
        if (stageNo === 0) return new GameStage();

        stepNo = normStage.step;
        seqObj = this.stager.sequence[stageNo - 1];

        execLoops = 'undefined' === typeof execLoops ? true : execLoops;

        // Within same stage.

        // Handle stepping.
        if (stepNo > 1) {
            return new GameStage({
                stage: stageNo,
                step:  stepNo - 1,
                round: normStage.round
            });
        }

        // Handle rounds:
        if (normStage.round > 1) {
            return new GameStage({
                stage: stageNo,
                step:  seqObj.steps.length,
                round: normStage.round - 1
            });
        }

        // Handle beginning (0.0.0).
        if (stageNo === 1) return new GameStage();

        // Go to previous stage.

        // Get previous sequence object:
        prevSeqObj = this.stager.sequence[stageNo - 2];

        // Return null if a loop is found and can't be executed.
        if (!execLoops && seqObj.type === 'loop') return null;

        // Skip over loops if their callbacks return false:
        while (prevSeqObj.type === 'loop' &&
               !prevSeqObj.cb.call(this.node.game)) {

            stageNo--;
            // (0.0.0).
            if (stageNo <= 1) return new GameStage();

            // Update seq object.
            prevSeqObj = this.stager.sequence[stageNo - 2];
        }

        // Get number of steps in previous stage:
        prevStepNo = prevSeqObj.steps.length;

        // Handle repeat block:
        if (prevSeqObj.type === 'repeat') {
            return new GameStage({
                stage: stageNo - 1,
                step:  prevStepNo,
                round: prevSeqObj.num
            });
        }

        // Handle normal blocks:
        return new GameStage({
            stage: stageNo - 1,
            step:  prevStepNo,
            round: 1
        });
    };

    /**
     * ### GamePlot.jump
     *
     * Returns a distant stage in the stager
     *
     * Works with negative delta only in simple mode.
     *
     * Uses `GamePlot.previous` and `GamePlot.next` for stepping.
     *
     * @param {GameStage} curStage The GameStage of reference
     * @param {number} delta The offset. Negative number for backward stepping.
     * @param {bolean} execLoops Optional. If true, loop and doLoop
     *   conditional function will be executed to determine next stage.
     *   If false, null will be returned when a loop or doLoop is found
     *   and more evaluations are still required. Default: true.
     *
     * @return {GameStage|string|null} The distant game stage
     *
     * @see GameStage
     * @see GamePlot.previous
     * @see GamePlot.next
     */
    GamePlot.prototype.jump = function(curStage, delta, execLoops) {
        var stageType;
        execLoops = 'undefined' === typeof execLoops ? true : execLoops;
        if (delta < 0) {
            while (delta < 0) {
                curStage = this.previous(curStage, execLoops);

                if (!(curStage instanceof GameStage) || curStage.stage === 0) {
                    return curStage;
                }
                delta++;
                if (!execLoops) {
                    // If there are more steps to jump, check if we have loops.
                    stageType = this.stager.sequence[curStage.stage -1].type;
                    if (stageType === 'loop') {
                        if (delta < 0) return null;
                    }
                    else if (stageType === 'doLoop') {
                        if (delta < -1) return null;
                        else return curStage;
                    }
                }
            }
        }
        else {
            while (delta > 0) {
                curStage = this.next(curStage, execLoops);
                // If we find a loop return null.
                if (!(curStage instanceof GameStage)) return curStage;

                delta--;
                if (!execLoops) {
                    // If there are more steps to jump, check if we have loops.
                    stageType = this.stager.sequence[curStage.stage -1].type;
                    if (stageType === 'loop' || stageType === 'doLoop') {
                        if (delta > 0) return null;
                        else return curStage;
                    }
                }
            }
        }

        return curStage;
    };

    /**
     * ### GamePlot.stepsToNextStage
     *
     * Returns the number of steps to reach the next stage
     *
     * By default, each stage repetition is considered as a new stage.
     *
     * @param {GameStage|string} gameStage The reference step
     * @param {boolean} countRepeat If TRUE stage repetitions are
     *  considered as current stage, and included in the count. Default: FALSE.
     *
     * @return {number|null} The number of steps including current one,
     *   or NULL on error.
     *
     * @see GamePlot.normalizeGameStage
     */
    GamePlot.prototype.stepsToNextStage = function(gameStage, countRepeat) {
        var seqObj, totSteps, stepNo;
        if (!this.stager) return null;

        // Checks stage and step ranges.
        gameStage = this.normalizeGameStage(gameStage);
        if (!gameStage) return null;
        if (gameStage.stage === 0) return 1;
        seqObj = this.getSequenceObject(gameStage);
        if (!seqObj) return null;
        stepNo = gameStage.step;
        totSteps = seqObj.steps.length;
        if (countRepeat) {
            if (seqObj.type === 'repeat') {
                if (gameStage.round > 1) {
                    stepNo = ((gameStage.round-1) * totSteps) + stepNo;
                }
                totSteps = totSteps * seqObj.num;
            }
            else if (seqObj.type === 'loop' || seqObj.type === 'doLoop') {
                return null;
            }
        }
        return 1 + totSteps - stepNo;
    };

    // TODO: remove in next version.
    GamePlot.prototype.stepsToPreviousStage = function(gameStage) {
        console.log('GamePlot.stepsToPreviousStage is **deprecated**. Use' +
                    'GamePlot.stepsFromPreviousStage instead.');
        return this.stepsFromPreviousStage(gameStage);
    };

    /**
     * ### GamePlot.stepsFromPreviousStage
     *
     * Returns the number of steps passed from the previous stage
     *
     * By default, each stage repetition is considered as a new stage.
     *
     * @param {GameStage|string} gameStage The reference step
     * @param {boolean} countRepeat If TRUE stage repetitions are
     *  considered as current stage, and included in the count. Default: FALSE.
     *
     * @return {number|null} The number of steps including current one, or
     *   NULL on error.
     *
     * @see GamePlot.normalizeGameStage
     */
    GamePlot.prototype.stepsFromPreviousStage = function(gameStage,
                                                         countRepeat) {

        var seqObj, stepNo;
        if (!this.stager) return null;

        // Checks stage and step ranges.
        gameStage = this.normalizeGameStage(gameStage);
        if (!gameStage || gameStage.stage === 0) return null;
        seqObj = this.getSequenceObject(gameStage);
        if (!seqObj) return null;
        stepNo = gameStage.step;
        if (countRepeat) {
            if (seqObj.type === 'repeat') {
                if (gameStage.round > 1) {
                    stepNo = (seqObj.steps.length * (gameStage.round-1)) +
                        stepNo;
                }
            }
            else if (seqObj.type === 'loop' || seqObj.type === 'doLoop') {
                return null;
            }
        }
        return stepNo;
    };

    /**
     * ### GamePlot.getSequenceObject
     *
     * Returns the sequence object corresponding to a GameStage
     *
     * @param {GameStage|string} gameStage The GameStage object,
     *   or its string representation
     *
     * @return {object|null} The corresponding sequence object,
     *   or NULL if not found
     */
    GamePlot.prototype.getSequenceObject = function(gameStage) {
        if (!this.stager) return null;
        gameStage = this.normalizeGameStage(gameStage);
        return gameStage ? this.stager.sequence[gameStage.stage - 1] : null;
    };

    /**
     * ### GamePlot.getStage
     *
     * Returns the stage object corresponding to a GameStage
     *
     * @param {GameStage|string} gameStage The GameStage object,
     *  or its string representation
     *
     * @return {object|null} The corresponding stage object, or NULL
     *  if the step was not found
     */
    GamePlot.prototype.getStage = function(gameStage) {
        var stageObj;
        if (!this.stager) return null;
        gameStage = this.normalizeGameStage(gameStage);
        if (gameStage) {
            stageObj = this.stager.sequence[gameStage.stage - 1];
            stageObj = stageObj ? this.stager.stages[stageObj.id] : null;
        }
        return stageObj || null;
    };

    /**
     * ### GamePlot.getStep
     *
     * Returns the step object corresponding to a GameStage
     *
     * @param {GameStage|string} gameStage The GameStage object,
     *  or its string representation
     *
     * @return {object|null} The corresponding step object, or NULL
     *  if the step was not found
     */
    GamePlot.prototype.getStep = function(gameStage) {
        var seqObj, stepObj;
        if (!this.stager) return null;
        // Game stage is normalized inside getSequenceObject.
        seqObj = this.getSequenceObject(gameStage);
        if (seqObj) {
            stepObj = this.stager.steps[seqObj.steps[gameStage.step - 1]];
        }
        return stepObj || null;
    };

    /**
     * ### GamePlot.getStepRule
     *
     * Returns the step-rule function for a given game-stage
     *
     * Otherwise, the order of lookup is:
     *
     * 1. step object
     * 2. stage object
     * 3. default property
     * 4. default step-rule of the Stager object
     *
     * @param {GameStage|string} gameStage The GameStage object,
     *   or its string representation
     *
     * @return {function} The step-rule function or the default rule
     *
     * @see Stager.getDefaultStepRule
     */
    GamePlot.prototype.getStepRule = function(gameStage) {
        var rule;
        rule = this.getProperty(gameStage, 'stepRule');
        if ('string' === typeof rule) rule = parent.stepRules[rule];
        return rule || this.stager.getDefaultStepRule();
    };

    /**
     * ### GamePlot.getGlobal
     *
     * Looks up the value of a global variable
     *
     * Looks for definitions of a global variable in
     *
     * 1. the globals property of the step object of the given gameStage,
     *
     * 2. the globals property of the stage object of the given gameStage,
     *
     * 3. the defaults, defined in the Stager.
     *
     * @param {GameStage|string} gameStage The GameStage object,
     *  or its string representation
     * @param {string} globalVar The name of the global variable
     *
     * @return {mixed|null} The value of the global variable if found,
     *   NULL otherwise.
     */
    GamePlot.prototype.getGlobal = function(gameStage, globalVar) {
        var stepObj, stageObj;
        var stepGlobals, stageGlobals, defaultGlobals;

        gameStage = new GameStage(gameStage);

        // Look in current step:
        stepObj = this.getStep(gameStage);
        if (stepObj) {
            stepGlobals = stepObj.globals;
            if (stepGlobals && stepGlobals.hasOwnProperty(globalVar)) {
                return stepGlobals[globalVar];
            }
        }

        // Look in current stage:
        stageObj = this.getStage(gameStage);
        if (stageObj) {
            stageGlobals = stageObj.globals;
            if (stageGlobals && stageGlobals.hasOwnProperty(globalVar)) {
                return stageGlobals[globalVar];
            }
        }

        // Look in Stager's defaults:
        if (this.stager) {
            defaultGlobals = this.stager.getDefaultGlobals();
            if (defaultGlobals && defaultGlobals.hasOwnProperty(globalVar)) {
                return defaultGlobals[globalVar];
            }
        }

        // Not found:
        return null;
    };

    /**
     * ### GamePlot.getGlobals
     *
     * Looks up and build the _globals_ object for the specified game stage
     *
     * Globals properties are mixed in at each level (defaults, stage, step)
     * to form the complete set of globals available for the specified
     * game stage.
     *
     * @param {GameStage|string} gameStage The GameStage object,
     *  or its string representation
     *
     * @return {object} The _globals_ object for the specified  game stage
     */
    GamePlot.prototype.getGlobals = function(gameStage) {
        var stepstage, globals;
        if ('string' !== typeof gameStage && 'object' !== typeof gameStage) {
            throw new TypeError('GamePlot.getGlobals: gameStage must be ' +
                                'string or object.');
        }
        globals = {};
        // No stager found, no globals!
        if (!this.stager) return globals;

        // Look in Stager's defaults:
        J.mixin(globals, this.stager.getDefaultGlobals());

        // Look in current stage:
        stepstage = this.getStage(gameStage);
        if (stepstage) J.mixin(globals, stepstage.globals);

        // Look in current step:
        stepstage = this.getStep(gameStage);
        if (stepstage) J.mixin(globals, stepstage.globals);

        return globals;
    };

    /**
     * ### GamePlot.getProperty
     *
     * Looks up the value of a property in a hierarchy of lookup locations
     *
     * The hierarchy of lookup locations is:
     *
     * 1. the temporary cache, if game stage equals current game stage
     * 2. the game plot cache
     * 3. the step object of the given gameStage,
     * 4. the stage object of the given gameStage,
     * 5. the defaults, defined in the Stager.
     *
     * @param {GameStage|string} gameStage The GameStage object,
     *   or its string representation
     * @param {string} prop The name of the property
     * @param {mixed} notFound Optional. A value to return if
     *   property is not found. Default: NULL
     * @param {object} mask Optional. An object disabling specific lookup
     *    locations. Default:
     * ```
     * { tmpCache: false, cache: false, step: false, stage: false, game: false }
     * ```
     *
     * @return {mixed|null} The value of the property if found, NULL otherwise.
     *
     * @see GamePlot.cache
     */
    GamePlot.prototype.getProperty = function(gameStage, prop, notFound, mask) {

        var stepObj, stageObj, defaultProps, found, res;

        if ('string' !== typeof prop) {
            throw new TypeError('GamePlot.getProperty: property must be ' +
                                'string. Found: ' + prop);
        }

        gameStage = new GameStage(gameStage);

        mask = mask || {};
        if ('object' !== typeof mask) {
            throw new TypeError('GamePlot.getProperty: mask must be ' +
                                'object or undefined. Found: ' + mask);
        }

        // Look in the tmpCache (cleared every step).
        if (!mask.tmpCache && this.tmpCache.hasOwnProperty(prop) &&
            GameStage.compare(gameStage,this.node.player.stage) === 0) {

            return this.tmpCache(prop);
        }

        // Look in the main cache (this persists over steps).
        if (!mask.tmpCache && this.cache[gameStage] &&
            this.cache[gameStage].hasOwnProperty(prop)) {

            return this.cache[gameStage][prop];
        }

        // Look in current step.
        if (!mask.step) {
            stepObj = this.getStep(gameStage);
            if (stepObj && stepObj.hasOwnProperty(prop)) {
                res = stepObj[prop];
                found = true;
            }
        }

        // Look in current stage.
        if (!found && !mask.stage) {
            stageObj = this.getStage(gameStage);
            if (stageObj && stageObj.hasOwnProperty(prop)) {
                res = stageObj[prop];
                found = true;
            }
        }

        // Look in Stager's defaults.
        if (!found && !mask.game && this.stager) {
            defaultProps = this.stager.getDefaultProperties();
            if (defaultProps && defaultProps.hasOwnProperty(prop)) {
                res = defaultProps[prop];
                found = true;
            }
        }

        // Cache it and return it.
        if (found) {
            cacheStepProperty(this, gameStage, prop, res);
            return res;
        }

        // Return notFound.
        return 'undefined' === typeof notFound ? null : notFound;
    };


    /**
     * ### GamePlot.updateProperty
     *
     * Looks up a property and updates it to the new value
     *
     * Look up follows the steps described in _GamePlot.getProperty_,
     * excluding step 1. If a property is found and updated, its value
     * is stored in the cached.
     *
     * @param {GameStage|string} gameStage The GameStage object,
     *   or its string representation
     * @param {string} property The name of the property
     * @param {mixed} value The new value for the property.
     *
     * @return {bool} TRUE, if property is found and updated, FALSE otherwise.
     *
     * @see GamePlot.cache
     */
    GamePlot.prototype.updateProperty = function(gameStage, property, value) {
        var stepObj, stageObj, defaultProps, found;

        gameStage = new GameStage(gameStage);

        if ('string' !== typeof property) {
            throw new TypeError('GamePlot.updateProperty: property must be ' +
                                'string. Found: ' + property);
        }

        // Look in current step.
        stepObj = this.getStep(gameStage);
        if (stepObj && stepObj.hasOwnProperty(property)) {
            stepObj[property] = value;
            found = true;
        }

        // Look in current stage.
        if (!found) {
            stageObj = this.getStage(gameStage);
            if (stageObj && stageObj.hasOwnProperty(property)) {
                stageObj[property] = value;
                found = true;
            }
        }

        // Look in Stager's defaults.
        if (!found && this.stager) {
            defaultProps = this.stager.getDefaultProperties();
            if (defaultProps && defaultProps.hasOwnProperty(property)) {
                defaultProps[property] = value;
                found = true;
            }
        }

        // Cache it and return it.
        if (found) {
            cacheStepProperty(this, gameStage, property, value);
            return true;
        }

        // Not found.
        return false;
    };

    /**
     * ### GamePlot.setStepProperty
     *
     * Sets the value a property in a step object
     *
     * @param {GameStage|string} gameStage The GameStage object,
     *  or its string representation
     * @param {string} property The name of the property
     * @param {mixed} value The new value for the property.
     *
     * @return {bool} TRUE, if property is found and updated, FALSE otherwise.
     *
     * @see GamePlot.cache
     */
    GamePlot.prototype.setStepProperty = function(gameStage, property, value) {
        var stepObj;

        gameStage = new GameStage(gameStage);

        if ('string' !== typeof property) {
            throw new TypeError('GamePlot.setStepProperty: property must be ' +
                                'string');
        }

        // Get step.
        stepObj = this.getStep(gameStage);

        if (stepObj) {
            stepObj[property] = value;
            // Cache it.
            cacheStepProperty(this, gameStage, property, value);
            return true;
        }

        return false;
    };

    /**
     * ### GamePlot.setStageProperty
     *
     * Sets the value a property in a step object
     *
     * @param {GameStage|string} gameStage The GameStage object,
     *  or its string representation
     * @param {string} property The name of the property
     * @param {mixed} value The new value for the property.
     *
     * @return {bool} TRUE, if property is found and updated, FALSE otherwise.
     *
     * @see GamePlot.cache
     */
    GamePlot.prototype.setStageProperty = function(gameStage, property, value) {
        var stageObj;

        gameStage = new GameStage(gameStage);

        if ('string' !== typeof property) {
            throw new TypeError('GamePlot.setStageProperty: property must be ' +
                                'string');
        }

        // Get stage.
        stageObj = this.getStage(gameStage);

        if (stageObj) {
            stageObj[property] = value;
            return true;
        }

        return false;
    };

    /**
     * ### GamePlot.isReady
     *
     * Returns whether the stager has any content
     *
     * @return {boolean} FALSE if stager is empty, TRUE otherwise
     */
    GamePlot.prototype.isReady = function() {
        return this.stager &&
            (this.stager.sequence.length > 0 ||
             this.stager.generalNextFunction !== null ||
             !J.isEmpty(this.stager.nextFunctions));
    };

    /**
     * ### GamePlot.normalizeGameStage
     *
     * Converts the GameStage fields to numbers
     *
     * Checks if stage and step numbers are within the range
     * of what found in the stager.
     *
     * Works only in simple mode.
     *
     * @param {GameStage|string} gameStage The GameStage object
     *
     * @return {GameStage|null} The normalized GameStage object; NULL on error
     */
    GamePlot.prototype.normalizeGameStage = function(gameStage) {
        var stageNo, stageObj, stepNo, seqIdx, seqObj;
        var gs;

        if (this.isFlexibleMode()) {
            throw new Error('GamePlot.normalizeGameStage: invalid call in ' +
                            'flexible sequence.')
        }

        // If already normalized and in cache, return it.
        if ('string' === typeof gameStage) {
            if (this._normalizedCache[gameStage]) {
                return this._normalizedCache[gameStage];
            }
        }

        gs = new GameStage(gameStage);

        // Find stage number.
        if ('number' === typeof gs.stage) {
            if (gs.stage === 0) return new GameStage();
            stageNo = gs.stage;
        }
        else if ('string' === typeof gs.stage) {
            if (gs.stage ===  GamePlot.GAMEOVER ||
                gs.stage === GamePlot.END_SEQ ||
                gs.stage === GamePlot.NO_SEQ) {

                return null;
            }

            for (seqIdx = 0; seqIdx < this.stager.sequence.length; seqIdx++) {
                if (this.stager.sequence[seqIdx].id === gs.stage) {
                    break;
                }
            }
            stageNo = seqIdx + 1;
        }
        else {
            throw new Error('GamePlot.normalizeGameStage: gameStage.stage ' +
                            'must be number or string: ' +
                            (typeof gs.stage));
        }

        if (stageNo < 1 || stageNo > this.stager.sequence.length) {
            this.node.silly('GamePlot.normalizeGameStage: non-existent ' +
                            'stage: ' + gs.stage);
            return null;
        }

        // Get sequence object.
        seqObj = this.stager.sequence[stageNo - 1];
        if (!seqObj) return null;

        if (seqObj.type === 'gameover') {
            return new GameStage({
                stage: stageNo,
                step:  1,
                round: gs.round
            });
        }

        // Get stage object.
        stageObj = this.stager.stages[seqObj.id];
        if (!stageObj) return null;

        // Find step number.
        if ('number' === typeof gs.step) {
            stepNo = gs.step;
        }
        else if ('string' === typeof gs.step) {
            stepNo = seqObj.steps.indexOf(gs.step) + 1;
        }
        else {
            throw new Error('GamePlot.normalizeGameStage: gameStage.step ' +
                            'must be number or string: ' +
                            (typeof gs.step));
        }

        if (stepNo < 1 || stepNo > stageObj.steps.length) {
            this.node.silly('normalizeGameStage non-existent step: ' +
                           stageObj.id + '.' + gs.step);
            return null;
        }

        // Check round property.
        if ('number' !== typeof gs.round) return null;

        gs = new GameStage({
            stage: stageNo,
            step:  stepNo,
            round: gs.round
        });

        if ('string' === typeof gameStage) {
            this._normalizedCache[gameStage] = gs;
        }

        return gs;
    };

    /**
     * ### GamePlot.isFlexibleMode
     *
     * Returns TRUE if operating in _flexible_ mode
     *
     * In _flexible_ mode the next step to be executed is decided by a
     * a callback function.
     *
     * In standard mode all steps are already inserted in a sequence.
     *
     * @return {boolean} TRUE if flexible mode is on
     */
    GamePlot.prototype.isFlexibleMode = function() {
        return this.stager.sequence.length === 0;
    };

    /**
     * ### GamePlot.getRound
     *
     * Returns the current/remaining/past/total round number in a game stage
     *
     * @param {mixed} gs The game stage of reference
     * @param {string} mod Optional. Modifies the return value.
     *
     *   - 'current': current round number (default)
     *   - 'total': total number of rounds
     *   - 'remaining': number of rounds remaining (excluding current round)
     *   - 'past': number of rounds already past  (excluding current round)
     *
     * @return {number|null} The requested information, or null if
     *   the number of rounds is not known (e.g. if the stage is a loop)
     *
     * @see GamePlot.getSequenceObject
     */
    GamePlot.prototype.getRound = function(gs, mod) {
        var seqObj;
        gs = new GameStage(gs);
        if (gs.stage === 0) return null;

        seqObj = this.getSequenceObject(gs);
        if (!seqObj) return null;

        if (!mod || mod === 'current') return gs.round;
        if (mod === 'past') return gs.round - 1;

        if (mod === 'total') {
            if (seqObj.type === 'repeat') return seqObj.num;
            else if (seqObj.type === 'plain') return 1;
            else return null;
        }
        if (mod === 'remaining') {
            if (seqObj.type === 'repeat') return seqObj.num - gs.round;
            else if (seqObj.type === 'plain') return 1;
            else return null;
        }

        throw new TypeError('GamePlot.getRound: mod must be a known string ' +
                            'or undefined. Found: ' + mod);
    };

    // ## Helper Methods

    /**
     * ### cacheStepProperty
     *
     * Sets the value of a property in the cache
     *
     * Parameters are not checked
     *
     * @param {GamePlot} that The game plot instance
     * @param {GameStage|string} gameStage The GameStage object,
     *  or its string representation
     * @param {string} property The name of the property
     * @param {mixed} value The value of the property
     *
     * @see GamePlot.cache
     *
     * @api private
     */
    function cacheStepProperty(that, gameStage, property, value) {
        if (!that.cache[gameStage]) that.cache[gameStage] = {};
        that.cache[gameStage][property] = value;
    }

    // ## Closure
})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # GameMsgGenerator
 *
 * Copyright(c) 2015 Stefano Balietti
 * MIT Licensed
 *
 * `nodeGame` component rensponsible creating messages
 *
 * Static factory of objects of type `GameMsg`.
 *
 * @see GameMsg
 * @see node.target
 * @see node.action
 */
(function(exports, parent) {

    "use strict";

    // ## Global scope

    exports.GameMsgGenerator = GameMsgGenerator;

    var GameMsg = parent.GameMsg,
    GameStage = parent.GameStage,
    constants = parent.constants;

    /**
     * ## GameMsgGenerator constructor
     *
     * Creates an instance of GameMSgGenerator
     *
     */
    function GameMsgGenerator(node) {
        this.node = node;
    }

    // ## GameMsgGenerator methods

    /**
     * ### GameMsgGenerator.create
     *
     * Primitive for creating a new GameMsg object
     *
     * Decorates an input object with all the missing properties
     * of a full GameMsg object.
     *
     * By default GAMECOMMAND, REDIRECT, PCONNET, PDISCONNECT, PRECONNECT
     * have priority 1, all the other targets have priority 0.
     *
     * @param {object} msg Optional. The init object
     *
     * @return {GameMsg} The full GameMsg object
     *
     * @see GameMsg
     */
    GameMsgGenerator.prototype.create = function(msg) {
        var gameStage, priority, node;
        node = this.node;

        if (msg.stage) {
            gameStage = msg.stage;
        }
        else {
            gameStage = node.game ?
                node.game.getCurrentGameStage() : new GameStage('0.0.0');
        }

        if ('undefined' !== typeof msg.priority) {
            priority = msg.priority;
        }
        else if (msg.target === constants.target.GAMECOMMAND ||
                 msg.target === constants.target.REDIRECT ||
                 msg.target === constants.target.PCONNECT ||
                 msg.target === constants.target.PDISCONNECT ||
                 msg.target === constants.target.PRECONNECT ||
                 msg.target === constants.target.SERVERCOMMAND ||
                 msg.target === constants.target.SETUP) {

            priority = 1;
        }
        else {
            priority = 0;
        }

        return new GameMsg({
            session: 'undefined' !== typeof msg.session ?
                msg.session : node.socket.session,
            stage: gameStage,
            action: msg.action || constants.action.SAY,
            target: msg.target || constants.target.DATA,
            from: node.player ? node.player.id : constants.UNDEFINED_PLAYER,
            to: 'undefined' !== typeof msg.to ? msg.to : 'SERVER',
            text: 'undefined' !== typeof msg.text ? "" + msg.text : null,
            data: 'undefined' !== typeof msg.data ? msg.data : {},
            priority: priority,
            reliable: msg.reliable || 1
        });

    };

    // ## Closure
})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # PushManager
 *
 * Push players to advance to next step, otherwise disconnects them.
 *
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 */
(function(exports, parent) {

    "use strict";

    // ## Global scope
    exports.PushManager = PushManager;

    var GameStage = parent.GameStage;

    var DONE = parent.constants.stageLevels.DONE;
    var PUSH_STEP = parent.constants.gamecommands.push_step;
    var GAMECOMMAND = parent.constants.target.GAMECOMMAND;

    PushManager.offsetWaitTime = 5000;
    PushManager.replyWaitTime = 2000;
    PushManager.checkPushWaitTime = 2000;

    /**
     * ## PushManager constructor
     *
     * Creates a new instance of PushManager
     *
     * @param {NodeGameClient} node A nodegame-client instance
     * @param {object} options Optional. Configuration options
     */
    function PushManager(node, options) {

        /**
         * ### PushManager.node
         *
         * Reference to a nodegame-client instance
         */
        this.node = node;

        /**
         * ### PushManager.timer
         *
         * The timer object that will fire the checking of clients
         *
         * The timer will be created only if needed.
         *
         * @see PushManager.startTimer
         */
        this.timer = null;

        /**
         * ### PushManager.offsetWaitTime
         *
         * Time that is always added to the timer value of
         *
         * @see PushManager.startTimer
         */
        this.offsetWaitTime = PushManager.offsetWaitTime;

        /**
         * ### PushManager.replyWaitTime
         *
         * Time to wait to get a reply from a pushed client
         *
         * @see PushManager.pushGame
         */
        this.replyWaitTime = PushManager.replyWaitTime;

        /**
         * ### PushManager.checkPushWaitTime
         *
         * Time to wait to check if a pushed client updated its state
         *
         * @see PushManager.pushGame
         */
        this.checkPushWaitTime = PushManager.checkPushWaitTime;

        this.init(options);
    }

    /**
     * ### PushManager.init
     *
     * Inits the configuration for the instance
     *
     * @param {object} Optional. Configuration object
     *
     * @see checkAndAssignAllWaitTimes
     */
    PushManager.prototype.init = function(options) {
        options = options || {};
        checkAndAssignAllWaitTimes('init', options, this);
    };

    /**
     * ## PushManager.startTimer
     *
     * Sets a timer for checking if all clients have finished current step
     *
     * The duration of the timer is specified by parameter  conf.offset.
     * (Default this.offsetWaitTime). Other options in configuration
     * parameter are passed to `PushManager.pushGame`, which is called
     * if timer expires.
     *
     * Calling startTimer on a running timer will clear previous one,
     * and create a new one.
     *
     * @param {boolean|object} conf Optional. Configuration object passed
     *    to `pushGame` method.
     *
     * @see PushManager.offsetWaitTime
     * @see PushManager.pushGame
     * @see GameTimer.parseMilliseconds
     */
    PushManager.prototype.startTimer = function(conf) {
        var stage, that, offset;
        var node;

        // Adjust user input.
        if (conf === true || 'undefined' === typeof conf) {
            conf = {};
        }
        else if ('object' !== typeof conf) {
            throw new TypeError('PushManager.startTimer: conf must be ' +
                               'object, TRUE, or undefined. Found: ' + conf);
        }

        node = this.node;

        if (!this.timer) {
            this.timer = node.timer.createTimer({
                name: 'push_clients',
                validity: 'game'
            });
        }
        else {
            this.clearTimer();
        }

        if ('undefined' !== typeof conf.offset) {
            offset = node.timer.parseInput('offset', conf.offset);
        }
        else {
            offset = this.offsetWaitTime;
        }

        // Cloning current stage.
        stage = {
            stage: node.player.stage.stage,
            step: node.player.stage.step,
            round: node.player.stage.round
        };

        node.info('push-manager: starting timer with offset ' + offset);

        that = this;

        // Make sure milliseconds and update are the same.
        this.timer.init({
            milliseconds: offset,
            update: offset,
            timeup: function() { that.pushGame.call(that, stage, conf); },
        });
        this.timer.start();
    };

    /**
     * ## PushManager.clearTimer
     *
     * Clears timer for checking if all clients have finished current step
     *
     * This function is normally called at every new step.
     *
     * @see PushManager.startTimer
     * @see Game.gotoStep
     */
    PushManager.prototype.clearTimer = function() {
        if (this.timer && !this.timer.isStopped()) {
            this.node.silly('push-manager: timer cleared.');
            // console.log('push-manager: timer cleared.');
            this.timer.stop();
        }
    };

    /**
     * ## PushManager.isActive
     *
     * Returns TRUE if timer is running
     */
    PushManager.prototype.isActive = function() {
        return !this.timer.isStopped();
    };

    /**
     * ### PushManager.pushGame
     *
     * Pushes any client that is connected, but not DONE, to step forward
     *
     * It sends a GET message to all clients whose stage level is not
     * marked as DONE (100), and waits for the reply. If the reply does
     * not arrive it will disconnect them. If the reply arrives, it will
     * later check if they manage to step, and if not disconnects them.
     *
     * @param {object} stage The stage to check
     * @param {object} conf Optional. Configuration options.
     *
     * @see checkIfPushWorked
     */
    PushManager.prototype.pushGame = function(stage, conf) {
        var m, node, replyWaitTime, checkPushWaitTime;
        node = this.node;

        node.info('push-manager: checking clients');

        if ('object' === typeof conf) {
            m = 'pushGame';
            replyWaitTime = checkAndAssignWaitTime(m, conf, 'reply', conf);
            checkPushWaitTime = checkAndAssignWaitTime(m, conf, 'check', conf);
        }
        if ('undefined' === typeof replyWaitTime) {
            replyWaitTime = this.replyWaitTime;
        }
        if ('undefined' === typeof checkPushWaitTime) {
            checkPushWaitTime = this.checkPushWaitTime;
        }

        node.game.pl.each(function(p) {

            // A client is not DONE and it is still in the same stage level.
            if (p.stageLevel !== DONE &&
                GameStage.compare(p.stage, stage) === 0) {

                // console.log('push needed: ', p.id);
                node.warn('push-manager: push needed: ' + p.id);
                // Send push.
                node.get(PUSH_STEP,
                         function(value) {
                             checkIfPushWorked(node, p, stage,
                                               checkPushWaitTime);
                         },
                         p.id, {
                             timeout: replyWaitTime,
                             executeOnce: true,
                             target: GAMECOMMAND,
                             timeoutCb: function() {
                                 forceDisconnect(node, p);
                             }
                         });
            }
        });
    };

    // ## Helper methods

    /**
     * ### checkIfPushWorked
     *
     * Checks whether the stage of a client has changed after
     *
     * @param {NodeGameClient} node The node instance used to send msg
     * @param {object} p The player object containing info about id and sid
     * @param {GameStage} stage The stage to check
     * @param {number} milliseconds Optional The number of milliseconds to
     *   wait before checking again the stage of a client. Default 0.
     */
    function checkIfPushWorked(node, p, stage, milliseconds) {

        node.info('push-manager: received reply from ' + p.id);

        setTimeout(function() {
            var pp;
            if (node.game.pl.exist(p.id)) {
                pp = node.game.pl.get(p.id);

                // Client could have moved to next step, or be DONE
                // waiting for a command from server.
                if (GameStage.compare(pp.stage, stage) !== 0 ||
                    pp.stageLevel === DONE) {

                    node.info('push-manager: push worked for ' + p.id);
                }
                else {
                    forceDisconnect(node, pp);
                }
            }
        }, milliseconds || 0);
    }

    /**
     * ### forceDisconnect
     *
     * Disconnects one player by sending a DISCONNECT msg to server
     *
     * @param {NodeGameClient} node The node instance used to send msg
     * @param {object} p The player object containing info about id and sid
     */
    function forceDisconnect(node, p) {
        var msg;
        // No reply to GET, disconnect client.
        node.warn('push-manager: disconnecting ' + p.id);
        // console.log('push-manager: disconnecting: ' + p.id);
        msg = node.msg.create({
            target: 'SERVERCOMMAND',
            text: 'DISCONNECT',
            data: {
                id: p.id,
                sid: p.sid
            }
        });
        node.socket.send(msg);
    }

    /**
     * ### checkAndAssignWaitTime
     *
     * Checks if a valid wait time is found in options object, if so assigns it
     *
     * Option name is first tried as it is, and if not found, 'WaitTime'
     * is appended, and check if performed again.
     *
     * If set, properties must be positive numbers, otherwise an error is
     * thrown.
     *
     * @param {string} method Then name of the method invoking the function
     * @param {object} options Configuration options
     * @param {string} name The name of the option to check and assign.
     *    If the option is not defined, it appends 'WaitTime', and tries again.
     * @param {object} that The instance to which assign the correct value
     *
     * @return {number} The validated number, or undefined if not set
     */
    function checkAndAssignWaitTime(method, options, name, that) {
        var n;
        n = options[name];
        if ('undefined' !== typeof n) {
            name = name + 'WaitTime';
            n = options[name];
        }
        if ('undefined' !== typeof n) {
            if ('number' !== typeof n || n < 0) {
                throw new TypeError('PushManager.' + method + ': options.' +
                                    name + 'must be a positive number. ' +
                                    'Found: ' + n);
            }
            that[name] = n;
            return n;
        }
    }

    /**
     * ### checkAndAssignAllWaitTimes
     *
     * Validates properties 'offset', 'reply', and 'check' of an object
     *
     * @param {string} method Then name of the method invoking the function
     * @param {object} options Configuration options
     * @param {object} that The instance to which assign the correct value
     *
     * @see PushManager.init
     * @see checkAndAssignWaitTime
     */
    function checkAndAssignAllWaitTimes(method, options, that) {
        checkAndAssignWaitTime(method, options, 'offset', that);
        checkAndAssignWaitTime(method, options, 'reply', that);
        checkAndAssignWaitTime(method, options, 'check', that);
    }
})(
    'undefined' !== typeof node ? node : module.exports,
    'undefined' !== typeof node ? node : module.parent.exports
);

/**
 * # SizeManager
 * Copyright(c) 2016 Stefano Balietti
 * MIT Licensed
 *
 * Handles changes in the number of connected players.
 */
(function(exports, parent) {

    "use strict";

    // ## Global scope

    // Exposing SizeManager constructor
    exports.SizeManager = SizeManager;

    var J = parent.JSUS;

    /**
     * ## SizeManager constructor
     *
     * Creates a new instance of SizeManager
     *
     * @param {NodeGameClient} node A valid NodeGameClient object
     */
    function SizeManager(node) {

        /**
         * ### SizeManager.node
         *
         * Reference to a nodegame-client instance
         */
        this.node = node;

        /**
         * ### SizeManager.checkSize
         *
         * Checks if the current number of players is right
         *
         * This function is recreated each step based on the values
         * of properties `min|max|exactPlayers` found in the Stager.
         *
         * It is used by `Game.shouldStep` to determine if we go to the
         * next step.
         *
         * Unlike `SizeManager.changeHandler` this method does not
         * accept parameters nor execute callbacks, just returns TRUE/FALSE.
         *
         * @return {boolean} TRUE if all checks are passed
         *
         * @see Game.shouldStep
         * @see Game.shouldEmitPlaying
         * @see SizeManager.init
         * @see SizeManager.changeHandler
         */
        this.checkSize = function() { return true; };

        /**
         * ### SizeManager.changeHandler
         *
         * Handles changes in the number of players
         *
         * This function is recreated each step based on the values
         * of properties `min|max|exactPlayers` found in the Stager.
         *
         * Unlike `SizeManager.checkSize` this method requires input
         * parameters and executes the appropriate callback functions
         * in case a threshold is hit.
         *
         * @param {string} op The name of the operation:
         *   'pdisconnect', 'pconnect', 'pupdate', 'replace'
         * @param {Player|PlayerList} obj The object causing the update
         *
         * @return {boolean} TRUE, if no player threshold is passed
         *
         * @see SizeManager.min|max|exactPlayers
         * @see SizeManager.min|max|exactCbCalled
         * @see SizeManager.init
         * @see SizeManager.checkSize
         */
        this.changeHandler = function(op, obj) { return true; };

        /**
         * ### SizeManager.minThresold
         *
         * The min-players threshold currently set
         */
        this.minThresold = null;

        /**
         * ### SizeManager.minCb
         *
         * The callback to execute once the min threshold is hit
         */
        this.minCb = null;

        /**
         * ### SizeManager.minCb
         *
         * The callback to execute once the min threshold is restored
         */
        this.minRecoveryCb = null;

        /**
         * ### SizeManager.maxThreshold
         *
         * The max-players threshold currently set
         */
        this.maxThreshold = null;

        /**
         * ### SizeManager.minCbCalled
         *
         * TRUE, if the minimum-player callback has already been called
         *
         * This is reset when the max-condition is satisfied again.
         *
         * @see SizeManager.changeHandler
         */
        this.minCbCalled = false;

        /**
         * ### SizeManager.maxCb
         *
         * The callback to execute once the max threshold is hit
         */
        this.maxCb = null;

        /**
         * ### SizeManager.maxCb
         *
         * The callback to execute once the max threshold is restored
         */
        this.maxRecoveryCb = null;

        /**
         * ### SizeManager.maxCbCalled
         *
         * TRUE, if the maximum-player callback has already been called
         *
         * This is reset when the max-condition is satisfied again.
         *
         * @see SizeManager.changeHandler
         */
        this.maxCbCalled = false;

        /**
         * ### SizeManager.exactThreshold
         *
         * The exact-players threshold currently set
         */
        this.exactThreshold = null;

        /**
         * ### SizeManager.exactCb
         *
         * The callback to execute once the exact threshold is hit
         */
        this.exactCb = null;

        /**
         * ### SizeManager.exactCb
         *
         * The callback to execute once the exact threshold is restored
         */
        this.exactRecoveryCb = null;

        /**
         * ### SizeManager.exactCbCalled
         *
         * TRUE, if the exact-player callback has already been called
         *
         * This is reset when the exact-condition is satisfied again.
         *
         * @see SizeManager.changeHandler
         */
        this.exactCbCalled = false;
    }

    /**
     * ### SizeManager.init
     *
     * Sets all internal references to null
     *
     * @see SizeManager.init
     */
    SizeManager.prototype.clear = function() {
        this.minThreshold = null;
        this.minCb = null;
        this.minRecoveryCb = null;
        this.minCbCalled = false;

        this.maxThreshold = null;
        this.maxCb = null;
        this.maxRecoveryCb = null;
        this.maxCbCalled = false;

        this.exactThreshold = null;
        this.exactCb = null;
        this.exactRecoveryCb = null;
        this.exactCbCalled = false;

        this.changeHandler = function(op, obj) { return true; };
        this.checkSize = function() { return true; };
    };

    /**
     * ### SizeManager.init
     *
     * Evaluates the requirements for the step and store references internally
     *
     * If required, it adds a listener to changes in the size of player list.
     *
     * At the beginning, calls `SizeManager.clear`
     *
     * @param {GameStage} step Optional. The step to evaluate.
     *   Default: node.player.stage
     *
     * @return {boolean} TRUE if a full handler was added
     *
     * @see SizeManager.changeHandlerFull
     * @see SizeManager.clear
     */
    SizeManager.prototype.init = function(step) {
        var node, property, doPlChangeHandler;

        this.clear();

        node = this.node;
        step = step || node.player.stage;
        property = node.game.plot.getProperty(step, 'minPlayers');
        if (property) {
            this.setHandler('min', property);
            doPlChangeHandler = true;
        }

        property = node.game.plot.getProperty(step, 'maxPlayers');
        if (property) {
            this.setHandler('max', property);

            if (this.minThreshold === '*') {
                throw new Error('SizeManager.init: maxPlayers cannot be' +
                                '"*" if minPlayers is "*"');
            }

            if (this.maxThreshold <= this.minThreshold) {
                throw new Error('SizeManager.init: maxPlayers must be ' +
                                'greater than minPlayers: ' +
                                this.maxThreshold + '<=' + this.minThreshold);
            }

            doPlChangeHandler = true;
        }

        property = node.game.plot.getProperty(step, 'exactPlayers');
        if (property) {
            if (doPlChangeHandler) {
                throw new Error('SizeManager.init: exactPlayers ' +
                                'cannot be set if either minPlayers or ' +
                                'maxPlayers is set.');
            }
            this.setHandler('exact', property);
            doPlChangeHandler = true;
        }

        if (doPlChangeHandler) {

            this.changeHandler = this.changeHandlerFull;
            // Maybe this should be a parameter.
            // this.changeHandler('init');
            this.addListeners();

            this.checkSize = this.checkSizeFull;
        }
        else {
            // Set bounds-checking function.
            this.checkSize = function() { return true; };
            this.changeHandler = function() { return true; };
        }

        return doPlChangeHandler;
    };

    /**
     * ### SizeManager.checkSizeFull
     *
     * Implements SizeManager.checkSize
     *
     * @see SizeManager.checkSize
     */
    SizeManager.prototype.checkSizeFull =  function() {
        var nPlayers, limit;
        nPlayers = this.node.game.pl.size();

        // Players should count themselves too.
        if (!this.node.player.admin) nPlayers++;

        limit = this.minThreshold;
        if (limit && limit !== '*' && nPlayers < limit) {
            return false;
        }

        limit = this.maxThreshold;
        if (limit && limit !== '*' && nPlayers > limit) {
            return false;
        }

        limit = this.exacThreshold;
        if (limit && limit !== '*' && nPlayers !== limit) {
            return false;
        }

        return true;
    };

    /**
     * ### SizeManager.changeHandlerFull
     *
     * Implements SizeManager.changeHandler
     *
     * @see SizeManager.changeHandler
     */
    SizeManager.prototype.changeHandlerFull = function(op, player) {
        var threshold, cb, nPlayers;
        var game, res;

        res = true;
        game = this.node.game;
        nPlayers = game.pl.size();
        // Players should count themselves too.
        if (!this.node.player.admin) nPlayers++;

        threshold = this.minThreshold;
        if (threshold) {
            if (op === 'pdisconnect') {
                if (threshold === '*' || nPlayers < threshold) {

                    if (!this.minCbCalled) {
                        this.minCbCalled = true;
                        cb = game.getProperty('onWrongPlayerNum');

                        cb.call(game, 'min', this.minCb, player);
                    }
                    res = false;
                }
            }
            else if (op === 'pconnect') {
                if (this.minCbCalled) {
                    cb = game.getProperty('onCorrectPlayerNum');
                    cb.call(game, 'min', this.minRecoveryCb, player);
                }
                // Must stay outside if.
                this.minCbCalled = false;
            }
        }

        threshold = this.maxThreshold;
        if (threshold) {
            if (op === 'pconnect') {
                if (threshold === '*' || nPlayers > threshold) {

                    if (!this.maxCbCalled) {
                        this.maxCbCalled = true;
                        cb = game.getProperty('onWrongPlayerNum');
                        cb.call(game, 'max', this.maxCb, player);
                    }
                    res = false;
                }
            }
            else if (op === 'pdisconnect') {
                if (this.maxCbCalled) {
                    cb = game.getProperty('onCorrectPlayerNum');
                    cb.call(game, 'max', this.maxRecoveryCb, player);
                }
                // Must stay outside if.
                this.maxCbCalled = false;
            }
        }

        threshold = this.exactThreshold;
        if (threshold) {
            if (nPlayers !== threshold) {
                if (!this.exactCbCalled) {
                    this.exactCbCalled = true;
                    cb = game.getProperty('onWrongPlayerNum');
                    cb.call(game, 'exact', this.exactCb, player);
                }
                res = false;
            }
            else {
                if (this.exactCbCalled) {
                    cb = game.getProperty('onCorrectPlayerNum');
                    cb.call(game, 'exact', this.exactRecoveryCb, player);
                }
                // Must stay outside if.
                this.exactCbCalled = false;
            }
        }

        return res;
    };

    /**
     * ### SizeManager.setHandler
     *
     * Sets the desired handler
     *
     * @param {string} type One of the available types: 'min', 'max', 'exact'
     * @param {number|array} The value/s for the handler
     */
    SizeManager.prototype.setHandler = function(type, values) {
        values = checkMinMaxExactParams(type, values, this.node);
        this[type + 'Threshold'] = values[0];
        this[type + 'Cb'] = values[1];
        this[type + 'RecoveryCb'] = values[2];
    };

    /**
     * ### SizeManager.addListeners
     *
     * Adds listeners to disconnect and connect to the `step` event manager
     *
     * Notice: PRECONNECT is not added and must handled manually.
     *
     * @see SizeManager.removeListeners
     */
    SizeManager.prototype.addListeners = function() {
        var that;
        that = this;
        this.node.events.step.on('in.say.PCONNECT', function(p) {
            that.changeHandler('pconnect', p.data);
        }, 'plManagerCon');
        this.node.events.step.on('in.say.PDISCONNECT', function(p) {
            that.changeHandler('pdisconnect', p.data);
        }, 'plManagerDis');
    };

    /**
     * ### SizeManager.removeListeners
     *
     * Removes the listeners to disconnect and connect
     *
     * Notice: PRECONNECT is not added and must handled manually.
     *
     * @see SizeManager.addListeners
     */
    SizeManager.prototype.removeListeners = function() {
        this.node.events.step.off('in.say.PCONNECT', 'plManagerCon');
        this.node.events.step.off('in.say.PDISCONNECT', 'plManagerDis');
    };

    // ## Helper methods.

   /**
     * ### checkMinMaxExactParams
     *
     * Checks the parameters of min|max|exactPlayers property of a step
     *
     * @param {string} name The name of the parameter: min|max|exact
     * @param {number|array} property The property to check
     * @param {NodeGameClient} node Reference to the node instance
     *
     * @see SizeManager.init
     */
    function checkMinMaxExactParams(name, property, node) {
        var num, cb, recoverCb, newArray;

        if ('number' === typeof property) {
            newArray = true;
            property = [property];
        }
        else if (!J.isArray(property)) {
            throw new TypeError('SizeManager.init: ' + name +
                                'Players property must be number or ' +
                                'non-empty array. Found: ' + property);
        }

        num = property[0];
        cb = property[1] || null;
        recoverCb = property[2] || null;

        if (num === '@') {
            num = node.game.pl.size() || 1;
            // Recreate the array to avoid altering the reference.
            if (!newArray) {
                property = property.slice(0);
                property[0] = num;
            }
        }
        else if (num !== '*' &&
                 ('number' !== typeof num || !isFinite(num) || num < 1)) {

            throw new TypeError('SizeManager.init: ' + name +
                                'Players must be a finite number greater ' +
                                'than 1 or a wildcard (*,@). Found: ' + num);
        }

        if (!cb) {
            property[1] = null;
        }
        else if ('function' !== typeof cb) {

            throw new TypeError('SizeManager.init: ' + name +
                                'Players cb must be ' +
                                'function or undefined. Found: ' + cb);
        }

        if (!recoverCb) {
            property[2] = null;
        }
        else if ('function' !== typeof cb) {

            throw new TypeError('SizeManager.init: ' + name +
                                'Players recoverCb must be ' +
                                'function or undefined. Found: ' + recoverCb);
        }

        return property;
    }


    // ## Closure
})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # Stager stages and steps
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 */
(function(exports, node) {

    var J = node.JSUS;

    // Export Stager.
    var Stager = exports.Stager = {};

    /**
     * ## Block.blockTypes
     *
     * List of available block types
     */
    var blockTypes = {

        // #### BLOCK_DEFAULT
        //
        // The first block automatically added to the stager.
        //
        BLOCK_DEFAULT:           '__default',

        // #### BLOCK_STAGEBLOCK
        //
        // A block that is a collection of stages
        //
        BLOCK_STAGEBLOCK:        '__stageBlock_',

        // #### BLOCK_STAGE
        //
        // A block that contains a stage (possibly contains a step block)
        //
        BLOCK_STAGE:             '__stage',

        // #### BLOCK_STEPBLOCK
        //
        // A block that is a collection of steps
        //
        BLOCK_STEPBLOCK:         '__stepBlock_',

        // #### BLOCK_STEP
        //
        // A block that contains a step.
        //
        BLOCK_STEP:              '__step',

        // BLOCK_ENCLOSING
        //
        // TODO: check . It is suffix using for search and to compose names
        //
        BLOCK_ENCLOSING:         '__enclosing_',

        // #### BLOCK_ENCLOSING_STEPS
        //
        //
        //
        BLOCK_ENCLOSING_STEPS:   '__enclosing_steps',

        // #### BLOCK_ENCLOSING_STAGES
        //
        //
        //
        BLOCK_ENCLOSING_STAGES:  '__enclosing_stages',
    };

    // Add private functions to Stager.
    Stager.blockTypes = blockTypes;
    Stager.checkPositionsParameter = checkPositionsParameter;
    Stager.addStageBlock = addStageBlock;
    Stager.addBlock = addBlock;
    Stager.checkFinalized = checkFinalized;
    Stager.handleStepsArray = handleStepsArray;
    Stager.makeDefaultCb = makeDefaultCb;
    Stager.isDefaultCb = isDefaultCb;
    Stager.isDefaultStep = isDefaultStep;
    Stager.makeDefaultStep = makeDefaultStep;
    Stager.unmakeDefaultStep = unmakeDefaultStep;
    Stager.addStepToBlock = addStepToBlock;

    var BLOCK_DEFAULT     = blockTypes.BLOCK_DEFAULT;
    var BLOCK_STAGEBLOCK  = blockTypes.BLOCK_STAGEBLOCK;
    var BLOCK_STAGE       = blockTypes.BLOCK_STAGE;

    /**
     * #### handleStepsArray
     *
     * Validates the items of a steps array, creates new steps if necessary
     *
     * @param {Stager} that Stager object
     * @param {string} stageId The original stage id
     * @param {array} steps The array of steps to validate
     * @param {string} method The name of the method invoking the method
     */
    function handleStepsArray(that, stageId, steps, method) {
        var i, len;
        i = -1, len = steps.length;
        // Missing steps are added with default callback (if string),
        // or as they are, if object.
        for ( ; ++i < len ; ) {
            if ('object' === typeof steps[i]) {
                // Throw error if step.id is not unique.
                that.addStep(steps[i]);
                // Substitute with its id.
                steps[i] = steps[i].id;
            }
            else if ('string' === typeof steps[i]) {
                if (!that.steps[steps[i]]) {
                    // Create a step with a default cb (will be substituted).
                    // Note: default callback and default step are two
                    // different things.
                    that.addStep({
                        id: steps[i],
                        cb: that.getDefaultCb()
                    });
                }
            }
            else {
                throw new TypeError('Stager.' + method + ': stage ' +
                                    stageId  + ': each item in the steps ' +
                                    ' array must be string or object. Found: ' +
                                    steps[i]);
            }
        }
    }


    /**
     * #### addStageBlock
     *
     * Close last step and stage blocks and add a new stage block
     *
     * @param {Stager} that The stager instance
     * @param {string} id Optional. The id of the stage block
     * @param {string} type The type of the stage block:
     *    -  BLOCK_ENCLOSING_STAGES
     *    -  BLOCK_STAGEBLOCK
     * @param {string|number} The allowed positions for the block
     *
     * @see addBlock
     */
    function addStageBlock(that, id, type, positions) {
        var toClose;
        // When the default block is added, this does not apply yet.
        // It is **not** executed only for the first user block.
        if (that.currentStage !== BLOCK_DEFAULT

            // Adding a stage after a stage block.
            // && that.currentBlockType !== BLOCK_STAGEBLOCK
        ) {

            // TODO: check why if type is BLOCK_STAGEBLOCK it wants only one
            // (or zero?)
            // block closed. It works, but it is unclear why. In this way,
            // it closes the steps from the previous block and leaves open
            // the stage (and stage-block).
            toClose = type === BLOCK_STAGEBLOCK ? 1 : 2;
            that.endBlocks(toClose + that.openStepBlocks);
            that.openStepBlocks = 0;
        }
        // that.currentStage = BLOCK_DEFAULT; // TODO: do we need this line?
        addBlock(that, id, type, positions, BLOCK_STAGE);
    }

    /**
     * #### addBlock
     *
     * Adds a new block of the specified type to the sequence
     *
     * @param {Stager} that The stager instance
     * @param {string} id Optional. The id of the stage block
     * @param {string} type The block type
     * @param {string|number} positions The allowed positions for the block
     * @param {string} currentBlockType The value for `Stager.currentBlockType`
     *    (BLOCK_STAGE or BLOCK_STEP)
     */
    function addBlock(that, id, type, positions, currentBlockType) {
        var block;

        // Set current block type.
        that.currentBlockType = currentBlockType;

        // Create the new block, and add it block arrays.

        block = new node.Block({
            id: id || J.uniqueKey(that.blocksIds, type),
            type: type,
            positions: positions
        });
        that.unfinishedBlocks.push(block);
        that.blocks.push(block);

        // Save block id into the blocks map.
        that.blocksIds[block.id] = (that.blocks.length - 1);
    }

    /**
     * #### checkFinalized
     *
     * Check whether the stager is already finalized, and throws an error if so
     *
     * @param {object} that Reference to Stager object
     * @param {string} method The name of the method calling the validation
     *
     * @api private
     */
    function checkFinalized(that, method) {
        if (that.finalized) {
            throw new Error('Stager.' + method + ': stager has been ' +
                            'already finalized');
        }
    }

    /**
     * #### checkPositionsParameter
     *
     * Check validity of a positions parameter
     *
     * Called by: `stage`, `repeat`, `doLoop`, 'loop`.
     *
     * @param {string|number} stage The positions parameter to validate
     * @param {string} method The name of the method calling the validation
     *
     * @api private
     */
    function checkPositionsParameter(positions, method) {
        var err;
        if ('undefined' === typeof positions) return;
        if ('number' === typeof positions) {
            if (isNaN(positions) ||
                positions < 0 ||
                !isFinite(positions)) {
                err = true;
            }
            else {
                positions += '';
            }
        }

        if (err || 'string' !== typeof positions || positions.trim() === '') {
            throw new TypeError('Stager.' + method + ': positions must ' +
                                'be a non-empty string, a positive finite ' +
                                'number, or undefined. Found: ' + positions);
        }
        return positions;
    }

    /**
     * #### addStepToBlock
     *
     * Adds a step to a block
     *
     * Checks if a step with the same id was already added.
     *
     * @param {object} that Reference to Stager object
     * @param {object} stage The block object
     * @param {string} stepId The id of the step
     * @param {string} stageId The id of the stage the step belongs to
     * @param {string|number} positions Optional. Positions allowed for
     *    step in the block
     *
     * @return {boolean} TRUE if the step is added to the block
     */
    function addStepToBlock(that, block, stepId, stageId, positions) {
        var stepInBlock;

        // Add step, if not already added.
        if (block.hasItem(stepId)) return false;

        stepInBlock = {
            type: stageId,
            item: stepId,
            id: stepId
        };

        if (isDefaultStep(that.steps[stepId])) {
            makeDefaultStep(stepInBlock);
        }
        block.add(stepInBlock, positions);
        return true;
    }

    /**
     * #### makeDefaultCb
     *
     * Flags or create a callback function marked as `default`
     *
     * @param {function} cb Optional. The function to mark. If undefined,
     *   an empty function is used
     *
     * @return {function} A function flagged as `default`
     *
     * @see isDefaultCb
     */
    function makeDefaultCb(cb) {
        if ('undefined' === typeof cb) cb = function() {};
        cb._defaultCb = true;
        return cb;
    }

    /**
     * #### isDefaultCb
     *
     * Returns TRUE if a callback was previously marked as `default`
     *
     * @param {function} cb The function to check
     *
     * @return {boolean} TRUE if function is default callback
     *
     * @see makeDefaultCb
     */
    function isDefaultCb(cb) {
        return cb._defaultCb;
    }

    /**
     * #### makeDefaultStep
     *
     * Flags or create a step object marked as `default`
     *
     * @param {object|string} step The step object to mark. If a string
     *   is passed, a new step object with default cb is created.
     * @ param {function} cb Optional A function to create the step cb
     *
     * @return {object} step the step flagged as `default`
     *
     * @see makeDefaultCb
     * @see isDefaultStep
     */
    function makeDefaultStep(step, cb) {
        if ('string' === typeof step) {
            step = {
                id: step,
                cb: makeDefaultCb(cb)
            };
        }
        step._defaultStep = true;
        return step;
    }

    /**
     * #### unmakeDefaultStep
     *
     * Removes the flag from a step marked as `default`
     *
     * @param {object} step The step object to unmark.
     *
     * @return {object} step the step without the `default` flag
     *
     * @see makeDefaultDefaultStep
     * @see isDefaultStep
     */
    function unmakeDefaultStep(step) {
        if (step._defaultStep) step._defaultStep = null;
        return step;
    }

    /**
     * #### isDefaultStep
     *
     * Returns TRUE if a step object was previously marked as `default`
     *
     * @param {object} step The step object to check
     *
     * @return {boolean} TRUE if step object is default step
     *
     * @see makeDefaultStep
     */
    function isDefaultStep(step) {
        return step._defaultStep;
    }

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # Block
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Blocks contain items that can be sorted in the sequence.
 *
 * Blocks can also contain other blocks as items, in this case all
 * items are sorted recursevely.
 *
 * Each item must contain an id (unique within the block), and a type parameter.
 * Optionally, a `positions` parameter, controlling the positions that the item
 * can take in the sequence, can be be passed along.
 *
 * Items is encapsulated in objects of the type:
 *
 * ```js
 *    { item: item, positions: positions }
 * ```
 * and added to the `unfinishedItems` array.
 *
 * When the finalized method is called, items are sorted according to the
 * `positions` parameter and moved into the items array.
 */
(function(exports, parent) {

    "use strict";

    // ## Global scope
    exports.Block = Block;

    var J = parent.JSUS;

    // Mock stager object. Contains only shared variables at this point.
    // The stager class will be added later.
    var Stager = parent.Stager;

    // Referencing shared entities.
    var isDefaultStep = Stager.isDefaultStep;
    var blockTypes = Stager.blockTypes;
    var BLOCK_ENCLOSING_STEPS    = blockTypes.BLOCK_ENCLOSING_STEPS;


    /**
     * ## Block constructor
     *
     * Creates a new instance of Block
     *
     * @param {object} options Configuration object
     */
    function Block(options) {
        if ('object' !== typeof options) {
            throw new TypeError('Block constructor: options must be object: ' +
                                options);
        }

        if ('string' !== typeof options.type || options.type.trim() === '') {
            throw new TypeError('Block constructor: options.type must ' +
                                'be a non-empty string: ' + options.type);
        }

        if ('string' !== typeof options.id || options.id.trim() === '') {
            throw new TypeError('Block constructor: options.id must ' +
                                'be a non-empty string: ' + options.id);
        }

        // ### Properties

        /**
         * #### Block.type
         *
         * Stage or Step block
         */
        this.type = options.type;

        /**
         * #### Block.id
         *
         * An identifier (name) for the block instance
         */
        this.id = options.id;

        /**
         * #### Block.positions
         *
         * Positions in the enclosing Block that this block can occupy
         */
        this.positions = 'undefined' !== typeof options.positions ?
            options.positions : 'linear';

        /**
         * #### Block.takenPositions
         *
         * Positions within this Block that this are occupied
         */
        this.takenPositions = [];

        /**
         * #### Block.items
         *
         * The sequence of items within this Block
         */
        this.items = [];

        /**
         * #### Block.itemsIds
         *
         * List of the items added to the block so far
         */
        this.itemsIds = {};

        /**
         * #### Block.unfinishedItems
         *
         * Items that have not been assigned a position in this block
         */
        this.unfinishedItems = [];

         /**
         * #### Block.index
         *
         * Index of the current element to be returned by Block.next
         *
         * @see Block.next
         */
        this.index = 0;

        /**
         * #### Block.finalized
         *
         * Flag to indicate whether a block is completed
         */
        this.finalized = false;

        /**
         * #### Block.resetCache
         *
         * Cache object to reset Block after finalization
         */
        this.resetCache = null;

    }

    // ### Methods

    /**
     * #### Block.add
     *
     * Adds an item to a block
     *
     * @param {object} item The item to be added
     * @param {string} positions The positions where item can be added
     *   Setting this parameter to "linear" or undefined adds the
     *   item to the next free n-th position where this is the n-th
     *   call to add.
     */
    Block.prototype.add = function(item, positions) {

        if (this.finalized) {
            throw new Error('Block.add: block already finalized, ' +
                            'cannot add further items');
        }

        if ('string' !== typeof item.id) {
            throw new TypeError('Block.add: block ' + this.id + ': item id ' +
                                'must be string: ' + item.id || 'undefined');
        }
        if ('string' !== typeof item.type) {
            throw new TypeError('Block.add: block ' + this.id +
                                ': item type must be string: ' +
                                item.type || 'undefined');
        }

        if (this.itemsIds[item.id]) {
            throw new TypeError('Block.add: block ' + this.id +
                                ': item was already added to block: ' +
                                item.id);
        }


        // We cannot set the position as a number here,
        // because it might change with future modifications of
        // the block. Only on block.finalize the position is fixed.
        if ('undefined' === typeof positions) {
            positions = 'linear';
        }

        this.unfinishedItems.push({
            item: item,
            positions: positions
        });

        // Save item's id.
        this.itemsIds[item.id] = true;
    };

    /**
     * #### Block.remove
     *
     * Removes an item from a block
     *
     * @param {string} itemId The id of the item to be removed
     *
     * @return {object} The removed item, or undefined if the item
     *    does not exist
     */
    Block.prototype.remove = function(itemId) {
        var i, len;

        if (this.finalized) {
            throw new Error('Block.remove: block already finalized, ' +
                            'cannot remove items.');
        }

        if (!this.hasItem(itemId)) return;

        i = -1, len = this.unfinishedItems.length;
        for ( ; ++i < len ; ) {
            if (this.unfinishedItems[i].item.id === itemId) {
                this.itemsIds[itemId] = null;

                // Delete from cache as well.
                if (this.resetCache &&
                    this.resetCache.unfinishedItems[itemId]) {

                    delete this.resetCache.unfinishedItems[itemId];
                }
                return this.unfinishedItems.splice(i,1);
            }
        }

        throw new Error('Block.remove: item ' + itemId + ' was found in the ' +
                        'in the itemsIds list, but could not be removed ' +
                        'from block ' + this.id);
    };

    /**
     * #### Block.removeAllItems
     *
     * Removes all items from a block
     *
     * @see Block.remove
     */
    Block.prototype.removeAllItems = function() {
        var i, len;

        if (this.finalized) {
            throw new Error('Block.remove: block already finalized, ' +
                            'cannot remove items.');
        }

        i = -1, len = this.unfinishedItems.length;
        for ( ; ++i < len ; ) {
            // Always remove item 0, size is changing.
            this.remove(this.unfinishedItems[0].item.id);
        }

    };

    /**
     * #### Block.hasItem
     *
     * Checks if an item has been previously added to block
     *
     * @param {string} itemId The id of item to check
     *
     * @return {boolean} TRUE, if the item is found
     */
    Block.prototype.hasItem = function(itemId) {
        return !!this.itemsIds[itemId];
    };

    /**
     * #### Block.finalize
     *
     * Processes all unfinished entries, assigns each to a position
     *
     * Sets the finalized flag.
     */
    Block.prototype.finalize = function() {
        var entry, item, positions, i, len, chosenPosition;
        var available;

        if (this.finalized) return;
        if (!this.unfinishedItems.length) {
            this.finalized = true;
            return;
        }

        // Remove default step if it is BLOCK_STEP and further steps were added.
        if (this.isType(BLOCK_ENCLOSING_STEPS) && this.size() > 1) {
            if (isDefaultStep(this.unfinishedItems[0].item)) {
                // Remove the id of the removed item from the lists of ids.
                this.itemsIds[this.unfinishedItems[0].item.id] = null;
                this.unfinishedItems.splice(0,1);
            }
        }

        i = -1, len = this.unfinishedItems.length;
        // Update the positions of other steps as needed.
        for ( ; ++i < len ; ) {
            if (this.unfinishedItems[i].positions === 'linear') {
                this.unfinishedItems[i].positions = i;
            }
        }

        // Creating array of available positions:
        // from 0 to nItems accounting for already taken positions.
        available = J.seq(0, this.size()-1);

        // TODO: this could be done inside the while loop. However, as
        // every iterations also other entries are updated, it requires
        // multiple calls to J.range.
        // Parsing all of the position strings into arrays.
        i = -1, len = this.unfinishedItems.length;
        for ( ; ++i < len ; ) {
            positions = this.unfinishedItems[i].positions;
            this.unfinishedItems[i].positions = J.range(positions, available);
        }


        // Assigning positions.
        while (this.unfinishedItems.length > 0) {
            // Select entry with least possibilities of where to go.
            this.unfinishedItems.sort(sortFunction);
            entry = this.unfinishedItems.pop();
            item = entry.item;
            positions = entry.positions;

            // No valid position specified.
            if (positions.length === 0) {
                throw new Error('Block.finalize: no valid position for ' +
                                'entry ' + item.id + ' in Block ' + this.id);
            }

            // Chose position randomly among possibilities.
            chosenPosition =  positions[J.randomInt(0, positions.length) - 1];
            this.items[chosenPosition] = item;
            this.takenPositions.push(chosenPosition);

            // Adjust possible positions in remaining entries.
            i = -1, len = this.unfinishedItems.length;
            for ( ; ++i < len ; ) {
                J.removeElement(chosenPosition,
                                this.unfinishedItems[i].positions);
            }
        }
        this.finalized = true;
    };

    /**
     * #### Block.next
     *
     * Gets the next item in a hierarchy of Blocks
     *
     * If there is not next item, false is returned.
     * If the next item is another Block, next is called recursively.
     *
     * @return {object|boolean} The the item in hierarchy, or FALSE
     *   if none is found.
     */
    Block.prototype.next = function() {
        var item;
        if (this.index < this.items.length) {
            item = this.items[this.index];
            if (item instanceof Block) {
                item = item.next();
                if (item === false) {
                    this.index++;
                    return this.next();
                }
                else {
                    return item;
                }
            }
            else {
                this.index++;
                return item;
            }
        }
        return false;
    };

    /**
     * #### Block.backup
     *
     * Saves the current state of the block
     *
     * @see Block.restore
     */
    Block.prototype.backup = function() {
        this.resetCache = J.classClone({
            takenPositions: this.takenPositions,
            unfinishedItems: this.unfinishedItems,
            items: this.items,
            itemsIds: this.itemsIds
        }, 3);
    };

    /**
     * #### Block.restore
     *
     * Resets the state of the block to the latest saved state
     *
     * Even if the reset cache for the block is empty, it sets
     * index to 0 and finalized to false.
     *
     * Marks the block as not `finalized`
     *
     * @see Block.finalize
     */
    Block.prototype.restore = function() {
        this.index = 0;
        this.finalized = false;

        if (!this.resetCache) return;
        this.unfinishedItems = this.resetCache.unfinishedItems;
        this.takenPositions = this.resetCache.takenPositions;
        this.items = this.resetCache.items;
        this.itemsIds = this.resetCache.itemsIds;
        this.resetCache = null;
    };

    /**
     * ## Block.size
     *
     * Returns the total number of items inside the block
     *
     * @return {number} The total number of items in the block
     */
    Block.prototype.size = function() {
        return this.items.length + this.unfinishedItems.length;
    };

    /**
     * ## Block.isType | isOfType
     *
     * Returns TRUE if the block is of the specified type
     *
     * @param {string} type The type to check
     *
     * @return {boolean} TRUE if the block is of the specified type
     */
    Block.prototype.isType = Block.prototype.isOfType = function(type) {
        return this.type === type;
    };

    /**
     * ## Block.clone
     *
     * Returns a copy of the block
     *
     * @return {Block} A new instance of block with the same settings and items
     */
    Block.prototype.clone = function() {
        var block;
        block = new Block({
            type: this.type,
            id: this.id
        });

        block.positions = J.clone(this.positions);
        block.takenPositions = J.clone(this.takenPositions);
        block.items = J.clone(this.items);
        block.itemsIds = this.itemsIds;
        block.unfinishedItems = J.clone(this.unfinishedItems);
        block.index = this.index;
        block.finalized = this.finalized;
        block.resetCache = J.clone(this.resetCache);
        return block;
    };

    // ## Helper Functions

    /**
     * #### sortFunction
     *
     * Sorts elements in block by number of available positions
     *
     * Those with fewer positions go last, because then Array.pop is used.
     *
     * @api private
     */
    function sortFunction(left, right) {
        if (left.positions.length <= right.positions.length) return 1;
        return -1;
    }

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # Stager
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Builds and store the game sequence.
 *
 * The game sequence is a sequence of blocks which can be moved around
 * until they are finalized.
 *
 * Blocks are generic containers and can contain steps, stages, and
 * even other blocks.
 *
 * ## Stager Technical Guide
 *
 * ### The Default block.
 *
 * The sequence of blocks always begins with the default block:
 *
 * ```js
 * {
 *     type: '__stageBlock_',
 *     id: '__default',
 *     positions: 'linear',
 *     takenPositions: Array(0),
 *     items: Array(0),
 *     itemsIds: {},
 *     unfinishedItems: [],
 *     index: 0,
 *     finalized: false,
 *     resetCache: null
 *  }
 * ```
 *
 * which will contain all the other blocks. This block is added to both:
 *
 * - `Stager.blocks`, and
 * - `Stager.unfinishedBlocks`.
 *
 *
 * We test now this sequence and how it affects the stager internals.
 *
 * ```js
 * stager.stage('myStage')
 * stager.step('myStep')
 * stager.stage('anotherStage')
 * stager.stageBlock('myStageBlock', 'linear')
 * stager.stage('stageInBlock')
 * stager.stage('stageInBlock2')
 * stager.stepBlock('myStepBlock', 'linear')
 * stager.step('stepInBlock')
 * stager.step('stepInBlock2')
 * stager.stepBlock('anotherStepBlock', 'linear')
 * stager.step('anotherStepInBlock')
 * stager.step('anotherStepInBlock2')
 * stager.stage('stageInBlock3')
 * stager.stageBlock('anotherStageBlock', 'linear')
 * stager.stage('lastStageInBlock')
 * ```
 *
 * ### Adding a first stage
 *
 * If we add a stage with
 *
 * ```js
 * stager.stage('myStage');
 * ```
 *
 * two blocks are added:
 *
 * ```js
 * {
 *     type: '__enclosing_stages',
 *     id: '__enclosing_myStage_1',
 *     positions: 'linear',
 *     ...
 * },
 * { type: '__enclosing_steps',
 *   id: '__enclosing_myStage_steps_1',
 *   positions: 'linear',
 *   ...
 * }
 * ```
 *
 * to both `blocks` and `unfinishedBlocks`.
 *
 * ### Adding a first step inside the stage
 *
 * If we add a step with
 *
 * ```js
 * stager.step('myStep');
 * ```
 *
 * no new blocks are added, but one item is added inside the `unfinishedItems`
 * array of the last open block ('__enclosing_myStage_steps_1').
 *
 * Note! When the user adds the first step to a stage, it is actually the second
 * item in the `unfinishedItems` array. The first one the default step named
 * after the name of the stage. This default item will be removed upon
 * finalizing the stage (if there are other steps in the stage)
 *
 * Any other step added inside the stage will add an item in the
 * `unfinishedItems` array.
 *
 *
 * ### Adding a second stage
 *
 * If we add another stage with
 *
 * ```js
 * stager.stage('anotherStage');
 * ```
 *
 * two blocks are added to the `blocks` array:
 *
 * ```js
 * {
 *    type: '__enclosing_stages',
 *    id: '__enclosing_anotherStage_2',
 *    positions: 'linear',
 *    ...
 * },
 * {
 *   type: '__enclosing_steps',
 *   id: '__enclosing_anotherStage_steps_2',
 *   positions: 'linear',
 *   ...
 * }
 * ```
 *
 * The last two blocks in the `unfinishedBlocks` array removed, and two new
 * ones for the new stage are added.
 *
 *
 * ### Adding a first stage block
 *
 * If we add a stage block with:
 *
 * ```js
 * stager.stageBlock('myStageBlock', 'linear');
 * ```
 *
 * one block is added to the `blocks` array:
 *
 * ```js
 * {
 * type: '__stageBlock_',
 * id: 'First StageBlock',
 * positions: 'linear',
 * ...
 * }
 * ```
 *
 * The last block in the `unfinishedBlocks` array is removed (for the steps
 * of the previous stage), and a new one for the new stage block is added
 * No enclosing stages and steps blocks added yet.
 *
 *
 * ### Adding one stage within a stage block
 *
 * If we add a stage in the block with:
 *
 * ```js
 * stager.stage('stageInBlock');
 * ```
 *
 * two blocks are added to the `blocks` array:
 *
 * ```js
 {
     type: '__enclosing_stages',
     id: '__enclosing_stageInBlock_3',
     positions: 'linear',
     ...
 },
 {
    type: '__enclosing_steps',
    id: '__enclosing_stageInBlock_steps_3',
    positions: 'linear',
    ...
 }
 * ```
 *
 * to both `blocks` and `unfinishedBlocks`. The two last blocks from
 * `unfinishedBlocks` are removed before (the stage-block enclosing this stage
 * and the stage from previous block). ??? TODO CHECK whether this makes sense.
 *
 * Adding another stage within the stage block will behave the same way,
 * will remove the current last two blocks from the `unfinishedBlocks` array
 * and replaced with two blocks for the new stage.
 *
 *
 * ### Adding a step block inside a stage
 *
 * If we add a step block inside a stage with:
 *
 * ```js
 *     stager.stepBlock('myStepBlock', 'linear');
 * ```
 *
 * Adds a new block:
 *
 * ```js
 * {
 *     type: '__stepBlock_',
 *     id: 'myStepBlock',
 *     positions: 'linear',
 *     ...
 * }
 * ```
 *
 * to both `blocks` and `unfinishedBlocks`. No block is removed from
 * the `unfinishedBlocks` array.
 *
 *
 * ### Adding a step inside the step block
 *
 *  If we add a step inside the step block with:
 *
 * ```js
 *     stager.step('stepInBlock');
 * ```
 *
 * no new blocks are added, but one item is added inside the `unfinishedItems`
 * array of the last open block ('myStepBlock').
 *
 * ```js
 * {
 *    type: 'stageInBlock2',
 *    item: 'stepInBlock',
 *    id: 'stepInBlock'
 * }
 * ```
 *
 * Further steps in the same step block will add new items here.
 *
 *
 * ### Adding another step block inside a stage
 *
 * If we add an additional step block inside a stage with:
 *
 * ```js
 *     stager.stepBlock('anotherStepBlock', 'linear');
 * ```
 *
 * Adds a new block:
 *
 * ```js
 * {
 *     type: '__stepBlock_',
 *     id: 'anotherStepBlock',
 *     positions: 'linear',
 *     ...
 * }
 * ```
 *
 * to both `blocks` and `unfinishedBlocks`. No block is removed from
 * the `unfinishedBlocks` array.
 *
 * ### Adding another stage after a step block
 *
 * If we add another stage with
 *
 * ```js
 * stager.stage('stageInBlock3');
 * ```
 *
 * two blocks are added to the `blocks` array:
 *
 * ```js
 * {
 *    type: '__enclosing_stages',
 *    id: '__enclosing_stageInBlock3_6',
 *    positions: 'linear',
 *    ...
 * },
 * {
 *   type: '__enclosing_steps',
 *   id: '__enclosing_stageInBlock3_steps_6',
 *   positions: 'linear',
 *   ...
 * }
 * ```
 *
 * The last two blocks in the `unfinishedBlocks` array plus all step blocks
 * (in total 4 blocks) are removed, and two new ones for the new
 * stage are added.
 *
 *
 * ### Adding a second stage block
 *
 * If we add a second stage block with:
 *
 * ```js
 * stager.stageBlock('anotherStageBlock', 'linear');
 * ```
 *
 * one block is added to the `blocks` array:
 *
 * ```js
 * {
 * type: '__stageBlock_',
 * id: 'anotherStageBlock',
 * positions: 'linear',
 * ...
 * }
 * ```
 *
 * The last block in the `unfinishedBlocks` array is removed (for the steps
 * of the previous stage), and a new one for the new stage block is added
 * No enclosing stages and steps blocks added yet.
 *
 *
 * ### Adding one stage within the second stage block
 *
 * If we add a stage in the block with:
 *
 * ```js
 * stager.stage('stageInBlock');
 * ```
 *
 * two blocks are added to the `blocks` array:
 *
 * ```js
 {
     type: '__enclosing_stages',
     id: '__enclosing_stageInBlock_3',
     positions: 'linear',
     ...
 },
 {
    type: '__enclosing_steps',
    id: '__enclosing_stageInBlock_steps_3',
    positions: 'linear',
    ...
 }
 * ```
 *
 * to both `blocks` and `unfinishedBlocks`. The two last blocks from
 * `unfinishedBlocks` are removed before (the stage-block enclosing this stage
 * and the stage from previous block). ??? TODO CHECK whether this makes sense.
 *
 * Adding another stage within the stage block will behave the same way,
 * will remove the current last two blocks from the `unfinishedBlocks` array
 * and replaced with two blocks for the new stage.
 *
 *
 */
(function(exports, parent) {

    "use strict";

    // ## Global scope

    var J = parent.JSUS;

    // What is in the Stager obj at this point.
    var tmpStager = parent.Stager
    // Add it to the Stager class.
    J.mixin(Stager, tmpStager);
    // Export the Stager class.
    exports.Stager = Stager;

    // Referencing shared entities.
    var blockTypes = Stager.blockTypes;
    var isDefaultStep = Stager.isDefaultStep;

    // ## Static Methods

    /**
     * #### Stager.defaultCallback
     *
     * Default callback added to steps when none is specified
     *
     * @see Stager.setDefaultCallback
     * @see Stager.getDefaultCallback
     */
    Stager.defaultCallback = function() {
        this.node.log(this.getCurrentStepObj().id);
    };

    // Flag it as `default`.
    Stager.makeDefaultCb(Stager.defaultCallback);

    /**
     * ## Stager constructor
     *
     * Creates a new instance of Stager
     *
     * @param {object} stateObj Optional. State to initialize the new
     *   Stager object.
     *
     * @see Stager.setState
     */
    function Stager(stateObj) {

        // ## Properties

        /**
        * #### Stager.sequence
        *
        * Sequence block container
        *
        * Stores the game plan in 'simple mode'.
        *
        * @see Stager.gameover
        * @see Stager.next
        * @see Stager.repeat
        * @see Stager.loop
        * @see Stager.doLoop
        */
        this.sequence = [];

        /**
         * #### Stager.stages
         *
         * Maps stage ids to stage objects
         *
         * Each stage object contains an array of steps referencing an object
         * in `Stager.steps`.
         *
         * Format:
         *
         * ```js
         * {
         *     oneStage:  { id: 'oneStage', steps: [ { ...  } },
         *     anotherStage: { id: 'anotherStage', steps: [ { ... } ] }
         * }
         * ```
         *
         * Stage aliases are stored the same way, with a reference to
         * the original stage object as the value.
         *
         * @see Stager.steps
         * @see Stager.addStage
         */
        this.stages = {};

        /**
         * #### Stager.steps
         *
         * Maps step ids to step objects
         *
         * Format:
         *
         * ```js
         * {
         *     oneStep:  { id: 'oneStep', cb: function() { ... } },
         *     anotherStep: { id: 'anotherStep', cb: function() { ... } }
         * }
         * ```
         *
         * @see Stager.addStep
         */
        this.steps = {};

        /**
         * #### Stager.blocks
         *
         * Array of blocks in the order they were added to the stager
         */
        this.blocks = [];

        /**
         * #### Stager.blocksIds
         *
         * Map block-id to block-position in the blocks array
         *
         * @see blocks
         */
        this.blocksIds = {};

        /**
         * #### Stager.unfinishedBlocks
         *
         * List of all Blocks stager might still modify
         */
        this.unfinishedBlocks = [];

        /**
         * #### Stager.openStepBlocks
         *
         * Number of step blocks that need to be closed when the stage is closed
         *
         * @see addStageBlock
         */
        this.openStepBlocks = 0;

        /**
         * #### Stager.currentStage
         *
         * Name of the current stage in the blocks' hierarchy
         */
        this.currentStage = blockTypes.BLOCK_DEFAULT;

        /**
         * #### Stager.currentBlockType
         *
         * The type of block tharwas added last
         *
         * @see blockTypes
         */
        this.currentBlockType = blockTypes.BLOCK_DEFAULT;

        /**
         * #### Stager.generalNextFunction
         *
         * General next-stage decider function
         *
         * Returns the id of the next game step.
         * Available only when nodegame is executed in _flexible_ mode.
         *
         * @see Stager.registerGeneralNext
         */
        this.generalNextFunction = null;

        /**
         * #### Stager.nextFunctions
         *
         * Per-stage next-stage decider function
         *
         * key: stage ID,  value: callback function
         *
         * Stores functions to be called to yield the id of the next
         * game stage for a specific previous stage.
         *
         * @see Stager.registerNext
         */
        this.nextFunctions = {};

        /**
         * #### Stager.defaultStepRule
         *
         * Default step-rule function
         *
         * This function decides whether it is possible to proceed to
         * the next step/stage. If a step/stage object defines a
         * `steprule` property, then that function is used instead.
         *
         * @see Stager.getDefaultStepRule
         * @see GamePlot.getStepRule
         */
        this.setDefaultStepRule();

        /**
         * #### Stager.defaultGlobals
         *
         * Defaults of global variables
         *
         * This map holds the default values of global variables. These
         * values are overridable by more specific version in step and
         * stage objects.
         *
         * @see Stager.setDefaultGlobals
         * @see GamePlot.getGlobal
         */
        this.defaultGlobals = {};

        /**
         * #### Stager.defaultProperties
         *
         * Defaults of properties
         *
         * This map holds the default values of properties. These values
         * are overridable by more specific version in step and stage
         * objects.
         *
         * @see Stager.setDefaultProperties
         * @see GamePlot.getProperty
         */
        this.defaultProperties = {};

        /**
         * #### Stager.onInit
         *
         * Initialization function
         *
         * This function is called as soon as the game is instantiated,
         * i.e. at stage 0.0.0.
         *
         * Event listeners defined here stay valid throughout the whole
         * game, unlike event listeners defined inside a function of the
         * gamePlot, which are valid only within the specific function.
         */
        this.onInit = null;

        /**
         * #### Stager.onGameover
         *
         * Cleaning up function
         *
         * This function is called after the last stage of the gamePlot
         * is terminated.
         */
        this.onGameover = null;


        /**
         * #### Stager.finalized
         *
         * Flag indicating if the hierarchy of has been set
         *
         * Indicates if the hierarchy of stages and steps has been set.
         */
        this.finalized = false;



        /**
         * #### Stager.toSkip
         *
         * List of stages and steps to skip when building the sequence
         *
         * Skipped steps are stored as "stageId.stepId".
         *
         * If a stage/step is unskipped, its entry is set to null.
         *
         * @see Stager.skip
         * @see Stager.unskip
         */
        this.toSkip = {
            stages: {},
            steps: {}
        };

        /**
         * #### Stager.defaultCallback
         *
         * Default callback assigned to a step if none is provided
         */
        this.defaultCallback = Stager.defaultCallback;

        /**
         * #### Stager.cacheReset
         *
         * Cache used to reset the state of the stager after finalization
         */
        this.cacheReset = {
            unfinishedBlocks: []
        };

        /**
         * #### Stager.log
         *
         * Default standard output. Override to redirect.
         */
        this.log = console.log;

        // Set the state if one is passed.
        if (stateObj) {
            if ('object' !== typeof stateObj) {
                throw new TypeError('Stager: stateObj must be object. ' +
                'Found: ' + stateObj);
            }
            this.setState(stateObj);
        }
        else {
            // Add first block.
            this.stageBlock(blockTypes.BLOCK_DEFAULT, 'linear');
        }
    }

    // ## Methods

    // ### Clear, init, finalize, reset.

    /**
     * #### Stager.clear
     *
     * Clears the state of the stager
     *
     * @return {Stager} this object
     */
    Stager.prototype.clear = function() {
        this.steps = {};
        this.stages = {};
        this.sequence = [];
        this.openStepBlocks = 0;
        this.generalNextFunction = null;
        this.nextFunctions = {};
        this.setDefaultStepRule();
        this.defaultGlobals = {};
        this.defaultProperties = {};
        this.onInit = null;
        this.onGameover = null;
        this.blocks = [];
        this.blocksIds = {};
        this.unfinishedBlocks = [];
        this.finalized = false;
        this.currentStage = blockTypes.BLOCK_DEFAULT;
        this.currentBlockType = blockTypes.BLOCK_DEFAULT;
        this.toSkip = { stages: {}, steps: {} };
        this.defaultCallback = Stager.defaultCallback;
        this.cacheReset = { unfinishedBlocks: [] };
        return this;
    };

    /**
     * #### Stager.init
     *
     * Clears the state of the stager and adds a default block
     *
     * @return {Stager} this object
     *
     * @see Stager.clear
     */
    Stager.prototype.init = function() {
        this.clear();
        this.stageBlock(blockTypes.BLOCK_DEFAULT, 'linear');
        return this;
    };

    /**
     * #### Stager.finalize
     *
     * Builds stage and step sequence from the blocks' hieararchy
     *
     * Stages and steps are excluded from the sequence if they were marked
     * as _toSkip_.
     *
     * Steps are excluded from the sequence if they were added as
     * _default step_, but then other steps have been added to the same stage.
     *
     * @see Stager.reset
     */
    Stager.prototype.finalize = function() {
        var currentItem, stageId, stepId;
        var outermostBlock, blockIndex;
        var i, len, seqItem;

        // Already finalized.
        if (this.finalized) return;

        // Nothing to do, finalize called too early.
        if (!this.blocks.length) return;

        // Cache the ids of unfinishedBlocks for future calls to .reset.
        i = -1, len = this.unfinishedBlocks.length;
        for ( ; ++i < len ; ) {
            this.cacheReset.unfinishedBlocks.push(this.unfinishedBlocks[i].id);
        }

        // Need to backup all blocks before calling endAllBlocks().
        for (blockIndex = 0; blockIndex < this.blocks.length; ++blockIndex) {
            this.blocks[blockIndex].backup();
        }


        // Closes unclosed blocks.
        this.endAllBlocks();

        // Fixes the position of unfixed elements inside each block.
        for (blockIndex = 0; blockIndex < this.blocks.length; ++blockIndex) {
            this.blocks[blockIndex].finalize();
        }

        // Take outermost block and start building sequence.
        outermostBlock = this.blocks[0];
        currentItem = outermostBlock.next();
        while (currentItem) {
            if (currentItem.type === blockTypes.BLOCK_STAGE) {
                stageId = currentItem.item.id;
                // Add it to sequence if it was
                // not marked as `toSkip`, or it is a gameover stage.
                if (currentItem.item.type === 'gameover' ||
                    !this.isSkipped(stageId)) {

                    seqItem = J.clone(currentItem.item);
                    seqItem.steps = [];
                    this.sequence.push(seqItem);
                }
            }
            else {
                // It is a step, currentItem.type = stage id (TODO: change).
                stageId = currentItem.type;
                stepId = currentItem.item;

                // 1 - Step was marked as `toSkip`.
                if (!this.isSkipped(stageId, stepId) &&

                    // 2 - Step was a default step,
                    //     but other steps have been added.
                    (!isDefaultStep(this.steps[stepId]) ||
                     this.stages[stageId].steps.length === 1)) {

                    // Ok, add the step to the sequence (must look up stage).
                    i = -1, len = this.sequence.length;
                    for ( ; ++i < len ; ) {
                        if (this.sequence[i].id === stageId) {
                            this.sequence[i].steps.push(stepId);
                            break;
                        }
                    }
                }
            }
            currentItem = outermostBlock.next();
        }
        this.finalized = true;
    };

    /**
     * #### Stager.reset
     *
     * Undoes a previous call to `finalize`
     *
     * Allows to call `Stager.finalize` again to build a potentially
     * different sequence from the Block hierarchy.
     *
     * @see Stager.finalize
     * @see Stager.cacheReset
     */
    Stager.prototype.reset = function() {
        var blockIdx, i, len;

        if (!this.finalized) return this;

        // Restore unfinishedBlocks, if any.
        len = this.cacheReset.unfinishedBlocks.length;
        if (len) {
            // Copy by reference cached blocks.
            i = -1;
            for ( ; ++i < len ; ) {
                blockIdx = this.blocksIds[this.cacheReset.unfinishedBlocks[i]];
                this.unfinishedBlocks.push(this.blocks[blockIdx]);
            }
            this.cacheReset = { unfinishedBlocks: []};
        }
        // End restore unfinishedBlocks.

        // Call restore on individual blocks.
        for (blockIdx = 0; blockIdx < this.blocks.length; ++blockIdx) {
            this.blocks[blockIdx].restore();
        }

        this.sequence = [];
        this.finalized = false;
    };

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # Stager stages and steps
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 */
(function(exports, node) {

    var J      = node.JSUS;
    var Stager = node.Stager;

    // Get reference to shared entities in Stager.
    var checkPositionsParameter = Stager.checkPositionsParameter;
    var addStageBlock           = Stager.addStageBlock;
    var addBlock                = Stager.addBlock;
    var checkFinalized          = Stager.checkFinalized;
    var handleStepsArray        = Stager.handleStepsArray;
    var makeDefaultStep         = Stager.makeDefaultStep;
    var addStepToBlock          = Stager.addStepToBlock;

    var blockTypes              = Stager.blockTypes;
    var BLOCK_STAGE             = blockTypes.BLOCK_STAGE;
    var BLOCK_STEPBLOCK         = blockTypes.BLOCK_STEPBLOCK;
    var BLOCK_STEP              = blockTypes.BLOCK_STEP;

    var BLOCK_ENCLOSING         = blockTypes.BLOCK_ENCLOSING;
    var BLOCK_ENCLOSING_STEPS   = blockTypes.BLOCK_ENCLOSING_STEPS;
    var BLOCK_ENCLOSING_STAGES  = blockTypes.BLOCK_ENCLOSING_STAGES;

    /**
     * #### Stager.addStep | createStep
     *
     * Adds a new step
     *
     * Registers a new game step object. Must have the following fields:
     *
     * - id (string): The step's name
     * - cb (function): The step's callback function
     *
     * @param {object} step A valid step object. Shallowly copied.
     */
    Stager.prototype.createStep = Stager.prototype.addStep = function(step) {
        checkStepValidity(step, 'addStep');

        if (this.steps.hasOwnProperty(step.id)) {
            throw new Error('Stager.addStep: step "' + step.id + '" already ' +
                            'existing, use extendStep to modify it');
        }
        this.steps[step.id] = step;
    };

    /**
     * #### Stager.addStage | createStage
     *
     * Adds a new stage
     *
     * Registers a new game stage object. Must have an id field:
     *
     * - id (string): The stage's name
     *
     * and either of the two following fields:
     *
     * - steps (array of strings|objects): The names of the steps belonging
     *     to this stage, or the steps objects to define them. In the latter
     *     case steps with the same id must not have been defined before.
     *
     * - cb (function): The callback function. If this field is used,
     *     then a step with the same name as the stage will be created,
     *     containing all the properties. The stage will be an empty
     *     container referencing
     *
     * @param {object} stage A valid stage or step object. Shallowly
     *    copied.
     *
     * @see checkStageValidity
     */
    Stager.prototype.createStage = Stager.prototype.addStage = function(stage) {
        var id;

        checkStageValidity(stage, 'addStage');

        id = stage.id;

        if (this.stages.hasOwnProperty(id)) {
            throw new Error('Stager.addStage: stage "' + id + '" already ' +
                            'existing, use extendStage to modify it');
        }

        // The stage contains only 1 step inside given through the callback
        // function. A step will be created with same id and callback.
        if (stage.cb) {
            this.addStep({
                id: id,
                cb: stage.cb
            });
            delete stage.cb;
            stage.steps = [ id ];
        }
        else {
            // Process every step in the array. Steps array is modified.
            handleStepsArray(this, id, stage.steps, 'addStage');
        }
        this.stages[id] = stage;
    };

    /**
     * #### Stager.cloneStep
     *
     * Clones a stage and assigns a new id to it
     *
     * @param {string} stepId The name of the stage to clone
     * @param {string} newStepId The new unique id to assign to the clone
     *
     * @return {object} step Reference to the cloned step
     *
     * @see Stager.addStep
     */
    Stager.prototype.cloneStep = function(stepId, newStepId) {
        var step;
        if ('string' !== typeof stepId) {
            throw new TypeError('Stager.cloneStep: stepId must be string. ' +
                               'Found: ' + stepId);
        }
        if ('string' !== typeof newStepId) {
            throw new TypeError('Stager.cloneStep: newStepId must be ' +
                                'string. Found: ' + newStepId);
        }
        if (this.steps[newStepId]) {
            throw new Error('Stager.cloneStep: newStepId already taken: ' +
                            newStepId);
        }
        step = this.steps[stepId];
        if (!step) {
            throw new Error('Stager.cloneStep: step not found: ' + stepId);
        }
        step = J.clone(step);
        step.id = newStepId;
        this.addStep(step);
        return step;
    };

    /**
     * #### Stager.cloneStage
     *
     * Clones a stage and assigns a new id to it
     *
     * @param {string} stageId The id of the stage to clone
     * @param {string} newStageId The new unique id to assign to the clone
     *
     * @return {object} stage Reference to the cloned stage
     *
     * @see Stager.addStage
     */
    Stager.prototype.cloneStage = function(stageId, newStageId) {
        var stage;
        if ('string' !== typeof stageId) {
            throw new TypeError('Stager.cloneStage: stageId must be string.' +
                               'Found: ' + stageId);
        }
        if ('string' !== typeof newStageId) {
            throw new TypeError('Stager.cloneStage: newStageId must ' +
                                'be string. Found: ' + newStageId);
        }
        if (this.stages[newStageId]) {
            throw new Error('Stager.cloneStage: newStageId already taken: ' +
                            newStageId + '.');
        }
        stage = this.stages[stageId];
        if (!stage) {
            throw new Error('Stager.cloneStage: stage not found: ' + stageId);
        }
        stage = J.clone(stage);
        stage.id = newStageId;
        this.addStage(stage);
        return stage;
    };

    /**
     * #### Stager.step
     *
     * Adds a step to the current Block.
     *
     * @param {string|object} stage A valid step object or the stepId string.
     * @param {string} positions Optional. Positions within the
     *    enclosing Block that this step can occupy.
     *
     * @return {Stager} Reference to this instance for method chaining
     *
     * @see Stager.addStep
     */
    Stager.prototype.step = function(step, positions) {
        var id, curBlock;

        curBlock = this.getCurrentBlock();
        if (!curBlock.isType(BLOCK_ENCLOSING_STEPS) &&
            !curBlock.isType(BLOCK_STEPBLOCK)) {

            throw new Error('Stager.step: step "' +  step + '" cannot be ' +
                            'added here. Have you add at least one stage?');
        }

        checkFinalized(this, 'step');
        id = handleStepParameter(this, step, 'step');
        positions = checkPositionsParameter(positions, 'step');

        addStepToBlock(this, curBlock, id, this.currentStage, positions);

        this.stages[this.currentStage].steps.push(id);

        return this;
    };

    /**
     * #### Stager.next | stage
     *
     * Adds a stage block to sequence
     *
     * The `id` parameter must have the form 'stageID' or 'stageID AS alias'.
     * stageID must be a valid stage and it (or alias if given) must be
     * unique in the sequence.
     *
     * @param {string|object} id A stage name with optional alias
     *   or a stage object.
     * @param {string} positions Optional. Allowed positions for the stage
     *
     * @return {Stager} Reference to this instance for method chaining
     *
     * @see Stager.addStage
     */
    Stager.prototype.stage = Stager.prototype.next =
        function(stage, positions) {
            var stageName;

            checkFinalized(this, 'next');
            stageName = handleStageParameter(this, stage, 'next');
            positions = checkPositionsParameter(positions, 'next');

            addStageToCurrentBlock(this, {
                type: 'plain',
                id: stageName
            }, positions);

            // Must be done after addStageToCurrentBlock.
            addStepsToCurrentBlock(this, this.stages[stageName].steps);
            return this;
        };

    /**
     * #### Stager.repeat | repeatStage
     *
     * Adds repeated stage block to sequence
     *
     * @param {string|object} stage A stage name with optional alias
     *   or a stage object.
     * @param {string} positions Optional. Allowed positions for the stage
     *
     * @return {Stager} Reference to this instance for method chaining
     *
     * @see Stager.addStage
     * @see Stager.next
     */
    Stager.prototype.repeatStage = Stager.prototype.repeat =
        function(stage, nRepeats, positions) {
            var stageName;

            checkFinalized(this, 'repeat');

            stageName = handleStageParameter(this, stage, 'next');

            if ('number' !== typeof nRepeats ||
                isNaN(nRepeats) ||
                nRepeats <= 0) {

                throw new Error('Stager.repeat: nRepeats must be a positive ' +
                                'number. Found: ' + nRepeats);
            }

            positions = checkPositionsParameter(positions, 'repeat');

            addStageToCurrentBlock(this, {
                type: 'repeat',
                id: stageName,
                num: parseInt(nRepeats, 10)
            }, positions);

            // Must be done after addStageToCurrentBlock is called.
            addStepsToCurrentBlock(this, this.stages[stageName].steps);
            return this;
        };

    /**
     * #### Stager.loop | loopStage
     *
     * Adds looped stage block to sequence
     *
     * The given stage will be repeated as long as the `func` callback
     * returns TRUE. If it returns FALSE on the first time, the stage is
     * never executed.
     *
     * @param {string|object} stage A stage name with optional alias
     *   or a stage object.
     * @param {function} loopFunc Callback returning TRUE for
     *   repetition.
     *
     * @return {Stager} Reference to this instance for method chaining
     *
     * @see Stager.addStage
     * @see Stager.next
     * @see Stager.doLoop
     */
    Stager.prototype.loopStage = Stager.prototype.loop =
        function(stage, loopFunc, positions) {

            return addLoop(this, 'loop', stage, loopFunc, positions);
        };

    /**
     * #### Stager.doLoop | doLoopStage
     *
     * Adds alternatively looped stage block to sequence
     *
     * The given stage will be repeated once plus as many times as the
     * `func` callback returns TRUE.
     *
     * @param {string|object} stage A stage name with optional alias
     *   or a stage object.
     * @param {function} loopFunc Optional. Callback returning TRUE for
     *   repetition.
     *
     * @return {Stager} Reference to this instance for method chaining
     *
     * @see Stager.addStage
     * @see Stager.next
     * @see Stager.loop
     */
    Stager.prototype.doLoopStage = Stager.prototype.doLoop =
        function(stage, loopFunc, positions) {

            return addLoop(this, 'doLoop', stage, loopFunc, positions);
        };

    /**
     * #### Stager.gameover
     *
     * Adds gameover block to sequence
     *
     * @return {Stager} this object
     */
    Stager.prototype.gameover = function() {
        addStageToCurrentBlock(this, {
            id: 'gameover',
            type: 'gameover'
        });
        return this;
    };

    // ## Private Methods

    /**
     * #### addLoop
     *
     * Handles adding a looped stage (doLoop or loop)
     *
     * @param {object} that Reference to Stager object
     * @param {string} type The type of loop (doLoop or loop)
     * @param {string|object} stage The stage to loop
     * @param {function} loopFunc The function checking the
     * @param {string} positions Optional. Positions within the
     *      enclosing Block that this block can occupy.
     *
     * @return {Stager|null} this object on success, NULL on error
     *
     * @see Stager.loop
     * @see Stager.doLoop
     *
     * @api private
     */
    function addLoop(that, type, stage, loopFunc, positions) {
        var stageName;

        checkFinalized(that, type);

        stageName = handleStageParameter(that, stage, type);

        if ('function' !== typeof loopFunc) {
            throw new TypeError('Stager.' + type + ': loopFunc must be ' +
                                'function. Found: ' + loopFunc);
        }

        positions = checkPositionsParameter(positions, type);

        addStageToCurrentBlock(that, {
            type: type,
            id: stageName,
            cb: loopFunc
        }, positions);

        // Must be done after addStageToCurrentBlock is called.
        addStepsToCurrentBlock(that, that.stages[stageName].steps);
        return that;
    }

    /**
     * #### addStageToCurrentBlock
     *
     * Performs several meta operations necessary to add a stage block
     *
     * Operations:
     *
     *  - Ends any unclosed blocks.
     *  - Begin a new enclosing block.
     *  - Adds a stage block.
     *  - Adds a steps block.
     *
     * @param {Stager} that Stager object
     * @param {object} stage The stage to add containing its type
     * @param {string} positions Optional. The allowed positions for the stage
     *
     * @api private
     */
    function addStageToCurrentBlock(that, stage, positions) {
        var name, curBlock, rndName;
        name = stage.id || stage.type;

        // was:
        // rndName = '_' + J.randomInt(10000);
        rndName = '_' + Math.floor((that.blocks.length + 1)/2);

        // Closes last step and stage blocks.
        // Then adds a new enclosing-stages block.
        addStageBlock(that,
                      BLOCK_ENCLOSING + name + rndName,
                      BLOCK_ENCLOSING_STAGES,
                      positions);

        // Gets the enclosing-stages block just added.
        curBlock = that.getCurrentBlock();
        curBlock.add({
            type: BLOCK_STAGE,
            item: stage,
            id: stage.id
        });

        that.currentStage = name;

        addBlock(that,
                 BLOCK_ENCLOSING + name + '_steps' + rndName,
                 BLOCK_ENCLOSING_STEPS,
                 'linear',
                 BLOCK_STEP);
    }

    /**
     * #### addStepsToCurrentBlock
     *
     * Adds steps to current block
     *
     * For each step inside stage.step, it checks whether the step was
     * already added to current block, and if not, it adds it.
     *
     * @param {object} that Reference to Stager object
     * @param {array} steps Array containing the id of the steps
     *
     * @see addStepToBlock
     */
    function addStepsToCurrentBlock(that, steps) {
        var curBlock, i, len;
        curBlock = that.getCurrentBlock();
        i = -1, len = steps.length;
        for ( ; ++i < len ; ) {
            addStepToBlock(that, curBlock, steps[i], that.currentStage);
        }
    }

    /**
     * #### extractAlias
     *
     * Returns an object where alias and id are separated
     *
     * @param {string} nameAndAlias The stage-name string
     *
     * @return {object} Object with properties id and alias (if found)
     *
     * @api private
     *
     * @see handleAlias
     */
    function extractAlias(nameAndAlias) {
        var tokens;
        tokens = nameAndAlias.split(' AS ');
        return {
            id: tokens[0].trim(),
            alias: tokens[1] ? tokens[1].trim() : undefined
        };
    }

    /**
     * #### handleAlias
     *
     * Handles stage id and alias strings
     *
     * Takes a string like 'stageID' or 'stageID AS alias' and return 'alias'.
     * Checks that alias and stage id are different.
     *
     * @param {object} that Reference to Stager object
     * @param {string} nameAndAlias The stage-name string
     * @param {string} method The name of the method calling the validation
     *
     * @return {object} Object with properties id and alias (if found)
     *
     * @see Stager.next
     * @see handleAlias
     *
     * @api private
     */
    function handleAlias(that, nameAndAlias, method) {
        var tokens, id, alias;
        tokens = extractAlias(nameAndAlias);
        id = tokens.id;
        alias = tokens.alias;
        if (id === alias) {
            throw new Error('Stager.' + method + ': id equal to alias: ' +
                            nameAndAlias);
        }
        if (alias && !that.stages[id]) {
            throw new Error('Stager.' + method + ': alias is referencing ' +
                            'non-existing stage: ' + id);
        }
        if (alias && that.stages[alias]) {
            throw new Error('Stager.' + method + ': alias is not unique: ' +
                            alias);
        }
        return tokens;
    }

    /**
     * #### checkStepValidity
     *
     * Returns whether given step is valid
     *
     * Checks for syntactic validity of the step object. Does not validate
     * whether the name is unique, etc.
     *
     * @param {object} step The step object
     * @param {string} method The name of the method calling the validation
     *
     * @see Stager.addStep
     * @see checkStageStepId
     *
     * @api private
     */
    function checkStepValidity(step, method) {
        if (step === null || 'object' !== typeof step) {
            throw new TypeError('Stager.' + method + ': step must be ' +
                                'object. Found: ' + step);
        }
        if ('function' !== typeof step.cb) {
            throw new TypeError('Stager.' + method + ': step.cb must be ' +
                                'function. Found: ' + step.cb);
        }
        checkStageStepId(method, 'step', step.id);
    }

     /**
      * checkStageValidity
      *
      * Returns whether given stage is valid
      *
      * Checks for syntactic validity of the stage object. Does not validate
      * whether the stage name is unique, the steps exists, etc.
      *
      * @param {object} stage The stage to validate
      * @param {string} method The name of the method calling the validation
      *
      * @see Stager.addStage
      * @see checkStageStepId
      *
      * @api private
      */
    function checkStageValidity(stage, method) {
        if ('object' !== typeof stage) {
            throw new TypeError('Stager.' + method + ': stage must be ' +
                                'object. Found: ' + stage);
        }
        if ((!stage.steps && !stage.cb) || (stage.steps && stage.cb)) {
            throw new TypeError('Stager.' + method + ': stage must have ' +
                                'either a steps or a cb property');
        }
        if (J.isArray(stage.steps)) {
            if (!stage.steps.length) {
                throw new Error('Stager.' + method + ': stage.steps cannot ' +
                                'be empty');
            }
        }
        else if (stage.steps) {
            throw new TypeError('Stager.' + method + ': stage.steps must be ' +
                                'array or undefined.  Found: ' + stage.steps);
        }
        checkStageStepId(method, 'stage', stage.id);
     }

    /**
     * #### handleStepParameter
     *
     * Check validity of a stage parameter, eventually adds it if missing
     *
     * @param {Stager} that Stager object
     * @param {string|object} step The step to validate
     * @param {string} method The name of the method calling the validation
     *
     * @return {string} The id of the step
     *
     * @api private
     */
    function handleStepParameter(that, step, method) {
        var id;
        if ('object' === typeof step) {
            id = step.id;
            if (that.steps[id]) {
                throw new Error('Stager.' + method + ': step is object, ' +
                                'but a step with the same id already ' +
                                'exists: ' + id);
            }
            // Add default callback, if missing.
            if (!step.cb) step.cb = that.getDefaultCallback();
        }
        else if ('string' === typeof step) {
            id = step;
            step = {
                id: id,
                cb: that.getDefaultCallback()
            };
        }
        else {
            throw new TypeError('Stager.' + method + ': step must be ' +
                                'string or object. Found: ' + step);
        }

        // A new step is created if not found (performs validation).
        if (!that.steps[id]) that.addStep(step);

        return id;
    }

    /**
     * #### handleStageParameter
     *
     * Check validity of a stage parameter, eventually adds it if missing
     *
     * Called by: `stage`, `repeat`, `doLoop`, 'loop`.
     *
     * @param {Stager} that Stager object
     * @param {string|object} stage The stage to validate
     * @param {string} method The name of the method calling the validation
     *
     * @return {string} The id or alias of the stage
     *
     * @api private
     *
     * @see checkStageValidity
     */
    function handleStageParameter(that, stage, method) {
        var tokens, id, alias;
        if ('object' === typeof stage) {
            id = stage.id;

            // Check only if it is already existing
            // (type checking is done later).
            if (that.stages[id]) {
                throw new Error('Stager.' + method + ': stage is object, ' +
                                'but a stage with the same id already ' +
                                'exists: ' + id);
            }

            // If both cb and steps are missing, adds steps array,
            // and create new step, if necessary.
            if (!stage.cb && !stage.steps) {
                stage.steps = [ id ];
                if (!that.steps[id]) {
                    that.addStep({ id: id, cb: that.getDefaultCb() });
                }
            }
            // If a cb property is present create a new step with that cb.
            // If a step with same id is already existing, raise an error.
            else if (stage.cb) {
                if (that.steps[id]) {
                    throw new Error('Stager.' + method + ': stage has ' +
                                    'cb property, but a step with the same ' +
                                    'id is already defined: ' + id);
                }
                that.addStep({ id: id, cb: stage.cb });
                delete stage.cb;
                stage.steps = [ id ];
            }
            that.addStage(stage);
        }
        else if ('string' === typeof stage) {

            // See whether the stage id contains an alias. Throws errors.
            tokens = handleAlias(that, stage, method);
            alias = tokens.alias;
            id = tokens.id;
            // Alias must reference an existing stage (checked before).
            if (alias) {
                that.stages[alias] = that.stages[id];
            }
            else if (!that.stages[id]) {
                // Add the step if not existing and flag it as default.
                if (!that.steps[id]) {
                    that.addStep(makeDefaultStep(id, that.getDefaultCb()));
                }
                that.addStage({
                    id: id,
                    steps: [ id ]
                });
            }
        }
        else {
            throw new TypeError('Stager.' + method + ': stage must be ' +
                                'string or object. Found: ' + stage);
        }

        return alias || id;
    }

    /**
     * #### checkStageStepId
     *
     * Check the validity of the ID of a step or a stage
     *
     * Must be non-empty string, and cannot begin with a dot.
     *
     * Notice: in the future, the following limitations might apply:
     *
     * - no dots at all in the name
     * - cannot begin with a number
     *
     * @param {string} method The name of the invoking method
     * @param {string} s A string taking value 'step' or 'stage'
     * @param {string} id The id to check
     */
    function checkStageStepId(method, s, id) {
        if ('string' !== typeof id) {
            throw new TypeError('Stager.' + method + ': ' + s + '.id must ' +
                                'be string. Found: ' + id);
        }
        if (id.trim() === '') {
            throw new TypeError('Stager.' + method + ': ' + s + '.id cannot ' +
                                'be an empty string.');
        }
        if (id.lastIndexOf('.') !== -1) {
            throw new Error('Stager.' + method + ': ' + s + '.id cannot ' +
                            'contains dots. Found: ' + id);
        }
        if (/^\d+$/.test(id.charAt(0))) {
            throw new Error('Stager.' + method + ': ' + s + '.id cannot ' +
                            'begin with a number. Found: ' + id);
        }
    }

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # Stager Setter and Getters
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 */
(function(exports, node) {

    var J = node.JSUS;
    var Stager = node.Stager;
    var stepRules = node.stepRules;

    // Referencing shared entities.
    var isDefaultCb = Stager.isDefaultCb;
    var makeDefaultCb = Stager.makeDefaultCb;

    /**
     * #### Stager.setState
     *
     * Sets the internal state of the Stager
     *
     * The passed state object can have the following fields:
     * steps, stages, sequence, generalNextFunction, nextFunctions,
     * defaultStepRule, defaultGlobals, defaultProperties, onInit,
     * onGameover.
     * All fields are optional.
     *
     * This function calls the corresponding functions to set these
     * fields, and performs error checking.
     *
     * If updateRule is 'replace', the Stager is cleared before applying
     * the state.
     *
     * @param {object} stateObj The Stager's state
     * @param {string} updateRule Optional. Whether to
     *    'replace' (default) or to 'append'.
     *
     * @see Stager.getState
     */
    Stager.prototype.setState = function(stateObj, updateRule) {
        var idx;
        var stageObj, seqObj, blockObj;

        if ('object' !== typeof stateObj) {
            throw new TypeError('Stager.setState: stateObj must be object. ' +
                                'Found: ' + stageObj);
        }

        updateRule = updateRule || 'replace';

        if ('string' !== typeof updateRule) {
            throw new TypeError('Stager.setState: updateRule must be string ' +
                                'or undefined. Found: ' + updateRule);
        }

        // Clear previous state:
        if (updateRule === 'replace') {
            this.clear();
        }
        else if (updateRule !== 'append') {
            throw new Error('Stager.setState: invalid updateRule: ' +
                            updateRule);
        }

        // Add steps:
        for (idx in stateObj.steps) {
            if (stateObj.steps.hasOwnProperty(idx)) {
                this.addStep(stateObj.steps[idx]);
            }
        }

        // Add stages:
        // first, handle all non-aliases
        // (key of `stages` entry is same as `id` field of its value)
        for (idx in stateObj.stages) {
            stageObj = stateObj.stages[idx];
            if (stateObj.stages.hasOwnProperty(idx) &&
                stageObj.id === idx) {
                    this.addStage(stageObj);
            }
        }
        // second, handle all aliases
        // (key of `stages` entry is different from `id` field of
        // its value)
        for (idx in stateObj.stages) {
            stageObj = stateObj.stages[idx];
            if (stateObj.stages.hasOwnProperty(idx) &&
                stageObj.id !== idx) {
                    this.stages[idx] = this.stages[stageObj.id];
            }
        }

        // Set openStepBlocks.
        if (stateObj.hasOwnProperty('openStepBlocks')) {
            this.openStepBlocks = stateObj.openStepBlocks;
        }

        // Add sequence:
        if (stateObj.hasOwnProperty('sequence')) {
            for (idx = 0; idx < stateObj.sequence.length; idx++) {
                seqObj = stateObj.sequence[idx];
                this.sequence[idx] = seqObj;
            }
        }

        // Set general next-decider:
        if (stateObj.hasOwnProperty('generalNextFunction')) {
            this.registerGeneralNext(stateObj.generalNextFunction);
        }

        // Set specific next-deciders:
        for (idx in stateObj.nextFunctions) {
            if (stateObj.nextFunctions.hasOwnProperty(idx)) {
                this.registerNext(idx, stateObj.nextFunctions[idx]);
            }
        }

        // Set default step-rule:
        if (stateObj.hasOwnProperty('defaultStepRule')) {
            this.setDefaultStepRule(stateObj.defaultStepRule);
        }

        // Set default globals:
        if (stateObj.hasOwnProperty('defaultGlobals')) {
            this.setDefaultGlobals(stateObj.defaultGlobals);
        }

        // Set default properties:
        if (stateObj.hasOwnProperty('defaultProperties')) {
            this.setDefaultProperties(stateObj.defaultProperties);
        }

        // Set onInit:
        if (stateObj.hasOwnProperty('onInit')) {
            this.setOnInit(stateObj.onInit);
        }

        // Set onGameover:
        if (stateObj.hasOwnProperty('onGameover')) {
            this.setOnGameover(stateObj.onGameover);
        }

        // Set toSkip.
        if (stateObj.hasOwnProperty('toSkip')) {
            this.toSkip = stateObj.toSkip;
        }

        // Set defaultCallback.
        if (stateObj.hasOwnProperty('defaultCallback')) {
            this.setDefaultCallback(stateObj.defaultCallback);
        }

        // Cache reset.
        if (stateObj.hasOwnProperty('cacheReset')) {
            this.cacheReset = stateObj.cacheReset;
        }

        // Blocks.
        if (stateObj.hasOwnProperty('blocks')) {
            this.blocksIds = {};
            for (idx = 0; idx < stateObj.blocks.length; idx++) {
                blockObj = stateObj.blocks[idx];
                this.blocks[idx] = blockObj;
                // Save block id into the blocks map.
                this.blocksIds[blockObj.id] = idx;
            }
        }
        if (stateObj.hasOwnProperty('currentStage')) {
            this.currentStage = stateObj.currentStage;
        }
        if (stateObj.hasOwnProperty('currentBlockType')) {
            this.currentBlockType = stateObj.currentBlockType;
        }

        // Mark finalized.
        this.finalized = true;
    };

    /**
     * #### Stager.getState
     *
     * Finalizes the stager and returns a copy of internal state
     *
     * // TODO: the finalize param does not do what expected
     * @param {boolean} finalize. If TRUE, it calls finalize before
     *   cloning the stager. Default: TRUE.
     *
     * @return {object} Clone of the Stager's state
     *
     * @see Stager.setState
     * @see Stager.finalize
     */
    Stager.prototype.getState = function(finalize) {
        var out, i, len;
        finalize = 'undefined' === typeof finalize ? true : !!finalize;
        if (finalize) this.finalize();

        out = J.clone({
            steps:               this.steps,
            stages:              this.stages,
            sequence:            this.sequence,
            generalNextFunction: this.generalNextFunction,
            nextFunctions:       this.nextFunctions,
            defaultStepRule:     this.defaultStepRule,
            defaultGlobals:      this.defaultGlobals,
            defaultProperties:   this.defaultProperties,
            onInit:              this.onInit,
            onGameover:          this.onGameover,
            toSkip:              this.toSkip,
            defaultCallback:     this.defaultCallback,
            cacheReset:          this.cacheReset,
            currentStage:        this.currentStage,
            currentBlockType:    this.currentBlockType,
            openStepBlocks:      this.openStepBlocks
        });

        // Cloning blocks separately.
        out.blocks = [];
        i = -1, len = this.blocks.length;
        for ( ; ++i < len ; ) {
            out.blocks.push(this.blocks[i].clone());
        }
        if (!finalize) {
            out.unfinishedBlocks = [];
            i = -1, len = this.unfinishedBlocks.length;
            for ( ; ++i < len ; ) {
                out.unfinishedBlocks.push(this.unfinishedBlocks[i].clone());
            }
        }

        return out;
    };

    /**
     * #### Stager.setDefaultStepRule
     *
     * Sets the default step-rule function
     *
     * @param {function} stepRule Optional. The step-rule function.
     *   If undefined, the `SOLO` rule is set.
     *
     * @see Stager.defaultStepRule
     * @see stepRules
     */
    Stager.prototype.setDefaultStepRule = function(stepRule) {
        if (stepRule) {
            if ('function' !== typeof stepRule) {
                throw new TypeError('Stager.setDefaultStepRule: ' +
                                    'stepRule must be function or ' +
                                    'undefined. Found: ' + stepRule);
            }

            this.defaultStepRule = stepRule;
        }
        else {
            // Initial default.
            this.defaultStepRule = stepRules.SOLO;
        }
    };

    /**
     * #### Stager.getDefaultStepRule
     *
     * Returns the default step-rule function
     *
     * @return {function} The default step-rule function
     */
    Stager.prototype.getDefaultStepRule = function() {
        return this.defaultStepRule;
    };

    /**
     * #### Stager.setDefaultCallback
     *
     * Sets the default callback
     *
     * The callback immediately replaces the current callback
     * in all the steps that have a default callback.
     *
     * Function will be modified and flagged as `default`.
     *
     * @param {function|null} cb The default callback or null to unset it
     *
     * @see Stager.defaultCallback
     * @see Stager.getDefaultCallback
     * @see makeDefaultCallback
     */
    Stager.prototype.setDefaultCallback = function(cb) {
        var i;
        if (cb === null) {
            cb = Stager.defaultCallback;
        }
        else if ('function' !== typeof cb) {
            throw new TypeError('Stager.setDefaultCallback: defaultCallback ' +
                                'must be function or null. Found: ' + cb);
        }
        this.defaultCallback = makeDefaultCb(cb);

        for (i in this.steps) {
            if (this.steps.hasOwnProperty(i)) {
                if (isDefaultCb(this.steps[i].cb)) {
                    this.steps[i].cb = this.defaultCallback;
                }
            }
        }
    };

    /**
     * #### Stager.getDefaultCallback | getDefaultCb
     *
     * Returns the default callback
     *
     * If the default callback is not set return the static function
     * `Stager.defaultCallback`
     *
     * @return {function} The default callback
     *
     * @see Stager.defaultCallback (static)
     * @see Stager.defaultCallback
     * @see Stager.setDefaultCallback
     */
    Stager.prototype.getDefaultCb =
        Stager.prototype.getDefaultCallback = function() {
        return this.defaultCallback || Stager.defaultCallback;
    };

    /**
     * #### Stager.setDefaultGlobals
     *
     * Sets/mixes in the default globals
     *
     * @param {object} defaultGlobals The map of default global
     *   variables
     * @param {boolean} mixin Optional. If TRUE, parameter defaultGlobals
     *    will be mixed-in with current globals, otherwise it will replace
          it. Default FALSE.
     *
     * @see Stager.defaultGlobals
     * @see GamePlot.getGlobal
     */
    Stager.prototype.setDefaultGlobals = function(defaultGlobals, mixin) {
        if (!defaultGlobals || 'object' !== typeof defaultGlobals) {
            throw new TypeError('Stager.setDefaultGlobals: defaultGlobals ' +
                                'must be object. Found: ' + defaultGlobals);
        }
        if (mixin) J.mixin(this.defaultGlobals, defaultGlobals);
        else this.defaultGlobals = defaultGlobals;
    };

    /**
     * #### Stager.getDefaultGlobals
     *
     * Returns the default globals
     *
     * @return {object} The map of default global variables
     *
     * @see Stager.defaultGlobals
     * @see GamePlot.getGlobal
     */
    Stager.prototype.getDefaultGlobals = function() {
        return this.defaultGlobals;
    };

    /**
     * #### Stager.setDefaultProperty
     *
     * Sets a default property
     *
     * @param {string} name The name of the default property
     * @param {mixed} value The value for the default property
     *
     * @see Stager.defaultProperties
     * @see Stager.setDefaultProperties
     * @see GamePlot.getProperty
     */
    Stager.prototype.setDefaultProperty = function(name, value) {
        if ('string' !== typeof name) {
            throw new TypeError('Stager.setDefaultProperty: name ' +
                                'must be string. Found: ' + name);
        }
        this.defaultProperties[name] = value;
    };

    /**
     * #### Stager.setDefaultProperties
     *
     * Sets the default properties
     *
     * @param {object} defaultProperties The map of default properties
     * @param {boolean} mixin Optional. If TRUE, parameter defaulProperties
     *    will be mixed-in with current globals, otherwise it will replace
          it. Default FALSE.
     *
     * @see Stager.defaultProperties
     * @see GamePlot.getProperty
     */
    Stager.prototype.setDefaultProperties = function(defaultProperties,
                                                     mixin) {
        if (!defaultProperties ||
            'object' !== typeof defaultProperties) {
            throw new TypeError('Stager.setDefaultProperties: ' +
                                'defaultProperties must be object. Found: ' +
                                defaultProperties);
        }
        if (mixin) J.mixin(this.defaultProperties, defaultProperties);
        else this.defaultProperties = defaultProperties;
    };

    /**
     * #### Stager.getDefaultProperties
     *
     * Returns the default properties
     *
     * @return {object} The map of default properties
     *
     * @see Stager.defaultProperties
     * @see GamePlot.getProperty
     */
    Stager.prototype.getDefaultProperties = function() {
        return this.defaultProperties;
    };

    /**
     * #### Stager.setOnInit
     *
     * Sets onInit function
     *
     * @param {function|null} func The onInit function.
     *   NULL can be given to signify non-existence.
     *
     * @see Stager.onInit
     */
    Stager.prototype.setOnInit = function(func) {
        if (func && 'function' !== typeof func) {
            throw new TypeError('Stager.setOnInit: func must be ' +
                                'function or undefined. Found: ' + func);
        }
        this.onInit = func;
    };

    /**
     * #### Stager.getOnInit
     *
     * Gets onInit function
     *
     * @return {function|null} The onInit function.
     *  NULL signifies non-existence.
     *
     * @see Stager.onInit
     */
    Stager.prototype.getOnInit = function() {
        return this.onInit;
    };

    /**
     * #### Stager.setOnGameover
     *
     * Sets onGameover function
     *
     * @param {function|null} func The onGameover function.
     *   NULL can be given to signify non-existence.
     *
     * @see Stager.onGameover
     */
    Stager.prototype.setOnGameover = function(func) {
        if (func && 'function' !== typeof func) {
            throw new Error('Stager.setOnGameover: func must be ' +
                                'function or undefined.');
        }
        this.onGameover = func;
    };

    /**
     * #### Stager.setOnGameOver
     *
     * Alias for `setOnGameover`
     *
     * @see Stager.setOnGameover
     */
    Stager.prototype.setOnGameOver = Stager.prototype.setOnGameover;

    /**
     * #### Stager.getOnGameover
     *
     * Gets onGameover function
     *
     * @return {function|null} The onGameover function, or NULL if none
     *    is found
     *
     * @see Stager.onGameover
     */
    Stager.prototype.getOnGameover = function() {
        return this.onGameover;
    };

    /**
     * #### Stager.getOnGameOver
     *
     * Alias for `getOnGameover`
     *
     * @see Stager.getOnGameover
     */
    Stager.prototype.getOnGameOver = Stager.prototype.getOnGameover;

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # Stager flexible mode
 * Copyright(c) 2019 Stefano Balietti
 * MIT Licensed
 */
(function(exports, node) {

    var Stager = node.Stager;

    /**
     * #### Stager.registerGeneralNext
     *
     * Sets general callback for next stage decision
     *
     * Available only when nodegame is executed in _flexible_ mode.
     * The callback given here is used to determine the next stage.
     *
     * @param {function|null} func The decider callback. It should
     *   return the name of the next stage, 'NODEGAME_GAMEOVER' to end
     *   the game or FALSE for sequence end. NULL can be given to
     *   signify non-existence.
     */
    Stager.prototype.registerGeneralNext = function(func) {
        if (func !== null && 'function' !== typeof func) {
            throw new TypeError('Stager.registerGeneralNext: ' +
                                'func must be function or undefined. Found: ' +
                                func);
        }
        this.generalNextFunction = func;
    };

    /**
     * #### Stager.registerNext
     *
     * Registers a step-decider callback for a specific stage
     *
     * The function overrides the general callback for the specific
     * stage, and determines the next stage.
     * Available only when nodegame is executed in _flexible_ mode.
     *
     * @param {string} id The name of the stage after which the decider
     *   function will be called
     * @param {function} func The decider callback. It should return the
     *   name of the next stage, 'NODEGAME_GAMEOVER' to end the game or
     *   FALSE for sequence end.
     *
     * @see Stager.registerGeneralNext
     */
    Stager.prototype.registerNext = function(id, func) {
        if ('function' !== typeof func) {
            throw new TypeError('Stager.registerNext: func must be ' +
                'function. Found: ' + func);
        }

        if (!this.stages[id]) {
            throw new TypeError('Stager.registerNext: non existent ' +
                               'stage id: ' + id);
        }

        this.nextFunctions[id] = func;
    };

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # Stager extend stages, modify sequence
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 */
(function(exports, node) {

    var J = node.JSUS;
    var Stager = node.Stager;

    var checkFinalized    = Stager.checkFinalized;
    var handleStepsArray  = Stager.handleStepsArray;
    var addStepToBlock    = Stager.addStepToBlock;
    var isDefaultStep     = Stager.isDefaultStep;
    var unmakeDefaultStep = Stager.unmakeDefaultStep;

    /**
     * #### Stager.extendStep
     *
     * Extends an existing step
     *
     * Notice: properties `id` cannot be modified, and property `cb`
     * must always be a function.
     *
     * @param {string} stepId The id of the step to update
     * @param {object|function} update The object containing the
     *   properties to update, or an update function that takes a copy
     *   of current step and returns the whole new updated step
     *
     * @see Stager.addStep
     * @see validateExtendedStep
     */
    Stager.prototype.extendStep = function(stepId, update) {
        var step;
        if ('string' !== typeof stepId) {
            throw new TypeError('Stager.extendStep: stepId must be ' +
                                'string. Found: ' + stepId);
        }
        step = this.steps[stepId];
        if (!step) {
            throw new Error('Stager.extendStep: stepId not found: ' +
                            stepId);
        }
        if ('function' === typeof update) {
            step = update(J.clone(step));
            validateExtendedStep(stepId, step, true);
            this.steps[stepId] = step;
        }
        else if (update && 'object' === typeof update) {
            validateExtendedStep(stepId, update, false);
            J.mixin(step, update);
        }
        else {
            throw new TypeError('Stager.extendStep: step "' + stepId +
                                '": update must be object ' +
                                'or function. Found: ' + update);
        }
    };

    /**
     * #### Stager.extendStage
     *
     * Extends an existing stage
     *
     * Notice: properties `id` and `cb` cannot be modified / added.
     *
     * @param {string} stageId The id of the stage to update
     * @param {object|function} update The object containing the
     *   properties to update, or an update function that takes a copy
     *   of current stage and returns the whole new updated stage
     *
     * @see Stager.addStage
     * @see validateExtendedStage
     */
    Stager.prototype.extendStage = function(stageId, update) {
        var stage;

        if ('string' !== typeof stageId) {
            throw new TypeError('Stager.extendStage: stageId must be ' +
                                'string. Found: ' + stageId);
        }
        stage = this.stages[stageId];
        if (!stage) {
            throw new Error('Stager.extendStage: stageId not found: ' +
                            stageId);
        }

        if ('function' === typeof update) {
            stage = update(J.clone(stage));
            if (!stage || 'object' !== typeof stage ||
                !stage.id || !stage.steps) {

                throw new TypeError('Stager.extendStage: update function ' +
                                    'must return an object with id and ' +
                                    'steps. Found: ' + stage);
            }
            validateExtendedStage(this, stageId, stage, true);
            this.stages[stageId] = stage;

        }
        else if (update && 'object' === typeof update) {
            validateExtendedStage(this, stageId, update, false);
            J.mixin(stage, update);
        }
        else {
            throw new TypeError('Stager.extendStage: stage "' + stageId +
                                '": update must be object ' +
                                'or function. Found: ' + update);
        }
    };

    /**
     * #### Stager.extendAllSteps
     *
     * Extends all existing steps
     *
     * @param {object|function} update The object containing the
     *   properties to update, or an update function that takes a copy
     *   of current step and returns the whole new updated step
     *
     * @see Stager.addStep
     * @see Stager.extendStep
     */
    Stager.prototype.extendAllSteps = function(update) {
        var step;
        for (step in this.steps) {
            if (this.steps.hasOwnProperty(step)) {
                this.extendStep(step, update);
            }
        }
    };

    /**
     * #### Stager.extendSteps
     *
     * Extends steps with given ids
     *
     * @param {array} stepIds The ids of the steps to update.
     * @param {object|function} update The object containing the
     *   properties to update, or an update function that takes a copy
     *   of current step and returns the whole new updated step
     *
     * @see Stager.addStep
     * @see Stager.extendStep
     */
    Stager.prototype.extendSteps = function(stepIds, update) {
        if (!J.isArray(stepIds)) {
            throw new TypeError('Stager.extendSteps: stepIds ' +
                                'must be array. Found: ' + stepIds);
        }
        stepIds.forEach((stepId) => {
            if (!this.steps[stepId]) {
                console.log('**warn: Stager.extendSteps: step with id " '+
                            stepId + '" not found');
            }
            else {
                this.extendStep(stepId, update);
            }

        });
    };

    /* #### Stager.extendAllStages
     *
     * Extends all existing stages
     *
     * @param {object|function} update The object containing the
     *   properties to update, or an update function that takes a copy
     *   of current stage and returns the whole new updated stage
     *
     * @see Stager.addStage
     * @see Stager.extendStage
     */
    Stager.prototype.extendAllStages = function(update) {
        var stage;
        for (stage in this.stages) {
            if (this.stages.hasOwnProperty(stage)) {
                this.extendStage(stage, update);
            }
        }
    };

    /**
     * #### Stager.extendStages
     *
     * Extends steps with given ids
     *
     * @param {array} stageIds The ids of the stages to update.
     * @param {object|function} update The object containing the
     *   properties to update, or an update function that takes a copy
     *   of current stage and returns the whole new updated stage
     *
     * @see Stager.extendStage
     */
    Stager.prototype.extendStages = function(stageIds, update) {
        if (!J.isArray(stageIds)) {
            throw new TypeError('Stager.extendSteps: stageIds ' +
                                'must be array. Found: ' + stageIds);
        }
        stageIds.forEach((stageId) => {
            if (!this.stages[stageId]) {
                console.log('**warn: Stager.extendStages: stage with id " '+
                            stageId + '" not found');
            }
            else {
                this.extendStage(stageId, update);
            }
        });
    };

    /**
     * #### Stager.skip
     *
     * Marks a stage or as step as `toSkip` and won't be added to sequence
     *
     * Must be called before invoking `Stager.finalize()`.
     *
     * @param {string|array} stageId The id/s of the stage to skip
     * @param {string|array} stepId Optional. The id/s of the step within
     *   the stage to skip. Notice stepId and stageId cannot be both arrays.
     *
     * @see Stager.unskip
     * @see Stager.finalize
     */
    Stager.prototype.skip = function(stageId, stepId) {
        checkFinalized(this, 'skip');
        setSkipStageStepArray(this, stageId, stepId, true, 'skip');

    };

    /**
     * #### Stager.unskip
     *
     * Unskips a stage or step
     *
     * Must be called before invoking `Stager.finalize()`.
     *
     * @param {string|array} stageId The id/s of the stage to skip
     * @param {string|array} stepId Optional. The id/s of the step within
     *   the stage to unskip. Notice stepId and stageId cannot be both arrays.
     *
     * @see Stager.skip
     * @see Stager.finalize
     */
    Stager.prototype.unskip = function(stageId, stepId) {
        checkFinalized(this, 'unskip');
        setSkipStageStepArray(this, stageId, stepId, false, 'unskip');
    };

    /**
     * #### Stager.isSkipped
     *
     * Returns TRUE if a stage or step is currently marked as `toSkip`
     *
     * @param {string} stageId The id of the stage
     * @param {string} stepId Optional. The id of the step within the stage
     *
     * @return {boolean} TRUE, if the stage or step is marked as `toSkip`
     *
     * @see Stager.skip
     * @see Stager.unskip
     */
    Stager.prototype.isSkipped = function(stageId, stepId) {
        return !!setSkipStageStep(this, stageId, stepId, undefined,
                                  'isSkipped');
    };

    // ## Helper functions.

    /**
     * #### setSkipStageStep
     *
     * Sets/Gets the value for the flag `toSkip` for a stage or a step
     *
     * @param {Stager} that Stager object
     * @param {string} stageId The id of the stage
     * @param {string} stepId Optional. The id of the step within the stage
     * @param {mixed} value If defined, is assigned to the stage or step
     * @param {string} method The name of the method calling the validation
     *
     * @return {boolean|null} The current value for the stage or step
     *
     * @api private
     */
    function setSkipStageStepArray(that, stageId, stepId, value, method) {

        if (J.isArray(stageId) && stageId.length === 1) stageId = stageId[0];
        if (J.isArray(stepId) && stepId.length === 1) stepId = stepId[0];

        if (J.isArray(stageId) && J.isArray(stepId)) {
            throw new Error('Staker.' + method + ': stageId and stepId ' +
                            'cannot be both arrays of length > 1');
        }
        if (J.isArray(stageId)) {
            stageId.forEach((_stageId) => {
                setSkipStageStep(that, _stageId, stepId, value, method);
            });
        }
        else if (J.isArray(stepId)) {
            stepId.forEach((_stepId) => {
                setSkipStageStep(that, stageId, _stepId, value, method);
            });
        }
        else {
            setSkipStageStep(that, stageId, stepId, value, method);
        }
    }

    /**
     * #### setSkipStageStep
     *
     * Sets/Gets the value for the flag `toSkip` for a stage or a step
     *
     * @param {Stager} that Stager object
     * @param {string} stageId The id of the stage
     * @param {string} stepId Optional. The id of the step within the stage
     * @param {mixed} value If defined, is assigned to the stage or step
     * @param {string} method The name of the method calling the validation
     *
     * @return {boolean|null} Whether the stage or step is currently skipped.
     *     A step can be skipped if its stage is skipped; vice versa, a stage
     *     can be skipped if all of its steps are skipped.
     *
     * @api private
     */
    function setSkipStageStep(that, stageId, stepId, value, method) {
        var allStepsSkipped, steps, i;
        if ('string' !== typeof stageId || stageId.trim() === '') {
            throw new TypeError('Stager.' + method + ': stageId must ' +
                                'be a non-empty string. Found: ' + stageId);
        }
        if (!that.stages[stageId]) {
            console.log('**warn: Stager.' + method + ': unknown stage: "' +
                        stageId + '" (you may still add it later)');
        }
        if (stepId) {
            if ('string' !== typeof stepId || stepId.trim() === '') {
                throw new TypeError('Stager.' + method + ': stepId must ' +
                                    'be a non-empty string or undefined.' +
                                    'Found: ' + stepId);
            }

            if (!that.steps[stepId]) {
                console.log('**warn: Stager.' + method + ': unknown step: "' +
                            stepId + '" (you may still add it later)');
            }

            if ('undefined' !== typeof value) {
                that.toSkip.steps[stageId + '.' + stepId] = value;
            }

            // A step may be skipped if the stage is skipped.
            return that.toSkip.stages[stageId] ||
                   that.toSkip.steps[stageId + '.' + stepId];
        }

        // Set the value.
        if ('undefined' !== typeof value) that.toSkip.stages[stageId] = value;

        // If the stage was previously set to be skipped return TRUE.
        if (that.toSkip.stages[stageId]) return true;

        // A stage can be skipped if all of its steps are skipped.
        allStepsSkipped = true;
        steps = that.stages[stageId].steps;
        for (i = 0; i < steps.length; i++) {
            // First step might be the default one and will be removed
            // if there are additional steps.
            if (i === 0 && steps.length > 1) {
                if (isDefaultStep(that.steps[steps[i]])) continue;
            }
            if (!that.toSkip.steps[stageId + '.' + steps[i]]) {
                allStepsSkipped = false;
                break;
            }
        }

        return allStepsSkipped;
    }


    /**
     * #### validateExtendedStep
     *
     * Validates the modification to a step (already known as object)
     *
     * Each step inside the steps array is validated via `handleStepsArray`.
     *
     * @param {string} stepId The original step id
     * @param {object} update The update/updated object
     * @param {boolean} updateFunction TRUE if the update object is the
     *    value returned by an update function
     *
     * @see handleStepsArray
     */
    function validateExtendedStep(stepId, update, updateFunction) {
        var errBegin;
        if (updateFunction) {
            errBegin = 'Stager.extendStep: update function must return ' +
                'an object with ';

            if (!update || 'object' !== typeof update) {
                throw new TypeError(errBegin + 'id and cb. Found: ' + update +
                                    '. Step id: ' +  stepId);
            }
            if (update.id !== stepId) {
                throw new Error('Stager.extendStep: update function ' +
                                'cannot alter the step id: ' + stepId);
            }
            if ('function' !== typeof update.cb) {
                throw new TypeError(errBegin + 'a valid callback. Step id:' +
                                    stepId);
            }
            if (update.init && 'function' !== typeof update.init) {
                throw new TypeError(errBegin + 'invalid init property. ' +
                                    'Function or undefined expected, found: ' +
                                    typeof update.init + '. Step id:' +
                                    stepId);
            }
            if (update.exit && 'function' !== typeof update.exit) {
                throw new TypeError(errBegin + 'invalid exit property. ' +
                                    'Function or undefined expected, found: ' +
                                    typeof update.exit + '. Step id:' +
                                    stepId);
            }
            if (update.done && 'function' !== typeof update.done) {
                throw new TypeError(errBegin + 'invalid done property. ' +
                                    'Function or undefined expected, found: ' +
                                    typeof update.done + '. Step id:' +
                                    stepId);
            }
        }
        else {
            if (update.hasOwnProperty('id')) {
                throw new Error('Stager.extendStep: update.id cannot be set. ' +
                                'Step id: ' + stepId);
            }
            if (update.cb && 'function' !== typeof update.cb) {
                throw new TypeError('Stager.extendStep: update.cb must be ' +
                                    'function or undefined. Step id:' +
                                    stepId);
            }
            if (update.init && 'function' !== typeof update.init) {
                throw new TypeError('Stager.extendStep: update.init must be ' +
                                    'function or undefined. Step id:' +
                                    stepId);
            }
            if (update.exit && 'function' !== typeof update.exit) {
                throw new TypeError('Stager.extendStep: update.exit must be ' +
                                    'function or undefined. Step id:' +
                                    stepId);
            }
            if (update.done && 'function' !== typeof update.done) {
                throw new TypeError('Stager.extendStep: update.done must be ' +
                                    'function or undefined. Step id:' +
                                    stepId);
            }

        }
    }

    /**
     * #### validateExtendedStage
     *
     * Validates the modification to a stage (already known as object)
     *
     * Each step inside the steps array is validated via `handleStepsArray`.
     *
     * @param {Stager} that Stager object
     * @param {string} stageId The original stage id
     * @param {object} update The update/updated object
     * @param {boolean} updateFunction TRUE if the update object is the
     *    value returned by an update function
     *
     * @see handleStepsArray
     */
    function validateExtendedStage(that, stageId, update, updateFunction) {
        var block, i, len;
        if ((updateFunction && update.id !== stageId) ||
            (!updateFunction && update.hasOwnProperty('id'))) {

            throw new Error('Stager.extendStage: id cannot be altered: ' +
                            stageId);
        }
        if (update.cb) {
            throw new TypeError('Stager.extendStage: update.cb cannot be ' +
                                'specified. Stage id: ' + stageId);
        }
        if (update.init && 'function' !== typeof update.init) {
            throw new TypeError('Stager.extendStage: update.init must be ' +
                                'function or undefined. Stage id:' +
                                stageId);
        }
        if (update.exit && 'function' !== typeof update.exit) {
            throw new TypeError('Stager.extendStage: update.exit must be ' +
                                'function or undefined. Stage id:' +
                                stageId);
        }
        if (update.done && 'function' !== typeof update.done) {
            throw new TypeError('Stager.extendStage: update.done must be ' +
                                'function or undefined. Stage id:' +
                                stageId);
        }
        if (update.steps) {
            if (!J.isArray(update.steps)) {
                throw new Error('Stager.extendStage: update.steps must be ' +
                                'array or undefined. Stage id: ' + stageId +
                                'Found: ' + update.steps);
            }

            if (!update.steps.length) {
                throw new Error('Stager.extendStage: update.steps is an ' +
                                'empty array. Stage id: ' + stageId);
            }

            // No changes to the steps array, just exit.
            if (J.equals(that.stages[stageId].steps, update.steps)) return;

            // Process every step in the array. Steps array is modified.
            handleStepsArray(that, stageId, update.steps, 'extendStage');

            // We need to get the enclosing steps block,
            // following the stage block.
            block = that.findBlockWithItem(stageId);

            // Stage is not in any block, just exit.
            if (!block) return;

            // We need to update the block in which the stage was.

            if ('undefined' !== typeof block.unfinishedItems[1]) {
                block = block.unfinishedItems[1].item;
            }
            // The stage block was not ended yet,
            // so the the step block is the last of the sequence.
            else {
                block = that.blocks[that.blocks.length -1];
            }

            // Remove all previous steps before adding the updated steps.
            block.removeAllItems();

            // Add steps to block (if necessary).
            i = -1, len = update.steps.length;
            for ( ; ++i < len ; ) {
                // If the default step is contained in the list of updated
                // steps, then it's not a default step and we keep it.
                if (isDefaultStep(that.steps[update.steps[i]])) {
                    unmakeDefaultStep(that.steps[update.steps[i]]);
                }
                addStepToBlock(that, block, update.steps[i], stageId);
            }
        }
    }

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # Stager blocks operations
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 */
(function(exports, node) {

    var Stager = node.Stager;

    var checkPositionsParameter = Stager.checkPositionsParameter;
    var addStageBlock = Stager.addStageBlock;
    var addBlock = Stager.addBlock;

    var blockTypes               = Stager.blockTypes;
    var BLOCK_DEFAULT            = blockTypes.BLOCK_DEFAULT;
    var BLOCK_STAGEBLOCK         = blockTypes.BLOCK_STAGEBLOCK;
    var BLOCK_STEPBLOCK          = blockTypes.BLOCK_STEPBLOCK;
    var BLOCK_STEP               = blockTypes.BLOCK_STEP;
    var BLOCK_ENCLOSING          = blockTypes.BLOCK_ENCLOSING;
    var BLOCK_ENCLOSING_STEPS    = blockTypes.BLOCK_ENCLOSING_STEPS;

    /**
     * #### Stager.stepBlock
     *
     * Begins a new Block of steps
     *
     * This function just validates the input paramters and passes them
     * to lower level function `addBlock`.
     *
     * @param {string} id The id of the block.
     * @param {string|number} positions Optional. Positions within the
     *   enclosing Block that this block may occupy.
     *
     * @return {Stager} Reference to the current instance for method chaining
     */
    Stager.prototype.stepBlock = function(id, positions) {
        var curBlock, err;

        if (arguments.length === 1) {
            console.log('***deprecation warning: Stager.stepBlock will ' +
                        'require two parameters in the next version.***');

           positions = id;
        }
        else {
            if ('string' !== typeof id || id.trim() === '') {
                throw new TypeError('Stager.stepBlock: id must be a ' +
                                    'non-empty string. Found: ' + id);
            }
            if (this.blocksIds[id]) {
                throw new Error('Stager.stepBlock: non-unique id: ' + id);
            }
        }

        // Check if a stage block can be added in this position.
        curBlock = this.getCurrentBlock();

        if (!curBlock || curBlock.id === BLOCK_DEFAULT ||
            (!curBlock.isType(BLOCK_ENCLOSING_STEPS) &&
            !curBlock.isType(BLOCK_STEPBLOCK))) {

            err = 'Stager.stepBlock: block ';
            if (id) err += '"' +  id + '"';
            err += 'cannot be added here. Did add at least one stage before?'
            throw new Error(err);
        }


           // !curBlock.isType(BLOCK_STEPBLOCK))
        if (curBlock.isType(BLOCK_STEPBLOCK) && curBlock.size() === 0) {
            err = 'Stager.stepBlock: block ';
            if (id) err += '"' +  id + '"';
            err += 'cannot be added here. Did add at least one step ' +
                   'in the previous step block?'
            throw new Error(err);
        }

        checkPositionsParameter(positions, 'stepBlock');

        addBlock(this, id, BLOCK_STEPBLOCK, positions, BLOCK_STEP);
        this.openStepBlocks++;

        return this;
    };

    /**
     * #### Stager.stageBlock
     *
     * Begins a new Block of stages
     *
     * This function just validates the input paramters and passes them
     * to lower level function `addStageBlock`.
     *
     * @param {string} id The id of the block.
     * @param {string|number} positions Optional. Positions within the
     *   enclosing Block that this block can occupy.
     *
     * @return {Stager} Reference to the current instance for method chainining
     *
     * @see addStageBlock
     */
    Stager.prototype.stageBlock = function(id, positions) {
        var curBlock, err;

        if (arguments.length === 1) {
            console.log('***deprecation warning: Stager.stageBlock will ' +
                        'require two parameters in the next version.***');

           positions = id;
        }
        else {
            if ('string' !== typeof id || id.trim() === '') {
                throw new TypeError('Stager.stageBlock: id must be a ' +
                                    'non-empty string. Found: ' + id);
            }
            if (this.blocksIds[id]) {
                throw new Error('Stager.stageBlock: non-unique id: ' + id);
            }
        }

        // Check if a stage block can be added in this position.
        curBlock = this.getCurrentBlock();

        if (curBlock && curBlock.id !== BLOCK_DEFAULT &&
            // (curBlock.isType(BLOCK_STAGE) ||
            curBlock.isType(BLOCK_STAGEBLOCK)) {

            err = 'Stager.stageBlock: block ';
            if (id) err += '"' +  id + '"';
            err += 'cannot be added here. Did add at least one stage ' +
                   'in the previous stage block?'
            throw new Error(err);
        }

        checkPositionsParameter(positions, 'stageBlock');

        // Closes last step and stage blocks.
        // Then adds a new enclosing-stages block.
        addStageBlock(this, id, BLOCK_STAGEBLOCK, positions);

        return this;
    };

    /**
     * #### Stager.getCurrentBlock
     *
     * Returns the Block that Stager is currently working on
     *
     * @return {object|boolean} Currently open block, or FALSE if no
     *   unfinished block is found
     */
    Stager.prototype.getCurrentBlock = function() {
        if (this.unfinishedBlocks.length === 0) return false;
        return this.unfinishedBlocks[this.unfinishedBlocks.length -1];
    };

    /**
     * #### Stager.endBlock
     *
     * Ends the current Block
     *
     * param {object} options Optional If `options.finalize` is set, the
     *   block gets finalized.
     *
     * @return {Stager} Reference to the current instance for method chainining
     */
    Stager.prototype.endBlock = function(options) {
        var block, currentBlock;
        var found, i;
        if (!this.unfinishedBlocks.length) return this;
        options = options || {};

        block = this.unfinishedBlocks.pop();

        // Step block.
        if (block.isType(BLOCK_STEPBLOCK)) {

            // We find the first enclosing block for the step block
            // (in between there could several steps).
            i = this.blocks.length-1;
            do {
                currentBlock = this.blocks[i];
                found = currentBlock.id.indexOf(BLOCK_ENCLOSING) !== -1;
                i--;
            }
            while (!found && i >= 0)

            if (found) {
                currentBlock.add(block, block.positions);
            }
            else {
                throw new Error('Stager.endBlock: could not find enclosing ' +
                                'block for stepBlock ' + block.name);
            }

        }
        // Normal stage / step block, add it to previous
        else if (!block.isType(BLOCK_STAGEBLOCK)) {

            currentBlock = this.getCurrentBlock();
            if (currentBlock) currentBlock.add(block, block.positions);

        }
        // Add stage block to default block.
        else if (block.id !== BLOCK_DEFAULT &&
                 block.id.indexOf(BLOCK_ENCLOSING) === -1) {

            this.blocks[0].add(block, block.positions);
        }
        if (options.finalize) block.finalize();
        return this;
    };

    /**
     * #### Stager.endBlocks
     *
     * Ends multiple unfinished Blocks
     *
     * @param Number n Number of unfinished Blocks to be ended.
     * @param {object} options Optional If options.finalize is set, the
     *    block gets finalized.
     */
    Stager.prototype.endBlocks = function(n, options) {
        var i;
        for (i = 0; i < n; ++i) {
            this.endBlock(options);
        }
        return this;
    };

    /**
     * #### Stager.endAllBlocks
     *
     * Ends all unfinished Blocks.
     */
    Stager.prototype.endAllBlocks = function() {
        this.endBlocks(this.unfinishedBlocks.length);
    };

    /**
     * #### Stager.findBlockWithItem
     *
     * Returns the block where the item (step|stage) with specified id is found
     *
     * @param {string} itemId The id of the item
     *
     * @return {object|boolean} The block containing the requested item,
     *    or FALSE if none is found
     */
    Stager.prototype.findBlockWithItem = function(itemId) {
        var i, len;
        i = -1, len = this.blocks.length;
        for ( ; ++i < len ; ) {
            if (this.blocks[i].hasItem(itemId)) return this.blocks[i];
        }
        return false;
    };

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # Stager Extract Info
 * Copyright(c) 2019 Stefano Balietti
 * MIT Licensed
 */
(function(exports, node) {

    var Stager = node.Stager;

    /**
     * #### Stager.getSequence
     *
     * Returns the sequence of stages
     *
     * @param {string} format 'hstages' for an array of human-readable
     *   stage descriptions, 'hsteps' for an array of human-readable
     *   step descriptions, 'o' for the internal JavaScript object
     *
     * @return {array|object|null} The stage sequence in requested
     *   format. NULL on error.
     */
    Stager.prototype.getSequence = function(format) {
        var result;
        var seqIdx;
        var seqObj;
        var stepPrefix;

        switch (format) {
        case 'hstages':
            result = [];

            for (seqIdx in this.sequence) {
                if (this.sequence.hasOwnProperty(seqIdx)) {
                    seqObj = this.sequence[seqIdx];

                    switch (seqObj.type) {
                    case 'gameover':
                        result.push('[game over]');
                        break;

                    case 'plain':
                        result.push(seqObj.id);
                        break;

                    case 'repeat':
                        result.push(seqObj.id + ' [x' + seqObj.num +
                            ']');
                        break;

                    case 'loop':
                        result.push(seqObj.id + ' [loop]');
                        break;

                    case 'doLoop':
                        result.push(seqObj.id + ' [doLoop]');
                        break;

                    default:
                        throw new Error('Stager.getSequence: unknown' +
                                        'sequence object type: ' + seqObj.type);
                    }
                }
            }
            break;

        case 'hsteps':
            result = [];

            for (seqIdx in this.sequence) {
                if (this.sequence.hasOwnProperty(seqIdx)) {
                    seqObj = this.sequence[seqIdx];
                    stepPrefix = seqObj.id + '.';

                    switch (seqObj.type) {
                    case 'gameover':
                        result.push('[game over]');
                        break;

                    case 'plain':
                        seqObj.steps.map(
                            function(stepID) {
                                result.push(stepPrefix + stepID);
                            }
                        );
                        break;

                    case 'repeat':
                        seqObj.steps.map(
                            function(stepID) {
                                result.push(stepPrefix + stepID +
                                    ' [x' + seqObj.num + ']');
                            }
                        );
                        break;

                    case 'loop':
                        seqObj.steps.map(
                            function(stepID) {
                                result.push(stepPrefix +
                                            stepID + ' [loop]');
                            }
                        );
                        break;

                    case 'doLoop':
                        seqObj.steps.map(
                            function(stepID) {
                                result.push(stepPrefix +
                                            stepID + ' [doLoop]');
                            }
                        );
                        break;

                    default:
                        throw new Error('Stager.getSequence: unknown' +
                                        'sequence object type: ' + seqObj.type);
                    }
                }
            }
            break;

        case 'o':
            result = this.sequence;
            break;

        default:
            throw new Error('Stager.getSequence: invalid format: ' + format);
        }

        return result;
    };

    /**
     * #### Stager.extractStage
     *
     * Returns a minimal state package containing one or more stages
     *
     * The returned package consists of a `setState`-compatible object
     * with the `steps` and `stages` properties set to include the given
     * stages.
     * The `sequence` is optionally set to a single `next` block for the
     * stage.
     *
     * @param {string|array} ids Valid stage name(s)
     * @param {boolean} useSeq Optional. Whether to generate a singleton
     *   sequence.  TRUE by default.
     *
     * @return {object|null} The state object on success, NULL on error
     *
     * @see Stager.setState
     */
    Stager.prototype.extractStage = function(ids, useSeq) {
        var result;
        var stepIdx, stepId;
        var stageId;
        var stageObj;
        var idArray, idIdx, id;

        if (ids instanceof Array) {
            idArray = ids;
        }
        else if ('string' === typeof ids) {
            idArray = [ ids ];
        }
        else return null;

        result = { steps: {}, stages: {}, sequence: [] };

        // undefined (default) -> true
        useSeq = (useSeq === false) ? false : true;

        for (idIdx in idArray) {
            if (idArray.hasOwnProperty(idIdx)) {
                id = idArray[idIdx];

                stageObj = this.stages[id];

                if (!stageObj) return null;

                // Add step objects:
                for (stepIdx in stageObj.steps) {
                    if (stageObj.steps.hasOwnProperty(stepIdx)) {
                        stepId = stageObj.steps[stepIdx];
                        result.steps[stepId] = this.steps[stepId];
                    }
                }

                // Add stage object:
                stageId = stageObj.id;
                result.stages[stageId] = stageObj;

                // If given id is alias, also add alias:
                if (stageId !== id) result.stages[id] = stageObj;

                // Add mini-sequence:
                if (useSeq) {
                    result.sequence.push({
                        type: 'plain',
                        id: stageId
                    });
                }
            }
        }

        return result;
    };

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # SocketFactory
 * Copyright(c) 2015 Stefano Balietti
 * MIT Licensed
 *
 * `nodeGame` component responsible for registering and instantiating
 * new GameSocket clients
 *
 * Contract: Socket prototypes must implement the following methods:
 *
 * - connect: establish a communication channel with a ServerNode instance
 * - send: pushes messages into the communication channel
 */
(function(exports) {

    "use strict";

    // Storage for socket types.
    var types = {};

    function checkContract(Proto) {
        var test;
        test = new Proto();
        if (!test.send) return false;
        if (!test.connect) return false;
        return true;
    }

    function getTypes() {
        return types;
    }

    function get( node, type, options ) {
        var Socket = types[type];
        return (Socket) ? new Socket(node, options) : null;
    }

    function register( type, proto ) {
        if (!type || !proto) return;

        // only register classes that fulfill the contract
        if ( checkContract(proto) ) {
            types[type] = proto;
        }
        else {
            throw new Error('Cannot register invalid Socket class: ' + type);
        }
    }

    // expose the socketFactory methods
    exports.SocketFactory = {
        checkContract: checkContract,
        getTypes: getTypes,
        get: get,
        register: register
    };


    // ## Closure
})(
    'undefined' != typeof node ? node : module.exports
);

/**
 * # Socket
 * Copyright(c) 2020 Stefano Balietti
 * MIT Licensed
 *
 * Wrapper class for the actual socket to send messages
 *
 * http://nodegame.org
 */
(function(exports, parent) {

    "use strict";

    exports.Socket = Socket;

    // ## Global scope

    var GameMsg = parent.GameMsg,
    SocketFactory = parent.SocketFactory,
    J = parent.JSUS;

    /**
     * ## Socket constructor
     *
     * Creates a new instance of Socket
     *
     * @param {NodeGameClient} node Reference to the node instance
     */
    function Socket(node) {

        // ## Public properties

        /**
         * ### Socket.buffer
         *
         * Buffer of queued incoming messages
         *
         * @api private
         */
        this.buffer = [];

        /**
         * ### Socket.outBuffer
         *
         * Buffer of queued outgoing messages
         *
         * TODO: implement!
         *
         * @api private
         */
        // this.outBuffer = [];

        /**
         * ### Socket.session
         *
         * The session id shared with the server
         *
         * This property is initialized only when a game starts
         *
         */
        this.session = null;

        /**
         * ### Socket.userOptions
         *
         * Contains the options that will be passed to the `connect` method
         *
         * The property is set by `node.setup.socket`.
         * Passing options to the `connect` method will overwrite this property.
         *
         * @see node.setup
         * @see Socket.connect
         */
        this.userOptions = {};

        /**
         * ### Socket.socket
         *
         * The actual socket object (e.g. SocketDirect, or SocketIo)
         */
        this.socket = null;

        /**
         * ### Socket.connected
         *
         * Socket connection established
         *
         * For realiably checking whether the connection is established
         * use `Socket.isConnected()`.
         *
         * @see Socket.connecting
         * @see Socket.isConnected
         * @see Socket.onConnect
         * @see Socket.onDisconnect
         */
        this.connected = false;

        /**
         * ### Socket.connecting
         *
         * Socket connection being established
         *
         * TODO see whether we should merge connected / connecting
         * in one variable with socket states.
         *
         * @see Socket.connected
         * @see Socket.isConnected
         * @see Socket.onConnect
         * @see Socket.onDisconnect
         */
        this.connecting = false;


         /**
         * ### Socket.reconnecting
         *
         * Flags that a reconnection is in progress
         *
         * This is useful when `Socket.reconnect()` triggers a disconnection
         *
         * @see Socket.reconnect
         */
        this.reconnecting = false;

         /**
         * ### Socket.connectingTimeout
         *
         * Timeout to cancel the connecting procedure
         *
         * @see Socket.connecting
         * @see Socket.connect
         */
        this.connectingTimeout = null;

         /**
         * ### Socket.connectingTimeoutMs
         *
         * Number of milliseconds for the connecting timeout
         *
         * Default: 10000 (10 seconds)
         *
         * @see Socket.connecting
         * @see Socket.connect
         */
        this.connectingTimeoutMs = 10000;

        /**
         * ### Socket.url
         *
         * The full url to which the socket is connected
         *
         * This is set when a new connection attempt is started.
         *
         * It might not be meaningful for all types of sockets. For example,
         * in case of SocketDirect, it is not an real url.
         *
         * @see Socket.connect
         */
        this.url = null;

        /**
         * ### Socket.channelName
         *
         * The name of the channel to which the socket is connected
         *
         * This is set upon a successful connection.
         *
         * @see Socket.startSession
         */
        this.channelName = null;

        /**
         * ### Socket.type
         *
         * The type of socket used
         */
        this.type = null;

        /**
         * ### Socket.emitOutMsg
         *
         * If TRUE, outgoing messages will be emitted upon sending
         *
         * This allows, for example, to modify all outgoing messages.
         */
        this.emitOutMsg = false;

        /**
         * ### Socket.antiSpoofing
         *
         * If TRUE, sid is added to each message
         *
         * This setting is sent over by server.
         */
        this.antiSpoofing = null;

        // Experimental Journal.
        // TODO: check if we need it.
        this.journalOn = false;

        // Experimental
        this.journal = new parent.NDDB({
            update: {
                indexes: true
            }
        });
        if (!this.journal.player) {
            this.journal.hash('to');
        }

        // this.journal.comparator('stage', function(o1, o2) {
        //     return parent.GameStage.compare(o1.stage, o2.stage);
        // });


        // if (!this.journal.stage) {
        //     this.journal.hash('stage', function(gb) {
        //         if (gb.stage) {
        //             return parent.GameStage.toHash(gb.stage, 'S.s.r');
        //         }
        //     });
        // }
        // End Experimental Code.

        /**
         * ### Socket.node
         *
         * Reference to the node object.
         */
        this.node = node;
    }

    // ## Socket methods

    /**
     * ### Socket.setup
     *
     * Configures the socket
     *
     * @param {object} options Optional. Configuration options.
     *
     * @see node.setup.socket
     */
    Socket.prototype.setup = function(options) {
        if (!options) return;
        if ('object' !== typeof options) {
            throw new TypeError('Socket.setup: options must be object ' +
                                'or undefined.');
        }
        options = J.clone(options);
        if (options.connectingTimeout) {
            if (!J.isInt(options.connectingTimeout, 0)) {

                throw new TypeError('Socket.setup: options.connectingTimeout ' +
                                    'a positive number or undefined.');
            }
            this.connectingTimeoutMs = options.connectingTimeout;
        }
        if (options.type) {
            this.setSocketType(options.type, options);
            options.type = null;
        }
        if ('undefined' !== typeof options.emitOutMsg) {
            this.emitOutMsg = options.emitOutMsg;
            options.emitOutMsg = null;
        }
        this.userOptions = options;
    };

    /**
     * ### Socket.setSocketType
     *
     * Sets the default socket by requesting it to the Socket Factory
     *
     * Supported types: 'Direct', 'SocketIo'.
     *
     * @param {string} type The name of the socket to use.
     * @param {object} options Optional. Configuration options for the socket.
     *
     * @return {object} The newly created socket object.
     *
     * @see SocketFactory
     */
    Socket.prototype.setSocketType = function(type, options) {
        if ('string' !== typeof type) {
            throw new TypeError('Socket.setSocketType: type must be string.');
        }
        if (options && 'object' !== typeof options) {
            throw new TypeError('Socket.setSocketType: options must be ' +
                                'object or undefined.');
        }
        this.socket = SocketFactory.get(this.node, type, options);

        if (!this.socket) {
            throw new Error('Socket.setSocketType: type not found: ' +
                            type + '.');
        }

        this.type = type;
        return this.socket;
    };

    /**
     * ### Socket.connect
     *
     * Calls the connect method on the actual socket object
     *
     * Uri is usually empty when using SocketDirect.
     *
     * @param {string} uri Optional. The uri to which to connect.
     * @param {object} options Optional. Configuration options for the socket.
     */
    Socket.prototype.connect = function(uri, options) {
        var humanReadableUri, that;

        if (this.isConnected()) {
            throw new Error('Socket.connect: socket is already connected. ' +
                            'Only one connection is allowed.');
        }
        if (this.connecting) {
            throw new Error('Socket.connecting: one connection attempt is ' +
                            'already in progress. Please try again later.');
        }
        if (uri && 'string' !== typeof uri) {
            throw new TypeError('Socket.connect: uri must be string or ' +
                                'undefined.');
        }
        if (options) {
            if ('object' !== typeof options) {
                throw new TypeError('Socket.connect: options must be ' +
                                    'object or undefined.');
            }
            this.userOptions = options;
        }

        humanReadableUri = uri || 'local server';

        if (!this.socket) {
            throw new Error('Socket.connet: cannot connet to ' +
                            humanReadableUri + ' . No socket defined.');
        }
        this.connecting = true;
        this.url = uri;
        this.node.info('connecting to ' + humanReadableUri + '.');
        this.node.emit('SOCKET_CONNECTING');
        this.socket.connect(this.url, this.userOptions);

        // Socket Direct might be already connected.
        if (this.connected) return;

        that = this;
        this.connectingTimeout = setTimeout(function() {
            that.node.warn('connection attempt to ' + humanReadableUri +
                           ' timed out. Disconnected.');
            that.socket.disconnect();
            that.connecting = false;
        }, this.connectingTimeoutMs);
    };

    /**
     * ### Socket.reconnect
     *
     * Calls the connect method with previous parameters
     *
     * @param {boolean} force Optional. Forces the process to continue
     *   even if a previous reconnection is in progress. Warning: can
     *   cause an infinite loop. Default: FALSE
     *
     * @see Socket.connect
     * @see Socket.disconnect
     */
    Socket.prototype.reconnect = function(force) {
        if (!this.url) {
            throw new Error('Socket.reconnect: cannot find previous uri.');
        }
        if (this.reconnecting && !force) {
            node.warn('Socket.reconnect: socket is already reconnecting. ' +
                     'Try with force parameter.');
            return;
        }
        this.reconnecting = true;
        if (this.connecting || this.isConnected()) this.disconnect();
        this.connect(this.url, this.userOptions);
        this.reconnecting = false;
    };

    /**
     * ### Socket.disconnect
     *
     * Calls the disconnect method on the actual socket object
     *
     * @param {boolean} force Forces to call the underlying
     *   `socket.disconnect` method even if socket appears not connected
     *   nor connecting at the moment.
     */
    Socket.prototype.disconnect = function(force) {
        if (!force && (!this.connecting && !this.isConnected())) {
            node.warn('Socket.disconnect: socket is not connected nor ' +
                      'connecting. Try with force parameter.');
            return;
        }
        this.socket.disconnect();
        this.connecting = false;
        this.connected = false;
    };

    /**
     * ### Socket.onConnect
     *
     * Handler for connections to the server
     *
     * @emit SOCKET_CONNECT
     */
    Socket.prototype.onConnect = function() {
        this.connected = true;
        this.connecting = false;
        if (this.connectingTimeout) clearTimeout(this.connectingTimeout);
        this.node.emit('SOCKET_CONNECT');

        // The testing framework expects this, do not remove.
        this.node.info('socket connected.');
    };

    /**
     * ### Socket.onDisconnect
     *
     * Handler for disconnections from the server
     *
     * Clears the player and monitor lists.
     *
     * @emit SOCKET_DISCONNECT
     */
    Socket.prototype.onDisconnect = function() {
        this.connected = false;
        this.connecting = false;
        this.node.emit('SOCKET_DISCONNECT');

        // Save the current stage of the game
        //this.node.session.store();

        // On re-connection will receive a new ones.
        this.node.game.pl.clear();
        this.node.game.ml.clear();

        // Restore original message handler.
        this.setMsgListener(this.onMessageHI);

        // Delete session.
        this.session = null;

        this.node.info('socket closed.');
    };

    /**
     * ### Socket.secureParse
     *
     * Parses a string representing a game msg into a game msg object
     *
     * Checks that the id of the session is correct.
     *
     * @param {string} msg The msg string as received by the socket.
     * @return {GameMsg|undefined} gameMsg The parsed msg, or
     *   undefined on error.
     */
    Socket.prototype.secureParse = function(msg) {
        var gameMsg;
        try {
            gameMsg = GameMsg.clone(JSON.parse(msg));
            this.node.info('R: ' + gameMsg);
        }
        catch(e) {
            return logSecureParseError.call(this, 'malformed msg received', e);
        }
        return gameMsg;
    };

    /**
     * ### Socket.validateIncomingMsg
     *
     * Checks whether an incoming message is valid.
     *
     * Checks that the id of the session is correct.
     *
     * @param {object} msg The msg object to check
     * @return {GameMsg|undefined} gameMsg The parsed msg, or
     *   undefined on error.
     */
    Socket.prototype.validateIncomingMsg = function(gameMsg) {
        if (this.session && gameMsg.session !== this.session) {
            return logSecureParseError.call(this, 'mismatched session in ' +
                                            'incoming message.');
        }
        return gameMsg;
    };

    /**
     * ### Socket.onMessageHI
     *
     * Initial handler for incoming messages from the server
     *
     * This handler will be replaced by the FULL handler, upon receiving
     * a HI message from the server.
     *
     * This method starts the game session, by creating a player object
     * with the data received by the server.
     *
     * @param {GameMsg} msg The game message received and parsed by a socket.
     *
     * @see Socket.validateIncomingMsg
     * @see Socket.startSession
     * @see Socket.onMessageFull
     * @see node.createPlayer
     */
    Socket.prototype.onMessageHI = function(msg) {
        msg = this.validateIncomingMsg(msg);
        if (!msg) return;

        // Parsing successful.
        if (msg.target === 'HI') {

            // Check if connection was authorized.
            if (msg.to === parent.constants.UNAUTH_PLAYER) {
                this.node.warn('connection was not authorized.');
                if (msg.text === 'redirect') {
                    if ('undefined' !== typeof window) {
                        window.location = msg.data;
                    }
                }
                else {
                    this.disconnect();
                }
                return;
            }

            // Replace itself: will change onMessage to onMessageFull.
            this.setMsgListener();

            // This will emit PLAYER_CREATED
            this.startSession(msg);
            // Functions listening to these events can be executed before HI.

            this.node.emit('NODEGAME_READY');
        }
    };

    /**
     * ### Socket.onMessageFull
     *
     * Full handler for incoming messages from the server
     *
     * All parsed messages are either emitted immediately or buffered,
     * if the game is not ready, and the message priority is low.x
     *
     * @param {GameMsg} msg The game message received and parsed by a socket.
     *
     * @see Socket.validateIncomingMsg
     * @see Socket.onMessage
     * @see Game.isReady
     */
    Socket.prototype.onMessageFull = function(msg) {
        msg = this.validateIncomingMsg(msg);
        if (!msg) return;

        // Message with high priority are executed immediately.
        if (msg.priority > 0 || this.node.game.isReady()) {
            this.node.emit(msg.toInEvent(), msg);
        }
        else {
            this.node.silly('B: ' + msg);
            this.buffer.push(msg);
        }
    };

    /**
     * ### Socket.onMessage
     *
     * Handler for incoming messages from the server
     *
     * @see Socket.onMessageHI
     * @see Socket.onMessageFull
     */
    Socket.prototype.onMessage = Socket.prototype.onMessageHI;

    /**
     * ### Socket.setMsgListener
     *
     * Sets the onMessage listener
     *
     * @param msgHandler {function} Optional. Callback function which is
     *  called for every message in the buffer instead of the messages
     *  being emitted.
     *  Default: Socket.onMessageFull
     *
     * @see this.node.emit
     * @see Socket.clearBuffer
     */
    Socket.prototype.setMsgListener = function(msgHandler) {
        if (msgHandler && 'function' !== typeof msgHandler) {
            throw new TypeError('Socket.setMsgListener: msgHandler must be a ' +
                                'function or undefined. Found: ' + msgHandler);
        }

        this.onMessage = msgHandler || this.onMessageFull;
    };

    /**
     * ### Socket.shouldClearBuffer
     *
     * Returns TRUE, if buffered messages can be emitted
     *
     * @see node.emit
     * @see Socket.clearBuffer
     * @see Game.isReady
     */
    Socket.prototype.shouldClearBuffer = function() {
        return this.node.game.isReady();
    };

    /**
     * ### Socket.clearBuffer
     *
     * Emits and removes all the events in the message buffer
     *
     * @param msgHandler {function} Optional. Callback function which is
     *  called for every message in the buffer instead of the messages
     *  being emitted.
     *  Default: Emit every buffered message.
     *
     * @see node.emit
     * @see Socket.shouldClearBuffer
     */
    Socket.prototype.clearBuffer = function(msgHandler) {
        var nelem, msg, i;
        var funcCtx, func;

        if (msgHandler) {
            funcCtx = this.node.game;
            func = msgHandler;
        }
        else {
            funcCtx = this.node.events;
            func = this.node.events.emit;
        }

        nelem = this.buffer.length;
        for (i = 0; i < nelem; i++) {
            // Modify the buffer at every iteration, so that if an error
            // occurs, already emitted messages are out of the way.
            msg = this.buffer.shift();
            if (msg) {
                func.call(funcCtx, msg.toInEvent(), msg);
                this.node.silly('D: ' + msg);
            }
        }
    };

    /**
     * ### Socket.eraseBuffer
     *
     * Removes all messages currently in the buffer
     *
     * This operation is not reversible
     *
     * @see Socket.clearBuffer
     */
    Socket.prototype.eraseBuffer = function() {
        this.buffer = [];
    };

    /**
     * ### Socket.startSession
     *
     * Initializes a nodeGame session
     *
     * Creates a the player and saves it in node.player, and
     * stores the session ids in the session object.
     *
     * If a game window reference is found, sets the `uriChannel` variable.
     *
     * @param {GameMsg} msg A game-msg
     * @param {boolean} force If TRUE, a new session will be created even
     *    if an existing one is found.
     *
     * @see node.createPlayer
     * @see Socket.registerServer
     * @see GameWindow.setUriChannel
     */
    Socket.prototype.startSession = function(msg, force) {
        if (this.session && !force) {
            throw new Error('Socket.startSession: session already existing. ' +
                            'Use force parameter to overwrite it.');
        }

        // We need to first set the session,
        // and then eventually stop an ongoing game.
        this.session = msg.session;
        if (this.node.game.isStoppable()) this.node.game.stop();

        // Channel name and create player.
        this.channelName = msg.data.channel.name;
        this.node.createPlayer(msg.data.player);

        // Set anti-spoofing as requested by server.
        if (msg.data.antiSpoofing) {
            if (this.socket.enableAntiSpoofing) {
                this.antiSpoofing = true;
                this.socket.enableAntiSpoofing(true);
            }
            else {
                this.node.log('Socket.startSession: server requested anti-' +
                              'spoofing, but socket does not support it.');
            }
        }

        // Notify GameWindow (if existing, and if not default channel).
        if (this.node.window && !msg.data.channel.isDefault) {
            this.node.window.setUriChannel(this.channelName);
        }
    };

    /**
     * ### Socket.isConnected
     *
     * Returns TRUE if socket connection is ready.
     */
    Socket.prototype.isConnected = function() {
        return this.socket && this.socket.isConnected();
    };

    /**
     * ### Socket.send
     *
     * Pushes a message into the socket
     *
     * The msg is actually received by the client itself as well.
     *
     * @param {GameMsg} msg The game message to send
     *
     * @return {boolean} TRUE on success
     *
     * @see GameMsg
     *
     * TODO: when trying to send a message and the socket is not connected
     * the message is just discarded. Outgoing messages could be buffered
     * and sent out whenever the connection is available again.
     */
    Socket.prototype.send = function(msg) {
        var outEvent;

        if (!msg.from || msg.from === this.node.UNDEFINED_PLAYER) {
            this.node.err('Socket.send: sender id not initialized, ' +
                          'message not sent');
            return false;
        }

        if (!this.isConnected()) {
            this.node.err('Socket.send: no open socket, ' +
                          'message not sent');

            // TODO: test this
            // this.outBuffer.push(msg);
            return false;
        }

        // TODO: test this
        // if (!this.node.game.isReady()) {
        //     this.outBuffer.push(msg);
        //     return false;
        // }

        // Emit out event, if required.
        if (this.emitOutMsg) {
            outEvent = msg.toOutEvent();
            this.node.events.ee.game.emit(outEvent, msg);
            this.node.events.ee.stage.emit(outEvent, msg);
            this.node.events.ee.step.emit(outEvent, msg);
        }

        this.socket.send(msg);
        this.node.info('S: ' + msg);

        // TODO: check this.
        // Experimental code.
        if (this.journalOn) {
            // Only Game messages are stored.
            if (this.node.game.isReady()) this.journal.insert(msg);
        }
        // End experimental code.

        return true;
    };

    // Helper methods.

    function logSecureParseError(text, e) {
        var error;
        text = text || 'generic error while parsing a game message.';
        error = (e) ? text + ": " + e : text;
        this.node.err('Socket.secureParse: ' + error);
        return false;
    }

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # SocketIo
 * Copyright(c) 2018 Stefano Balietti
 * MIT Licensed
 *
 * Remote communication through Socket.IO
 *
 * This file requires that the socket.io library is already loaded before
 * nodeGame is loaded to work (see closure).
 */
(function(exports, node, io) {

    // io is undefined in Node.JS because
    // module.parents.exports.io does not exist.

    // ## Global scope

    var J = node.JSUS;

    exports.SocketIo = SocketIo;

    /**
     * ## SocketIo constructor
     *
     * Creates a new instance of SocketIo
     *
     * @param {NodeGameClient} node Reference to the node instance
     */
    function SocketIo(node) {

        // ## Private properties

        /**
         * ### SocketIo.node
         *
         * Reference to the node object.
         */
        this.node = node;

        /**
         * ### Socket.socket
         *
         * Reference to the actual socket-io socket created on connection
         */
        this.socket = null;
    }

    /**
     * ### SocketIo.connect
     *
     * Establishes a socket-io connection with a server
     *
     * Sets the on: 'connect', 'message', 'disconnect' event listeners.
     *
     * @param {string} url The address of the server channel
     * @param {object} options Optional. Configuration options
     */
    SocketIo.prototype.connect = function(url, options) {
        var node, socket;
        node = this.node;

        if ('string' !== typeof url) {
            throw TypeError('SocketIO.connect: url must be string.');
        }

        // See https://github.com/Automattic/socket.io-client/issues/251
        J.mixin(options, { 'force new connection': true });

        socket = io.connect(url, options); //conf.io

        socket.on('connect', function() {
            node.info('socket.io connection open');
            node.socket.onConnect.call(node.socket);
            socket.on('message', function(msg) {
                msg = node.socket.secureParse(msg);
                if (msg) {
                    node.socket.onMessage(msg);
                }
            });
        });

        socket.on('disconnect', function() {
            node.socket.onDisconnect.call(node.socket);
        });

        this.socket = socket;

        return true;
    };

    /**
     * ### SocketIo.disconnect
     *
     * Triggers the disconnection from a server
     */
    SocketIo.prototype.disconnect = function() {
        this.socket.disconnect();
    };

    /**
     * ### SocketIo.isConnected
     *
     * Returns TRUE, if currently connected
     */
    SocketIo.prototype.isConnected = function() {
        return this.socket && this.socket.connected;
    };

    /**
     * ### SocketIo.sendEasy
     *
     * Stringifies and send a message through the socket-io socket
     *
     * @param {object} msg Object implementing a stringify method. Usually,
     *    a game message.
     *
     * @see GameMessage
     */
    SocketIo.prototype.sendEasy = function(msg) {
        this.socket.send(msg.stringify());
    };

    /**
     * ### SocketIo.sendNoSpoof
     *
     * Like SocketIo.sendEasy, but it adds the sid to the message.
     *
     * @param {object} msg Object implementing a stringify method. Usually,
     *    a game message.
     *
     * @see SocketIo.sendEasy
     */
    SocketIo.prototype.sendNoSpoof = function(msg) {
        // Add socket id to prevent spoofing.
        msg.sid = this.node.player.strippedSid;
        this.socket.send(msg.stringify());
    };

    /**
     * ### SocketIo.send
     *
     * Generic function to send a message through the socket-io socket
     *
     * @param {object} msg Object implementing a stringify method. Usually,
     *    a game message.
     *
     * @see GameMessage
     * @see SocketIo.sendEasy
     * @see SocketIo.sendNoSpoof
     */
    SocketIo.prototype.send = SocketIo.prototype.sendEasy;

    /**
     * ### SocketIo.enableAntiSpoofing
     *
     * Adds/removes no-spoof signature from messages
     *
     * @param {boolean} value TRUE to enable, FALSE to disable
     *
     * @see SocketIo.sendEasy
     * @see SocketIo.sendNoSpoof
     */
    SocketIo.prototype.enableAntiSpoofing = function(value) {
        if (value) this.send = this.sendNoSpoof;
        else this.send = this.sendEasy;
    };

    node.SocketFactory.register('SocketIo', SocketIo);

})(
    'undefined' !== typeof node ? node : module.exports,
    'undefined' !== typeof node ? node : module.parent.exports,
    'undefined' !== typeof module && 'undefined' !== typeof require ?
        require('socket.io-client') : 'undefined' !== typeof io ? io : {}
);

/**
 * # Roler
 * Copyright(c) 2017 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Handles assigning roles to matches.
 *
 * Currently only supports assigning roles to matches of size 2.
 */
(function(exports, parent) {

    "use strict";

    // TODO: have x, y indexes like in Matcher?

    // ## Global scope
    var J = parent.JSUS;

    exports.Roler = Roler;

    // ## Static methods.

    /**
     * ### Roler.linearRolifier
     *
     * Applies roles to a single match
     *
     * This is the default callback copied over `Matcher.rolify`.
     *
     * @param {array} A match array containing two valid ids, or
     *   one id and a 'missing-id'
     *
     * @return {array} roles An array containing the roles for the match.
     *   Missing ids will receive an undefined role
     *
     * @see Roler.rolify
     * @see Roler.setRolifyCb
     */
    Roler.linearRolifier = function(match, x, y) {
        var roles, len;
        var id1, id2, soloIdx;
        len = match.length;
        if (!len) {
            throw new Error('Roler.rolify: match must be a non empty array. ' +
                            'Found: ' + match);
        }
        id1 = match[0];
        id2 = match[1];
        roles = new Array(len);
        if (id1 !== this.missingId && id2 !== this.missingId) {
            this.setRoleFor(id1, this.rolesArray[0], x);
            this.setRoleFor(id2, this.rolesArray[1], x);
            roles = [ this.rolesArray[0], this.rolesArray[1] ];
        }
        else {
            if (!this.rolesArray[2]) {
                throw new Error('Roler.rolify: role3 required, but not found.');
            }
            soloIdx = (id1 === this.missingId) ? 1 : 0;
            this.setRoleFor(match[soloIdx], this.rolesArray[2], x);
            roles[soloIdx] = this.rolesArray[2];
        }
        return roles;
    };

    /**
     * ## Roler constructor
     *
     * Creates a new instance of role mapper
     */
    function Roler() {

        /**
         * ### Roler.roles
         *
         * List of all available roles
         *
         * @see Roler.setRoles
         */
        this.roles = {};

        /**
         * ### Roler.rolesArray
         *
         * The array of currently available roles
         *
         * @see Roler.setRoles
         * @see Roler.clear
         */
        this.rolesArray = [];

        /**
         * ### Roler.rolifiedMatches
         *
         * Array of arrays of roles assigned for all matches in all rounds
         *
         * For example:
         * ```javascript
         * [
         *     // Round 1.
         *     [  [ 'ROLE_A', 'ROLE_B' ], [ 'ROLE_A', 'ROLE_B' ], ... ],
         *     // Round 2.
         *     [  [ 'ROLE_A', 'ROLE_B' ], [ 'ROLE_A', 'ROLE_B' ], ... ],
         *     ...
         * ]
         * ```
         *
         * @see Roler.rolifyAll
         * @see Roler.setRolifiedMatches
         */
        this.rolifiedMatches = null;

        /**
         * ### Roler.role2IdMatches
         *
         * Array of arrays of maps role to id/s for all matches in all rounds
         *
         * For example:
         * ```javascript
         * [
         *     [ { ROLE_A: 'ID1', ROLE_B: 'ID2' }, ... ], // Round 1.
         *     [ { ROLE_A: [ 'ID1', 'ID2' ] }, ... ], // Round 2.
         *     ...
         * ]
         * ```
         *
         * @see Roler.rolifyAll
         * @see Roler.setRolifiedMatches
         */
        this.role2IdMatches = null;

        /**
         * ### Roler.id2RoleMatches
         *
         * Array of arrays of maps id to role for all matches in all rounds
         *
         * For example:
         * ```javascript
         * [
         *     [ { ID1: 'ROLE_A', ID2: 'ROLE_B' }, ... ], // Round 1.
         *     [ { ID1: 'ROLE_A', ID2: 'ROLE_A' }, ... ], // Round 2.
         *     ...
         * ]
         * ```
         *
         * @see Roler.rolifyAll
         * @see Roler.setRolifiedMatches
         */
        this.id2RoleMatches = null;

        /**
         * ### Roler.role2IdRoundMap
         *
         * Array of maps of role to id/s per each round
         *
         * For example:
         * ```javascript
         * [
         *     // Round 1.
         *     [ { ROLE_A: [ 'ID1', 'ID3', ... ], ROLE_B: 'ID2', ... } ],
         *     // Round 2.
         *     [ { ROLE_A: [ 'ID1', 'ID2', ... ], ROLE_B: 'ID3', ... } ],
         *     ...
         * ]
         * ```
         */
        this.role2IdRoundMap = [];

        /**
         * ### Roler.rolify
         *
         * Callback that assigns roles to a single match
         *
         * @see Roler.linearRolifier
         */
        this.rolify = Roler.linearRolifier;

        /**
         * ### Roler.missingId
         *
         * The id indicating a skipped match (i.e. a bye in a match)
         *
         * @see Matcher.missingId
         */
        this.missingId = 'bot';
    }

    // ## Init/clear.

    /**
     * ### Roler.init
     *
     * Inits the Roler instance
     *
     * @param {object} options
     */
    Roler.prototype.init = function(options) {
        options = options || {};
        if (options.rolifyCb) this.setRolifyCb(options.rolifyCb);
        if (options.roles) this.setRoles(options.roles);
        if (options.missingId) this.missingId = options.missingId;
    };

    /**
     * ### Roler.clear
     *
     * Clears all roles lists
     */
    Roler.prototype.clear = function() {
        this.roles = {};
        this.rolesArray = [];
        this.id2RoleRoundMap = [];
        this.role2IdRoundMap = [];
        this.rolifiedMatches = null;
        this.role2IdMatches = null;
        this.id2RoleMatches = null;
    };

    // ## Setters.

    /**
     * ### Roler.setRolifyCb
     *
     * Sets the callback assigning the roles
     *
     * The callback takes as input a match array, and optionally its
     * x and y coordinates in the array of matches.
     *
     * @param {function} cb The rolifier cb
     *
     * @see Roler.rolify
     */
    Roler.prototype.setRolifyCb = function(cb) {
        if ('function' !== typeof cb) {
            throw new TypeError('Roler.setRolifyCb: cb must be function. ' +
                                'Found: ' + cb);
        }
        this.rolify = cb;
    };

    /**
     * ### Roler.setRoles
     *
     * Validates and sets the roles
     *
     * @param {array} roles Array of roles (string)
     * @param {number} min At least _min_ roles must be specified. Default: 2
     * @param {number} max At least _max_ roles must be specified. Default: inf
     *
     * @see Roler.setRoles
     * @see Roler.clear
     */
    Roler.prototype.setRoles = function(roles, min, max) {
        var rolesObj, role;
        var i, len;
        var err;

        // Clear previousd data.
        this.clear();

        if (min && 'number' !== typeof min || min < 2) {
            throw new TypeError('Roler.setRoles: min must be a ' +
                                'number > 2 or undefined. Found: ' + min);
        }
        min = min || 2;

        if (max && 'number' !== typeof max || max < min) {
            throw new TypeError('Roler.setRoles: max must ' +
                                'be number or undefined. Found: ' + max);
        }

        // At least two roles must be defined
        if (!J.isArray(roles)) {
            throw new TypeError('Roler.setRoles: roles must ' +
                                'be array. Found: ' + roles);
        }

        len = roles.length;
        // At least two roles must be defined
        if (len < min || len > max) {
            err = 'Roler.setRoles: roles must contain at least ' +
                min + ' roles';
            if (max) err += ' and no more than ' + max;
            err += '. Found: ' + len;
            throw new Error(err);
        }

        rolesObj = {};
        i = -1;
        for ( ; ++i < len ; ) {
            role = roles[i];
            if ('string' !== typeof role || role.trim() === '') {
                throw new TypeError('Roler.setRoles: each role ' +
                                    'must be a non-empty string. Found: ' +
                                    role);
            }
            rolesObj[role] = true;
        }
        // All data validated.
        this.roles = rolesObj;
        this.rolesArray = roles;
    };

    /**
     * ### Roler.setRoleFor
     *
     * Sets a role for the given id at the specified round
     *
     * @param {string} id The id of a player
     * @param {string} role A valid role for the id
     * @param {number} x The x-th round the role is being set for
     *
     * @see Roler.id2RoleRoundMap
     * @see Roler.role2IdRoundMap
     */
    Roler.prototype.setRoleFor = function(id, role, x) {
        if ('string' !== typeof id) {
            throw new TypeError('Roler.setRoleFor: id must be string. Found: ' +
                                id);
        }
        if ('string' !== typeof role) {
            throw new TypeError('Roler.setRoleFor: role must be string. ' +
                                'Found: ' + role);
        }
        if (!this.roles[role]) {
            throw new Error('Roler.setRoleFor: unknown role: ' + role);
        }
        if ('number' !== typeof x || x < 0 || isNaN(x)) {
            throw new TypeError('Roler.setRoleFor: x must be a non-negative ' +
                                'number. Found: ' + x);
        }
        // Id to role.
        if (!this.id2RoleRoundMap[x]) this.id2RoleRoundMap[x] = {};
        this.id2RoleRoundMap[x][id] = role;

        // Role to id.
        if (!this.role2IdRoundMap[x]) this.role2IdRoundMap[x] = {};
        if (!this.role2IdRoundMap[x][role]) this.role2IdRoundMap[x][role] = [];
        this.role2IdRoundMap[x][role].push(id);
    };

    /**
     * ### Roler.setRolifiedMatches
     *
     * Sets a preinited array of rolified matches
     *
     * @param {array} rolifiedMatches The rolified matches
     * @param {boolean} validate Optional. Boolean flag to
     *   turn on/off validation. Default: TRUE
     *
     * @see Roler.rolifiedMatches
     */
    Roler.prototype.setRolifiedMatches = function(rolifiedMatches, validate) {
        var i, len;
        var j, lenJ;
        if ('undefined' === typeof validate || !!validate) {
            if (!J.isArray(rolifiedMatches) || !rolifiedMatches.length) {
                throw new Error('Roler.setRolifiedMatches: rolifiedMatches ' +
                                'must be a non-empty array. Found: ' +
                                rolifiedMatches);
            }
            i = -1, len = rolifiedMatches.length;
            for ( ; ++i < len ; ) {
                i = -1, lenJ = rolifiedMatches[i].length;
                if (!lenJ) {
                    throw new Error('Roler.setRolifiedMatches: ' +
                                    'rolifiedMatches round ' + i +
                                    'has no elements.');
                }
                for ( ; ++i < lenJ ; ) {
                    if (!J.isArray(rolifiedMatches[i][j])) {
                        throw new Error('Roler.setRolifiedMatches: ' +
                                        'rolifiedMatches round ' + i +
                                        ' element ' + j +
                                        ' should be array. Found: ' +
                                        rolifiedMatches[i][j]);
                    }
                    // These are specific to the rolify cb.
                    if (rolifiedMatches[i][j].length !== 2) {
                        throw new Error('Roler.setRolifiedMatches: roles (' +
                                        i + ',' + j + ') was expected to have' +
                                        ' length 2: ' + rolifiedMatches[i][j]);
                    }
                    if ('string' !== typeof rolifiedMatches[i][j][0] ||
                        'string' !== typeof rolifiedMatches[i][j][1] ||
                        rolifiedMatches[i][j][0].trim() === '' ||
                        rolifiedMatches[i][j][1].trim() === '') {

                        throw new Error('Roler.setRolifiedMatches: roles (' +
                                        i + ',' + j + ') has invalid ' +
                                        'elements: ' + rolifiedMatches[i][j]);
                    }
                }

            }
        }
        this.rolifiedMatches = rolifiedMatches;
    };

    /**
     * ### Roler.setRole2IdMatches
     *
     * Sets a preinited array of role to id/s matches
     *
     * @param {array} matches The role to id/s matches
     * @param {boolean} validate Optional. Boolean flag to
     *   turn on/off validation. Default: TRUE
     *
     * @see Roler.rolifiedMatches
     */
    Roler.prototype.setRole2IdMatches = function(matches, validate) {
        if ('undefined' === typeof validate || !!validate) {
            validateRoleIdMatches('setRole2IdMatches', matches);
        }
        this.role2IdMatches = matches;
    };

    /**
     * ### Roler.setId2RoleMatches
     *
     * Sets a preinited array of id to role matches
     *
     * @param {array} matches The roles-obj matches
     * @param {boolean} validate Optional. Boolean flag to
     *   turn on/off validation. Default: TRUE
     *
     * @see Roler.id2RoleMatches
     */
    Roler.prototype.setId2RoleMatches = function(matches, validate) {
        if ('undefined' === typeof validate || !!validate) {
            validateRoleIdMatches('setId2RoleMatches', matches);
        }
        this.id2RoleMatches = matches;
    };

    // ## Getters.

    /**
     * ### Roler.getRoleFor
     *
     * Returns the role hold by an id at round x
     *
     * @param {string} id The id to check
     * @param {number} x The round to check
     *
     * @return {string|null} The role currently hold, or null
     *    if the id is not found
     *
     * @see Roler.id2RoleRoundMap
     */
    Roler.prototype.getRoleFor = function(id, x) {
        if ('string' !== typeof id) {
            throw new TypeError('Roler.getRoleFor: id must be string. Found: ' +
                                id);
        }
        if ('number' !== typeof x || x < 0 || isNaN(x)) {
            throw new TypeError('Roler.getRoleFor: x must be a non-negative ' +
                                'number. Found: ' + x);
        }
        return this.id2RoleRoundMap[x][id] || null;
    };

    /**
     * ### Roler.getIdForRole
     *
     * Returns the id/s holding the specified role at round x
     *
     * @param {string} role The role
     * @param {number} x The round
     *
     * @return {array} Array of id/s holding the role at round x
     *
     * @see Roler.role2IdRoundMap
     */
    Roler.prototype.getIdForRole = function(role, x) {
        if ('string' !== typeof role) {
            throw new TypeError('Roler.getIdForRole: role must be string. ' +
                                'Found: ' + role);
        }
        if ('number' !== typeof x || x < 0 || isNaN(x)) {
            throw new TypeError('Roler.getIdForRole: x must be a ' +
                                'non-negative number. Found: ' + x);
        }
        return this.role2IdRoundMap[x][role] || [];
    };

    /**
     * ### Roler.getRolifiedMatches
     *
     * Returns all matched roles
     *
     * @return {array} The matched roles
     *
     * @see Roler.rolifiedMatches
     */
    Roler.prototype.getRolifiedMatches = function() {
        return this.rolifiedMatches;
    };

    /**
     * ### Roler.getRoleMatch
     *
     * Returns the requested roles
     *
     * @param {number} x The round of the roles
     * @param {number} y Optional. The y-th role within round x
     *
     * @return {array|null} The requested role matches or null
     *    if the x or y indexes are out of bounds
     *
     * @see Roler.rolifiedMatches
     */
    Roler.prototype.getRoleMatch = function(x, y) {
        if ('number' !== typeof x || x < 0 || isNaN(x)) {
            throw new TypeError('Roler.getRoleMatch: x must be a ' +
                                'non-negative number. Found: ' + x);
        }
        if ('undefined' === typeof y) {
            return this.rolifiedMatches[x] || null;
        }
        if ('number' !== typeof y || y < 0 || isNaN(y)) {
            throw new TypeError('Roler.getRoleMatch: y must be undefined or ' +
                                'a non-negative number. Found: ' + y);
        }
        return this.rolifiedMatches[x][y] || null;
    };

    /**
     * ### Roler.getRole2IdMatch
     *
     * Returns the requested role to id matches
     *
     * @param {number} x The round of the roles
     * @param {number} y Optional. The y-th role within round x
     *
     * @return {array|object|null} The role to id/s matches or null
     *    if the x or y indexes are out of bounds
     *
     * @see Roler.role2IdRoundMatch
     */
    Roler.prototype.getRole2IdMatch = function(x, y) {
        if ('number' !== typeof x || x < 0 || isNaN(x)) {
            throw new TypeError('Roler.getRole2IdMatch: x must be a ' +
                                'non-negative number. Found: ' + x);
        }
        if ('undefined' === typeof y) {
            return this.role2IdMatches[x] || null;
        }
        if ('number' !== typeof y || y < 0 || isNaN(y)) {
            throw new TypeError('Roler.getRole2IdMatch: y must be a ' +
                                'non-negative number. Found: ' + y);
        }
        return this.role2IdMatches[x][y] || null;
    };

    /**
     * ### Roler.getId2RoleMatch
     *
     * Returns the requested id to role matches
     *
     * @param {number} x The round of the roles
     * @param {number} y Optional. The y-th role within round x
     *
     * @return {array|object|null} The id to role matches or null
     *    if the x or y indexes are out of bounds
     *
     * @see Roler.rolifiedMatches
     */
    Roler.prototype.getId2RoleMatch = function(x, y) {
        if ('number' !== typeof x || x < 0 || isNaN(x)) {
            throw new TypeError('Roler.getId2RoleMatch: x must be a ' +
                                'non-negative number. Found: ' + x);
        }
        if ('undefined' === typeof y) {
            return this.id2RoleMatches[x] || null;
        }
        if ('number' !== typeof y || y < 0 || isNaN(y)) {
            throw new TypeError('Roler.getId2RoleMatch: y must be a ' +
                                'non-negative number. Found: ' + y);
        }
        return this.id2RoleMatches[x][y] || null;
    };

    /**
     * ### Roler.getRole2IdRoundMap
     *
     * Returns the requested role to id/s mapping
     *
     * @param {number} x The round
     *
     * @return {object|null} The role to id/s map or null
     *    if x is out of bounds
     *
     * @see Roler.role2IdRoundMap
     */
    Roler.prototype.getRole2IdRoundMap = function(x) {
        if ('number' !== typeof x || x < 0 || isNaN(x)) {
            throw new TypeError('Roler.getRole2IdRoundMap: x must be a ' +
                                'non-negative number. Found: ' + x);
        }
        return this.role2IdRoundMap[x] || null;
    };

    /**
     * ### Roler.getId2RoleRoundMap
     *
     * Returns the requested id to role mapping
     *
     * @param {number} x The round
     *
     * @return {object|null} The role-to-id map or null
     *    if x is out of bounds
     *
     * @see Roler.id2RoleRoundMap
     */
    Roler.prototype.getId2RoleRoundMap = function(x) {
        if ('number' !== typeof x || x < 0 || isNaN(x)) {
            throw new TypeError('Roler.getId2RoleRoundMap: x must be a ' +
                                'non-negative number. Found: ' + x);
        }
        return this.id2RoleRoundMap[x] || null;
    };

    // ## Rolify.

    /**
     * ### Roler.rolifyAll
     *
     * Applies roles to all matches
     *
     * @param {array} Array of array of matches
     *
     * @return {array} rolifiedMatches The full maps of roles
     *
     * @see Roler.rolifiedMatches
     * @see Roler.role2IdMatches
     * @see Roler.id2RoleMatches
     */
    Roler.prototype.rolifyAll = function(matches) {
        var i, len, j, lenJ, row, rolifiedMatches;
        var r1, r2, rolesObj, idRolesObj;

        if (!J.isArray(matches) || !matches.length) {
            throw new Error('Roler.rolifyAll: match must be a non empty ' +
                            'array. Found: ' + matches);
        }
        i = -1, len = matches.length;
        rolifiedMatches = new Array(len);
        rolesObj = new Array(len);
        idRolesObj = new Array(len);
        for ( ; ++i < len ; ) {
            row = matches[i];
            j = -1, lenJ = row.length;
            rolifiedMatches[i] = new Array(lenJ);
            rolesObj[i] = new Array(lenJ);
            idRolesObj[i] = new Array(lenJ);
            for ( ; ++j < lenJ ; ) {
                rolifiedMatches[i][j] = this.rolify(row[j], i, j);
                // TODO: this code is repeated in Matcher.match, make it one!
                r1 = rolifiedMatches[i][j][0];
                r2 = rolifiedMatches[i][j][1];
                rolesObj[i][j] = {};
                if (r1 !== r2) {
                    rolesObj[i][j][r1] = row[j][0];
                    rolesObj[i][j][r2] = row[j][1];
                }
                else {
                    rolesObj[i][j][r1] = [ row[j][0], row[j][1] ];
                }
                idRolesObj[i][j] = {};
                idRolesObj[i][j][row[j][0]] = r1;
                idRolesObj[i][j][row[j][1]] = r2;
            }
        }
        this.rolifiedMatches = rolifiedMatches;
        this.role2IdMatches = rolesObj;
        this.id2RoleMatches = idRolesObj;

        return rolifiedMatches;
    };

    // ## Checkings.

    /**
     * ### Roler.roleExists
     *
     * Returns TRUE if the requested role exists
     *
     * @param {string} role The role to check
     *
     * @see Roler.roles
     */
    Roler.prototype.roleExists = function(role) {
        if ('string' !== typeof role || role.trim() === '') {
            throw new TypeError('Roler.roleExists: role must be ' +
                                'a non-empty string. Found: ' + role);
        }
        return !!this.roles[role];
    };

    /**
     * ### Roler.hasRole
     *
     * Returns TRUE if a given id is holding the specified role at round x
     *
     * @param {string} id The id to check
     * @param {string} role The role to check
     * @param {number} x The round to check
     *
     * @return {boolean} True if id has given role
     *
     * @see Roler.id2RoleRoundMap
     */
    Roler.prototype.hasRole = function(id, role, x) {
        if ('string' !== typeof id) {
            throw new TypeError('Roler.hasRole: id must be string. Found: ' +
                                id);
        }
        if ('string' !== typeof role) {
            throw new TypeError('Roler.hasRole: role must be string. Found: ' +
                                role);
        }
        if ('number' !== typeof x || x < 0 || isNaN(x)) {
            throw new TypeError('Roler.hasRole: x must be a non-negative ' +
                                'number. Found: ' + x);
        }
        return this.id2RoleRoundMap[x][id] === role;
    };

    // ## Edit/Replace.

    /**
     * ### Roler.replaceId
     *
     * Replaces an id with a new one in all roles
     *
     * @param {string} oldId The id to be replaced
     * @param {string} newId The replacing id
     *
     * @return {boolean} TRUE, if the oldId was found and replaced
     *
     * @see MatcherManager.replaceId
     * @see Matcher.replaceId
     */
    Roler.prototype.replaceId = function(oldId, newId) {
        var m, n;
        var i, len, j, lenJ, h, lenH, k, lenK;
        var rowFound;
        var tmp, role;

        if ('string' !== typeof oldId) {
            throw new TypeError('Roler.replaceId: oldId should be string. ' +
                                'Found: ' + oldId);
        }
        if ('string' !== typeof newId && newId.trim() !== '') {
            throw new TypeError('Roler.replaceId: newId should be a ' +
                                'non-empty string. Found: ' + newId);
        }

        // No id was assigned yet.
        if (!this.id2RoleMatches) return false;

        // Update id2RoleMatches and role2IdMatches at the same time.
        m = this.id2RoleMatches;
        n = this.role2IdMatches;

        i = -1, len = m.length;
        for ( ; ++i < len ; ) {
            j = -1, lenJ = m[i].length;
            // If it was not found in the previous row, return FALSE.
            if (j > 0 && !rowFound) return false;
            for ( ; ++j < lenJ ; ) {
                rowFound = false;
                for (h in m[i][j]) {
                    if (m[i][j].hasOwnProperty(h)) {
                        if (h === oldId) {
                            role = m[i][j][oldId];
                            m[i][j][newId] = role;
                            delete m[i][j][oldId];
                            rowFound = true;

                            // All ids in match with same role.
                            tmp = n[i][j][role];

                            // If it is an array, try to optimize replacement.
                            if (J.isArray(tmp)) {
                                lenK = tmp.length;
                                if (lenK === 1) {
                                    tmp[0] = newId;
                                }
                                else if (lenK === 2) {
                                    if (tmp[0] === oldId) tmp[0] = newId;
                                    else tmp[1] = newId;
                                }
                                else {
                                    k = -1;
                                    for ( ; ++k < lenK ; ) {
                                        if (tmp[k] === oldId) {
                                            tmp[k] = newId;
                                            break;
                                        }
                                    }
                                }
                            }
                            else {
                                n[i][j][role] = newId;
                            }

                            break;
                        }
                    }
                }
                if (rowFound) break;
            }
        }

        // Update id2RoleRoundMap and role2IdRoundMap at the same time.
        m = this.id2RoleRoundMap;
        n = this.role2IdRoundMap;

        i = -1, len = m.length;
        for ( ; ++i < len ; ) {
            rowFound = false;
            for (j in m[i]) {
                if (m[i].hasOwnProperty(j)) {
                    if (j === oldId) {
                        m[i][newId] = m[i][oldId];
                        delete m[i][oldId];
                        rowFound = true;

                        // All ids with same role at same round.
                        tmp = n[i][m[i][newId]];

                        lenH = tmp.length;
                        if (lenH === 1) {
                            tmp[0] = newId;
                        }
                        else {
                            h = -1;
                            for ( ; ++h < len ; ) {
                                if (tmp[h] === oldId) {
                                    tmp[h] = newId;
                                    break;
                                }
                            }
                        }

                    }
                }
                if (rowFound) break;
            }
        }

        return true;
    };

    // ## Helper methods.

    /**
     * ### validateRoleIdMatches
     *
     * Deep validates role-id or id-role matches (object type), throws errors
     *
     * Validation:
     *
     *  - The map is an array of objects
     *  - Each object must have two info-items.
     *  - An info-item can contain:
     *      a) 2 keys-valus pairs (id-role|role-id), or
     *      b) an array of length 2 (role: id1, id2) [allowed only if
     *         invoking method is 'setRole2IdMatches']
     *
     * @param {string} method The name of the method invoking validation
     * @param {array} matches The matches to validate
     *
     * @see validString
     * @see setRole2IdMatches
     * @see setId2RoleMatches
     */
    function validateRoleIdMatches(method, matches) {
        var i, len;
        var j, lenJ;
        var k, nKeys;
        var arrayOk, elem, isArray;

        if (!J.isArray(matches) || !matches.length) {
            throw new Error('Roler.' + method + ': matches must be a ' +
                            'non-empty array. Found: ' + matches);
        }
        arrayOk = (method === 'setRole2IdMatches') ? true : false;
        i = -1, len = matches.length;
        for ( ; ++i < len ; ) {
            i = -1, lenJ = matches[i].length;
            if (!lenJ) {
                throw new Error('Roler.' + method + ': matches round ' +
                                i + 'has no elements.');
            }
            for ( ; ++i < lenJ ; ) {
                if ('object' !== typeof matches[i][j]) {
                    throw new Error('Roler.' + method + ': matches ' +
                                    'round ' + i + ' element ' + j +
                                    ' should be object. Found: ' +
                                    matches[i][j]);
                }

                nKeys = 0;
                isArray = false;
                for (k in matches[i][j]) {
                    if (matches[i][j].hasOwnProperty(k)) {
                        nKeys++;
                        if (k.trim() === '') {
                            throw new Error('Roler.' + method + ': ' +
                                            'roles matches (' + i + ',' + j +
                                            ') has invalid key: ' + k);
                        }
                        elem = matches[i][j][k];
                        if (arrayOk && J.isArray(elem)) {
                            isArray = true;
                            if (elem.length !== 2) {
                                throw new Error('Roler.' + method + ': ' +
                                                'roles matches (' + i + ',' +
                                                j + ', ' + k + ') has ' +
                                                'invalid length: ' + elem);
                            }
                            validString(method, elem[0], i, j, k);
                            validString(method, elem[1], i, j, k);
                        }
                        else {
                            validString(method, elem, i, j, k);
                        }
                    }
                }
                // These are specific to the rolify cb.
                if ((isArray && nKeys !== 1) || (!isArray && nKeys !== 2)) {
                    throw new Error('Roler.' + method + ': roles matches (' +
                                    i + ',' + j + ') was expected to have ' +
                                    '2 elements in total. Found: ' +
                                    matches[i][j]);
                }
            }
        }
    }

    /**
     * ### validString
     *
     * Validates the content of role/id or id/role match, throws errors
     *
     * @param {string} method The name of the method invoking validation
     * @param {mixed} elem The element to validate (should
     *    be non-empty string: id or role)
     * @param {number} i The i-th round in the matches array
     * @param {number} j The j-th match at round i-th in the matches array
     * @param {string} k The name of the key containig mapping to elem
     *
     * @see validString
     */
    function validString(method, elem, i, j, k) {
        if ('string' !== typeof elem || elem.trim() === '') {
            throw new Error('Roler.' + method + ': roles map (' + i + ',' + j +
                            ',' + k +') has invalid elements: ' + elem);
        }
    }

    // ## Closure
})(
    'undefined' !== typeof node ? node : module.exports,
    'undefined' !== typeof node ? node : module.parent.exports
);

/**
 * # Matcher
 * Copyright(c) 2020 Stefano Balietti
 * MIT Licensed
 *
 * Class handling the creation of tournament schedules.
 *
 * http://www.nodegame.org
 * ---
 */
(function(exports, node) {

    var J = node.JSUS;
    var Roler = node.Roler;

    // Object containing methods to fetch a match in the requested format.
    // Will be initialized later.
    var fetchMatch;

    exports.Matcher = Matcher;

    // ## Static methods.

    /**
     * ### Matcher.bye
     *
     * Symbol used to complete matching when partner is missing
     *
     * @see Matcher.matches

     */
    Matcher.bye = -1;

    /**
     * ### Matcher.missingId
     *
     * Symbol assigned to matching number without valid id
     *
     * @see Matcher.resolvedMatches
     * @see Roler.missingId
     */
    Matcher.missingId = 'bot';

    /**
     * ## Matcher.randomAssigner
     *
     * Assigns ids to positions randomly.
     *
     * @param {array} ids The ids to assign
     *
     * @return The sorted array
     *
     * @see JSUS.shuffle
     */
    Matcher.randomAssigner = function(ids) {
        return J.shuffle(ids);
    };

    /**
     * ### Matcher.linearAssigner
     *
     * Assigns ids to positions linearly.
     *
     * @param {array} ids The ids to assign
     *
     * @return The sorted array
     */
    Matcher.linearAssigner = function(ids) {
        return J.clone(ids);
    };

    /**
     * ## Matcher constructor
     *
     * Creates a new Matcher object
     *
     * @param {object} options Optional. Configuration options
     */
    function Matcher(options) {

        options = options || {};

        /**
         * ### Matcher.x
         *
         * The row-index of the last returned match by Matcher.getMatch
         *
         * @see Matcher.getMatch
         */
        this.x = null;

        /**
         * ### Matcher.y
         *
         * The column-index of the last returned match by Matcher.getMatch
         *
         * @see Matcher.getMatch
         */
        this.y = null;

        /**
         * ### Matcher.matches
         *
         * Nested array of matches (with position-numbers)
         *
         * Nests a new array for each round, and within each round
         * individual matches are also array. For example:
         *
         * ```javascript
         *
         * // Matching array.
         * [
         *
         *   // First round.
         *   [ [ p1, p2 ], [ p3, p4 ], ... ],
         *
         *   // Second round.
         *   [ [ p2, p3 ], [ p4, p1 ], ... ],
         *
         *   // Further rounds.
         * ];
         * ```
         *
         * @see Matcher.setMatches
         */
        this.matches = null;

        /**
         * ### Matcher.resolvedMatches
         *
         * Nested array of matches (with id-strings)
         *
         * Exactly Matcher.matches, but with with ids instead of numbers
         *
         * This method is used both by getMatch and getMatchObject (if
         * a single match is requested).
         *
         * @see Matcher.matches
         * @see Matcher.resolvedMatchesObj
         * @see Matcher.resolvedMatchesById
         * @see Matcher.setIds
         * @see Matcher.setAssignerCb
         * @see Matcher.match
         */
        this.resolvedMatches = null;

        /**
         * ### Matcher.resolvedMatchesObj
         *
         * Array of maps id to partner, one map per round
         *
         * ```javascript
         *
         * // Matching array.
         * [
         *
         *   // First round.
         *   { p1: 'p2', p2: 'p1', p3: 'p4', p4: 'p3',  ... },
         *
         *   // Second round.
         *   { p2: 'p3', p3: 'p2', p4: 'p1', p1: 'p4',  ... },
         *
         *   // Further rounds.
         * ];
         * ```
         *
         * @see Matcher.resolvedMatches
         * @see Matcher.resolvedMatchesById
         * @see Matcher.setIds
         * @see Matcher.match
         */
        this.resolvedMatchesObj = null;

        /**
         * ### Matcher.resolvedMatchesById
         *
         * Maps ids to a sequence of matches
         *
         * ```javascript
         *
         * // Matching object.
         * {
         *
         *   // All rounds.
         *   p1: [ 'p2', 'p4', ... ],
         *   p2: [ 'p1', 'p3', ... ],
         *   p3: [ 'p4', 'p2', ... ],
         *   p4: [ 'p3', 'p1', ... ]
         *   ...
         *
         * };
         * ```
         *
         * @see Matcher.resolvedMatches
         * @see Matcher.resolvedMatchesObj
         * @see Matcher.setIds
         * @see Matcher.match
         */
        this.resolvedMatchesById = null;

        /**
         * ### Matcher.ids
         *
         * Array ids to match
         *
         * @see Matcher.setIds
         */
        this.ids = null;

        /**
         * ### Matcher.ids
         *
         * Array mapping each ordinal position to an id
         *
         * @see Matcher.ids
         * @see Matcher.assignerCb
         */
        this.assignedIds = null;

        /**
         * ### Matcher.idsMap
         *
         * Map ids to match
         *
         * @see Matcher.setIds
         */
        this.idsMap = null;

        /**
         * ### Matcher.assignedIdsMap
         *
         * Map ids to ordinal position in matches
         *
         * @see Matcher.idsMap
         * @see Matcher.assignedIds
         */
        this.assignedIdsMap = null;

        /**
         * ### Matcher.assignerCb
         *
         * Callback that assigns ids to positions
         *
         * An assigner callback must take as input an array of ids,
         * reorder them according to some criteria, and return it.
         * The order of the items in the returned array will be used to
         * match the numbers in the `matches` array.
         *
         * @see Matcher.ids
         * @see Matcher.matches
         * @see Matcher.assignedIds
         */
        this.assignerCb = Matcher.randomAssigner;

        /**
         * ## Matcher.missingId
         *
         * An id used to replace missing players ids
         */
        this.missingId = Matcher.missingId;

        /**
         * ## Matcher.missingId
         *
         * An id used by matching algorithms to complete unfinished matches
         */
        this.bye = Matcher.bye;

        /**
         * ## Matcher.doObjLists
         *
         * Flag that obj lists should be created when `match` is invoked
         *
         * @see Matcher.resolvedMatchesObj
         * @see Matcher.matcher
         */
        this.doObjLists = true;

        /**
         * ## Matcher.doIdLists
         *
         * Flag that id lists should be created when `match` is invoked
         *
         * @see Matcher.resolvedMatchesById
         * @see Matcher.matcher
         */
        this.doIdLists = true;

        /**
         * ## Matcher.doRoles
         *
         * Flag that roles should be assigned when `match` is invoked
         *
         * Requires roles to be set, otherwise an error is thrown
         *
         * @see Matcher.roles
         * @see Matcher.roler
         * @see Matcher.matcher
         */
        this.doRoles = false;

        /**
         * ## Matcher.roler
         *
         * Handles assigning roles to matches
         *
         * If null here, is initialized by `init` if doRoles is TRUE.
         *
         * @see Matcher.doRoles
         * @see Matcher.init
         */
        this.roler = options.roler || null;

        /**
         * ## Matcher.roles
         *
         * Roles map created if `doRoles` is TRUE
         *
         * @see Matcher.doRoles
         * @see Matcher.roler
         * @see Matcher.matcher
         */
        this.roler = options.roler || null;

        // Init.
        this.init(options);
    }

    /**
     * ### Matcher.init
     *
     * Inits the Matcher instance
     *
     * @param {object} options
     */
    Matcher.prototype.init = function(options) {
        options = options || {};

        if (options.assignerCb) this.setAssignerCb(options.assignerCb);
        if (options.ids) this.setIds(options.ids);
        if (options.bye) this.bye = options.bye;
        if (options.missingId) this.missingId = options.missingId;

        if (null === options.x) this.x = null;
        else if ('number' === typeof options.x) {
            if (options.x < 0) {
                throw new Error('Matcher.init: options.x cannot be negative.' +
                                'Found: ' + options.x);
            }
            this.x = options.x;
        }
        else if (options.x) {
            throw new TypeError('Matcher.init: options.x must be number, ' +
                                'null or undefined. Found: ' + options.x);
        }

        if (null === options.y) this.y = null;
        else if ('number' === typeof options.y) {
            if (options.y < 0) {
                throw new Error('Matcher.init: options.y cannot be negative.' +
                                'Found: ' + options.y);
            }
            this.y = options.y;
        }
        else if (options.y) {
            throw new TypeError('Matcher.init: options.y must be number, ' +
                                'null or undefined. Found: ' + options.y);
        }

        if (options.doRoles || options.roles) {
            if (!this.roler) this.roler = new Roler();
            this.roler.init({
                missingId: this.missingId,
                roles: options.roles
            });
            this.doRoles = true;
        }
        else if ('undefined' !== typeof options.doRoles) {
            this.doRoles = !!options.doRoles;
        }

        if ('undefined' !== typeof options.doObjLists) {
            this.doObjLists = !!options.doObjLists;
        }

        if ('undefined' !== typeof options.doIdLists) {
            this.doIdLists = !!options.doIdLists;
        }
    };

    /**
     * ### Matcher.generateMatches
     *
     * Creates a matches array according to the chosen scheduling algorithm
     *
     * Throws an error if the selected algorithm is not found.
     *
     * @param {string} alg The chosen algorithm. Available: 'roundrobin',
     *   'random'
     *
     * @return {array} The array of matches
     */
    Matcher.prototype.generateMatches = function(alg) {
        var matches;
        if ('string' !== typeof alg) {
            throw new TypeError('Matcher.generateMatches: alg must be ' +
            'string. Found: ' + alg);
        }
        alg = alg.toLowerCase();
        if (alg === 'roundrobin' || alg === 'round_robin' ||
            alg === 'random' || alg === 'random_pairs' ) {

            matches = pairMatcher(alg, arguments[1], arguments[2]);
        }
        else {
            throw new Error('Matcher.generateMatches: unknown algorithm: ' +
                            alg);
        }

        this.setMatches(matches);
        return matches;
    };

    /**
     * ### Matcher.setMatches
     *
     * Sets the matches for current instance
     *
     * Resets resolvedMatches and resolvedMatchesObj to null.
     *
     * @param {array} The array of matches
     *
     * @see this.matches
     */
    Matcher.prototype.setMatches = function(matches) {
        if (!J.isArray(matches) || !matches.length) {
            throw new TypeError('Matcher.setMatches: matches must be a ' +
                                'non-empty array. Found: ' + matches);
        }
        this.matches = matches;
        resetResolvedData(this);
    };

    /**
     * ### Matcher.getMatches
     *
     * Returns the matches for current instance
     *
     * @return {array|null} The array of matches (NULL if not yet set)
     *
     * @see this.matches
     */
    Matcher.prototype.getMatches = function() {
        return this.matches;
    };

    /**
     * ### Matcher.setIds
     *
     * Sets the ids to be used for the matches
     *
     * @param {array} ids Array containing the id of the matches
     *
     * @see Matcher.ids
     * @see Matcher.idsMap
     */
    Matcher.prototype.setIds = function(ids) {
        var i, len;
        if (!J.isArray(ids) || !ids.length) {
            throw new TypeError('Matcher.setIds: ids must be a non-empty ' +
                                'array. Found: ' + ids);
        }
        // Keep track of all ids.
        this.idsMap = {};
        i = -1, len = ids.length;
        for ( ; ++i < len ; ) {
            // TODO: validate? Duplicated ids are fine?
            this.idsMap[ids[i]] = true;
        }
        this.ids = ids;
        resetResolvedData(this);
    };

    /**
     * ### Matcher.getIds
     *
     * Returns the ids used to created the matching
     *
     * @return {array} ids Ids in use
     *
     * @see Matcher.ids
     */
    Matcher.prototype.getIds = function() {
        return this.ids;
    };

    /**
     * ### Matcher.assignIds
     *
     * Calls the assigner callback to assign ids to positions
     *
     * Ids can be overwritten by parameter. If no ids are found,
     * they will be automatically generated, provided that matches
     * have been generated first.
     *
     * @param {array} ids Optional. Array containing the id of the matches
     *   to pass to Matcher.setIds
     *
     * @see Matcher.ids
     * @see Matcher.setIds
     * @see Matcher.assignedIds
     * @see Matcher.assignedIdsMap
     */
    Matcher.prototype.assignIds = function(ids) {
        var i, len;
        if ('undefined' !== typeof ids) this.setIds(ids);
        if (!J.isArray(this.ids) || !this.ids.length) {
            if (!J.isArray(this.matches) || !this.matches.length) {
                throw new TypeError('Matcher.assignIds: no ids and no ' +
                                    'matches found.');
            }
            this.ids = J.seq(0, this.matches.length -1, 1, function(i) {
                return '' + i;
            });
        }
        this.assignedIds = this.assignerCb(this.ids);
        // Map all ids to its position.
        this.assignedIdsMap = {};
        i = -1, len = this.assignedIds.length;
        for ( ; ++i < len ; ) {
            this.assignedIdsMap[this.assignedIds[i]] = i;
        }
    };

    /**
     * ### Matcher.setAssignerCb
     *
     * Specify a callback to be used to assign existing ids to positions
     *
     * @param {function} cb The assigner cb
     *
     * @see Matcher.ids
     * @see Matcher.matches
     * @see Matcher.assignerCb
     */
    Matcher.prototype.setAssignerCb = function(cb) {
        if ('function' !== typeof cb) {
            throw new TypeError('Matcher.setAssignerCb: cb must be ' +
                                'function. Found: ' + cb);
        }
        this.assignerCb = cb;
    };

    /**
     * ### Matcher.match
     *
     * Substitutes the ids to the matches
     *
     * Populates the indexes:
     *
     *   - `resolvedMatches`,
     *   - `resolvedMatchesObj`,
     *   - `resolvedMatchesById`
     *
     * If the matches array is not already set, an error is thrown.
     *
     * If the ids have not been assigned, it does automatic assignment.
     *
     * @param {boolean|array} assignIds Optional. A flag to force to
     *   re-assign existing ids, or an an array containing new ids to
     *   assign.
     *
     * @see Matcher.assignIds
     * @see Matcher.resolvedMatchesObj
     * @see Matcher.resolvedMatches
     *
     * TODO: creates two lists of matches with bots and without.
     */
    Matcher.prototype.match = function(assignIds) {
        var i, lenI, j, lenJ, pair;
        var matched, matchedObj, matchedId, id1, id2;
        var roles, rolesObj, idRolesObj, r1, r2;

        if (!J.isArray(this.matches) || !this.matches.length) {
            throw new Error('Matcher.match: no matches found');
        }

        // Assign/generate ids if not done before.
        if (!this.assignedIds || assignIds) {
            if (J.isArray(assignIds)) this.assignIds(assignIds);
            else this.assignIds();
        }

        // Parse the matches array and creates two data structures
        // where the absolute position becomes the player id.
        i = -1, lenI = this.matches.length;
        matched = new Array(lenI);
        matchedObj = this.doObjLists ? new Array(lenI) : null;
        matchedId = this.doIdLists ? {} : null;
        if (this.doRoles) {
            roles = new Array(lenI);
            rolesObj = new Array(lenI);
            idRolesObj = new Array(lenI);
        }
        else {
            roles = null;
            rolesObj = null;
            idRolesObj = null;
        }
        for ( ; ++i < lenI ; ) {
            j = -1, lenJ = this.matches[i].length;
            matched[i] = new Array(lenJ);
            if (this.doObjLists) matchedObj[i] = {};
            if (this.doRoles) {
                roles[i] = new Array(lenJ);
                rolesObj[i] = new Array(lenJ);
                idRolesObj[i] = new Array(lenJ);
            }
            for ( ; ++j < lenJ ; ) {
                id1 = null, id2 = null;
                pair = this.matches[i][j];
                // Resolve matches.
                id1 = importMatchItem(i, j,
                                      pair[0],
                                      this.assignedIds,
                                      this.missingId);
                id2 = importMatchItem(i, j,
                                      pair[1],
                                      this.assignedIds,
                                      this.missingId);
                // Create resolved matches:
                // Array.
                matched[i][j] = [id1, id2];
                // Obj.
                if (this.doObjLists) {
                    matchedObj[i][id1] = id2;
                    matchedObj[i][id2] = id1;
                }
                // By Id.
                if (this.doIdLists) {
                    if (!matchedId[id1]) matchedId[id1] = new Array(lenI);
                    if (!matchedId[id2]) matchedId[id2] = new Array(lenI);
                    matchedId[id1][i] = id2;
                    matchedId[id2][i] = id1;
                }
                // Roles.
                if (this.doRoles) {
                    roles[i][j] = this.roler.rolify(matched[i][j], i, j);
                    // TODO: this code is repeated in Roler.rolifyAll.
                    // make it one!
                    r1 = roles[i][j][0];
                    r2 = roles[i][j][1];
                    rolesObj[i][j] = {};
                    if (r1 !== r2) {
                        rolesObj[i][j][r1] = id1;
                        rolesObj[i][j][r2] = id2;
                    }
                    else {
                        rolesObj[i][j][r1] = [ id1, id2 ];
                    }
                    idRolesObj[i][j] = {};
                    idRolesObj[i][j][id1] = r1;
                    idRolesObj[i][j][id2] = r2;
                }
            }
        }
        // Substitute matching-structure.
        this.resolvedMatches = matched;
        this.resolvedMatchesObj = matchedObj;
        this.resolvedMatchesById = matchedId;
        this.roles = roles;
        this.rolesObj = rolesObj;
        if (this.doRoles) {
            this.roler.setRolifiedMatches(roles, false);
            this.roler.setRole2IdMatches(rolesObj, false);
            this.roler.setId2RoleMatches(idRolesObj, false);
        }
        // Set getMatch indexes to 0.
        this.x = null;
        this.y = null;
    };

    /**
     * ### Matcher.hasNext
     *
     * Returns TRUE if there is next match to be returned by getMatch
     *
     * @param {number} x Optional. The x-th round. Default: Matcher.x
     * @param {number} y Optional. The y-th match within the x-th round
     *    Default: Matcher.y
     *
     * @return {bolean} TRUE, if there exists a next match
     *
     * @see Matcher.x
     * @see Matcher.y
     * @see Matcher.resolvedMatches
     * @see hasOrGetNext
     */
    Matcher.prototype.hasNext = function(x, y) {
        return hasOrGetNext.call(this, 'hasNext', 0, x, y);
    };

    /**
     * ### Matcher.getMatch
     *
     * Returns the next match, or the specified match
     *
     * @param {number} x Optional. The x-th round. Default: Matcher.x
     * @param {number} y Optional. The y-th match within the x-th round.
     *    Default: Matcher.y
     *
     * @return {array} The next or requested match, or null if not found
     *
     * @see Matcher.x
     * @see Matcher.y
     * @see Matcher.resolvedMatches
     * @see hasOrGetNext
     */
    Matcher.prototype.getMatch = function(x, y) {
        return hasOrGetNext.call(this, 'getMatch', 1, x, y);
    };

    /**
     * ### Matcher.getMatchFor
     *
     * Returns the id/s of the next or the x-th match for the specified id
     *
     * If id lists are not generated (see `Matcher.doIdLists) an
     * error is thrown.
     *
     * @param {string} id The id to get the matches for
     * @param {number} x Optional. The x-th round. Default: Matcher.x
     *
     * @return {string|array} The next or requested match, or null if not found
     *
     * @see Matcher.x
     * @see Matcher.y
     * @see Matcher.doIdLists
     * @see Matcher.resolvedMatches
     * @see hasOrGetNext
     */
    Matcher.prototype.getMatchFor = function(id, x) {
        var out;
        if ('string' !== typeof id) {
            throw new TypeError('Matcher.getMatchFor: id must be string. ' +
                                'Found:' + id);
        }
        if (!this.resolvedMatchesById) {
            throw new Error('Matcher.getMatchFor: no id-based matches found.');
        }
        out = this.resolvedMatchesById[id];
        if (!out) return null;
        if ('undefined' === typeof x) return out;
        if ('number' === typeof x) {
            if (x >= 0 && !isNaN(x)) return x > (out.length -1) ? null : out[x];
        }
        throw new TypeError('Matcher.getMatchFor: x must be a positive ' +
                            'number or undefined. Found: ' + x);
    };

    /**
     * ### Matcher.getMatchObject
     *
     * Returns all the matches of the next or requested round as key-value pairs
     *
     * If object lists are not generated (see `Matcher.doObjLists) an
     * error is thrown.
     *
     * @param {number} x Optional. The x-th round. Default: Matcher.x
     * @param {number} y Optional. The y-th match within the x-th round.
     *    Default: Matcher.y
     *
     * @return {object|null} The next or requested match, or null if not found
     *
     * @see Matcher.x
     * @see Matcher.y
     * @see Matcher.doObjLists
     * @see Matcher.resolvedMatchesObj
     */
    Matcher.prototype.getMatchObject = function(x, y) {
        if (!this.resolvedMatchesObj) {
            throw new Error('Matcher.getMatchObject: no obj matches found.');
        }
        return hasOrGetNext.call(this, 'getMatchObject', 3, x, y);
    };

    /**
     * ### Matcher.normalizeRound
     *
     * Returns the round index given the current number of matches
     *
     * For example, if the are only 10 matches repeated in cycle,
     * but the game has 20 rounds, round 13th will have normalized
     * round index equal to 3.
     *
     * Important! Matches are 0-based, but rounds are 1-based. This
     * method takes care of it.
     *
     * @param {number} round The round to normalize
     *
     * @return {object} The next or requested match, or null if not found
     *
     * @see Matcher.x
     * @see Matcher.matches
     */
    Matcher.prototype.normalizeRound = function(round) {
        if (!this.matches) {
            throw new TypeError('Matcher.normalizeRound: no matches found.');
        }
        if ('number' !== typeof round || isNaN(round) || round < 1) {
            throw new TypeError('Matcher.normalizeRound: round must be a ' +
                                'number > 0. Found: ' + round);
        }
        return (round-1) % this.matches.length;
    };

    /**
     * ### Matcher.replaceId
     *
     * Replaces an id with a new one in all matches
     *
     * @param {string} oldId The id to be replaced
     * @param {string} newId The replacing id
     *
     * @return {boolean} TRUE, if the oldId was found and replaced
     *
     * @see MatcherManager.replaceId
     * @see Roler.replaceId
     */
    Matcher.prototype.replaceId = function(oldId, newId) {
        var m;
        var i, len, j, lenJ, h, lenH;
        var rowFound;
        if ('string' !== typeof oldId) {
            throw new TypeError('Matcher.replaceId: oldId should be string. ' +
                                'Found: ' + oldId);
        }
        if ('string' !== typeof newId || newId.trim() === '') {
            throw new TypeError('Matcher.replaceId: newId should be a ' +
                                'non-empty string. Found: ' + newId);
        }

        // No id was assigned yet.
        if (!this.resolvedMatches) return false;

        // IdsMap.
        m = this.idsMap[oldId];
        if ('undefined' === typeof m) return false;

        this.idsMap[newId] = true;
        delete this.idsMap[oldId];

        // Ids.
        m = this.ids;
        i = -1, len = m.length;
        for ( ; ++i < len ; ) {
            if (m[i] === oldId) {
                m[i] = newId;
                break;
            }
        }

        // AssignedIds and AssignedIdsMap.
        m = this.assignedIdsMap;
        m[newId] = m[oldId];
        delete m[oldId];
        this.assignedIds[m[newId]] = newId;

        // Update resolvedMatches.
        m = this.resolvedMatches;
        if (!m) return true;

        i = -1, len = m.length;
        for ( ; ++i < len ; ) {
            j = -1, lenJ = m[i].length;
            rowFound = false;
            for ( ; ++j < lenJ ; ) {
                h = -1, lenH = m[i][j].length;
                for ( ; ++h < lenH ; ) {
                    if (m[i][j][h] === oldId) {
                        m[i][j][h] = newId;
                        rowFound = true;
                        break;
                    }
                }
                if (rowFound) break;
            }
        }

        // Update resolvedMatchesObj.
        m = this.resolvedMatchesObj;

        i = -1, len = m.length;
        for ( ; ++i < len ; ) {
            for (j in m[i]) {
                if (m[i].hasOwnProperty(j)) {
                    if (j === oldId) {
                        // Do the swap.
                        m[i][newId] = m[i][oldId];
                        m[i][m[i][oldId]] = newId;
                        delete m[i][oldId];
                        break;
                    }
                }
            }
        }

        // Update resolvedMatchesById.
        m = this.resolvedMatchesById;
        for (i in m) {
            if (m.hasOwnProperty(i)) {
                if (i === oldId) {
                    m[newId] = m[oldId];
                    delete m[oldId];
                }
                else {
                    lenJ = m[i].length;
                    // THIS OPTIMIZATION DOES NOT SEEM TO WORK.
                    // In fact, there might be more matches with the same
                    // partner in sequence.
                    // And also if === 1, it should be checked.
                    // if (lenJ == 1) {
                    //     m[i][0] = newId;
                    // }
                    // else if (lenJ === 2) {
                    //     if (m[i][0] === oldId) m[i][0] = newId;
                    //     else m[i][1] = newId;
                    // }
                    // else {
                    j = -1;
                    for ( ; ++j < lenJ ; ) {
                        if (m[i][j] === oldId) {
                            m[i][j] = newId;
                        }
                    }
                    // }
                }
            }
        }

        return true;
    };

    /**
     * ### Matcher.clear
     *
     * Clears the matcher as it would be a newly created object
     */
    Matcher.prototype.clear = function() {
        this.x = null;
        this.y = null;
        this.matches = null;
        this.resolvedMatches = null;
        this.resolvedMatchesObj = null;
        this.ids = null;
        this.assignedIds = null;
        this.idsMap = null;
        this.assignedIdsMap = null;
        this.assignerCb = Matcher.randomAssigner;
        this.missingId = Matcher.missingId;
        this.bye = Matcher.bye;
    };

    // ## Helper methods.

    /**
     * ### importMatchItem
     *
     * Handles importing items from the matches array
     *
     * Items in matches array must be numbers or strings. If numbers
     * they are translated into an id using the supplied map, otherwise
     * they are considered as already an id.
     *
     * Items that are not numbers neither strings will throw an error.
     *
     * @param {number} i The row-id of the item
     * @param {number} j The position in the row of the item
     * @param {string|number} item The item to check
     * @param {array} map The map of positions to ids
     * @param {string} miss The id of number that cannot be resolved in map
     *
     * @return {string} The resolved id of the item
     */
    function importMatchItem(i, j, item, map, miss) {
        if ('number' === typeof item) {
            return 'undefined' !== typeof map[item] ? map[item] : miss;
        }
        else if ('string' === typeof item) {
            return item;
        }
        throw new TypeError('Matcher.match: items can be only string or ' +
                            'number. Found: ' + item + ' at position ' +
                            i + ',' + j);
    }

    /**
     * ### resetResolvedData
     *
     * Resets resolved data of a matcher object
     *
     * @param {Matcher} matcher The matcher to reset
     */
    function resetResolvedData(matcher) {
        matcher.resolvedMatches = null;
        matcher.resolvedMatchesObj = null;
        matcher.resolvedMatchesById = null;
        matcher.assignedIds = null;
        matcher.assignedIdsMap = null;
    }

    /**
     * ### pairMatcherOld
     *
     * Creates tournament schedules for different algorithms
     *
     * @param {string} alg The name of the algorithm
     * @param {number|array} n The number of participants (>1) or
     *   an array containing the ids of the participants
     * @param {object} options Optional. Configuration object
     *   contains the following options:
     *
     *   - bye: identifier for dummy competitor. Default: -1.
     *   - skypeBye: flag whether players matched with the dummy
     *        competitor should be added or not. Default: true.
     *   - rounds: number of rounds to repeat matching. Default:
     *   - cycle: if there are more rounds than possible combinations
     *        this option specifies how to fill extra rounds. Available
     *        settings:
     *
     *        - 'repeat': repeats all available matches (default)
     *        - 'repeat_invert': repeats all available matches, but inverts
     *             the position of ids in the match
     *        - 'mirror': repeats all available matches in mirrored order.
     *        - 'mirror_invert': repeats all available matches in mirrored
     *              order and also inverts the position of the ids in the match
     *
     * @return {array} matches The matches according to the algorithm
     */
    function pairMatcher(alg, n, options) {
        var ps, matches, bye;
        var i, lenI, j, lenJ, jj;
        var id1, id2;
        var roundsLimit, cycle, cycleI, skipBye;
        var fixedRolesNoSameMatch;

        if ('number' === typeof n && n > 1) {
            ps = J.seq(0, (n-1));
        }
        else if (J.isArray(n) && n.length > 1) {
            ps = n.slice();
            n = ps.length;
        }
        else {
            throw new TypeError('pairMatcher.' + alg + ': n must be ' +
                                'number > 1 or array of length > 1.');
        }
        options = options || {};

        bye = 'undefined' !== typeof options.bye ? options.bye : -1;
        skipBye = options.skipBye || false;

        // Make sure we have even numbers.
        if ((n % 2) === 1) {
            ps.push(bye);
            n += 1;
        }

        // Does not work.
        if (options.fixedRoles && (options.canMatchSameRole === false)) {
            fixedRolesNoSameMatch = true;
        }

        // Limit rounds.
        if ('number' === typeof options.rounds) {
            if (options.rounds <= 0) {
                throw new Error('pairMatcher.' + alg + ': options.rounds ' +
                                'must be a positive number or undefined. ' +
                                'Found: ' + options.rounds);
            }
            if (options.rounds > (n-1)) {
                throw new Error('pairMatcher.' + alg + ': ' +
                                'options.rounds cannot be greater than ' +
                                (n-1) + '. Found: ' + options.rounds);
            }
            // Here roundsLimit does not depend on n (must be smaller).
            roundsLimit = options.rounds;
        }
        else if (fixedRolesNoSameMatch) {
            roundsLimit = Math.floor(n/2);
        }
        else {
            roundsLimit = n-1;
        }

        if ('undefined' !== typeof options.cycle) {
            cycle = options.cycle;
            if (cycle !== 'mirror_invert' && cycle !== 'mirror' &&
                cycle !== 'repeat_invert' && cycle !== 'repeat') {

                throw new Error('pairMatcher.' + alg + ': options.cycle ' +
                                'must be equal to "mirror"/"mirror_invert", ' +
                                '"repeat"/"repeat_invert" or undefined . ' +
                                'Found: ' + options.cycle);
            }

            matches = new Array(roundsLimit*2);
        }
        else {
            matches = new Array(roundsLimit);
        }

        i = -1, lenI = roundsLimit;
        for ( ; ++i < lenI ; ) {
            // Shuffle list of ids for random.
            if (alg === 'random') ps = J.shuffle(ps);
            // Create a new array for round i.
            lenJ = n / 2;
            matches[i] = skipBye ? new Array(lenJ-1) : new Array(lenJ);
            // Check if new need to cycle.
            if (cycle) {
                if (cycle === 'mirror' || cycle === 'mirror_invert') {
                    cycleI = (roundsLimit*2) -i -1;
                }
                else {
                    cycleI = i+roundsLimit;
                }
                matches[cycleI] = skipBye ?
                    new Array(lenJ-1) : new Array(lenJ);
            }
            // Counter jj is updated only if not skipBye,
            // otherwise we create holes in the matches array.
            jj = j = -1;
            for ( ; ++j < lenJ ; ) {
                if (fixedRolesNoSameMatch) {
                    id1 = ps[j*2];
                    id2 = ps[((i*2)+(j*2)+1) % n];
                }
                else {
                    id1 = ps[j];
                    id2 = ps[n - 1 - j];
                }
                if (!skipBye || (id1 !== bye && id2 !== bye)) {
                    jj++;
                    // Insert match.
                    matches[i][jj] = [ id1, id2 ];
                    // Insert cycle match (if any).
                    if (cycle === 'repeat') {
                        matches[cycleI][jj] = [ id1, id2 ];
                    }
                    else if (cycle === 'repeat_invert') {
                        matches[cycleI][jj] = [ id2, id1 ];
                    }
                    else if (cycle === 'mirror') {
                        matches[cycleI][jj] = [ id1, id2 ];
                    }
                    else if (cycle === 'mirror_invert') {
                        matches[cycleI][jj] = [ id2, id1 ];
                    }
                }
            }
            // Permutate for next round.
            if (!fixedRolesNoSameMatch) ps.splice(1, 0, ps.pop());
        }
        return matches;
    }

    /**
     * ## fetchMatch
     *
     * Maps method names to a return function to execute in case of success
     *
     *   - 0: hasNext -> returns true
     *   - 1: getMatch -> returns an array, or array of arrays
     *   - 2: getMatchFor -> returns a string
     *   - 3: getMatchObject -> returns an object
     *
     * @see hasOrGetNext
     */
    fetchMatch = [
        // hasNext.
        function() {
            return true;
        },
        // getMatch.
        function(x, y) {
            return 'number' === typeof y ?
                this.resolvedMatches[x][y] : this.resolvedMatches[x];
        },
        // getMatchFor.
        function(x, y, id) {
            if ('number' === typeof x && 'number' === typeof y) {
                return this.resolvedMatchesById[id][x];
            }
            return this.resolvedMatchesById[id];
        },
        // getMatchObject.
        function(x, y) {
            var match, res;
            if ('number' === typeof y) {
                res = {};
                match = this.resolvedMatches[x][y];
                res[match[0]] = match[1];
                res[match[1]] = match[0];
                return res;
            }
            return this.resolvedMatchesObj[x];
        }
    ];

    /**
     * ### hasOrGetNext
     *
     * Returns TRUE or the match if there is next match
     *
     * If in `get` mode it also updates the x and y indexes.
     *
     * @param {string} m The name of the method invoking it
     * @param {boolean} get TRUE, if the method should return the match
     * @param {number} x Optional. The x-th round. Default: Matcher.x
     * @param {number} y Optional. The y-th match within the x-th round
     *    Default: Matcher.y
     * @param {string} id Optional. Used by method getMatchFor
     *
     * @return {boolean|array|null} TRUE or the next match (if found),
     *   FALSE or null (if not found)
     *
     * @see Matcher.x
     * @see Matcher.y
     * @see Matcher.resolvedMatches
     * @see fetchMatch
     */
    function hasOrGetNext(m, mod, x, y, id) {
        var nRows, nCols;

        // Check if there is any match yet.
        if (!J.isArray(this.resolvedMatches) || !this.resolvedMatches.length) {
            throw new Error('Matcher.' + m + ': no resolved matches found.');
        }

        nRows = this.resolvedMatches.length - 1;

        // No x, No y get the next match.
        if ('undefined' === typeof x) {
            // Check both x and y.
            if ('undefined' !== typeof y) {
                throw new Error('Matcher.' + m +
                                ': cannot specify y without x.');
            }

            // No match was ever requested.
            if (null === this.x) {
                this.x = 0;
                this.y = 0;
                return fetchMatch[mod].call(this, 0, 0, id);
            }

            x = this.x;
            y = this.y + 1;
            if (x <= nRows) {
                nCols = this.resolvedMatches[x].length - 1;
                if (y <= nCols) {
                    if (mod) {
                        this.x = x;
                        this.y = y;
                        return fetchMatch[mod].call(this, x, y, id);
                        // return this.resolvedMatches[x][y];
                    }
                    else {
                        return true;
                    }
                }
                else {
                    x = x + 1;
                    y = 0;
                    if (mod) {
                        this.x = x;
                        this.y = y;
                    }
                    if (x <= nRows) {
                        return fetchMatch[mod].call(this, x, y, id);
                        // return mod ? this.resolvedMatches[x][y] : true;
                    }
                    else {
                        return mod ? null : false;
                    }
                }
            }
            else {
                return mod ? null : false;
            }
        }
        // End undefined x.

        // Validate x.
        if ('number' !== typeof x) {
            throw new TypeError('Matcher.' + m + ': x must be number ' +
                                'or undefined. Found: ' + x);
        }
        else if (x < 0 || isNaN(x)) {
            throw new Error('Matcher.' + m + ': x cannot be negative or NaN. ' +
                            'Found: ' + x);
        }

        if (x > nRows) {
            if (mod) {
                this.x = x;
                this.y = 0;
                return null;
            }
            else {
                return false;
            }
        }

        // Default y (whole row).
        if ('undefined' === typeof y) {
            if (mod) {
                this.x = x;
                this.y = this.resolvedMatches[nRows].length;
                // Return the whole row.
                return fetchMatch[mod].call(this, x, y, id);
                // return this.resolvedMatches[x];
            }
            else {
                return true;
            }
        }

        // Validate y.
        if ('number' !== typeof y) {
            throw new TypeError('Matcher.' + m  + ': y must be number ' +
                                'or undefined.');
        }
        else if (y < 0 || isNaN(y)) {
            throw new Error('Matcher.' + m + ': y cannot be negative or NaN. ' +
                            'Found: ' + y);
        }

        nCols = this.resolvedMatches[x].length - 1;

        // Valid x,y match.
        if (y <= nCols) {
            if (mod) {
                this.x = x;
                this.y = y;
                return fetchMatch[mod].call(this, x, y);
                // return this.resolvedMatches[x][y];
            }
            else {
                return true;
            }
        }
        // Out of bound.
        else {
            if (mod) {
                this.x = x;
                this.y = y;
                return null;
            }
            else {
                return false;
            }
        }
    }

    // ## Closure
})(
    'undefined' !== typeof node ? node : module.exports,
    'undefined' !== typeof node ? node : module.parent.exports
);

/**
 * # MatcherManager
 * Copyright(c) 2020 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Handles matching roles to players and players to players.
 *
 * ---
 * nodegame.org
 */
(function(exports, parent) {

    "use strict";

    exports.MatcherManager = MatcherManager;

    /**
     * ## MatcherManager constructor
     *
     * Creates a new instance of role mapper
     */
    function MatcherManager(node) {

        /**
         * ### MatcherManager.node
         *
         * Reference to the node object
         */
        this.node = node;

        /**
         * ### MatcherManager.roler
         *
         * The roler object
         *
         * @see Roler
         */
        this.roler = new parent.Roler();

        /**
         * ### MatcherManager.matcher
         *
         * The matcher object
         *
         * @see Matcher
         */
        this.matcher = new parent.Matcher({ roler: this.roler });

        /**
         * ### MatcherManager.lastSettings
         *
         * Reference to the last settings parsed
         */
        this.lastSettings = null;

        /**
         * ### MatcherManager.lastMatches
         *
         * Reference to the last matches
         */
        this.lastMatches = null;

        /**
         * ### MatcherManager.lastMatchesById
         *
         * Reference to the last matches organized by id of client
         */
        this.lastMatchesById = {};
    }

    /**
     * ### MatcherManager.clear
     *
     * Clears current matches and roles
     *
     * @param {string} mod Optional. Modifies what must be cleared.
     *    Values: 'roles', 'matches', 'all'. Default: 'all'
     */
    MatcherManager.prototype.clear = function(mod) {

        this.lastMatches = null;
        this.lastSettings = null;
        this.lastMatchesById = {};

        switch(mod) {
        case 'roles':
            this.roler.clear();
            break;
        case 'matches':
            this.matcher.clear();
            break;
        default:
            this.roler.clear();
            this.matcher.clear();
        }
    };

    /**
     * ### MatcherManager.match
     *
     * Parses a conf object and returns the desired matches of roles and players
     *
     * Stores references of last settings and matches.
     *
     * Returned matches are in a format which is ready to be sent out as
     * remote options. That is:
     *
     *     matches = [
     *         {
     *             id: 'playerId',
     *             options: {
     *                 role: "A", // Optional.
     *                 partner: "partnerId", // Optional.
     *                 group: "yyy" // For future use.
     *             }
     *         },
     *         // More matches...
     *     ];
     *
     * @param {object} settings The settings to generate the matches.
     *   The object is passed to `Matcher.match`
     *
     * @return {array} Array of matches ready to be sent out as remote options.
     *
     * @see randomPairs
     * @see MatcherManager.lastMatches
     * @see MatcherManager.lastMatchesById
     * @see MatcherManager.lastSettings
     * @see Matcher.match
     * @see Game.gotoStep
     */
    MatcherManager.prototype.match = function(settings) {
        var matches;

        // String is turned into object. Might still fail.
        if ('string' === typeof settings) settings = { match: settings };

        if ('object' !== typeof settings || settings === null) {
            throw new TypeError('MatcherManager.match: settings must be ' +
                                'object or string. Found: ' + settings);
        }

        if (settings.match === 'random_pairs' ||
            (settings.match === 'round_robin' ||
             settings.match === 'roundrobin')) {

            matches = randomPairs.call(this, settings);
        }
        else {
            throw new Error('MatcherManager.match: only "random_pairs" and ' +
                            '"round_robin" algorithms supported. Found: ' +
                            settings.match);
        }

        if (!matches || !matches.length) {
            throw new Error('MatcheManager.match: "' + settings.match +
                            '" did not return matches.');
        }

        return matches;
    };

    /**
     * ### MatcherManager.getMatches
     *
     * Returns all the matches in a round in the requested format
     *
     * Accepts two parameters to specify a round, and a modifier for
     * the return value. Important! Both parameters are optional and
     * they can be passed in either order.
     *
     * Valid modifiers and return values:
     *
     *  - 'ARRAY' (default): [ [ 'id1', 'id2' ], [ 'id3', 'id4' ], ... ]
     *
     *  - 'ARRAY_ROLES': [ [ 'ROLE1', 'ROLE2' ], [ 'ROLE1', 'ROLE2' ] ]
     *
     *  - 'ARRAY_ROLES_ID': [ { ROLE1: 'id1', ROLE2: 'id2' },
     *                     { ROLE1: 'id3', ROLE2: 'id4' }, ... ]
     *
     *  - 'ARRAY_ID_ROLES': [ { id1: 'ROLE1', id2: 'ROLE2' },
     *                        { id3: 'ROLE1', id4: 'ROLE4' }, ... ]
     *
     *  - 'OBJ': { id1: 'id2', id2: 'id1', id3: 'id4', id4: 'id3' }
     *
     *  - 'OBJ_ROLES_ID': { ROLE1: [ 'id1', 'id3' ], ROLE2: [ 'id2', 'id4' ] }
     *
     *  - 'OBJ_ID_ROLES': { id1: 'ROLE1', id2: 'ROLE2',
     *                      id3: 'ROLE1', id4: 'ROLE2' }
     *
     * @param {string} mod Optional. A valid modifier (default: 'ARRAY')
     * @param {number} round Optional. The round of the matches
     *   (default: current game round).
     *
     * @return {array|object|null} The requested matches in the requested
     *   format, or null matches are not yet set
     *
     * @see round2Index
     * @see Matcher.getMatch
     * @see Matcher.getMatchObject
     * @see Roler.getRoleObj
     * @see Roler.getIdRoleObj
     */
    MatcherManager.prototype.getMatches = function(mod, round) {

        if ('string' !== typeof mod) {
            if ('undefined' !== typeof mod) {
                throw new TypeError('MatcherManager.getMatches: mod must be ' +
                                    'undefined or string. Found: ' + mod);
            }
            mod = 'ARRAY';
        }

        if ('undefined' !== typeof round && 'number' !== typeof round) {
            throw new TypeError('MatcherManager.getMatches: round ' +
                                'must be undefined or number. Found: ' + round);
        }

        if (!this.matcher.getMatches()) return null;

        round = round2Index.call(this, 'getMatches', round);

        if (mod === 'ARRAY') return this.matcher.getMatch(round);
        if (mod === 'ARRAY_ROLES') return this.roler.getRoleMatch(round);
        if (mod === 'ARRAY_ID_ROLES') return this.roler.getId2RoleMatch(round);
        if (mod === 'ARRAY_ROLES_ID') return this.roler.getRole2IdMatch(round);

        if (mod === 'OBJ') return this.matcher.getMatchObject(round);
        if (mod === 'OBJ_ROLES_ID') return this.roler.getRole2IdRoundMap(round);
        if (mod === 'OBJ_ID_ROLES') return this.roler.getId2RoleRoundMap(round);

        throw new Error('MatcherManager.getMatches: unknown modifier: ' + mod);
    };

    /**
     * ### MatcherManager.getMatchFor
     *
     * Returns the match for the specified id
     *
     * @param {string} id The id to search a match for
     * @param {number} round Optional. Specifies a round other
     *   than current (will be normalized if there are more
     *   rounds than matches)
     *
     * @return {string|null} The current match for the id, or null
     *    if the id is not found or matches are not set
     *
     * @see Matcher.getMatchFor
     * @see round2Index
     */
    MatcherManager.prototype.getMatchFor = function(id, round) {
        if (!this.matcher.getMatches()) return null;
        round = round2Index.call(this, 'getMatchFor', round);
        return this.matcher.getMatchFor(id, round);
    };

    /**
     * ### MatcherManager.getRoleFor
     *
     * Returns the role for the specified id
     *
     * @param {string} id The id to search a role for
     * @param {number} round Optional. Specifies a round other
     *   than current (will be normalized if there are more
     *   rounds than matches)
     *
     * @return {string|null} The role hold by id at the
     *    specified round or null if matches are not yet set
     *
     * @see Roler.getRolerFor
     * @see round2Index
     */
    MatcherManager.prototype.getRoleFor = function(id, round) {
        if (!this.matcher.getMatches()) return null;
        round = round2Index.call(this, 'getRoleFor', round);
        return this.roler.getRoleFor(id, round);
    };

    /**
     * ### Roler.getIdForRole
     *
     * Returns the id/s holding a roles at round x
     *
     * @param {string} role The role to check
     * @param {number} round Optional. Specifies a round other
     *   than current (will be normalized if there are more
     *   rounds than matches)
     *
     * @return {array|null} Array of id/s holding the role at round x, or
     *   null if matches are not yet set
     *
     * @see Roler.getIdForRole
     * @see round2Index
     */
    MatcherManager.prototype.getIdForRole = function(role, round) {
        if (!this.matcher.getMatches()) return null;
        round = round2Index.call(this, 'getIdForRole', round);
        return this.roler.getIdForRole(role, round);
    };

    /**
     * ### MatcherManager.getIterationRound
     *
     * Returns the pointer the round in the matcher (matches are cycled through)
     *
     * @return {number} The current iteration round
     *
     * @see Matcher.x
     * @see Matcher.hasNext
     */
    MatcherManager.prototype.getIterationRound = function() {
        return this.matcher.x || 0;
    };

    /**
     * ### MatcherManager.replaceId
     *
     * Replaces an id with a new one in all roles and matches
     *
     * If the number of players and rounds is large,
     * this operation becomes costly. Consider replacing the ID
     * manually after being returned.
     *
     * @param {string} oldId The id to be replaced
     * @param {string} newId The replacing id
     *
     * @return {boolean} TRUE, if the oldId was found and replaced
     *
     * @see Matcher.replaceId
     * @see Roler.replaceId
     *
     * @experimental
     *
     * TODO: this does not scale up. Maybe have another registry of
     * substituted ids.
     *
     * TODO: maybe return info about the replaced id, e.g. current
     * options, instead of boolean.
     */
    MatcherManager.prototype.replaceId = function(oldId, newId) {
        var res;
        res = this.matcher.replaceId(oldId, newId);
        res = res && this.roler.replaceId(oldId, newId);
        return res;
    };

    /**
     * ### MatcherManager.getSetupFor
     *
     * Returns the setup object (partner and role options) for a specific id
     *
     * @param {string} id The id to get the setup object for
     *
     * @return {object|null} The requested setup object or null if not found
     *
     * @see Matcher.match
     * @see round2index
     */
    MatcherManager.prototype.getSetupFor = function(id) {
        var out;
        if ('string' !== typeof id) {
            throw new TypeError('MatcherManager.getSetupFor: id must be ' +
                                'string. Found: ' + id);
        }
        out = this.lastMatchesById[id];
        return out || null;
    };

    // ## Helper Methods.

    /**
     * ### round2Index
     *
     * Parses a round into corresponding index of matches
     *
     * Important! Matches are 0-based, but rounds are 1-based.
     * `Matcher.normalizeRound` takes care of it.
     *
     * @param {number} round Optional. The round to parse to an index.
     *   Default: current game round.
     *
     * @return {number} The normalized round
     *
     * @see Matcher.normalizeRound
     * @see Matcher.x
     * @see Game.getCurrentGameStage
     */
    function round2Index(method, round) {
        if ('undefined' === typeof round) {
            round = this.node.game.getRound();
            if (round === 0) {
                throw new Error('MatcherManager.' + method + ': game stage ' +
                                'is 0.0.0, please specify a valid round');
            }
        }
        if ('number' === typeof round) {
            round = this.matcher.normalizeRound(round);
        }
        return round;
    }

    /**
     * ### randomPairs
     *
     * Matches players and/or roles in random pairs
     *
     * Supports odd number of players, if 3 roles are given in settings.
     *
     * @param {object} settings The settings object
     *
     * @return {array} The array of matches.
     */
    function randomPairs(settings) {
        var r1, r2;
        var ii, i, len;
        var roundMatches, nMatchesIdx, match, id1, id2, missId;
        var matches, matchesById, sayPartner, doRoles;
        var opts, roles, matchedRoles;

        var game, n;
        var nRounds;

        // Delete previous results.
        this.lastMatches = null;
        this.lastMatchesById = null;

        // Init local variables.

        matchesById = {};

        sayPartner = 'undefined' === typeof settings.sayPartner ?
            true : !!settings.sayPartner;

        doRoles = !!settings.roles;

        game = this.node.game;
        n = game.pl.size();

        // Settings the number of rounds.
        if ('undefined' !== typeof settings.rounds) {
            nRounds = settings.rounds;
        }
        else {
            nRounds = game.plot.getRound(game.getNextStep(), 'total');
        }
        if (nRounds > n-1) nRounds = n-1;

        // Algorithm: random.
        if (settings.match === 'random') {
            if (doRoles) {
                this.roler.clear();
                this.roler.setRoles(settings.roles, 2);
                this.matcher.init({ doRoles: doRoles });
            }
            this.matcher.generateMatches('random', n, {
                rounds: nRounds,
                // cycle: settings.cycle,
                skipBye: settings.skipBye,
                bye: settings.bye,
                fixedRoles: settings.fixedRoles,
                canMatchSameRole: settings.canMatchSameRole
            });
            this.matcher.setIds(game.pl.id.getAllKeys());
            // Generates new random matches for this round.
            this.matcher.match(true);
        }

        // Algorithm: round robin (but only if not already initialized
        // or if reInit = true).
        else {
            if (!this.matcher.matches || settings.reInit) {
                if (doRoles) {
                    this.roler.clear();
                    this.roler.setRoles(settings.roles, 2);
                    this.matcher.init({ doRoles: doRoles });
                }
                // Make a manual copy of settings object, and generate matches.
                this.matcher.generateMatches('roundrobin', n, {
                    rounds: nRounds,
                    cycle: settings.cycle,
                    skipBye: settings.skipBye,
                    bye: settings.bye,
                    fixedRoles: settings.fixedRoles,
                    canMatchSameRole: settings.canMatchSameRole
                });
                if (settings.assignerCb) {
                    this.matcher.setAssignerCb(settings.assignerCb);
                }
                this.matcher.setIds(game.pl.id.getAllKeys());
                // Generates matches.
                this.matcher.match(true);
            }
            // Cycle through the matches, if we do not have enough.
            else if (!this.matcher.hasNext()) {
                this.matcher.init( { x: null, y: null });
            }
        }

        // Get all the matches for round x, and increments x.
        nMatchesIdx = 'number' === typeof this.matcher.x ?
            (this.matcher.x + 1) : 0;
        // This also increments the index matcher.x.
        roundMatches = this.matcher.getMatch(nMatchesIdx);

        len = roundMatches.length;

        // Contains one remoteOptions object per player.
        matches = ((n % 2) === 0) ?
            new Array((len*2)) :
            (settings.skipBye ? new Array((len*2)-2) : new Array((len*2)-1));

        // The id in case the number of player is odd.
        missId = this.matcher.missingId;

        matchedRoles = this.roler.getRolifiedMatches();

        // While we have matches, send them to clients.
        ii = i = -1;
        for ( ; ++i < len ; ) {
            ii++;
            match = roundMatches[i];
            id1 = match[0];
            id2 = match[1];

            // Verify that id1 and id2 are still connected.
            if (!game.pl.exist(id1)) id1 = missId;
            if (!game.pl.exist(id2)) id2 = missId;

            // If both id1 and id2 are disconnected, skip matching them.
            if (id1 === id2) {
                // Reduce matches array length.
                len--;
                matches.length--;
                continue;
            }

            if (doRoles) {
                roles = matchedRoles[nMatchesIdx][i];

                // Prepare options to send to player 1, if role1 is defined.
                r1 = roles[0];

                if (r1) {
                    if (!sayPartner) {
                        opts = { id: id1, options: { role: r1 } };
                    }
                    else {
                        opts = { id: id1, options: { role: r1, partner: id2 } };
                    }
                    // Add options to array.
                    matches[ii] = opts;

                    // Keep reference.
                    matchesById[id1] = opts.options;
                }

                // Prepare options to send to player 2, if role2 is defined.
                r2 = roles[1];

                if (r2) {

                    // Increment ii index if both r1 and r2 are defined.
                    if (r1) ii++;

                    if (!sayPartner) {
                        opts = { id: id2, options: { role: r2 } };
                    }
                    else {
                        opts = { id: id2, options: { role: r2, partner: id1 } };
                    }
                    // Add options to array.
                    matches[ii] = opts;

                    // Keep reference.
                    matchesById[id2] = opts.options;
                }
            }
            else if (sayPartner) {
                if (id1 !== missId) {
                    opts = { id: id1, options: { partner: id2 } };
                    matches[ii] = opts;
                    matchesById[id1] = opts.options;
                }
                if (id2 !== missId) {
                    if (id1 !== missId) ii++;
                    opts = { id: id2, options: { partner: id1 } };
                    matches[ii] = opts;
                    matchesById[id2] = opts.options;
                }
            }
        }

        // Store references.
        this.lastMatches = matches;
        this.lastMatchesById = matchesById;
        this.lastSettings = settings;

        return matches;
    }

    // ## Closure
})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # GameDB
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Provides a simple, lightweight NO-SQL database for nodeGame
 *
 * It automatically indexes inserted items by:
 *
 *  - player,
 *  - stage.
 *
 * @see GameStage.compare
 * @see NDDB
 */
(function(exports, parent) {

    "use strict";

    // ## Global scope.
    var NDDB = parent.NDDB,
    GameStage = parent.GameStage,
    J = parent.JSUS;

    // Inheriting from NDDB.
    GameDB.prototype = new NDDB();
    GameDB.prototype.constructor = GameDB;

    // Expose constructors
    exports.GameDB = GameDB;

    /**
     * ## GameDB constructor
     *
     * Creates an instance of GameDB
     *
     * @param {object} options Optional. A configuration object
     * @param {array} db Optional. An initial array of items
     *
     * @see NDDB constructor
     */
    function GameDB(options, db) {
        var that;
        that = this;
        options = options || {};
        options.name = options.name || 'memory';

        if (!options.update) options.update = {};

        // Auto build indexes by default.
        options.update.indexes = true;

        // TODO: move on server-side only.
        options.defaultCSVHeader = [
            'session', 'treatment', 'player', 'stage', 'step', 'timestamp',
            'time', 'timeup'
        ];

        // Experimental. TODO.
        options.skipCSVKeys = {
            isCorrect: true,
            id: true,
            done: true
        };

        NDDB.call(this, options, db);

        this.comparator('stage', function(o1, o2) {
            var _o2;
            if ('string' === typeof o2.stage && that.node) {
                if (false === J.isInt(o2.stage)) {
                    _o2 = that.node.game.plot.normalizeGameStage(o2.stage);
                    if (_o2) o2.stage = _o2;
                }
            }
            return GameStage.compare(o1.stage, o2.stage);
        });

        this.hash('player', function(o) {
            return o.player;
        });

        this.hash('stage', function(o) {
            if (o.stage) return GameStage.toHash(o.stage, 'S.s.r');
        });

        this.view('done');

        // TODO: move on server-side only.
        this.on('save', function(opts, info) {
            if (opts.append) opts.flags = 'a';
            if (info.format === 'csv') decorateCSVSaveOptions(that, opts);
        }, true);

        this.stepView = function(step) {
            return this.view(step, function(item) {
                if (that.node.game.isStep(step, item.stage)) return true;
            });
        };

        this.stageView = function(stage) {
            return this.view(stage, function(item) {
                if (that.node.game.isStage(stage, item.stage)) return true;
            });
        };

        this.node = this.__shared.node;
    }

    /**
     * ### GameDB.add
     *
     * Wrapper around NDDB.insert
     *
     * Checks that the object contains a player and stage
     * property and also adds a timestamp and session field.
     *
     * @param {object} o The object to add
     *
     * @NDDB.insert
     */
    GameDB.prototype.add = function(o) {
        if ('string' !== typeof o.player) {
            throw new TypeError('GameDB.add: player missing or invalid: ', o);
        }
        if ('object' !== typeof o.stage) {
            throw new Error('GameDB.add: stage missing or invalid: ', o);
        }

        if (!o.timestamp) o.timestamp = Date.now ?
            Date.now() : new Date().getTime();

        o.session = this.node.nodename;

        o.treatment = this.node.game.settings.treatmentName;

        this.insert(o);
    };

    /**
     * ### decorateCSVSaveOptions
     *
     * Adds default options to improve data saving.
     *
     * @param {object} opts Optional. The option object to decorate
     */
    function decorateCSVSaveOptions(that, opts) {
        var toId, split, plot;
        if ('undefined' === typeof opts.bool2num) opts.bool2num = true;

        // Handle stage object.
        toId = 'undefined' === typeof opts.stageNum2Id ?
                    true : opts.stageNum2Id;
        split = 'undefined' === typeof opts.splitStage ?
                    true : opts.splitStage;

        plot = that.node.game.plot;

        if (!opts.adapter) opts.adapter = {};

        if (split) {
            if ('undefined' === typeof opts.adapter.stage) {
                opts.adapter.stage = function(i) {
                    if (!i.stage) return;
                    return toId ? plot.getStage(i.stage).id : i.stage.stage;
                };
            }
            if ('undefined' === typeof opts.adapter.step) {
                opts.adapter.step = function(i) {
                    if (!i.stage) return;
                    return toId ? plot.getStep(i.stage).id : i.stage.step;
                };
            }
            if ('undefined' === typeof opts.adapter.round) {
                opts.adapter.round = function(i) { return i.stage.round; };
            }
        }
        else {
            if ('undefined' === typeof opts.adapter.stage) {
                opts.adapter.stage = function(i) {
                    var s = i.stage;
                    if (!s) return;
                    if (toId) {
                        return plot.getStage(s).id + '.' +
                               plot.getStep(s).id + '.' + s.round;
                    }
                    return s.stage + '.' + s.step + '.' + s.round;
                };
            }
        }

        // Flatten.
        if (opts.flatten) {

            if ('undefined' === typeof opts.header &&
                'undefined' === typeof opts.headers) {

                opts.header = that.defaultCSVHeader || 'all';
            }

            opts.preprocess = function(item, current) {
                var s;
                // s = item.stage.stage + '.' + item.stage.step +
                // '.' + item.stage.round;
                s = that.node.game.plot.getStage(item.stage).id;
                s += '.' + that.node.game.plot.getStep(item.stage).id;
                s += '.' + item.stage.round;
                that.node.game.plot.getStage()
                if (item.time) item['time_' + s] = item.time;
                if (item.timeup) item['timeup_' + s] = item.timeup;
                if (item.timestamp) item['timestamp_' + s] = item.timestamp;
                delete item.time;
                delete item.timestamp;
            };
        }
    }

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # Game
 * Copyright(c) 2021 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Handles the flow of the game
 */
(function(exports, parent) {

    "use strict";

    // ## Global scope

    // Exposing Game constructor
    exports.Game = Game;

    var GameStage = parent.GameStage,
        GameMsg = parent.GameMsg,
        GameDB = parent.GameDB,
        GamePlot = parent.GamePlot,
        PlayerList = parent.PlayerList,
        Stager = parent.Stager,
        PushManager = parent.PushManager,
        SizeManager = parent.SizeManager,
        MatcherManager = parent.MatcherManager,
        J = parent.JSUS;

    var constants = parent.constants;
    var stageLevels = constants.stageLevels;
    var stateLevels = constants.stateLevels;

    /**
     * ## Game constructor
     *
     * Creates a new instance of Game
     *
     * @param {NodeGameClient} node A valid NodeGameClient object
     */
    function Game(node) {

        this.node = node;

        // This updates are never published.
        this.setStateLevel(stateLevels.UNINITIALIZED, 'S');
        this.setStageLevel(stageLevels.UNINITIALIZED, 'S');

        // ## Properties

        /**
         * ### Game.metadata
         *
         * The game's metadata
         *
         * This object is normally filled-in automatically with data
         * from the file `package.json` inside the game folder.
         *
         * Contains at least the following properties:
         *
         *  - name,
         *  - description,
         *  - version
         */
        this.metadata = {
            name:        'A nodeGame game',
            description: 'No description',
            version:     '0.0.1'
        };

        /**
         * ### Game.settings
         *
         * The game's settings
         *
         * This object is normally filled-in automatically with the settings
         * contained in the game folder: `game/game.settings`,
         * depending also on the chosen treatment.
         */
        this.settings = {};

        /**
         * ### Game.pl | playerList
         *
         * The list of players connected to the game
         *
         * The list may be empty, depending on the server settings.
         *
         * Two players with the same id, or any player with id equal to
         * `node.player.id` is not allowed, and it will throw an error.
         */
        this.playerList = this.pl = new PlayerList({
            log: this.node.log,
            logCtx: this.node,
            name: 'pl_' + this.node.nodename
        });

        this.pl.on('insert', function(p) {
            if (p.id === node.player.id) {
                throw new Error('node.game.pl.on.insert: cannot add player ' +
                                'with id equal to node.player.id.');
            }
        });

        /**
         * ### Game.ml | monitorList
         *
         * The list of monitor clients connected to the game
         *
         * The list may be empty, depending on the server settings
         */
        this.monitorList = this.ml = new PlayerList({
            log: this.node.log,
            logCtx: this.node,
            name: 'ml_' + this.node.nodename
        });

        /**
         * ### Game.memory
         *
         * A storage database for the game
         *
         * In the server logic the content of SET messages are
         * automatically inserted in this object
         *
         * @see NodeGameClient.set
         */
        this.memory = new GameDB({
            log: this.node.log,
            logCtx: this.node,
            shared: { node: this.node }
        });

        /**
         * ### Game.plot
         *
         * The Game plot
         *
         * @see GamePlot
         */
        this.plot = new GamePlot(this.node, new Stager());

        // TODO: check if we need this.
        // // Overriding stdout for game plot and stager.
        // this.plot.setDefaultLog(function() {
        //     // Must use apply, else will be executed in the wrong context.
        //     node.log.apply(node, arguments);
        // });

        /**
         * ### Game.role
         *
         * The "role" currently held in this game (if any)
         *
         * @see Game.gotoStep
         * @see Game.setRole
         * @see processGotoStepOptions
         */
        this.role = null;

        /**
         * ### Game.partner
         *
         * The id or alias of the "partner" in this game (if any)
         *
         * Some games are played in pairs, this variable holds the id
         * of the partner player.
         *
         * @see Game.setPartner
         * @see processGotoStepOptions
         */
        this.partner = null;

        /**
         * ### Game.matcher
         *
         * Handles assigning matching tasks
         *
         * Assigns roles to players, players to players, etc.
         *
         * @see Game.gotoStep
         */
        this.matcher = MatcherManager ? new MatcherManager(this.node) : null;

        /**
         * ### Game.timer
         *
         * Default game timer synced with stager 'timer' property
         *
         * @see GameTimer
         * @see GameTimer.syncWithStager
         */
        this.timer = this.node.timer.createTimer({
            name: 'game_timer',
            stagerSync: true
        });

        // Setting to stage 0.0.0 and starting.
        this.setCurrentGameStage(new GameStage(), 'S');
        this.setStateLevel(stateLevels.STARTING, 'S');

        /**
         * ### Game.paused
         *
         * TRUE, if the game is paused
         *
         * @see Game.pause
         * @see Game.resume
         */
        this.paused = false;

        /**
         * ### Game.pauseCounter
         *
         * Counts the number of times the game was paused
         *
         * @see Game.pause
         * @see Game.resume
         */
        this.pauseCounter = 0;

        /**
         * ### Game.willBeDone
         *
         * TRUE, if DONE was emitted and evaluated successfully
         *
         * If TRUE, when PLAYING is emitted `node.done` is called
         * immediately, and the game tries to step forward.
         *
         * @see NodeGameClient.done
         */
        this.willBeDone = false;

        /**
         * ### Game.globals
         *
         * Object pointing to the current step _globals_ properties
         *
         * Whenever a new step is executed the _globals_ properties of
         * the step are copied here. The _globals_ properties of the previous
         * stage are deleted.
         *
         * @see GamePlot
         * @see Stager
         */
        this.globals = {};

        /**
         * ### Game._steppedSteps
         *
         * Array of steps previously played
         *
         * @see Game.step
         * @see Game.stepBack
         *
         * @api private
         */
        this._steppedSteps = [ new GameStage() ];

        /**
         * ### Game._breakStage
         *
         * Flags to break current stage at next node.done call
         *
         * @see Game.breakStage
         */
        this._breakStage = false;

        /** ### Game.pushManager
         *
         * Handles pushing client to advance to next step
         *
         * @see PushManager
         */
        this.pushManager = new PushManager(this.node);

        /** ### Game.sizeManager
         *
         * Handles changes in the number of connected players
         *
         * @see SizeManager
         */
        this.sizeManager = new SizeManager(this.node);


        /** ### Game.session
         *
         * Stores variables and shares them with logic and other players
         *
         */
        (function(that, s, msg) {
            s = {};

            that.session = function(name, value, opts) {
                var to, from;
                opts = opts || {};
                from = opts.from || node.player.id;
                // If it is called from HTML before game is init.
                if (!from) {
                    from = '_own_';
                    node.once('PLAYER_CREATED', function(p) {
                        if (!s[from]) return;
                        s[p.id] = s[from];
                        s[from] = null;
                    });
                }
                if (!s[from]) s[from] = {};
                if (arguments.length > 1) {
                    s[from][name] = value;
                    to = 'undefined' === typeof opts.to ? 'SERVER' : opts.to;
                    if (to !== false) {
                        node.socket.send(node.msg.create({
                            target: 'SESSION',
                            data: { name: name, value: value },
                            to: to
                        }));
                    }
                }
                return s[from][name];
            };

            that.session.player = function(p) {
                return s[p] || {};
            };

        })(this);




    }

    // ## Game methods

    /**
     * ### Game.start
     *
     * Starts the game
     *
     * Calls the init function, and steps.
     *
     * Important: it does not use `Game.publishUpdate` because that is
     * just for change of state after the game has started.
     *
     * @param {object} options Optional. Configuration object. Fields:
     *
     *   - step: {boolean}. If false, jus call the init function, and
     *       does not enter the first step. Default: TRUE.
     *   - startStage: {GameStage}. If set, the game will step into
     *       the step _after_ startStage after initing. Default: 0.0.0
     *   - stepOptions: options to pass to the new step (only if step
     *       option is not FALSE).
     *
     * @see Game.step
     */
    Game.prototype.start = function(options) {
        var onInit, node, startStage;

        node = this.node;

        if (options && 'object' !== typeof options) {
            throw new TypeError('Game.start: options must be object or ' +
                                'undefined.');
        }
        if (node.player.placeholder) {
            throw new Error('Game.start: no player defined.');
        }
        if (!this.isStartable()) {
            throw new Error('Game.start: game cannot be started.');
        }
        node.info('game started.');

        // Store time.
        node.timer.setTimestamp('start');

        options = options || {};

        // Starts from beginning (default) or from a predefined stage
        // This options is useful when a player reconnets.
        startStage = options.startStage || new GameStage();

        // Update GLOBALS.
        this.updateGlobals(startStage);

        // INIT the game.
        onInit = this.plot.stager.getOnInit();
        if (onInit) {
            this.setStateLevel(stateLevels.INITIALIZING);
            node.emit('INIT');
            onInit.call(node.game);
        }

        this.setStateLevel(stateLevels.INITIALIZED);

        this.setCurrentGameStage(startStage, 'S');

        node.log('game started.');

        if (options.step !== false) this.step(options.stepOptions);
    };

    /**
     * ### Game.restart
     *
     * Stops and starts the game.
     *
     * @see Game.stop
     * @see Game.start
     */
    Game.prototype.restart = function() {
        this.stop();
        this.start();
    };

    /**
     * ### Game.stop
     *
     * Stops the current game
     *
     * Clears timers, event handlers, local memory, and window frame (if any).
     *
     * Does **not** clear _node.env_ variables and any node.player extra
     * property.
     *
     * GameStage is set to 0.0.0 and server is notified.
     */
    Game.prototype.stop = function() {
        var node;
        if (!this.isStoppable()) {
            throw new Error('Game.stop: game cannot be stopped.');
        }

        node = this.node;

        // Destroy currently running timers.
        node.timer.destroyAllTimers(true);

        // Remove all events registered during the game.
        node.events.ee.game.clear();
        node.events.ee.stage.clear();
        node.events.ee.step.clear();

        node.socket.eraseBuffer();

        // Clear memory.
        this.memory.clear();

        // If a _GameWindow_ object is found, clears it.
        if (node.window) node.window.reset();

        // Update state/stage levels and game stage.
        this.setStateLevel(stateLevels.STARTING, 'S');
        this.setStageLevel(stageLevels.UNINITIALIZED, 'S');
        // This command is notifying the server.
        this.setCurrentGameStage(new GameStage());

        // TODO: check if we need pl and ml again.
        node.game = null;
        node.game = new Game(node);
        node.game.pl = this.pl;
        node.game.ml = this.ml;

        node.log('game stopped.');
    };

    /**
     * ### Game.gameover
     *
     * Ends the game
     *
     * Calls the gameover function, sets levels.
     *
     * TODO: should it set the game stage to 0.0.0 again ?
     */
    Game.prototype.gameover = function() {
        var onGameover, node;
        node = this.node;

        if (this.getStateLevel() >= stateLevels.FINISHING) {
            node.warn('Game.gameover called on a finishing game.');
            return;
        }

        node.emit('GAME_ALMOST_OVER');

        // Call gameover callback, if it exists.
        onGameover = this.plot.stager.getOnGameover();
        if (onGameover) {
            this.setStateLevel(stateLevels.FINISHING);
            onGameover.call(node.game);
        }

        this.setStateLevel(stateLevels.GAMEOVER);
        this.setStageLevel(stageLevels.DONE);

        node.log('game over.');
        node.emit('GAME_OVER');
    };

    /**
     * ### Game.isPaused
     *
     * Returns TRUE, if game is paused
     *
     * @see Game.pause
     */
    Game.prototype.isPaused = function() {
        return this.paused;
    };

    /**
     * ### Game.pause
     *
     * Sets the game to pause
     *
     * @param {string} param Optional. A parameter to pass along the
     *   emitted events PAUSING and PAUSED.
     *
     * @see Game.resume
     */
    Game.prototype.pause = function(param) {
        var msgHandler, node;

        if (!this.isPausable()) {
            throw new Error('Game.pause: game cannot be paused.');
        }

        node = this.node;
        node.emit('PAUSING', param);

        this.paused = true;
        this.pauseCounter++;

        // If the Stager has a method for accepting messages during a
        // pause, pass them to it. Otherwise, buffer the messages
        // until the game is resumed.
        msgHandler = this.plot.getProperty(this.getCurrentGameStage(),
                                           'pauseMsgHandler');
        if (msgHandler) {
            node.socket.setMsgListener(function(msg) {
                msg = node.socket.secureParse(msg);
                msgHandler.call(node.game, msg.toInEvent(), msg);
            });
        }

        node.timer.setTimestamp('paused');
        node.emit('PAUSED', param);

        // TODO: broadcast?

        node.log('game paused.');
    };

    /**
     * ### Game.resume
     *
     * Resumes the game from pause
     *
     * @param {string} param Optional. A parameter to pass along the
     *   emitted events RESUMING and RESUMED.
     *
     * @see Game.pause
     */
    Game.prototype.resume = function(param) {
        var msgHandler, node;

        if (!this.isResumable()) {
            throw new Error('Game.resume: game cannot be resumed.');
        }

        node = this.node;

        node.emit('RESUMING', param);

        this.paused = false;

        // If the Stager defines an appropriate handler, give it the messages
        // that were buffered during the pause.
        // Otherwise, emit the buffered messages normally.
        msgHandler = this.plot.getProperty(this.getCurrentGameStage(),
                                           'resumeMsgHandler');

        node.socket.clearBuffer(msgHandler);

        // Reset the Socket's message handler to the default:
        node.socket.setMsgListener();
        node.timer.setTimestamp('resumed');
        node.emit('RESUMED', param);

        // TODO: broadcast?

        // Maybe the game was LOADED during the pausing.
        // In this case the PLAYING event got lost.
        if (this.shouldEmitPlaying()) {
            this.node.emit('PLAYING');
        }

        node.log('game resumed.');
    };

    /**
     * ### Game.shouldStep
     *
     * Checks if the next step can be executed
     *
     * The game can step forward if:
     *
     *   - There is the "right" number of players.
     *   - The game has been initialized, and is not in GAME_OVER.
     *   - The stepRule function for current step and returns TRUE.
     *
     * @param {number} stageLevel Optional. If set, it is used instead
     *   of `Game.getStageLevel()`
     *
     * @return {boolean} TRUE, if stepping is allowed.
     *
     * @see Game.step
     * @see SizeManager.checkSize
     * @see stepRules
     */
    Game.prototype.shouldStep = function(stageLevel) {
        var stepRule, curStep;

        if (!this.sizeManager.checkSize() || !this.isSteppable()) return false;

        curStep = this.getCurrentGameStage();
        stepRule = this.plot.getStepRule(curStep);

        if ('function' !== typeof stepRule) {
            throw new TypeError('Game.shouldStep: stepRule must be function. ' +
                                'Found: ' + stepRule);
        }

        stageLevel = stageLevel || this.getStageLevel();
        return stepRule(curStep, stageLevel, this.pl, this);
    };

    /**
     * ### Game.breakStage
     *
     * Sets/Removes a flag to break current stage
     *
     * If the flag is set, when node.done() is invoked, the game will
     * step into the next stage instead of into the next step.
     *
     * @param {boolean} doBreak Optional. TRUE to set the flag, FALSE to
     *   remove it, or undefined to just get returned the current value.
     *
     * @return {boolean} The value of the flag before it is overwritten
     *   by current call.
     *
     * @see Game._breakStage
     * @see Game.gotoStep
     */
    Game.prototype.breakStage = function(doBreak) {
        var b;
        b = this._breakStage;
        if ('undefined' !== typeof doBreak) this._breakStage = !!doBreak;
        return b;
    };

    /**
     * ### Game.stepBack
     *
     * Executes the previous stage / step
     *
     * Important! This function should be used only with the appropriate
     * syncStepping settings and step rules. For more info see:
     *
     *   https://github.com/nodeGame/nodegame/wiki/BackButton-Widget-v5
     *
     * @param {object} options Optional. Options passed to
     *   `getPreviousStep` and later `gotoStep`
     *
     * @return {boolean} FALSE, if the execution encountered an error
     *
     * @see Game.getPreviousStep
     * @see Game.gotoStep
     */
    Game.prototype.stepBack = function(options) {
        var prevStep;
        prevStep = this.getPreviousStep(1, options);
        if (!prevStep) return false;
        // Update the array of stepped steps before we go back
        // so that game.getPreviousStep() keeps working correctly.
        // We need to remove current step, as well as previous, which is
        // about to be re-added.
        this._steppedSteps.splice(this._steppedSteps.length - 2, 2);
        return this.gotoStep(prevStep, options);
    };

    /**
     * ### Game.step
     *
     * Executes the next stage / step
     *
     * @param {object} options Optional. Options passed to `gotoStep`
     *
     * @return {boolean} FALSE, if the execution encountered an error
     *
     * @see Game.stager
     * @see Game.currentStage
     * @see Game.gotoStep
     * @see Game.execStep
     * @see Game.breakStage
     */
    Game.prototype.step = function(options) {
        var curStep, nextStep;
        curStep = this.getCurrentGameStage();
        // Gets current value and sets breakStage flag in one call.
        if (this.breakStage(false)) nextStep = this.plot.nextStage(curStep);
        else nextStep = this.plot.next(curStep);
        return this.gotoStep(nextStep, options);
    };

    /**
     * ### Game.gotoStep
     *
     * Updates the current game step to toStep and executes it.
     *
     * It unloads the old step listeners, before loading the listeners of the
     * new one.
     *
     * It does note check if the next step is different from the current one,
     * and in this case the same step is re-executed.
     *
     * @param {string|GameStage} nextStep A game stage object, or a string like
     *   GAME_OVER.
     * @param {object} options Optional. Additional options, such as:
     *   `willBeDone` (immediately calls `node.done()`, useful
     *   for reconnections)
     *
     * @return {boolean|null} TRUE, if the step is found and it is executed;
     *   FALSE, if the step is not found or can't be executed; NULL, if
     *   we reached the end of the game sequence or it is game over.
     *
     * @see Game.execStep
     * @see PushManager.clearTimer
     * @see MatcherManager.match
     *
     * @emit STEPPING
     */
    Game.prototype.gotoStep = function(nextStep, options) {
        var node, tmp;

        // Steps references.
        var curStep, curStageObj, nextStepObj, nextStageObj;

        // Flags that we need to execute the stage init function.
        var stageInit;

        // Step init callback.
        var stepInitCb;

        // Variable related to matching roles and partners.
        var matcherOptions, matches, role, partner;
        var i, len, pid;

        // Sent to every client (if syncStepping and if necessary).
        var remoteOptions;

        // Value of exit cb for a step.
        var curStepExitCb;

        if (!this.isSteppable()) {
            throw new Error('Game.gotoStep: game cannot be stepped');
        }

        if ('string' !== typeof nextStep && 'object' !== typeof nextStep) {
            throw new TypeError('Game.gotoStep: nextStep must be ' +
                                'a object or a string. Found: ' + nextStep);
        }

        if (options && 'object' !== typeof options) {
            throw new TypeError('Game.gotoStep: options must be object or ' +
                                'undefined. Found: ' + options);
        }

        node = this.node;

        node.silly('Next step ---> ' + nextStep);

        // TODO: even if node.game.timer.syncWithStage is on,
        // node.done() is not called on logics. So the timer
        // is not stopped. We do it manually here for the moment,
        // and we clear also the milliseconds count.
        this.timer.reset();

        // Clear push-timer.
        this.pushManager.clearTimer();

        curStep = this.getCurrentGameStage();
        curStageObj = this.plot.getStage(curStep);
        // We need to call getProperty because getStep does not mixin tmpCache.
        // We do not lookup into the stage.
        curStepExitCb = this.plot.getProperty(curStep, 'exit',
                                              null, { stage: true });

        // Clear the cache of temporary changes to steps.
        this.plot.tmpCache.clear();

        // By default socket journal is off and cleared.
        // Need to do it before setup messages are send to clients.
        if (node.socket.journalOn) {
            node.socket.journalOn = false;
            node.socket.journal.clear();
        }

        // Sends start / step command to connected clients if option is on.
        if (this.plot.getProperty(nextStep, 'syncStepping')) {

            matcherOptions = this.plot.getProperty(nextStep, 'matcher');

            if (matcherOptions && 'object' === typeof matcherOptions) {

                // matches = [
                //             {
                //               id: 'playerId',
                //               options: {
                //                  role: "A", // Optional.
                //                  partner: "XXX", // Optional.
                //               }
                //             },
                //             ...
                //           ];
                //
                matches = this.matcher.match(matcherOptions);
                i = -1, len = matches.length;
                for ( ; ++i < len ; ) {
                    pid = matches[i].id;
                    // TODO: Allow a more general modification of plot obj
                    // in remote clients via a new callback, e.g. remoteOptions.
                    remoteOptions = { plot: matches[i].options };

                    if (curStep.stage === 0) {
                        node.remoteCommand('start', pid, {
                            stepOptions: remoteOptions
                        });
                    }
                    else {
                        remoteOptions.targetStep = nextStep;
                        node.remoteCommand('goto_step', pid, remoteOptions);
                    }
                }
            }
            else {

                if (true === matcherOptions) {
                    remoteOptions = { plot: { role: true, partner: true }};
                }

                if (curStep.stage === 0) {
                    // Note: Game.start looks for the stepOptions property
                    // and passes it Game.step.
                    node.remoteCommand('start', 'ROOM', {
                        stepOptions: remoteOptions
                    });
                }
                else {
                    // Note: 'goto_step' listeners extract the targetStep
                    // property from object if payload is not the targetStep
                    // itself (string|GameStage).
                    if (!remoteOptions) remoteOptions = nextStep;
                    else remoteOptions.targetStep = nextStep;
                    node.remoteCommand('goto_step', 'ROOM', remoteOptions);
                }

                // this.matcher.clear();
            }
        }

        // Calling exit function of the step.
        if (curStepExitCb) {
            this.setStateLevel(stateLevels.STEP_EXIT);
            this.setStageLevel(stageLevels.EXITING);

            curStepExitCb.call(this);
        }

        // Listeners from previous step are cleared (must be done after exit).
        node.events.ee.step.clear();

        // Emit buffered messages.
        if (node.socket.shouldClearBuffer()) {
            node.socket.clearBuffer();
        }

        // Destroy timers created in current step.
        node.timer.destroyStepTimers();

        // String STEP.

        if ('string' === typeof nextStep) {

            // TODO: see if we can avoid code duplication below.
            // Calling exit function of the stage.
            // Note: stage.exit is not inherited.
            if (curStageObj && curStageObj.exit) {
                this.setStateLevel(stateLevels.STAGE_EXIT);
                this.setStageLevel(stageLevels.EXITING);

                curStageObj.exit.call(this);
            }
            // Clear any event listeners added in the stage exit function.
            node.events.ee.stage.clear();

            if (nextStep === GamePlot.GAMEOVER) {
                this.gameover();
                // Emit buffered messages:
                if (node.socket.shouldClearBuffer()) {
                    node.socket.clearBuffer();
                }
                return null;
            }
            // Was:
            // else do nothing
            // return null;
            else {
                // Try to resolve game stage.
                tmp = this.plot.normalizeGameStage(nextStep);
                if (!nextStep) {
                    throw new Error('Game.gotoStep: could not resolve step: ' +
                                    nextStep);
                }
                nextStep = tmp;
                tmp = null;
            }
        }

        // Here we start processing the new STEP.

        // TODO maybe update also in case of string.
        node.emit('STEPPING', curStep, nextStep);

        // Check for stage/step existence:
        nextStageObj = this.plot.getStage(nextStep);
        if (!nextStageObj) return false;
        nextStepObj = this.plot.getStep(nextStep);
        if (!nextStepObj) return false;

        // If we enter a new stage we need to update a few things.
        if (!curStageObj || nextStageObj.id !== curStageObj.id) {

            // Calling exit function.
            // Note: stage.exit is not inherited.
            if (curStageObj && curStageObj.exit) {
                this.setStateLevel(stateLevels.STAGE_EXIT);
                this.setStageLevel(stageLevels.EXITING);

                curStageObj.exit.call(this);
            }

            // Destroy timers created in current stage.
            node.timer.destroyStageTimers();

            // Mark stage init.
            stageInit = true;
        }

        // stageLevel needs to be changed (silent), otherwise it stays
        // DONE for a short time in the new game stage:
        this.setStageLevel(stageLevels.UNINITIALIZED, 'S');
        this.setCurrentGameStage(nextStep);

        // Process options before calling any init function. Sets a role also.
        if ('object' === typeof options) {
            processGotoStepOptions(this, options);
        }
        else if (options) {
            throw new TypeError('Game.gotoStep: options must be object ' +
                                'or undefined. Found: ' +  options);
        }

        // Properties `role` and `partner` might have been specified
        // in the options, processed by processGotoStepOptions and
        // inserted in the plot, or be already in the plot.
        role = this.plot.getProperty(nextStep, 'role');

        if (role === true) {
            role = this.role;
            if (!role) {
                throw new Error('Game.gotoStep: "role" is true, but no ' +
                                'previous role is found in step ' + nextStep);
            }
        }
        else {
            if (!role) role = null;
            else if ('function' === typeof role) role = role.call(this);

            if (role === null && this.getProperty('roles') !== null) {
                throw new Error('Game.gotoStep: "role" is null, but "roles" ' +
                                'are found in step ' + nextStep);
            }
        }
        // Overwrites step properties if a role is set.
        this.setRole(role, true);

        partner = this.plot.getProperty(nextStep, 'partner');
        if (!partner) partner = null;
        else if (partner === true) partner = this.partner;
        else if ('function' === typeof partner) partner = partner.call(this);
        this.setPartner(partner, true);

        if (stageInit) {
            // Store time.
            node.timer.setTimestamp('stage', (new Date()).getTime());

            // Clear the previous stage listeners.
            node.events.ee.stage.clear();

            this.setStateLevel(stateLevels.STAGE_INIT);
            this.setStageLevel(stageLevels.INITIALIZING);

            // Execute the init function of the stage, if any:
            // Note: this property is not inherited.
            if (nextStageObj.hasOwnProperty('init')) {
                nextStageObj.init.call(node.game);
            }
        }

        // Important! Cannot use: nextStepObj.init because
        // a role might have changed the init function, or
        // there might be a default property (setDefaultProperty).
        // We are the skipping the stage.init property.
        stepInitCb = this.plot.getProperty(nextStep, 'init',
                                           null, { stage: true });

        // Execute the init function of the step, if any.
        if (stepInitCb) {
            this.setStateLevel(stateLevels.STEP_INIT);
            this.setStageLevel(stageLevels.INITIALIZING);
            stepInitCb.call(node.game);
        }

        this.setStateLevel(stateLevels.PLAYING_STEP);
        this.setStageLevel(stageLevels.INITIALIZED);

        // Updating the globals object.
        this.updateGlobals(nextStep);

        // Reads Min/Max/Exact Players properties.
        this.sizeManager.init(nextStep);

        // Emit buffered messages.
        if (node.socket.shouldClearBuffer()) node.socket.clearBuffer();

        // Update list of stepped steps.
        this._steppedSteps.push(nextStep);

        // TODO: check if here is right place, or better in execStep.
        // If reconnect is TRUE we save a copy of  all messages sent to clients.
        // Note: the journal is active only if Game.isReady is true.
        if (this.plot.getProperty(nextStep, 'reconnect') === true) {
            node.socket.journalOn = true;
        }

        // If we should be done now, we emit PLAYING without executing the step.
        // node.game.willBeDone is already set, and will trigger node.done().
        if (this.beDone) node.emit('PLAYING');
        else this.execStep(this.getCurrentGameStage());

        return true;
    };

    /**
     * ### Game.execStep
     *
     * Executes the specified stage object
     *
     * @param {GameStage} step Step to execute
     */
    Game.prototype.execStep = function(step) {
        var cb, origCb;
        var widget, widgetObj, widgetRoot;
        var widgetCb, widgetExit, widgetDone;
        var doneCb, origDoneCb, exitCb, origExitCb;
        var w, frame, uri, frameOptions, frameAutoParse, reloadFrame;

        if ('object' !== typeof step) {
            throw new TypeError('Game.execStep: step must be object. Found: ' +
                                step);
        }

        cb = this.plot.getProperty(step, 'cb');
        frame = this.plot.getProperty(step, 'frame');
        widget = this.plot.getProperty(step, 'widget');

        if (widget) {
            // Mark that it is a widget step.
            this.widgetStep = true;

            // Parse input params. // TODO: throws errors.
            if ('string' === typeof widget) widget = { name: widget };
            if ('string' !== typeof widget.id) {
                widget.id = 'ng_step_widget_' + widget.name;
            }
            if (!widget.ref) {
                widget.ref = widget.name.toLowerCase();
                // Make sure it is unique.
                if (this[widget.ref]) {
                    widget.ref = J.uniqueKey(this, widget.ref);
                }
            }

            // Add options, if missing.
            // User can specify the options in a nested object, or flat them
            // down in case there are no conflicts.
            if (!widget.options) widget.options = widget;

            // Make main callback to get/append the widget.
            widgetCb = function() {

                if (widget.append === false) {
                    widgetObj = this.node.widgets.get(widget.name,
                                                      widget.options);
                }
                else {
                    // Default class.
                    if (!widget.options.className) {
                        widget.options.className = 'centered';
                    }
                    widget.options.widgetStep = true;

                    // Default id 'container' (as in default.html).
                    if ('string' === typeof widget.root) {
                        widgetRoot = widget.root;
                    }
                    else if ('undefined' !== typeof widget.root) {
                        throw new TypeError('Game.execStep: widget.root must ' +
                                            'be string or undefined. Found: ' +
                                            widget.root);
                    }
                    else {
                        widgetRoot = 'container';
                    }
                    // If widgetRoot is not existing, it follows the
                    // default procedure for appending a widget.
                    widgetRoot =  W.getElementById(widgetRoot);
                    widgetObj = this.node.widgets.append(widget.name,
                                                         widgetRoot,
                                                         widget.options);
                }
                node.game[widget.ref] = widgetObj;
            };

            // Make the step callback.
            // Notice: This works with roles also.
            if (cb) {
                origCb = cb;
                cb = function() {
                    widgetCb.call(this);
                    origCb.call(this);
                };
            }
            else {
                cb = widgetCb;
            }

            // Make the done callback to send results.
            widgetDone = function() {
                var values, opts, req;
                req = widgetObj.required || widgetObj.requiredChoice;
                // TODO: harmonize: required or checkValues?
                if (req && widget.checkValues !== false) {
                    opts = { highlight: true, markAttempt: true };
                }
                else {
                    opts = { highlight: false, markAttempt: false };
                }
                // Under some special conditions (e.g., very fast DONE
                // clicking this can be null. TODO: check why.
                // Changed from this[widget.ref] to widgetObj.
                values = widgetObj.getValues(opts);

                // If it is not timeup, and user did not
                // disabled it, check answers.
                if (req && widget.checkValues !== false &&
                    !node.game.timer.isTimeup()) {

                    // Widget must return some values (otherwise it
                    // is impossible to check if the values are OK).
                    if (values &&
                        // TODO: check whether it is fine to comment out
                        // the checks on missValues. We should rely only
                        // on isCorrect, but some widgets might be outdated.
                        // (values.missValues === true ||
                        // (values.missValues && values.missValues.length) ||
                        (values.choice === null ||
                        values.isCorrect === false)) {


                        if (values._scrolledIntoView !== true &&
                            'function' === typeof
                            widgetObj.bodyDiv.scrollIntoView) {

                                widgetObj.bodyDiv.scrollIntoView({
                                    behavior: 'smooth'
                                });

                            // TODO: delete _scrolledIntoView ?
                        }

                        return false;
                    }
                }

                return values;
            };
            doneCb = this.plot.getProperty(step, 'done');
            if (doneCb) {
                origDoneCb = doneCb;
                doneCb = function() {
                    var values, valuesCb;
                    values = widgetDone.call(this);
                    if (values !== false) {
                        valuesCb = origDoneCb.call(this, values);
                        // Standard DONE callback behavior (to modify objects).
                        if ('undefined' !== typeof valuesCb) {
                            values = valuesCb;
                        }
                    }
                    return values;
                };
            }
            else {
                doneCb = widgetDone;
            }

            // Update the exit function for this step.
            this.plot.tmpCache('done', doneCb);

            // Make the exit callback (destroy widget by default).
            if (widget.destroyOnExit !== false) {
                widgetExit = function() {
                    // It can happen with a gotoStep remote command.
                    if (!node.game[widget.ref]) return;
                    node.game[widget.ref].destroy();
                    // Remove node.game reference.
                    node.game[widget.ref] = null;
                };
                // We are skipping the stage.exit property.
                exitCb = this.plot.getProperty(step, 'exit',
                                               null, { stage: true });
                if (exitCb) {
                    origExitCb = exitCb;
                    exitCb = function() {
                        widgetExit.call(this);
                        origExitCb.call(this);
                    };
                }
                else {
                    exitCb = widgetExit;
                }
                // Update the exit function for this step.
                this.plot.tmpCache('exit', exitCb);
            }

            // Sets a default frame, if none was found.
            if (widget.append !== false && !frame) {
                frame = '/pages/default.html';
            }
        }
        else {
            this.widgetStep = false;
        }

        w = this.node.window;
        // Handle frame loading natively, if required.
        if (frame) {
            frameOptions = {};
            if ('function' === typeof frame) frame = frame.call(node.game);
            if ('string' === typeof frame) {
                uri = frame;
            }
            else if ('object' === typeof frame) {
                uri = frame.uri;
                if ('string' !== typeof uri) {
                    throw new TypeError('Game.execStep: frame.uri must ' +
                                        'be string: ' + uri + '. ' +
                                        'Step: ' + step);
                }
                frameOptions.frameLoadMode = frame.loadMode;
                frameOptions.storeMode = frame.storeMode;
                frameAutoParse = frame.autoParse;
                if (frameAutoParse) {
                    // Replacing TRUE with node.game.settings.
                    if (frameAutoParse === true) {
                        frameAutoParse = this.settings;
                    }

                    frameOptions.autoParse = frameAutoParse;
                    frameOptions.autoParseMod = frame.autoParseMod;
                    frameOptions.autoParsePrefix = frame.autoParsePrefix;
                }
            }
            else {
                throw new TypeError('Game.execStep: frame must be string or ' +
                                    'object. Found: ' + frame + '. ' +
                                    'Step: ' + step);

            }

            if (w) reloadFrame = uri !== w.unprocessedUri;
            // We reload the frame if (order matters):
            // - it is a different uri from previous step,
            // - unless frameOptions.reload is false,
            // - or it is a different stage or round.
            if (!reloadFrame) {
                if ('undefined' !== typeof frame.reload) {
                    reloadFrame = !!frame.reload;
                }
                else {
                    // Get the previously played step
                    // (-2, because current step is already inserted).
                    reloadFrame =
                        this._steppedSteps[this._steppedSteps.length-2];
                    if (reloadFrame) {
                        reloadFrame = (reloadFrame.round !== step.round ||
                                       reloadFrame.stage !== step.stage);
                    }
                    else {
                        reloadFrame = true;
                    }
                }
            }

            if (reloadFrame) {
                // Auto load frame and wrap cb.
                this.execCallback(function() {
                    this.node.window.loadFrame(uri, cb, frameOptions);
                });
            }
            else {
                // Duplicated as below.
                this.execCallback(cb);
                if (w) {
                    w.adjustFrameHeight(0, 120);
                    if (frame.scrollUp !== false) window.scrollTo(0,0);
                }
            }
        }
        else {
            // Duplicated as above.
            this.execCallback(cb);
            if (w) {
                w.adjustFrameHeight(0, 120);
                window.scrollTo(0, 0);
            }
        }
    };

    /**
     * ### Game.execCallback
     *
     * Executes a game callback
     *
     * Sets the stage levels before and after executing the callback,
     * and emits an event before exiting.
     *
     * @param {function} cb The callback to execute
     *
     * @return {mixed} res The return value of the callback
     *
     * @emit 'STEP_CALLBACK_EXECUTED'
     */
    Game.prototype.execCallback = function(cb) {
        var res;
        this.setStageLevel(stageLevels.EXECUTING_CALLBACK);

        // Execute custom callback. Can throw errors.
        res = cb.call(this.node.game);
        if (res === false) {
            // A non fatal error occurred.
            this.node.err('A non fatal error occurred in callback ' +
                          'of stage ' + this.getCurrentGameStage());
        }

        this.setStageLevel(stageLevels.CALLBACK_EXECUTED);
        this.node.emit('STEP_CALLBACK_EXECUTED');
        // Internal listeners will check whether we need to emit PLAYING.
    };

    /**
     * ### Game.getCurrentStepObj
     *
     * Returns the object representing the current game step.
     *
     * The returning object includes all the properties, such as:
     * _id_, _cb_, _timer_, etc.
     *
     * @return {object} The game-step as defined in the stager.
     *
     * @see Stager
     * @see GamePlot
     */
    Game.prototype.getCurrentStepObj = function() {
        return this.plot.getStep(this.getCurrentGameStage());
    };

    /**
     * ### Game.getCurrentStep
     *
     * Alias for Game.prototype.getCurrentStepObj
     *
     * @deprecated
     */
    Game.prototype.getCurrentStep = Game.prototype.getCurrentStepObj;

    /**
     * ### Game.getCurrentStageObj
     *
     * Returns the object representing the current game stage.
     *
     * The returning object includes all the properties, such as:
     * _id_, _init_, etc.
     *
     * @return {object} The game-stage as defined in the stager.
     *
     * @see Stager
     * @see GamePlot
     */
    Game.prototype.getCurrentStageObj = function() {
        return this.plot.getStage(this.getCurrentGameStage());
    };

    /**
     * ### Game.getCurrentStepProperty
     *
     * Returns the object representing the current game step.
     *
     * The returning object includes all the properties, such as:
     * _id_, _cb_, _timer_, etc.
     *
     * @return {object} The game-step as defined in the stager.
     *
     * @see Stager
     * @see GamePlot
     */
    Game.prototype.getCurrentStepProperty = function(propertyName) {
        var step;
        if ('string' !== typeof propertyName) {
            throw new TypeError('Game.getCurrentStepProperty: propertyName ' +
                                'must be string');
        }
        step = this.plot.getStep(this.getCurrentGameStage());
        return 'undefined' === typeof step[propertyName] ?
            null : step[propertyName];
    };

    /**
     * ### Game.getCurrentGameStage
     *
     * Returns the GameStage that is currently being executed.
     *
     * @param {boolean} clone If TRUE, the GameStage is cloned, otherwise a
     *   reference is returned.
     *
     * @return {GameStage} The stage currently played.
     *
     * @see node.player.stage
     */
    Game.prototype.getCurrentGameStage = function(clone) {
        var s = this.node.player.stage;
        return clone ?
            new GameStage({ stage: s.stage, step: s.step, round: s.round }) : s;
    };

    /**
     * ### Game.setCurrentGameStage
     *
     * Sets the current game stage and notifies the server
     *
     * Stores the value of current game stage in `node.player.stage`.
     *
     * By default, it does not send the update to the server if the
     * new stage is the same as the previous one. However, it is
     * possible to override this behavior with specyfing a second
     * parameter `mod`.
     *
     * @param {string|GameStage} gameStage The value of the update.
     *   For example, an object, or a string like '1.1.1'.
     * @param {string} mod Optional. A string modifiying the default
     *   behavior ('F' = force, 'S' = silent').
     *
     * @see Game.publishUpdate
     */
    Game.prototype.setCurrentGameStage = function(gameStage, mod) {
        gameStage = new GameStage(gameStage);
        if (mod === 'F' ||
            (!mod && GameStage.compare(this.getCurrentGameStage(),
                                       gameStage) !== 0)) {

            // Important: First publish, then actually update.
            // The stage level, must also be sent in the published update,
            // otherwise we could have a mismatch in the remote
            // representation of the stage + stageLevel of the client.
            this.publishUpdate('stage', {
                stage: gameStage,
                stageLevel: this.getStageLevel()
            });
        }

        this.node.player.stage = gameStage;
    };

    /**
     * ### Game.getStateLevel
     *
     * Returns the state of the nodeGame engine
     *
     * The engine states are defined in `node.stateLevels`,
     * and it is of the type: STAGE_INIT, PLAYING_STEP, GAMEOVER, etc.
     * The return value is a reference to `node.player.stateLevel`.
     *
     * @return {number} The state of the engine.
     * @see node.player.stateLevel
     * @see node.stateLevels
     */
    Game.prototype.getStateLevel = function() {
        return this.node.player.stateLevel;
    };

    /**
     * ### Game.setStateLevel
     *
     * Sets the current game state level, and optionally notifies the server
     *
     * The value is actually stored in `node.player.stateLevel`.
     *
     * Stage levels are defined in `node.stageLevels`, for example:
     * STAGE_INIT, PLAYING_STEP, GAMEOVER, etc.
     *
     * By default, it does not send the update to the server if the
     * new state level is the same as the previous one. However, it is
     * possible to override this behavior with specyfing a second
     * parameter `mod`.
     *
     * @param {number} stateLevel The value of the update.
     * @param {string} mod Optional. A string modifiying the default
     *   behavior ('F' = force, 'S' = silent').
     *
     * @see Game.publishUpdate
     * @see node.stageLevels
     */
    Game.prototype.setStateLevel = function(stateLevel, mod) {
        var node;
        node = this.node;
        if ('number' !== typeof stateLevel) {
            throw new TypeError('Game.setStateLevel: stateLevel must be ' +
                                'number. Found: ' + stateLevel);
        }
        // Important: First publish, then actually update.
        if (mod === 'F' || (!mod && this.getStateLevel() !== stateLevel)) {
            this.publishUpdate('stateLevel', {
                stateLevel: stateLevel
            });
        }
        node.player.stateLevel = stateLevel;
    };

    /**
     * ### Game.getStageLevel
     *
     * Return the execution level of the current game stage
     *
     * The execution level is defined in `node.stageLevels`,
     * and it is of the type INITIALIZED, CALLBACK_EXECUTED, etc.
     * The return value is a reference to `node.player.stageLevel`.
     *
     * @return {number} The level of the stage execution.
     * @see node.player.stageLevel
     * @see node.stageLevels
     */
    Game.prototype.getStageLevel = function() {
        return this.node.player.stageLevel;
    };

    /**
     * ### Game.setStageLevel
     *
     * Sets the current game stage level, and optionally notifies the server
     *
     * The value is actually stored in `node.player.stageLevel`.
     *
     * Stage levels are defined in `node.stageLevels`, for example:
     * PLAYING, DONE, etc.
     *
     * By default, it does not send the update to the server if the
     * new state level is the same as the previous one. However, it is
     * possible to override this behavior with specyfing a second
     * parameter `mod`.
     *
     * @param {string|GameStage} gameStage The value of the update.
     * @param {string} mod Optional. A string modifiying the default
     *   behavior ('F' = force, 'S' = silent').
     *
     * @see Game.publishUpdate
     * @see node.stageLevels
     */
    Game.prototype.setStageLevel = function(stageLevel, mod) {
        var node;
        node = this.node;
        if ('number' !== typeof stageLevel) {
            throw new TypeError('Game.setStageLevel: stageLevel must be ' +
                                'number. Found: ' + stageLevel);
        }
        // Important: First publish, then actually update.
        if (mod === 'F' || (!mod && this.getStageLevel() !== stageLevel)) {
            this.publishUpdate('stageLevel', {
                stageLevel: stageLevel
            });
        }
        node.player.stageLevel = stageLevel;
    };

    /**
     * ### Game.publishUpdate
     *
     * Sends out a PLAYER_UPDATE message, if conditions are met.
     *
     * Type is a property of the `node.player` object.
     *
     * @param {string} type The type of update:
     *   'stateLevel', 'stageLevel', 'gameStage'.
     * @param {mixed} newValue Optional. The actual value of update to be sent.
     *
     * @see Game.shouldPublishUpdate
     */
    Game.prototype.publishUpdate = function(type, update) {
        if ('string' !== typeof type) {
            throw new TypeError('Game.publishUpdate: type must be string. ' +
                                'Found: ' + type);
        }
        if (type !== 'stage' &&
            type !== 'stageLevel' &&
            type !== 'stateLevel') {

            throw new Error('Game.publishUpdate: unknown update type: ' + type);
        }
        if (this.shouldPublishUpdate(type, update)) {
            this.node.socket.send(this.node.msg.create({
                target: constants.target.PLAYER_UPDATE,
                data: update,
                text: type,
                to: 'ROOM'
            }));
        }
    };

    /**
     * ### Game.shouldPublishUpdate
     *
     * Checks whether a game update should be sent to the server
     *
     * Evaluates the current `publishLevel`, the type of update, and the
     * value of the update to decide whether is to be published or not.
     *
     * Checks also if the `syncOnLoaded` option is on.
     *
     * Updates rules are described in '/lib/modules/variables.js'.
     *
     * @param {string} type The type of update:
     *   'stateLevel', 'stageLevel', 'gameStage'.
     * @param {mixed} value Optional. The actual update to be sent
     *
     * @return {boolean} TRUE, if the update should be sent
     */
    Game.prototype.shouldPublishUpdate = function(type, value) {
        var myStage, levels, myPublishLevel;
        if ('string' !== typeof type) {
            throw new TypeError(
                'Game.shouldPublishUpdate: type must be string.');
        }

        myStage = this.getCurrentGameStage();
        levels = constants.publishLevels;

        myPublishLevel = this.plot.getProperty(myStage, 'publishLevel');

        // Two cases are handled outside of the switch: NO msg
        // and LOADED stage with syncOnLoaded option.
        if (myPublishLevel === levels.NONE) {
            return false;
        }
        if (this.plot.getProperty(myStage, 'syncOnLoaded')) {
            if (type === 'stageLevel' &&
                value.stageLevel === stageLevels.LOADED) {
                return true;
            }
            // Else will be evaluated below.
        }

        // Check all the other cases.
        switch(myPublishLevel) {
        case levels.FEW:
            return type === 'stage';
        case levels.REGULAR:
            if (type === 'stateLevel') return false;
            if (type === 'stageLevel') {
                return (value.stageLevel === stageLevels.PLAYING ||
                        value.stageLevel === stageLevels.DONE);
            }
            return true; // type === 'stage'
        case levels.MOST:
            return type !== 'stateLevel';
        case levels.ALL:
            return true;
        default:
            // Unknown values of publishLevels are treated as ALL.
            return true;
        }
    };

    /**
     * ### Game.isReady
     *
     * Returns TRUE if a game is set and interactive
     *
     * A game is ready unless a stage or step is currently being
     * loaded or a DONE procedure has been started, i.e. between the
     * stage levels: PLAYING and GETTING_DONE.
     *
     * If a game is paused, it is also NOT ready.
     *
     * @see node.stageLevels
     */
    Game.prototype.isReady = function() {
        var stageLevel, stateLevel;

        if (this.paused) return false;

        stateLevel = this.getStateLevel();

        switch (stateLevel) {
        case stateLevels.UNINITIALIZED:
        case stateLevels.INITIALIZING:
        case stateLevels.STAGE_INIT:
        case stateLevels.STEP_INIT:
        case stateLevels.FINISHING:
        case stateLevels.STAGE_EXIT:
        case stateLevels.STEP_EXIT:
            return false;

        case stateLevels.PLAYING_STEP:

            stageLevel = this.getStageLevel();
            switch (stageLevel) {
            case stageLevels.EXECUTING_CALLBACK:
            case stageLevels.CALLBACK_EXECUTED:
            case stageLevels.PAUSING:
            case stageLevels.RESUMING:
            case stageLevels.GETTING_DONE:
            // TODO: should this be commented? See issue #168
            // case stageLevels.DONE:
                return false;
            }
            break;
        }
        return true;
    };

    /**
     * ### Game.isStartable
     *
     * Returns TRUE if Game.start can be called
     *
     * @return {boolean} TRUE if the game can be started.
     */
    Game.prototype.isStartable = function() {
        return this.plot.isReady() &&
            this.getStateLevel() < stateLevels.INITIALIZING;
    };


    /**
     * ### Game.isStoppable
     *
     * Returns TRUE if Game.stop can be called
     *
     * @return {boolean} TRUE if the game can be stopped.
     */
    Game.prototype.isStoppable = function() {
        return this.getStateLevel() > stateLevels.INITIALIZING;
    };


    /**
     * ### Game.isPausable
     *
     * Returns TRUE if Game.pause can be called
     *
     * @return {boolean} TRUE if the game can be paused.
     */
    Game.prototype.isPausable = function() {
        return !this.paused &&
            this.getStateLevel() > stateLevels.INITIALIZING;
    };


    /**
     * ### Game.isResumable
     *
     * Returns TRUE if Game.resume can be called
     *
     * @return {boolean} TRUE if the game can be resumed.
     */
    Game.prototype.isResumable = function() {
        return this.paused &&
            this.getStateLevel() > stateLevels.INITIALIZING;
    };


    /**
     * ### Game.isSteppable
     *
     * Returns TRUE if Game.step and Game.gotoStep can be called
     *
     * @return {boolean} TRUE if the game can be stepped.
     */
    Game.prototype.isSteppable = function() {
        var stateLevel;
        stateLevel = this.getStateLevel();

        return stateLevel > stateLevels.INITIALIZING &&
            stateLevel < stateLevels.FINISHING;
    };

    /**
     * ### Game.isGameover
     *
     * Returns TRUE if gameover was called and state level set
     *
     * @return {boolean} TRUE if is game over
     */
    Game.prototype.isGameover = Game.prototype.isGameOver = function() {
        return this.getStateLevel() === stateLevels.GAMEOVER;
    };

    /**
     * ### Game.shouldEmitPlaying
     *
     * Gives the last green light to let the players play a step.
     *
     * Sometimes we want to synchronize players to the very last
     * moment before they start playing. Here we check again.
     * This handles the case also if some players has disconnected
     * between the beginning of the stepping procedure and this
     * method call.
     *
     * Checks also the GameWindow object.
     *
     * @param {boolean} strict If TRUE, PLAYING can be emitted only coming
     *   from the LOADED stage level. Default: TRUE
     *
     * @return {boolean} TRUE, if the PLAYING event should be emitted.
     *
     * @see SizeManager.checkSize
     */
    Game.prototype.shouldEmitPlaying = function(strict) {
        var curGameStage, curStageLevel, syncOnLoaded, node;
        if ('undefined' === typeof strict || strict) {
            // Should emit PLAYING only after LOADED.
            curStageLevel = this.getStageLevel();
            if (curStageLevel !== stageLevels.LOADED) return false;
        }
        node = this.node;
        curGameStage = this.getCurrentGameStage();
        if (!this.isReady()) return false;
        if (!this.sizeManager.checkSize()) return false;

        // `syncOnLoaded` forces clients to wait for all the others to be
        // fully loaded before releasing the control of the screen to the
        // players. This introduces a little overhead in
        // communications and delay in the execution of a stage. It is
        // not necessary in local networks, and it is FALSE by default.
        syncOnLoaded = this.plot.getProperty(curGameStage, 'syncOnLoaded');
        if (!syncOnLoaded) return true;
        return node.game.pl.isStepLoaded(curGameStage);
    };

    /**
     * ### Game.compareCurrentStep
     *
     * Returns the relative order of a step with the current step
     *
     * @param {GameStage|string} step The step to compare
     *
     * @return {number} 0 if comparing step is the same as current step,
     *   -1 if current step is before comparing step, 1 if current step
     *   is after comparing step
     */
    Game.prototype.compareCurrentStep = function(step) {
        var normalizedStep;
        normalizedStep = this.plot.normalizeGameStage(new GameStage(step));
        return GameStage.compare(this.getCurrentGameStage(), normalizedStep);
    };

    /**
     * ### Game.getPreviousStep
     *
     * Returns the game-stage played delta steps ago
     *
     * @param {number} delta Optional. The number of past steps. Default 1
     * @param {bolean|object} opts Optional. A configuration object accepting
     *   the following options:
     *
     *      - acrossStages: if FALSE, if the previous step belongs to another
     *          stage, it returns NULL. Default: TRUE.
     *      - acrossRounds: if FALSE, if the previous step belongs to another
     *          round, it returns NULL. Default: TRUE.
     *      - noZeroStep: if TRUE, replaces return value 0.0.0 with NULL.
     *          Default: FALSE.
     *      - execLoops If TRUE, loop and doLoop conditional functions are
     *          executed to determine the previous step. If FALSE, if a loop
     *          or doLoop is found, it returns NULL. Note! This option is
     *          evaluated only if no step is found in the cache. Default: TRUE
     *
     *   Note: for backward compatibility, if this parameter is a boolean,
     *   it will be treated as option execLoops.
     *
     * @return {GameStage|null} The game-stage played delta steps ago,
     *   null if an error occurred (e.g., a loop stage), or stage 0.0.0 for
     *   all deltas > steppable steps (i.e., previous of 0.0.0 is 0.0.0).
     *
     * @see Game._steppedSteps
     * @see GamePlot.jump
     */
    Game.prototype.getPreviousStep = function(delta, opts) {
        var len, curStep, prevStep, execLoops;
        delta = delta || 1;
        if ('number' !== typeof delta || delta < 1) {
            throw new TypeError('Game.getPreviousStep: delta must be a ' +
                                'positive number or undefined. Found: ' +
                                delta);
        }
        len = this._steppedSteps.length - delta - 1;
        // In position 0 there is 0.0.0, which is added also in case
        // of a reconnection.
        if (len > 0) {
            prevStep = this._steppedSteps[len];
        }
        else {
            // It is possible that it is a reconnection, so we are missing
            // stepped steps. Let's do a deeper lookup.
            if ('boolean' === typeof opts) execLoops = opts;
            prevStep = this.plot.jump(this.getCurrentGameStage(),
                                      -delta, execLoops);
        }
        // Additional checks might be needed.
        if ('object' === typeof opts) {
            curStep = node.game.getCurrentGameStage();
            if (opts.acrossStages === false &&
                (curStep.stage !== prevStep.stage)) {

                return null;
            }
            if (opts.acrossRounds === false &&
                (curStep.round !== prevStep.round)) {

                return null;
            }
            if (opts.noZeroStep && prevStep.stage === 0) return null;

        }
        return prevStep;
        // For future reference, why is this complicated:
        // - Server could store all stepped steps and send them back
        //     upon reconnection, but it would miss steps stepped while client
        //     was disconnected.
        // - Server could send all steps stepped by logic, but it would not
        //     work if syncStepping is disabled.
        // TODO: Maybe the sequence of prev steps should be precomputed?
    };

    /**
     * ### Game.getNextStep
     *
     * Returns the game-stage that will be played in delta steps
     *
     * @param {number} delta Optional. The number of future steps. Default 1
     *
     * @return {GameStage|null} The game-stage that will be played in
     *   delta future steps, or null if none is found, or if the game
     *   sequence contains a loop in between
     */
    Game.prototype.getNextStep = function(delta) {
        delta = delta || 1;
        if ('number' !== typeof delta || delta < 1) {
            throw new TypeError('Game.getNextStep: delta must be a ' +
                                'positive number or undefined: ', delta);
        }
        return this.plot.jump(this.getCurrentGameStage(), delta, false);
    };

    /**
     * ### Game.updateGlobals
     *
     * Updates node.globals and adds properties to window in the browser
     *
     * @param {GameStage} stage Optional. The reference game stage.
     *   Default: Game.currentGameStage()
     *
     * @return Game.globals
     */
    Game.prototype.updateGlobals = function(stage) {
        var newGlobals, g;
        stage = stage || this.getCurrentGameStage();
        newGlobals = this.plot.getGlobals(stage);
        if ('undefined' !== typeof window && this.node.window) {
            // Adding new globals.
            for (g in newGlobals) {
                if (newGlobals.hasOwnProperty(g)) {
                    if (g === 'node' || g === 'W') {
                        node.warn('Game.updateGlobals: invalid name: ' + g);
                    }
                    else {
                        window[g] = newGlobals[g];
                    }
                }
            }
            // Removing old ones.
            for (g in this.globals) {
                if (this.globals.hasOwnProperty(g) &&
                    !newGlobals.hasOwnProperty(g)) {
                    if (g !== 'node' || g !== 'W') {
                        delete window[g];
                    }
                }
            }
        }
        // Updating globals reference.
        this.globals = newGlobals;
        return this.globals;
    };


    /**
     * ### Game.getProperty
     *
     * Returns the requested step property from the game plot
     *
     * @param {string} property The name of the property
     * @param {mixed} nf Optional. The return value in case the
     *   requested property is not found. Default: null.
     *
     * @return {mixed} The value of the requested step property
     *
     * @see GamePlot.getProperty
     */
    Game.prototype.getProperty = function(prop, nf) {
        return this.plot.getProperty(this.getCurrentGameStage(), prop, nf);
    };

    /**
    * ### Game.getStageId
    *
    * Returns the id of current stage, or of another user-specified stage
    *
    * @param {object} stage Optional. A GameStage object. Default: current
    *     game stage.
    *
    * @return {string|null} The id of (current) stage, or NULL if not found
    *
    * @see GamePlot.getStage
    */
    Game.prototype.getStageId = function(stage) {
        stage = this.plot.getStage(stage || this.getCurrentGameStage());
        return stage ? stage.id : null;
    };

    /**
    * ### Game.getStepId
    *
    * Returns the id of current step, or of another user-specified stage
    *
    * @param {object} stage Optional. A GameStage object. Default: current
    *     game stage.
    *
    * @return {string|null} The id of (current) step, or NULL if not found
    *
    * @see GamePlot.getStage
    */
    Game.prototype.getStepId = function(stage) {
        stage = this.plot.getStep(stage || this.getCurrentGameStage());
        return stage ? stage.id : null;
    };

    /**
    * ### Game.getRound
    *
    * Returns the current/remaining/past/total round number in current stage
    *
    * @param {string} mod Optional. Modifies the return value.
    *
    *   - 'current': current round number (default)
    *   - 'total': total number of rounds
    *   - 'remaining': number of rounds remaining (excluding current round)
    *   - 'past': number of rounds already past  (excluding current round)
    *
    * @return {number|null} The requested information, or null if
    *   the number of rounds is not known (e.g. if the stage is a loop)
    *
    * @see GamePlot.getRound
    */
    Game.prototype.getRound = function(mod) {
        return this.plot.getRound(this.getCurrentGameStage(), mod);
    };

    /**
    * ### Game.isStage
    *
    * Returns TRUE if current stage matches input parameter
    *
    * Steps and rounds aer not considered.
    *
    * @param {string|GameStage|number} stage The name of the stage, its
    *    ordinal position in the game sequence, or its object
    *    representation. If string, the object is resolved
    *    with GamePlot.normalizeGameStage
    * @param {GameStage} compareStage The stage to compare against.
    *    Default: current game stage.
    *
    * @return {boolean} TRUE if current stage matches input parameter
    *
    * @see GamePlot.normalizeGameStage
    * @see Game.getCurrentGameStage
    */
    Game.prototype.isStage = function(stage, compareStage) {
        var s;
        if (compareStage) {
            if ('object' === typeof compareStage) {
                s = compareStage.stage;
            }
            else {
                throw new TypeError('Game.isStage: compareStage must be ' +
                                    'object or undefined. Found: ' +
                                    compareStage);
            }
        }
        else {
            s = this.getCurrentGameStage().stage;
        }
        if ('number' === typeof stage) return stage === s;
        stage = this.plot.normalizeGameStage(stage);
        return !!(stage && stage.stage === s);
    };

    /**
    * ### Game.isStep
    *
    * Returns TRUE if current step matches input parameter
    *
    * Behavior changes depending on type of input parameter:
    *
    *   - number: only the ordinal position in the game stage is matched
    *   - object|string: the stage and the step are matched
    *
    * @param {string|GameStage|number} step The name of the step, its
    *    ordinal position in the game stage, or its object
    *    representation. If string, the object is resolved
    *    with GamePlot.normalizeGameStage
    * @param {GameStage} compareStage The stage to compare against.
    *    Default: current game stage.
    *
    * @return {boolean} TRUE if current step matches input parameter
    *
    * @see GamePlot.normalizeGameStage
    */
    Game.prototype.isStep = function(step, compareStage) {
        var s;
        if (compareStage) {
            if ('object' === typeof compareStage) {
                s = compareStage.step;
            }
            else {
                throw new TypeError('Game.isStep: compareStage must be ' +
                                    'object or undefined. Found: ' +
                                    compareStage);
            }
        }
        else {
            s = this.getCurrentGameStage().step;
        }
        if ('number' === typeof step) return step === s;
        // Add the current stage id for normalization if no stage is provided.
        if (step.lastIndexOf('.') === -1) {
            step = this.getStageId(compareStage) + '.' + step;
        }
        step = this.plot.normalizeGameStage(step);
        return !!(step && step.step === s);
    };

    /**
    * ### Game.isRound
    *
    * Returns TRUE if current step matches input parameter
    *
    * Behavior changes depending on type of input parameter:
    *
    *   - number: only the ordinal position in the game stage is matched
    *   - object: the stage and the step are matched
    *
    * @param {GameStage|number} round The round number or its object
    *    representation. If object, it is resolved
    *    with GamePlot.normalizeGameStage
    *
    * @return {boolean} TRUE if current step matches input parameter
    *
    * @see GamePlot.normalizeGameStage
    */
    Game.prototype.isRound = function(round) {
        var r;
        r = this.getRound();
        if ('number' === typeof round) return round === r;
        round = this.plot.normalizeGameStage(round);
        return !!(round && round.round === r);
    };

    /**
    * ### Game.isWidgetStep
    *
    * Returns TRUE if current step is a widget step
    *
    * @return {boolean} TRUE if current step is a widget step
    *
    * @see GamePlot.widgetStep
    * @see GamePlot.execStep
    */
    Game.prototype.isWidgetStep = function() {
        return this.widgetStep;
    };

    /**
     * ### Game.setRole
     *
     * Sets the current role in the game
     *
     * When a role is set, all the properties of a role overwrite
     * the current step properties.
     *
     * Roles are not supposed to be set more than once per step, and
     * an error will be thrown on attempts to overwrite roles.
     *
     * Updates the reference also in `node.player.role`.
     *
     * @param {string|null} role The name of the role
     * @param {boolean} force Optional. If TRUE, role can be overwritten
     *
     * @see Game.role
     * @see Player.role
     */
    Game.prototype.setRole = function(role, force) {
        var roles, roleObj, prop;
        if ('string' === typeof role && role.trim() !== '') {
            if (this.role && !force) {
                throw new Error('Game.setRole: attempt to change role "' +
                                this.role + '" to "' + role + '" in step: ' +
                                this.getCurrentGameStage());
            }
            roles = this.getProperty('roles');
            if (!roles) {
                throw new Error('Game.setRole: trying to set role "' +
                                role + '", but \'roles\' not found in ' +
                                'current step: ' +
                                this.getCurrentGameStage());
            }
            roleObj = roles[role];
            if (!roleObj) {
                throw new Error('Game.setRole: role "' + role +
                                '" not found in current step: ' +
                                this.getCurrentGameStage());
            }

            // Modify plot properties.
            for (prop in roleObj) {
                if (roleObj.hasOwnProperty(prop)) {
                    this.plot.tmpCache(prop, roleObj[prop]);
                }
            }

        }
        else if (role !== null) {
            throw new TypeError('Game.setRole: role must be string or null. ' +
                                'Found: ' + role);
        }
        this.role = role;
        this.node.player.role = role;
    };

    /**
     * ### Game.getRole
     *
     * Returns the current role in the game
     *
     * @see Game.role
     * @see Player.role
     */
    Game.prototype.getRole = function() {
        return this.role;
    };

    /**
     * ### Game.setPartner
     *
     * Sets the current partner in the game
     *
     * Partners are not supposed to be set more than once per step, and
     * an error will be thrown on attempts to overwrite them.
     *
     * Updates the reference also in `node.player.partner`.
     *
     * @param {string|null} partner The id or alias of the partner
     * @param {boolean} force Optional. If TRUE, partner can be overwritten
     *
     * @see Game.partner
     * @see Player.partner
     */
    Game.prototype.setPartner = function(partner, force) {
        if ('string' === typeof partner && partner.trim() !== '') {
            if (this.partner && !force) {
                throw new Error('Game.setPartner: attempt to change partner "' +
                                this.partner + '" to "' + partner +
                                '" in step: ' + this.getCurrentGameStage());
            }
        }
        else if (partner !== null) {
            throw new TypeError('Game.setPartner: partner must be a ' +
                                'non-empty string or null. Found: ' + partner);
        }
        this.partner = partner;
        this.node.player.partner = partner;
    };

    /**
     * ### Game.getPartner
     *
     * Returns the current partner in the game
     *
     * @see Game.partner
     * @see Player.partner
     */
    Game.prototype.getPartner = function() {
        return this.partner;
    };

    // ## Helper Methods

    /**
     * ### processGoToStepOptions
     *
     * Process options before executing the init functions of stage/steps
     *
     * Valid options:
     *
     *   - willBeDone: game will be done after loading the frame and executing
     *       the step callback function,
     *   - beDone: game is done without loading the frame or
     *       executing the step callback function,
     *   - plot: add entries to the tmpCache of the plot,
     *   - msgs: incoming messages to emit.
     *   - cb: a callback executed with the game context, and with options
     *       object itself as parameter
     *
     * @param {Game} game The game instance
     * @param {object} opts The options to process
     *
     * @see Game.gotoStep
     * @see GamePlot.tmpCache
     * @see Game.willBeDone
     * @see Game.beDone
     */
    function processGotoStepOptions(game, opts) {
        var prop, so;

        // Be done.. now! Skips Game.execStep.
        if (opts.beDone) {
            game.willBeDone = true;
            game.beDone = true;
        }
        else if (opts.willBeDone) {
            // TODO: why not setting willBeDone? It was not working, check!
            // Call node.done() immediately after PLAYING is emitted.
            game.node.once('PLAYING', function() {
                game.node.done();
            });
        }

        // Temporarily modify plot properties.
        // Must be done after setting the role.
        if (opts.plot) {
            for (prop in opts.plot) {
                if (opts.plot.hasOwnProperty(prop)) {
                    game.plot.tmpCache(prop, opts.plot[prop]);
                }
            }
        }

        if (opts.msgs) {
            opts.msgs.foreach(function(msg) {
                game.node.socket.onMessage(new GameMsg(msg).toInEvent(), msg);
            });
        }

        // Experimental. To be replaced by a session manager.
        // if (opts.game) {
        //     for (prop in opts.game) {
        //         if (opts.game.hasOwnProperty(prop)) {
        //             game[prop] = opts.game[prop];
        //         }
        //     }
        // }

        if (opts.session) {
            so = { to: false };
            for (prop in opts.session) {
                if (opts.session.hasOwnProperty(prop)) {
                    node.game.session(prop, opts.session[prop], so);
                }
            }
        }

        // TODO: rename cb.
        // Call the cb with opts as param, if found.
        if (opts.cb) {
            if ('function' === typeof opts.cb) {
                opts.cb.call(game, opts);
            }
            else {
                throw new TypeError('Game.gotoStep: opts.cb must be ' +
                                    'function or undefined. Found: ' +
                                    opts.cb);
            }
        }
    }

    // ## Closure
})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # GameSession
 * Copyright(c) 2022 Stefano Balietti
 * MIT Licensed
 *
 * `nodeGame` session manager
 */
(function(exports, node) {

    "use strict";

    // ## Global scope

    var J = node.JSUS;

    // Exposing constructor.
    exports.GameSession = GameSession;
    exports.GameSession.SessionManager = SessionManager;

    GameSession.prototype = new SessionManager();
    GameSession.prototype.constructor = GameSession;

    /**
     * ## GameSession constructor
     *
     * Creates a new instance of GameSession
     *
     * @param {NodeGameClient} node A reference to the node object.
     */
    function GameSession(node) {
        SessionManager.call(this);

        /**
         * ### GameSession.node
         *
         * The reference to the node object.
         */
        this.node = node;

        // Register default variables in the session.
        this.register('player', {
            set: function(p) {
                node.createPlayer(p);
            },
            get: function() {
                return node.player;
            }
        });

        this.register('game.memory', {
            set: function(value) {
                node.game.memory.clear(true);
                node.game.memory.importDB(value);
            },
            get: function() {
                return (node.game.memory) ? node.game.memory.fetch() : null;
            }
        });

        this.register('events.history', {
            set: function(value) {
                node.events.history.history.clear(true);
                node.events.history.history.importDB(value);
            },
            get: function() {
                return node.events.history ?
                    node.events.history.history.fetch() : null;
            }
        });

        this.register('stage', {
            set: function() {
                // GameSession.restoreStage
            },
            get: function() {
                return node.player.stage;
            }
        });

        this.register('node.env');
    }


//    GameSession.prototype.restoreStage = function(stage) {
//
//        try {
//            // GOTO STATE
//            node.game.execStage(node.plot.getStep(stage));
//
//            var discard = ['LOG',
//                           'STATECHANGE',
//                           'WINDOW_LOADED',
//                           'BEFORE_LOADING',
//                           'LOADED',
//                           'in.say.STATE',
//                           'UPDATED_PLIST',
//                           'NODEGAME_READY',
//                           'out.say.STATE',
//                           'out.set.STATE',
//                           'in.say.PLIST',
//                           'STAGEDONE', // maybe not here
//                           'out.say.HI'
//                          ];
//
//            // RE-EMIT EVENTS
//            node.events.history.remit(node.game.getStateLevel(), discard);
//            node.info('game stage restored');
//            return true;
//        }
//        catch(e) {
//            node.err('could not restore game stage. ' +
//                     'An error has occurred: ' + e);
//            return false;
//        }
//
//    };

    /**
     * ## SessionManager constructor
     *
     * Creates a new session manager.
     */
    function SessionManager() {

        /**
         * ### SessionManager.session
         *
         * Container of all variables registered in the session.
         */
        this.session = {};
    }

    // ## SessionManager methods

    /**
     * ### SessionManager.getVariable (static)
     *
     * Default session getter.
     *
     * @param {string} p The path to a variable included in _node_
     * @return {mixed} The requested variable
     */
    SessionManager.getVariable = function(p) {
        return J.getNestedValue(p, node);
    };

    /**
     * ### SessionManager.setVariable (static)
     *
     * Default session setter.
     *
     * @param {string} p The path to the variable to set in _node_
     * @param {mixed} value The value to set
     */
    SessionManager.setVariable = function(p, value) {
        J.setNestedValue(p, value, node);
    };

    /**
     * ### SessionManager.register
     *
     * Register a new variable to the session
     *
     * Overwrites previously registered variables with the same name.
     *
     * Usage example:
     *
     * ```javascript
     * node.session.register('player', {
     *       set: function(p) {
     *           node.createPlayer(p);
     *       },
     *       get: function() {
     *           return node.player;
     *       }
     * });
     * ```
     *
     * @param {string} path A string containing a path to a variable
     * @param {object} conf Optional. Configuration object containing setters
     *   and getters
     */
    SessionManager.prototype.register = function(path, conf) {
        if ('string' !== typeof path) {
            throw new TypeError('SessionManager.register: path must be ' +
                                'string.');
        }
        if (conf && 'object' !== typeof conf) {
            throw new TypeError('SessionManager.register: conf must be ' +
                                'object or undefined.');
        }

        this.session[path] = {

            get: (conf && conf.get) ?
                conf.get : function() {
                    return J.getNestedValue(path, node);
                },

            set: (conf && conf.set) ?
                conf.set : function(value) {
                    J.setNestedValue(path, value, node);
                }
        };

        return this.session[path];
    };

    /**
     * ### SessionManager.unregister
     *
     * Unegister a variable from session
     *
     * @param {string} path A string containing a path to a variable previously
     *   registered.
     *
     * @see SessionManager.register
     */
    SessionManager.prototype.unregister = function(path) {
        if ('string' !== typeof path) {
            throw new TypeError('SessionManager.unregister: path must be ' +
                                'string.');
        }
        if (!this.session[path]) {
            node.warn('SessionManager.unregister: path is not registered ' +
                      'in the session: ' + path + '.');
            return false;
        }

        delete this.session[path];
        return true;
    };

    /**
     * ### SessionManager.clear
     *
     * Unegister all registered session variables
     *
     * @see SessionManager.unregister
     */
    SessionManager.prototype.clear = function() {
        this.session = {};
    };

    /**
     * ### SessionManager.get
     *
     * Returns the value/s of one/all registered session variable/s
     *
     * @param {string|undefined} path A previously registred variable or
     *   undefined to return all values
     *
     * @see SessionManager.register
     */
    SessionManager.prototype.get = function(path) {
        var session = {};
        // Returns one variable.
        if ('string' === typeof path) {
            return this.session[path] ? this.session[path].get() : undefined;
        }
        // Returns all registered variables.
        else if ('undefined' === typeof path) {
            for (path in this.session) {
                if (this.session.hasOwnProperty(path)) {
                    session[path] = this.session[path].get();
                }
            }
            return session;
        }
        else {
            throw new TypeError('SessionManager.get: path must be string or ' +
                                'undefined.');
        }
    };

    /**
     * ### SessionManager.isRegistered
     *
     * Returns TRUE, if a variable is registred
     *
     * @param {string} path A previously registred variable
     *
     * @return {boolean} TRUE, if the variable is registered
     *
     * @see SessionManager.register
     * @see SessionManager.unregister
     */
    SessionManager.prototype.isRegistered = function(path) {
        if ('string' !== typeof path) {
            throw new TypeError('SessionManager.isRegistered: path must be ' +
                                'string.');
        }
        return this.session.hasOwnProperty(path);
    };

    /**
     * ### SessionManager.serialize
     *
     * Returns an object containing that can be to restore the session
     *
     * The serialized session is an object containing _getter_, _setter_, and
     * current value of each of the registered session variables.
     *
     * @return {object} session The serialized session
     *
     * @see SessionManager.restore
     */
    SessionManager.prototype.serialize = function() {
        var session = {};
        for (var path in this.session) {
            if (this.session.hasOwnProperty(path)) {
                session[path] = {
                    value: this.session[path].get(),
                    get: this.session[path].get,
                    set: this.session[path].set
                };
            }
        }
        return session;
    };

    /**
     * ### SessionManager.restore
     *
     * Restore a previously serialized session object
     *
     * @param {object} session A serialized session object
     * @param {boolean} register Optional. If TRUE, every path is also
     *    registered before being restored.
     */
    SessionManager.prototype.restore = function(session, register) {
        var i;
        if ('object' !== typeof session) {
            throw new TypeError('SessionManager.restore: session must be ' +
                                'object.');
        }
        register = 'undefined' !== typeof register ? register : true;
        for (i in session) {
            if (session.hasOwnProperty(i)) {
                if (register) this.register(i, session[i]);
                session[i].set(session[i].value);
            }
        }
    };

//    SessionManager.prototype.store = function() {
//        //node.store(node.socket.id, this.get());
//    };

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # Timer
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Timing-related utility functions
 */
(function(exports, parent) {

    "use strict";

    // ## Global scope
    var J = parent.JSUS;

    // Exposing Timer constructor
    exports.Timer = Timer;

    /**
     * ## Timer constructor
     *
     * Creates a new instance of Timer
     *
     * @param {NodeGameClient} node. A valid NodeGameClient object
     * @param {object} settings Optional. A configuration object
     */
    function Timer(node, settings) {
        var that;
        this.node = node;

        this.settings = settings || {};

        /**
         * ### Timer.timers
         *
         * Collection of currently active timers created by `Timer.createTimer`
         * @see Timer.createTimer
         */
        this.timers = {};

        /**
         * ### Timer._stepTimers
         *
         * Collection of temporary timers created in current step
         *
         * All references are cleared after each step.
         *
         * Notice: might not be updated, if user manually destroys a timer.
         *
         * @private
         */
        this._stepTimers = [];

        /**
         * ### Timer._stageTimers
         *
         * Collection of temporary timers created in current stage
         *
         * All references are cleared after each stage.
         *
         * Notice: might not be updated, if user manually destroys a timer.
         *
         * @private
         */
        this._stageTimers = [];

        /**
         * ### Timer.timestamps
         *
         * Named timestamp collection
         *
         * Maps names to numbers (milliseconds since epoch)
         *
         * @see Timer.setTimestamp
         * @see Timer.getTimestamp
         * @see Timer.getTimeSince
         */
        this.timestamps = {};

        /**
         * ### Timer.pausedTimestamps
         *
         * Collection of timestamps existing while game is paused
         *
         * Will be cleared on resume
         *
         * @see Timer.setTimestamp
         * @see Timer.getTimestamp
         * @see Timer.getTimeSince
         */
        this._pausedTimestamps = {};

        /**
         * ### Timer.cumulPausedTimestamps
         *
         * List of timestamps that had a paused time in between
         *
         * Persists after resume
         *
         * @see Timer.setTimestamp
         * @see Timer.getTimestamp
         * @see Timer.getTimeSince
         */
        this._cumulPausedTimestamps = {};

        /**
         * ### Timer._effectiveDiffs
         *
         * List of time differences between timestamps minus paused time
         *
         * Persists after resume
         *
         * @see Timer.setTimestamp
         * @see Timer.getTimestamp
         * @see Timer.getTimeSince
         */
        this._effectiveDiffs = {};

        that = this;
        this.node.on('PAUSED', function() {
            var i, ts;
            ts = that.getTimestamp('paused');
            for (i in that.timestamps) {
                if (that.timestamps.hasOwnProperty(i)) {
                    that._pausedTimestamps[i] = ts;
                }
            }
        });
        this.node.on('RESUMED', function() {
            var i, time, pt, cpt, pausedTime;
            pt = that._pausedTimestamps;
            cpt = that._cumulPausedTimestamps;
            time = J.now();
            for (i in pt) {
                if (pt[i] && pt.hasOwnProperty(i)) {
                    pausedTime = time - pt[i];
                    if (!cpt[i]) cpt[i] = pausedTime;
                    else cpt[i] += pausedTime;
                }
            }
            that._pausedTimestamps = {};
        });

        /**
        * ### Timer.random | Timer.wait
        *
        * Setups an object exposing multiple random handlers.
        *
        * Respects pausing / resuming. If the game has not started yet, it waits
        * until the `PLAYING` event is fired to start the random handler.
        *
        * Additional parameters are passed to each handler accordingly.
        *
        * @param {number} maxWait Optional. The maximum time (in milliseconds)
        *   to wait before emitting the event. Default: 5000
        * @param {number} minWait Optional. The minimum time (in milliseconds)
        *   to wait before executing the callback. Default: 1000
        *
        * @return {object} Object containing different random handlers
        *
        * ### Timer.random.done
        *
        * Randomly calls `node.done`
        *
        * ### Timer.random.emit
        *
        * Randomly emits an event
        *
        * @param {string} event The name of the event
        *
        * ### Timer.random.exec
        *
        * Randomly executs a function
        *
        * @param {function} func The callback function to execute
        * @param {object|function} ctx Optional. The context of execution of
        *   of the callback function. Default node.game
        *
        * @see randomFire
        */
        (function(that) {
            var _minWait, _maxWait, _prob;
            var args, i, len;

            // Init certain probability.
            _prob = 1;


            /**
            * ### randomFire
            *
            * Common handler for firing/emitting
            *
            * @param {string} method The name of the method invoking randomFire
            * @param {string|function} hook The function to call or the
             *  event to emit
            * @param {boolean} emit TRUE, if it is an event to emit
            * @param {object|function} ctx Optional. The context of
            *   execution for the function
            */
            function randomFire(method, hook, emit, ctx, args) {
                var that;
                var waitTime;
                var callback;
                var timerObj;
                var tentativeName;

                that = this;

                if ('undefined' === typeof _maxWait) {
                    _maxWait = 5000;
                }
                else if ('number' !== typeof _maxWait) {
                    resetWaits();
                    throw new TypeError('Timer.' + method + ': maxWait must ' +
                                        'be number or undefined. Found: ' +
                                        _maxWait);
                }
                if ('undefined' === typeof _minWait) {
                    _minWait = _maxWait < 1000 ? 0 : 1000;
                }
                else if ('number' !== typeof _minWait) {
                    resetWaits();
                    throw new TypeError('Timer.' + method + ': minWait must ' +
                                        'be number or undefined. Found: ' +
                                        _minWait);
                }

                waitTime = J.randomInt(_minWait, _maxWait);

                // Timeup callback: Emit.
                if (emit) {
                    callback = function() {
                        that.destroyTimer(timerObj);
                        if (args) {
                            that.node.emit.apply(that.node.events,
                                                [hook].concat(args));
                        }
                        else {
                            that.node.emit(hook);
                        }
                    };
                }
                // Timeup callback: Exec.
                else {
                    callback = function() {
                        that.destroyTimer(timerObj);
                        hook.apply(ctx, args);
                    };
                }

                tentativeName = method + '_' + hook + '_' +
                                J.randomInt(0, 1000000);

                // Create and run timer:
                timerObj = this.createTimer({
                    milliseconds: waitTime,
                    timeup: callback,
                    name: J.uniqueKey(this.timers, tentativeName)
                });

                // TODO: check if this condition is ok.
                if (this.node.game && this.node.game.isReady()) {
                    timerObj.start();
                }
                else {
                    // TODO: this is not enough. Does not cover all use cases.
                    this.node.once('PLAYING', function() {
                        timerObj.start();
                    });
                }

                resetWaits();
            }

            function resetWaits() {
                // Reset min and max wait to default.
                // Need to do it here, because user can access the random
                // and wait functions without executing them.
                _maxWait = 5000;
                _minWait = 1000;
            }

            function done(param) {

                // Probalistic abort.
                if (!evaluateProb()) return;

                randomFire.call(that, 'done', node.done, false, node, [param]);
            }

            function emit(event) {

                if ('string' !== typeof event) {
                    throw new TypeError('Timer.emit: event must be ' +
                    'string. Found: ' + event);
                }

                // Probalistic abort.
                if (!evaluateProb()) return;

                len = arguments.length;
                if (len === 2) {
                    args = [arguments[1]];
                }
                else if (len === 3) {
                    args = [arguments[2], arguments[1]];
                }
                else if (len > 3) {
                    i = -1, len = (len-1);
                    args = new Array(len);
                    for ( ; ++i < len ; ) {
                        args[i] = arguments[i+1];
                    }
                }
                randomFire.call(that, 'emit', event, true, null, args);
            }

            function exec(func, ctx) {
                if ('function' !== typeof func) {
                    throw new TypeError('Timer.exec: func must ' +
                    'be function. Found: ' + func);
                }
                if ('undefined' === typeof ctx) {
                    ctx = node.game;
                }
                else if ('object' !== typeof ctx && 'function' !== typeof ctx) {
                    throw new TypeError('Timer.exec: ctx must be ' +
                    'object, function or undefined. ' +
                    'Found: ' + ctx);
                }

                // Probalistic abort.
                if (!evaluateProb()) return;

                len = arguments.length;
                if (len === 3) {
                    args = [arguments[2]];
                }
                else if (len === 4) {
                    args = [arguments[3], arguments[2]];
                }
                else if (len > 4) {
                    i = -1, len = (len-2);
                    args = new Array(len);
                    for ( ; ++i < len ; ) {
                        args[i] = arguments[i+2];
                    }
                }
                randomFire.call(that, 'exec', func, false, ctx, args);
            }

            function timeup(param) {
                // Probalistic abort.
                if (!evaluateProb()) return;

                randomFire.call(that, 'timeup',
                               function() { node.game.timer.doTimeUp(); },
                               false, node.game, [param]);
            }

            function evaluateProb() {
                var p;
                // Get current value and resets it to 1.
                p = _prob;
                _prob = 1;
                if ('number' === typeof p) return Math.random() <= p;
                // It is either number of function.
                return !!p.call(node.game);
            }

            function prob(prob) {
                var tmp;
                if ('undefined' === typeof prob) {
                    _prob = 0.5;
                }
                else if ('function' === typeof prob) {
                    _prob = prob;
                }
                else {
                    tmp = J.isNumber(prob, 0, 1, true, true);
                    if (tmp === false) {
                        throw new Error('Timer.prob: ' +
                                        'prob must be a number between 0 and ' +
                                        '1, undefined or function. Found: ' +
                                        prob);
                    }
                    _prob = tmp;
                }

                return {
                    done: done,
                    emit: emit,
                    exec: exec,
                    timeup: timeup
                };
            }

            // Random and Wait functions.

            function random(maxWait, minWait) {
                _maxWait = maxWait;
                _minWait = minWait;

                return {
                    done: done,
                    emit: emit,
                    exec: exec,
                    timeup: timeup,
                    prob: prob
                };
            }

            function wait(wait) {
                return random(wait, wait);
            }

            // Make the handlers properties of the random and wait functions.
            random.done = done;
            random.emit = emit;
            random.exec = exec;
            random.prob = prob;
            random.timeup = timeup;

            wait.done = done;
            wait.emit = emit;
            wait.exec = exec;
            wait.prob = prob;
            wait.timeup = timeup;

            // Assign random and wait functions to Timer.
            that.random = random;
            that.wait = wait;
        })(this);

    }

    // ## Timer methods

    /**
     * ### Timer.setTimeout
     *
     * Wrapper for createTimer with same syntax as JS setTimeout
     *
     * @param {function|string} timeup A callback function or an event to emit
     *   when the timeout is fired
     * @param {number} milliseconds The delay for the timeout in milliseconds.
     *   Default: 1 (because zero would fire immediately and we want to keep
     *   the same behavior of JS setTimeout)
     * @param {string} validity The validity of the timeout. Default: validity
     *   changes depending on where the timeout is created (game, stage, step).
     *
     * @return {GameTimer} The game timer
     *
     * @see GameTimer
     */
    Timer.prototype.setTimeout = function(timeup, milliseconds, validity) {
        return this.createTimer({
            milliseconds: milliseconds || 1,
            timeup: timeup,
            validity: validity
        }).start();
    };

    /**
     * ### Timer.createTimer | Timer.create
     *
     * Returns a new GameTimer
     *
     * The GameTimer instance is automatically paused and resumed on
     * the respective events.
     *
     * Timer creation is flexible, and input parameter can be a full
     * configuration object, the number of milliseconds or nothing. In the
     * latter case, the new timer will need to be configured manually. If
     * only the number of milliseconds is passed the timer will fire a 'TIMEUP'
     * event once the time expires.
     *
     * @param {mixed} options The configuration object passed to the GameTimer
     *   constructor. Alternatively, it is possible to pass directly the number
     *   of milliseconds and the remaining settings will be added, or to leave
     *   it undefined.
     *
     * @return {GameTimer} timer The requested timer
     *
     * @see GameTimer
     */
    Timer.prototype.create = Timer.prototype.createTimer = function(options) {
        var gameTimer, pausedCb, resumedCb;
        var ee, val;

        if (options &&
            ('object' !== typeof options && 'number' !== typeof options)) {

            throw new TypeError('Timer.createTimer: options must be ' +
                                'undefined, object or number. Found: ' +
                                options);
        }

        if ('number' === typeof options) options = { milliseconds: options };
        options = options || {};

        options.name = options.name ||
            J.uniqueKey(this.timers, 'timer_' + J.randomInt(0, 10000000));

        if (this.timers[options.name]) {
            throw new Error('Timer.createTimer: timer name already in use: ' +
                            options.name);
        }

        // Retrieve the event emitter where the listeners are registered
        // based on options `validity` or the currently active event emitter.
        // If validity is 'step' or 'stage', a reference will be added to
        // the corresponding temporary array of timers (below).
        val = options.validity;
        if (!val) {
            ee = this.node.getCurrentEventEmitter();
        }
        else {
            ee = this.node.events.ee[val];
            if (!ee) {
                throw new Error('Timer.createTimer: validity must be "ng", ' +
                                '"game", "stage", "step". Found: ' + val);
            }
        }
        options.eventEmitterName = ee.name;

        // If game is paused add options startPaused, unless user
        // specified a value in the options object.
        if (this.node.game && this.node.game.paused) {
            if ('undefined' === typeof options.startPaused) {
                options.startPaused = true;
            }
        }

        // Create the GameTimer:
        gameTimer = new GameTimer(this.node, options);

        // Attach pause / resume listeners:
        pausedCb = function() {
            if (!gameTimer.isPaused()) {
                gameTimer.pause();
            }
        };
        resumedCb = function() {
            // startPaused=true also counts as a "paused" state:
            if (gameTimer.isPaused() || gameTimer.startPaused) {
                gameTimer.resume();
            }
        };

        ee.on('PAUSED', pausedCb);
        ee.on('RESUMED', resumedCb);

        // Attach listener handlers to GameTimer object so they can be
        // unregistered later:
        gameTimer.timerPausedCallback = pausedCb;
        gameTimer.timerResumedCallback = resumedCb;

        // Add a reference into this.timers.
        this.timers[gameTimer.name] = gameTimer;

        // Add reference to stage and step temporary timers.
        if (ee.name === 'step') this._stepTimers.push(gameTimer);
        else if (ee.name === 'stage') this._stageTimers.push(gameTimer);

        return gameTimer;
    };

    /**
     * ### Timer.destroyTimer
     *
     * Stops and removes a GameTimer
     *
     * The event handlers listening on PAUSED/RESUMED that are attached to
     * the given GameTimer object are removed.
     *
     * @param {object|string} gameTimer The gameTimer object or the name of
     *   the gameTimer created with Timer.createTimer
     */
    Timer.prototype.destroyTimer = function(gameTimer) {
        var eeName;
        if ('string' === typeof gameTimer) {
            if (!this.timers[gameTimer]) {
                throw new Error('node.timer.destroyTimer: gameTimer not ' +
                                'found: ' + gameTimer);
            }
            gameTimer = this.timers[gameTimer];
        }
        if ('object' !== typeof gameTimer) {
            throw new Error('node.timer.destroyTimer: gameTimer must be ' +
                            'string or object. Found: ' + gameTimer);
        }

        // Stop timer.
        if (!gameTimer.isStopped()) {
            gameTimer.stop();
        }

        eeName = gameTimer.eventEmitterName;
        // Detach listeners.
        if (eeName) {
            // We know where the timer was registered.
            this.node.events.ee[eeName].remove('PAUSED',
                                               gameTimer.timerPausedCallback);
            this.node.events.ee[eeName].remove('RESUMED',
                                               gameTimer.timerResumedCallback);
        }
        else {
            // We try to unregister from all.
            this.node.off('PAUSED', gameTimer.timerPausedCallback);
            this.node.off('RESUMED', gameTimer.timerResumedCallback);
        }

        // Remove listener syncing with stager (if any).
        gameTimer.syncWithStager(false);


        // Set status to DESTROYED and make object unusable
        // (in case external references to the object still exists).
        gameTimer.status = GameTimer.DESTROYED;

        // Delete reference in this.timers.
        delete this.timers[gameTimer.name];
    };

    /**
     * ### Timer.destroyStepTimers
     *
     * Stops and removes all timers registered in current step
     */
    Timer.prototype.destroyStepTimers = function() {
        destroyTempTimers(this, '_stepTimers');
    };

    /**
    * ### Timer.destroyStageTimers
    *
    * Stops and removes all timers registered in current stage
    */
    Timer.prototype.destroyStageTimers = function() {
        destroyTempTimers(this, '_stageTimers');
    };

    /**
     * ### Timer.destroyAllTimers
     *
     * Stops and removes all registered GameTimers
     *
     * By default, node.game.timer is not removed.
     *
     * @param {boolean} all Removes really all timers, including
     *    node.game.timer
     */
    Timer.prototype.destroyAllTimers = function(all) {
        var i;
        for (i in this.timers) {
            if (this.timers.hasOwnProperty(i)) {
                // Skip node.game.timer, unless so specified.
                if (!all && i === this.node.game.timer.name) continue;
                this.destroyTimer(this.timers[i]);
            }
        }
        // Clear temporary timers.
        this._stepTimers = [];
        this._stageTimers = [];
    };

    /**
     * ### Timer.getTimer
     *
     * Returns a reference to a previosly registered game timer.
     *
     * @param {string} name The name of the timer
     *
     * @return {GameTimer|null} The game timer with the given name, or
     *   null if none is found
     */
    Timer.prototype.getTimer = function(name) {
        if ('string' !== typeof name) {
            throw new TypeError('Timer.getTimer: name must be string. Found: ' +
                                name);
        }
        return this.timers[name] || null;
    };

    /**
     * ### Timer.setTimestamp
     *
     * Adds or changes a named timestamp
     *
     * @param {string} name The name of the timestamp
     * @param {number|undefined} time Optional. The time in ms as returned by
     *   Date.getTime(). Default: Current time.
     *
     * @return {number} time The value of the timestamp set
     *
     * @see Timer.getTimestamp
     */
    Timer.prototype.setTimestamp = function(name, time) {
        var i;
        // Default time: Current time
        if ('undefined' === typeof time) time = J.now();

        // Check inputs:
        if ('string' !== typeof name) {
            throw new Error('Timer.setTimestamp: name must be a string. ' +
                            'Found: ' + name);
        }
        if ('number' !== typeof time) {
            throw new Error('Timer.setTimestamp: time must be a number or ' +
                            'undefined. Found: ' + time);
        }

        // We had at least one pause.
        if (this.node.game.pauseCounter) {
            // Remove records of paused timestamps.
            if (this._pausedTimestamps[name]) {
                this._pausedTimestamps[name] = null;
            }
            if (this._cumulPausedTimestamps[name]) {
                this._cumulPausedTimestamps[name] = null;
            }
            // Mark timestamp as paused since the beginning, if game is paused.
            if (this.node.game.isPaused()) this._pausedTimestamps[name] = time;

            // Diffs are updated immediately.
            this._effectiveDiffs[name] = {};
            for (i in this.timestamps) {
                if (this.timestamps.hasOwnProperty(i)) {
                    this._effectiveDiffs[name][i] = this.getTimeSince(i, true);
                }
            }
        }
        this.timestamps[name] = time;
        return time;
    };

    /**
     * ### Timer.getTimestamp
     *
     * Retrieves a named timestamp
     *
     * @param {string} name The name of the timestamp
     *
     * @return {number|null} The time associated with the timestamp,
     *   NULL if it doesn't exist
     */
    Timer.prototype.getTimestamp = function(name) {
        // Check input:
        if ('string' !== typeof name) {
            throw new Error('Timer.getTimestamp: name must be a string. ' +
                            'Found: ' + name);
        }
        if (this.timestamps.hasOwnProperty(name)) return this.timestamps[name];
        else return null;
    };

    /**
     * ### Timer.getAllTimestamps
     *
     * Returns the map with all timestamps
     *
     * Do not change the returned object.
     *
     * @return {object} The timestamp map
     */
    Timer.prototype.getAllTimestamps = function() {
        return this.timestamps;
    };

    /**
     * ### Timer.getTimeSince
     *
     * Gets the time in ms since a timestamp
     *
     * @param {string} name The name of the timestamp
     * @param {boolean} effective Optional. If set, effective time
     *    is returned, i.e. time minus paused time. Default: false.
     *
     * @return {number|null} The time since the timestamp in ms,
     *   NULL if it doesn't exist
     *
     * @see Timer.getTimeDiff
     */
    Timer.prototype.getTimeSince = function(name, effective) {
        var currentTime;

        // Get current time:
        currentTime = J.now();

        // Check input:
        if ('string' !== typeof name) {
            throw new TypeError('Timer.getTimeSince: name must be string. ' +
                                'Found: ' + name);
        }

        if (this.timestamps.hasOwnProperty(name)) {
            if (effective) {
                if (this._pausedTimestamps[name]) {
                    currentTime -= (currentTime - this._pausedTimestamps[name]);
                }
                if (this._cumulPausedTimestamps[name]) {
                    currentTime -= this._cumulPausedTimestamps[name];
                }
            }
            return currentTime - this.timestamps[name];
        }
        else {
            return null;
        }
    };

    /**
     * ### Timer.getTimeDiff
     *
     * Returns the time difference between two registered timestamps
     *
     * @param {string} nameFrom The name of the first timestamp
     * @param {string} nameTo The name of the second timestamp
     * @param {boolean} effective Optional. If set, effective time
     *    is returned, i.e. time diff minus paused time. Default: false.
     *
     * @return {number} The time difference between the timestamps
     */
    Timer.prototype.getTimeDiff = function(nameFrom, nameTo, effective) {
        var timeFrom, timeTo, ed;

        // Check input:
        if ('string' !== typeof nameFrom) {
            throw new TypeError('Timer.getTimeDiff: nameFrom must be string.' +
                               'Found: ' + nameFrom);
        }
        if ('string' !== typeof nameTo) {
            throw new TypeError('Timer.getTimeDiff: nameTo must be string. ' +
                                'Found: ' + nameTo);
        }

        timeFrom = this.timestamps[nameFrom];

        if ('undefined' === typeof timeFrom || timeFrom === null) {
            throw new Error('Timer.getTimeDiff: nameFrom does not resolve to ' +
                            'a valid timestamp: ' + nameFrom);
        }

        timeTo = this.timestamps[nameTo];

        if ('undefined' === typeof timeTo || timeTo === null) {
            throw new Error('Timer.getTimeDiff: nameTo does not resolve to ' +
                            'a valid timestamp: ' + nameTo);
        }

        if (effective) {
            ed = this._effectiveDiffs;
            if (ed[nameFrom] && ed[nameFrom][nameTo]) {
                return ed[nameFrom][nameTo];
            }
            else if (ed[nameTo] && ed[nameTo][nameFrom]) {
                return ed[nameTo][nameFrom];
            }
        }

        return timeTo - timeFrom;
    };

    /**
     * ## Timer.parseInput
     *
     * Resolves an unknown value to a valid time quantity (number >=0)
     *
     * Valid types and operation:
     *   - number (as is),
     *   - string (casted),
     *   - object (property _name_ is parsed),
     *   - function (will be invoked with `node.game` context)
     *
     * Parsed value must be a number >= 0
     *
     * @param {string} name The name of the property if value is object
     * @param {number} value The value to parse
     * @param {string} methodName Optional. The name of the method invoking
     *   the function for the error messsage. Default: Timer.parseInput
     *
     * @param {number} The parsed value
     */
    Timer.prototype.parseInput = function(name, value, methodName) {
        var typeofValue, num;
        if ('string' !== typeof name) {
            throw new TypeError((methodName || 'Timer.parseInput') +
                                ': name must be string. Found: ' + name);
        }
        typeofValue = typeof value;
        switch (typeofValue) {

        case 'number':
            num = value;
            break;
        case 'object':
            if (null !== value) {
                if ('function' === typeof value[name]) {
                    num = value[name].call(this.node.game);
                }
            }
            break;
        case 'function':
            num = value.call(this.node.game);
            break;
        case 'string':
            num = Number(value);
            break;
        }

        if ('number' !== typeof num || num < 0) {
            throw new Error((methodName || 'Timer.parseInput') +
                            ': ' + name + ' must be number >= 0. Found: ' +
                           num);
        }

        return num;
    };

    // ## Helper Methods.

    /**
     * ### destroyTempTimers
     *
     * Common handler for randomEmit, randomExec, randomDone
     *
     * @param {Timer} that A live Timer instance
     * @param {string} timers The tname of the collection of temp timers
     */
    function destroyTempTimers(that, timers) {
        var i, len, t;
        len = that[timers].length;
        for (i = 0; i < len; i++) {
            t = that[timers][i];
            if (t.status !== GameTimer.DESTROYED) that.destroyTimer(t);
        }
        that[timers] = [];
    }

    /**
     * # GameTimer
     *
     * Copyright(c) 2016 Stefano Balietti
     * MIT Licensed
     *
     * Creates a controllable timer object for nodeGame.
     */
    exports.GameTimer = GameTimer;

    /**
     * ### GameTimer status levels
     * Numerical levels representing the state of the GameTimer
     *
     * @see GameTimer.status
     */
    GameTimer.STOPPED = -5;
    GameTimer.PAUSED = -3;
    GameTimer.UNINITIALIZED = -1;
    GameTimer.INITIALIZED = 0;
    GameTimer.LOADING = 3;
    GameTimer.RUNNING = 5;
    GameTimer.DESTROYED = 10;

    /**
     * ## GameTimer constructor
     *
     * Creates an instance of GameTimer
     *
     * @param {object} options. Optional. A configuration object
     */
    function GameTimer(node, options) {
        options = options || {};

        // ## Public properties

        /**
         * ### node
         *
         * Internal reference to node
         */
        this.node = node;

        /**
         * ### name
         *
         * Internal name of the timer
         */
        this.name = options.name || 'timer_' + J.randomInt(0, 1000000);

        /**
         * ### GameTimer.status
         *
         * Numerical index keeping the current the state of the GameTimer obj
         */
        this.status = GameTimer.UNINITIALIZED;

        /**
         * ### GameTimer.options
         *
         * The current settings for the GameTimer
         */
        this.options = options;

        /**
         * ### GameTimer.timerId
         *
         * The ID of the javascript interval
         */
        this.timerId = null;

        /**
         * ### GameTimer.timeLeft
         *
         * Total running time of timer
         */
        this.milliseconds = null;

        /**
         * ### GameTimer.timeLeft
         *
         * Milliseconds left before time is up
         */
        this.timeLeft = null;

        /**
         * ### GameTimer.timeLeft
         *
         * Milliseconds left when the last stop was called
         */
        this.timeLeftAtStop = null;

        /**
         * ### GameTimer.timePassed
         *
         * Milliseconds already passed from the start of the timer
         */
        this.timePassed = 0;

        /**
         * ### GameTimer.timePassed
         *
         * Milliseconds already passed when the last stop was called
         */
        this.timePassedAtStop = null;

        /**
         * ### GameTimer.update
         *
         * The frequency of update for the timer (in milliseconds)
         */
        this.update = undefined;

        /**
         * ### GameTimer.updateRemaining
         *
         * Milliseconds remaining for current update
         */
        this.updateRemaining = 0;

        /**
         * ### GameTimer.updateStart
         *
         * Timestamp of the start of the last update
         */
        this.updateStart = 0;

        /**
         * ### GameTimer.startPaused
         *
         * Whether to enter the pause state when starting
         */
        this.startPaused = null;

        /**
         * ### GameTimer.timeup
         *
         * Event string or function to fire when the time is up
         *
         * @see GameTimer.fire
         */
        this.timeup = 'TIMEUP';

        /**
         * ### GameTimer.hooks
         *
         * Array of hook functions to fire at every update
         *
         * The array works as a LIFO queue
         *
         * @see GameTimer.fire
         */
        this.hooks = [];

        /**
         * ### GameTimer.hookNames
         *
         * Object containing all names used for the hooks
         *
         * @see GameTimer.hooks
         */
        this.hookNames = {};

        /**
         * ### GameTimer.eventEmitterName
         *
         * The name of the event emitter where the timer was registered
         *
         * @see EventEmitter
         */
        this.eventEmitterName = null;

        /**
         * ## GameTimer.stagerSync
         *
         * TRUE if the timer is synced with stager
         *
         * It will use GameTimer.stagerProperty to sync
         *
         * @see GameTimer.stagerProperty
         * @see GameTimer.syncWithStager
         */
        this.stagerSync = false;

        /**
         * ## GameTimer.stagerProperty
         *
         * The name of the property used to sync with the stager
         *
         * @see GameTimer.stagerSync
         */
        this.stagerProperty = 'timer';

        // Init!
        this.init(this.options);
    }

    // ## GameTimer methods

    /**
     * ### GameTimer.init
     *
     * Inits the GameTimer
     *
     * Takes the configuration as an input parameter or
     * recycles the settings in `this.options`.
     *
     * The configuration object is of the type
     *
     * ```js
     *  var options = {
     *      // The length of the interval.
     *      milliseconds: 4000,
     *      // How often to update the time counter. Default: milliseconds
     *      update: 1000,
     *      // An event or function to fire when the timer expires.
     *      timeup: 'MY_EVENT',
     *      hooks: [
     *              // Array of functions or events to fire at every update.
     *              myFunc,
     *              'MY_EVENT_UPDATE',
     *              { hook: myFunc2,
     *                ctx: that, },
     *              ],
     *      // Sync with the 'timer' property of the stager
     *      stagerSync: true,
     *      // Name of the property to listen to (Default 'timer')
     *      stagerProperty: 'timer'
     *  }
     *  // Units are in milliseconds.
     * ```
     *
     * Note: if `milliseconds` is a negative number the timer fires
     * immediately.
     *
     * @param {object} options Optional. Configuration object
     *
     * @return {GameTimer} The game timer instance for chaining
     *
     * @see GameTimer.addHook
     */
    GameTimer.prototype.init = function(options) {
        var i, len, node;
        checkDestroyed(this, 'init');
        this.status = GameTimer.UNINITIALIZED;
        if (this.timerId) {
            clearInterval(this.timerId);
            this.timerId = null;
        }
        if (options) {
            if ('object' !== typeof options) {
                throw new TypeError('GameTimer.init: options must be object ' +
                                    'or undefined. Found: ' + options);
            }
            node = this.node;
            if ('undefined' !== typeof options.milliseconds) {
                this.milliseconds = node.timer.parseInput('milliseconds',
                                                          options.milliseconds);
            }
            if ('undefined' !== typeof options.update) {
                this.update = node.timer.parseInput('update', options.update);
            }
            else {
                // We keep the current update if not modified.
                this.update = this.update || this.milliseconds;
            }

            // Event to be fired when timer expires.
            if (options.timeup) {
                if ('function' === typeof options.timeup ||
                    'string' === typeof options.timeup) {

                    this.timeup = options.timeup;
                }
                else {
                    throw new TypeError('GameTimer.init: options.timeup must ' +
                                        'be function or undefined. Found: ' +
                                        options.timeup);
                }
            }
            else {
                this.timeup = this.timeup || 'TIMEUP';
            }

            if (options.hooks) {
                if (J.isArray(options.hooks)) {
                    len = options.hooks.length;
                    for (i = 0; i < len; i++) {
                        this.addHook(options.hooks[i]);
                    }
                }
                else {
                    this.addHook(options.hooks);
                }
            }

            // Set startPaused option. if specified. Default: FALSE
            this.startPaused = 'undefined' !== options.startPaused ?
                options.startPaused : false;

            if ('string' === typeof options.eventEmitterName) {
                this.eventEmitterName = options.eventEmitterName;
            }
            // Stager sync options.
            if ('undefined' !== typeof options.stagerSync) {
                this.syncWithStager(options.stagerSync);
            }
            if ('undefined' !== typeof options.stagerProperty) {
                this.setStagerProperty(options.stagerProperty);
            }

        }

        // TODO: check if this TODO is correct.
        // TODO: update and milliseconds must be multiple now.

        this.timeLeft = this.milliseconds;
        this.timePassed = 0;
        this.updateStart = 0;
        this.updateRemaining = 0;
        this._timeup = false;

        // Only set status to INITIALIZED if all of the state is valid and
        // ready to be used by this.start etc.
        if (checkInitialized(this) === null) {
            this.status = GameTimer.INITIALIZED;
        }

        return this;
    };


    /**
     * ### GameTimer.fire
     *
     * Fires a registered hook
     *
     * If hook is a string it is emitted as an event,
     * otherwise it is called as a function.
     *
     * @param {mixed} h The hook to fire (object, function, or string)
     *
     * @return {GameTimer} The game timer instance for chaining
     */
    GameTimer.prototype.fire = function(h) {
        var hook, ctx;
        checkDestroyed(this, 'fire');
        if ('object' === typeof h) {
            hook = h.hook;
            ctx = h.ctx;
            h = hook;
        }

        if ('function' === typeof h) {
            h.call(ctx || this.node.game, this.timeLeft, this);
        }
        else if ('string' === typeof h) {
            this.node.emit(h, this.timeLeft, this);
        }
        else {
            throw new TypeError('GameTimer.fire: h must be function, string ' +
                                'or object. Found: ' + h);
        }

        return this;
    };

    /**
     * ### GameTimer.start
     *
     * Starts the timer
     *
     * Updates the status of the timer and calls `setInterval`
     * At every update all the registered hooks are fired, and
     * time left is checked.
     *
     * When the timer expires the timeup event is fired, and the
     * timer is stopped
     *
     * @return {GameTimer} The game timer instance for chaining
     *
     * @see GameTimer.status
     * @see GameTimer.timeup
     * @see GameTimer.fire
     */
    GameTimer.prototype.start = function() {
        var error, that;
        checkDestroyed(this, 'start');
        // Check validity of state
        error = checkInitialized(this);
        if (error !== null) {
            throw new Error('GameTimer.start: ' + error);
        }

        if (this.isRunning()) {
            throw new Error('GameTimer.start: timer is already running');
        }

        this.status = GameTimer.LOADING;

        if (this.startPaused) {
            this.pause();
            return this;
        }

        // Remember time of start (used by this.pause to compute remaining time)
        this.updateStart = J.now();

        // Fires the event immediately if time is zero.
        // Double check necessary in strict mode.
        if ('undefined' !== typeof this.options.milliseconds &&
                this.options.milliseconds <= 0) {

            this.doTimeup();
            return this;
        }

        this.updateRemaining = this.update;

        that = this;
        // It is not possible to pass extra parameters to updateCallback,
        // by adding them after _this.update_. In IE does not work.
        this.timerId = setInterval(function() {
            updateCallback(that);
        }, this.update);

        return this;
    };

    /**
     * ### GameTimer.addHook
     *
     * Add an hook to the hook list after performing conformity checks
     *
     * The first parameter can be a string, a function, or an object
     * containing an hook property.
     *
     * @param {string|function|object} hook The hook (string or function),
     *   or an object containing a `hook` property (others: `ctx` and `name`)
     * @param {object} ctx The context wherein the hook is called.
     *   Default: node.game
     * @param {string} name The name of the hook. Default: a random name
     *   starting with 'timerHook'
     *
     * @return {string} The name of the hook
     */
    GameTimer.prototype.addHook = function(hook, ctx, name) {
        checkDestroyed(this, 'addHook');
        if ('undefined' === typeof hook) {
            throw new TypeError('GameTimer.addHook: hook must be function, ' +
                                'string or object. Found: ' + hook);
        }
        ctx = ctx || this.node.game;
        if (hook.hook) {
            ctx = hook.ctx || ctx;
            if (hook.name) name = hook.name;
            hook = hook.hook;
        }
        if (!name) {
            name = J.uniqueKey(this.hookNames, 'timerHook');
        }
        else if (this.hookNames[name]) {
            throw new Error('GameTimer.addHook: name already existing: ' +
                            name);
        }
        this.hookNames[name] = true;
        this.hooks.push({hook: hook, ctx: ctx, name: name});

        return name;
    };

    /**
     * ### GameTimer.removeHook
     *
     * Removes a hook by its name
     *
     * @param {string} name Name of the hook to be removed
     *
     * @return {mixed} the hook if it was removed; false otherwise.
     */
    GameTimer.prototype.removeHook = function(name) {
        var i;
        checkDestroyed(this, 'removeHook');
        if (this.hookNames[name]) {
            for (i = 0; i < this.hooks.length; i++) {
                if (this.hooks[i].name === name) {
                    delete this.hookNames[name];
                    return this.hooks.splice(i,1);
                }
            }
        }
        return false;
    };

    /**
     * ### GameTimer.pause
     *
     * Pauses the timer
     *
     * If the timer was running, clear the interval and sets the
     * status property to `GameTimer.PAUSED`.
     *
     * @return {GameTimer} The game timer instance for chaining
     */
    GameTimer.prototype.pause = function() {
        var timestamp;
        checkDestroyed(this, 'pause');
        if (this.isRunning()) {
            clearInterval(this.timerId);
            clearTimeout(this.timerId);
            this.timerId = null;

            this.status = GameTimer.PAUSED;

            // Save time of pausing.
            // If start was never called, or called with startPaused on.
            if (this.updateStart === 0) {
                this.updateRemaining = this.update;
            }
            else {
                // Save the difference of time left.
                timestamp = J.now();
                this.updateRemaining =
                    this.update - (timestamp - this.updateStart);
            }
        }
        else if (this.status === GameTimer.STOPPED) {
            // If the timer was explicitly stopped, we ignore the pause:
            return this;
        }
        else if (!this.isPaused()) {
            // pause() was called before start(); remember it:
            this.startPaused = true;
        }
        else {
            throw new Error('GameTimer.pause: timer was already paused');
        }

        return this;
    };

    /**
     * ### GameTimer.resume
     *
     * Resumes a paused timer
     *
     * If the timer was paused, restarts it with the current configuration
     *
     * @return {GameTimer} The game timer instance for chaining
     *
     * @see GameTimer.restart
     */
    GameTimer.prototype.resume = function() {
        var that;
        checkDestroyed(this, 'resume');

        // Don't start if the initialization is incomplete (invalid state):
        if (this.status === GameTimer.UNINITIALIZED) {
            this.startPaused = false;
            return this;
        }

        if (!this.isPaused() && !this.startPaused) {
            throw new Error('GameTimer.resume: timer was not paused');
        }

        this.status = GameTimer.LOADING;

        this.startPaused = false;

        this.updateStart = J.now();

        that = this;
        // Run rest of this "update" interval:
        this.timerId = setTimeout(function() {
            if (updateCallback(that)) {
                // start() needs the timer to not be running.
                that.status = GameTimer.INITIALIZED;

                that.start();

                // start() sets status to LOADING, so change it back to RUNNING.
                that.status = GameTimer.RUNNING;
            }
        }, this.updateRemaining);

        return this;
    };

    /**
     * ### GameTimer.stop
     *
     * Stops the timer
     *
     * If the timer was paused or running, clear the interval, sets the
     * status property to `GameTimer.STOPPED`, and reset the time passed
     * and time left properties
     *
     * @return {GameTimer} The game timer instance for chaining
     */
    GameTimer.prototype.stop = function() {
        checkDestroyed(this, 'stop');
        if (this.isStopped()) {
            throw new Error('GameTimer.stop: timer was not running');
        }

        this.status = GameTimer.STOPPED;
        clearInterval(this.timerId);
        clearTimeout(this.timerId);
        this.timerId = null;
        this.timePassedAtStop = this.timePassed;
        this.timePassed = 0;
        this.timeLeftAtStop = this.timeLeft;
        this.timeLeft = null;
        this.startPaused = null;
        this.updateRemaining = 0;
        this.updateStart = 0;

        return this;
    };

    /**
     * ### GameTimer.reset
     *
     * Resets the timer
     *
     * Stops the timer, sets the status to UNINITIALIZED, and
     * sets the following properties to default: milliseconds,
     * update, timeup, hooks, hookNames.
     *
     * Does **not** change properties: eventEmitterName, and
     * stagerSync.
     *
     * @return {GameTimer} The game timer instance for chaining
     */
    GameTimer.prototype.reset = function() {
        checkDestroyed(this, 'reset');
        if (!this.isStopped()) this.stop();
        this.options = {};
        this.milliseconds = null;
        this.update = undefined;
        this.timeup = 'TIMEUP';
        this.hooks = [];
        this.hookNames = {};

        return this;
    };

    /**
     * ### GameTimer.restart
     *
     * Restarts the timer
     *
     * Uses the input parameter as configuration object,
     * or the current settings, if undefined
     *
     * @param {object} options Optional. A configuration object
     *
     * @return {GameTimer} The game timer instance for chaining
     *
     * @see GameTimer.init
     */
    GameTimer.prototype.restart = function(options) {
        checkDestroyed(this, 'restart');
        if (!this.isStopped()) this.stop();
        this.init(options);
        return this.start();
    };

    /**
     * ### GameTimer.isRunning
     *
     * Returns whether timer is running
     *
     * Running means either LOADING or RUNNING.
     *
     * @return {boolean} TRUE if timer is running
     */
    GameTimer.prototype.isRunning = function() {
        checkDestroyed(this, 'isRunning');
        return (this.status > 0);
    };

    /**
     * ### GameTimer.isStopped
     *
     * Returns whether timer is stopped
     *
     * Stopped means either UNINITIALIZED, INITIALIZED or STOPPED.
     *
     * @return {boolean} TRUE if timer is stopped
     *
     * @see GameTimer.isPaused
     */
    GameTimer.prototype.isStopped = function() {
        checkDestroyed(this, 'isStopped');
        return (this.status === GameTimer.UNINITIALIZED ||
            this.status === GameTimer.INITIALIZED ||
            this.status === GameTimer.STOPPED);
    };

    /**
     * ### GameTimer.isPaused
     *
     * Returns whether timer is paused
     *
     * @return {boolean} TRUE if timer is paused
     */
    GameTimer.prototype.isPaused = function() {
        checkDestroyed(this, 'isPaused');
        return this.status === GameTimer.PAUSED;
    };

    /**
     * ### GameTimer.isDestroyed
     *
     * Returns TRUE if the timer is destroyed
     *
     * @return {boolean} TRUE if timer is destroyed
     */
    GameTimer.prototype.isDestroyed = function() {
        return this.status === GameTimer.DESTROYED;
    };

    /**
     * ### GameTimer.isTimeUp | isTimeup
     *
     * Return TRUE if the time expired
     *
     * If timer was stopped before expiring returns FALSE
     *
     * @return {boolean} TRUE if a timeup occurred from last initialization
     */
    GameTimer.prototype.isTimeUp = GameTimer.prototype.isTimeup = function() {
        checkDestroyed(this, 'isTimeup');
        return this._timeup;
    };

    /**
     * ## GameTimer.syncWithStager
     *
     * Enables listeners to events and reads options from stager
     *
     * @param {boolean|undefined} sync TRUE to sync, FALSE to remove sync.
     *    If undefined no operation is performed, and simply the current
     *    value is returned.
     * @param {string} property Optional. Name of the property of the stager
     *    from which load timer information. Default: 'timer'
     *
     * @return {boolean} TRUE if synced, FALSE otherwise
     *
     * @see GameTimer.setStagerProperty
     */
    GameTimer.prototype.syncWithStager = function(sync, property) {
        var node, that, ee;
        checkDestroyed(this, 'syncWithStager');
        if ('undefined' === typeof sync) return this.stagerSync;
        if ('boolean' !== typeof sync) {
            throw new TypeError('GameTimer.syncWithStager: sync must be ' +
                                'boolean or undefined. Found: ' + sync);
        }
        if (property) {
            if ('string' !== typeof property) {
                throw new TypeError('GameTimer.syncWithStager: property ' +
                                    'must be string or undefined. Found: ' +
                                    property);
            }
            this.setStagerProperty(property);
        }
        // Do nothing if no change of status is required.
        if (this.syncWithStager() === sync) return sync;
        node = this.node;
        ee = node.events[this.eventEmitterName];
        if (sync === true) {
            that = this;

            // On PLAYING starts.
            ee.on('PLAYING', function() {
                var options;
                options = that.getStepOptions();
                if (options) that.restart(options);
            }, this.name + '_PLAYING');

            // On REALLY_DONE stops.
            ee.on('REALLY_DONE', function() {
                if (!that.isStopped()) that.stop();
            }, this.name + '_REALLY_DONE');
        }
        else {
            ee.off('PLAYING', this.name + '_PLAYING');
            ee.off('REALLY_DONE', this.name + '_REALLY_DONE');
        }

        // Store value.
        this.stagerSync = sync;
        return sync;
    };

    /**
     * ### GameTimer.doTimeUp | doTimeup
     *
     * Stops the timer and calls the timeup
     *
     * It will call timeup even if the game is paused/stopped,
     * but not if timeup was already called.
     *
     * @return {GameTimer} The game timer instance for chaning
     *
     * @see GameTimer.isTimeup
     * @see GameTimer.stop
     * @see GameTimer.fire
     */
    GameTimer.prototype.doTimeUp = GameTimer.prototype.doTimeup = function() {
        checkDestroyed(this, 'doTimeup');
        if (this.isTimeup()) return;
        if (!this.isStopped()) this.stop();
        this._timeup = true;
        return this.fire(this.timeup);
    };

    // TODO: improve.

    /**
     * ## GameTimer.setStagerProperty
     *
     * Sets the value of stagerProperty
     *
     * @param {string} property The property to set
     *
     * @see GameTimer.stagerProperty
     * @see GameTimer.getStagerProperty
     */
    GameTimer.prototype.setStagerProperty = function(property) {
        checkDestroyed(this, 'setStagerProperty');
        if ('string' === typeof property) {
            throw new TypeError('GameTimer.setStageProperty: property must ' +
                                'be string. Found: ' + property);
        }
        this.stagerProperty = property;
    };

    /**
     * ## GameTimer.getStagerProperty
     *
     * Returns the current value of the stager property
     *
     * @return {string} stagerProperty
     *
     * @see GameTimer.setStagerProperty
     */
    GameTimer.prototype.getStagerProperty = function() {
        checkDestroyed(this, 'getStagerProperty');
        return this.stagerProperty;
    };

    /**
     * ### GameTimer.getStepOptions
     *
     * Makes an object out of step properties 'timer' and 'timeup'
     *
     * Looks up property 'timer' in the game plot. If it is not an object,
     * makes it an object with property 'milliseconds'. Makes sure
     * 'milliseconds' is a number, otherwise returns null.
     *
     * If property 'timeup' is not defined, it looks it up in the game plot.
     *
     * If property 'update' is not defined, it sets it equals to 'milliseconds'.
     *
     * For example:
     *
     * ```javascript
     * {
     *     milliseconds: 2000,
     *     update: 2000,
     *     timeup: function() {}
     *     // Additional properties as specified.
     * }
     * ```
     *
     * @param {mixed} step Optional. Game step. Default current game stepx
     * @param {string} prop Optional. The name of the property to look up
     *    in the plot containing 'timer' info. Default: `this.stagerProperty`
     *
     * @return {object} options Validated configuration object, or NULL
     *   if no timer info is found for current step
     */
    GameTimer.prototype.getStepOptions = function(step, prop) {
        var timer, timeup;
        checkDestroyed(this, 'getStepOptions');
        step = 'undefined' !== typeof step ?
            step : this.node.game.getCurrentGameStage();
        prop = prop || this.getStagerProperty();

        timer = this.node.game.plot.getProperty(step, prop);
        if (null === timer) return null;

        // If function, it can return a full object,
        // a function, or just the number of milliseconds.
        if ('function' === typeof timer) {
            timer = timer.call(this.node.game);
            if (null === timer) return null;
        }
        else if ('object' === typeof timer) {
            // Manual clone.
            timer = {
                milliseconds: timer.milliseconds,
                update: timer.update,
                timeup: timer.timeup,
                hooks: timer.hooks
            };
            if ('function' === typeof timer.milliseconds) {
                timer.milliseconds = timer.milliseconds.call(this.node.game);
            }
        }

        if ('function' === typeof timer) timer = timer.call(this.node.game);
        if ('number' === typeof timer) timer = { milliseconds: timer };

        if ('object' !== typeof timer ||
            'number' !== typeof timer.milliseconds ||
            timer.milliseconds < 0) {

            this.node.warn('GameTimer.getStepOptions: invalid value for ' +
                           'milliseconds. Found: ' + timer.milliseconds);
            return null;
        }

        // Make sure update and timer are the same.
        if ('undefined' === typeof timer.update) {
            timer.update = timer.milliseconds;
        }

        if ('undefined' === typeof timer.timeup) {
            timeup = this.node.game.plot.getProperty(step, 'timeup');
            if (timeup) timer.timeup = timeup;
        }

        return timer;
    };

    // ## Helper methods.

    /**
     * ### updateCallback
     *
     * Updates the timer object
     *
     * @param {GameTimer} that The game timer instance
     *
     * @return {boolean} FALSE if timer ran out, TRUE otherwise
     */
    function updateCallback(that) {
        var i;
        that.status = GameTimer.RUNNING;
        that.timePassed += that.update;
        that.timeLeft -= that.update;
        that.updateStart = J.now();
        // Fire custom hooks from the latest to the first if any.
        for (i = that.hooks.length; i > 0; i--) {
            that.fire(that.hooks[(i-1)]);
        }
        // Fire Timeup Event
        if (that.timeLeft <= 0) {
            that.doTimeup();
            return false;
        }

        return true;
    }

    /**
     * ### checkInitialized
     *
     * Check whether the timer has a valid initialized state
     *
     * @param {GameTimer} that The game timer instance
     *
     * @return {string|null} Returns null if timer is in valid,
     *    state, or an error string otherwise.
     */
    function checkInitialized(that) {
        if ('number' !== typeof that.milliseconds) {
            return 'milliseconds must be a number. Found ' + that.milliseconds;
        }
        if (that.update > that.milliseconds) {
            return 'update cannot be larger than milliseconds';
        }
        return null;
    }

    /**
     * ### checkDestroyed
     *
     * Check whether the timer has been destroyed and throws an error if so
     *
     * @param {GameTimer} that The game timer instance
     * @param {string} method The name of the method invoking it
     */
    function checkDestroyed(that, method) {
        if (that.status === GameTimer.DESTROYED) {
            throw new Error('GameTimer.' + method + ': gameTimer ' +
                            'marked as destroyed: ' + that.name);
        }
    }

    // ## Closure
})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # Matcher
 * Copyright(c) 2020 Stefano Balietti
 * MIT Licensed
 *
 * Class handling the creation of tournament schedules.
 *
 * http://www.nodegame.org
 * ---
 */
(function(exports, node) {

    var J = node.JSUS;
    var Roler = node.Roler;

    // Object containing methods to fetch a match in the requested format.
    // Will be initialized later.
    var fetchMatch;

    exports.Matcher = Matcher;

    // ## Static methods.

    /**
     * ### Matcher.bye
     *
     * Symbol used to complete matching when partner is missing
     *
     * @see Matcher.matches

     */
    Matcher.bye = -1;

    /**
     * ### Matcher.missingId
     *
     * Symbol assigned to matching number without valid id
     *
     * @see Matcher.resolvedMatches
     * @see Roler.missingId
     */
    Matcher.missingId = 'bot';

    /**
     * ## Matcher.randomAssigner
     *
     * Assigns ids to positions randomly.
     *
     * @param {array} ids The ids to assign
     *
     * @return The sorted array
     *
     * @see JSUS.shuffle
     */
    Matcher.randomAssigner = function(ids) {
        return J.shuffle(ids);
    };

    /**
     * ### Matcher.linearAssigner
     *
     * Assigns ids to positions linearly.
     *
     * @param {array} ids The ids to assign
     *
     * @return The sorted array
     */
    Matcher.linearAssigner = function(ids) {
        return J.clone(ids);
    };

    /**
     * ## Matcher constructor
     *
     * Creates a new Matcher object
     *
     * @param {object} options Optional. Configuration options
     */
    function Matcher(options) {

        options = options || {};

        /**
         * ### Matcher.x
         *
         * The row-index of the last returned match by Matcher.getMatch
         *
         * @see Matcher.getMatch
         */
        this.x = null;

        /**
         * ### Matcher.y
         *
         * The column-index of the last returned match by Matcher.getMatch
         *
         * @see Matcher.getMatch
         */
        this.y = null;

        /**
         * ### Matcher.matches
         *
         * Nested array of matches (with position-numbers)
         *
         * Nests a new array for each round, and within each round
         * individual matches are also array. For example:
         *
         * ```javascript
         *
         * // Matching array.
         * [
         *
         *   // First round.
         *   [ [ p1, p2 ], [ p3, p4 ], ... ],
         *
         *   // Second round.
         *   [ [ p2, p3 ], [ p4, p1 ], ... ],
         *
         *   // Further rounds.
         * ];
         * ```
         *
         * @see Matcher.setMatches
         */
        this.matches = null;

        /**
         * ### Matcher.resolvedMatches
         *
         * Nested array of matches (with id-strings)
         *
         * Exactly Matcher.matches, but with with ids instead of numbers
         *
         * This method is used both by getMatch and getMatchObject (if
         * a single match is requested).
         *
         * @see Matcher.matches
         * @see Matcher.resolvedMatchesObj
         * @see Matcher.resolvedMatchesById
         * @see Matcher.setIds
         * @see Matcher.setAssignerCb
         * @see Matcher.match
         */
        this.resolvedMatches = null;

        /**
         * ### Matcher.resolvedMatchesObj
         *
         * Array of maps id to partner, one map per round
         *
         * ```javascript
         *
         * // Matching array.
         * [
         *
         *   // First round.
         *   { p1: 'p2', p2: 'p1', p3: 'p4', p4: 'p3',  ... },
         *
         *   // Second round.
         *   { p2: 'p3', p3: 'p2', p4: 'p1', p1: 'p4',  ... },
         *
         *   // Further rounds.
         * ];
         * ```
         *
         * @see Matcher.resolvedMatches
         * @see Matcher.resolvedMatchesById
         * @see Matcher.setIds
         * @see Matcher.match
         */
        this.resolvedMatchesObj = null;

        /**
         * ### Matcher.resolvedMatchesById
         *
         * Maps ids to a sequence of matches
         *
         * ```javascript
         *
         * // Matching object.
         * {
         *
         *   // All rounds.
         *   p1: [ 'p2', 'p4', ... ],
         *   p2: [ 'p1', 'p3', ... ],
         *   p3: [ 'p4', 'p2', ... ],
         *   p4: [ 'p3', 'p1', ... ]
         *   ...
         *
         * };
         * ```
         *
         * @see Matcher.resolvedMatches
         * @see Matcher.resolvedMatchesObj
         * @see Matcher.setIds
         * @see Matcher.match
         */
        this.resolvedMatchesById = null;

        /**
         * ### Matcher.ids
         *
         * Array ids to match
         *
         * @see Matcher.setIds
         */
        this.ids = null;

        /**
         * ### Matcher.ids
         *
         * Array mapping each ordinal position to an id
         *
         * @see Matcher.ids
         * @see Matcher.assignerCb
         */
        this.assignedIds = null;

        /**
         * ### Matcher.idsMap
         *
         * Map ids to match
         *
         * @see Matcher.setIds
         */
        this.idsMap = null;

        /**
         * ### Matcher.assignedIdsMap
         *
         * Map ids to ordinal position in matches
         *
         * @see Matcher.idsMap
         * @see Matcher.assignedIds
         */
        this.assignedIdsMap = null;

        /**
         * ### Matcher.assignerCb
         *
         * Callback that assigns ids to positions
         *
         * An assigner callback must take as input an array of ids,
         * reorder them according to some criteria, and return it.
         * The order of the items in the returned array will be used to
         * match the numbers in the `matches` array.
         *
         * @see Matcher.ids
         * @see Matcher.matches
         * @see Matcher.assignedIds
         */
        this.assignerCb = Matcher.randomAssigner;

        /**
         * ## Matcher.missingId
         *
         * An id used to replace missing players ids
         */
        this.missingId = Matcher.missingId;

        /**
         * ## Matcher.missingId
         *
         * An id used by matching algorithms to complete unfinished matches
         */
        this.bye = Matcher.bye;

        /**
         * ## Matcher.doObjLists
         *
         * Flag that obj lists should be created when `match` is invoked
         *
         * @see Matcher.resolvedMatchesObj
         * @see Matcher.matcher
         */
        this.doObjLists = true;

        /**
         * ## Matcher.doIdLists
         *
         * Flag that id lists should be created when `match` is invoked
         *
         * @see Matcher.resolvedMatchesById
         * @see Matcher.matcher
         */
        this.doIdLists = true;

        /**
         * ## Matcher.doRoles
         *
         * Flag that roles should be assigned when `match` is invoked
         *
         * Requires roles to be set, otherwise an error is thrown
         *
         * @see Matcher.roles
         * @see Matcher.roler
         * @see Matcher.matcher
         */
        this.doRoles = false;

        /**
         * ## Matcher.roler
         *
         * Handles assigning roles to matches
         *
         * If null here, is initialized by `init` if doRoles is TRUE.
         *
         * @see Matcher.doRoles
         * @see Matcher.init
         */
        this.roler = options.roler || null;

        /**
         * ## Matcher.roles
         *
         * Roles map created if `doRoles` is TRUE
         *
         * @see Matcher.doRoles
         * @see Matcher.roler
         * @see Matcher.matcher
         */
        this.roler = options.roler || null;

        // Init.
        this.init(options);
    }

    /**
     * ### Matcher.init
     *
     * Inits the Matcher instance
     *
     * @param {object} options
     */
    Matcher.prototype.init = function(options) {
        options = options || {};

        if (options.assignerCb) this.setAssignerCb(options.assignerCb);
        if (options.ids) this.setIds(options.ids);
        if (options.bye) this.bye = options.bye;
        if (options.missingId) this.missingId = options.missingId;

        if (null === options.x) this.x = null;
        else if ('number' === typeof options.x) {
            if (options.x < 0) {
                throw new Error('Matcher.init: options.x cannot be negative.' +
                                'Found: ' + options.x);
            }
            this.x = options.x;
        }
        else if (options.x) {
            throw new TypeError('Matcher.init: options.x must be number, ' +
                                'null or undefined. Found: ' + options.x);
        }

        if (null === options.y) this.y = null;
        else if ('number' === typeof options.y) {
            if (options.y < 0) {
                throw new Error('Matcher.init: options.y cannot be negative.' +
                                'Found: ' + options.y);
            }
            this.y = options.y;
        }
        else if (options.y) {
            throw new TypeError('Matcher.init: options.y must be number, ' +
                                'null or undefined. Found: ' + options.y);
        }

        if (options.doRoles || options.roles) {
            if (!this.roler) this.roler = new Roler();
            this.roler.init({
                missingId: this.missingId,
                roles: options.roles
            });
            this.doRoles = true;
        }
        else if ('undefined' !== typeof options.doRoles) {
            this.doRoles = !!options.doRoles;
        }

        if ('undefined' !== typeof options.doObjLists) {
            this.doObjLists = !!options.doObjLists;
        }

        if ('undefined' !== typeof options.doIdLists) {
            this.doIdLists = !!options.doIdLists;
        }
    };

    /**
     * ### Matcher.generateMatches
     *
     * Creates a matches array according to the chosen scheduling algorithm
     *
     * Throws an error if the selected algorithm is not found.
     *
     * @param {string} alg The chosen algorithm. Available: 'roundrobin',
     *   'random'
     *
     * @return {array} The array of matches
     */
    Matcher.prototype.generateMatches = function(alg) {
        var matches;
        if ('string' !== typeof alg) {
            throw new TypeError('Matcher.generateMatches: alg must be ' +
            'string. Found: ' + alg);
        }
        alg = alg.toLowerCase();
        if (alg === 'roundrobin' || alg === 'round_robin' ||
            alg === 'random' || alg === 'random_pairs' ) {

            matches = pairMatcher(alg, arguments[1], arguments[2]);
        }
        else {
            throw new Error('Matcher.generateMatches: unknown algorithm: ' +
                            alg);
        }

        this.setMatches(matches);
        return matches;
    };

    /**
     * ### Matcher.setMatches
     *
     * Sets the matches for current instance
     *
     * Resets resolvedMatches and resolvedMatchesObj to null.
     *
     * @param {array} The array of matches
     *
     * @see this.matches
     */
    Matcher.prototype.setMatches = function(matches) {
        if (!J.isArray(matches) || !matches.length) {
            throw new TypeError('Matcher.setMatches: matches must be a ' +
                                'non-empty array. Found: ' + matches);
        }
        this.matches = matches;
        resetResolvedData(this);
    };

    /**
     * ### Matcher.getMatches
     *
     * Returns the matches for current instance
     *
     * @return {array|null} The array of matches (NULL if not yet set)
     *
     * @see this.matches
     */
    Matcher.prototype.getMatches = function() {
        return this.matches;
    };

    /**
     * ### Matcher.setIds
     *
     * Sets the ids to be used for the matches
     *
     * @param {array} ids Array containing the id of the matches
     *
     * @see Matcher.ids
     * @see Matcher.idsMap
     */
    Matcher.prototype.setIds = function(ids) {
        var i, len;
        if (!J.isArray(ids) || !ids.length) {
            throw new TypeError('Matcher.setIds: ids must be a non-empty ' +
                                'array. Found: ' + ids);
        }
        // Keep track of all ids.
        this.idsMap = {};
        i = -1, len = ids.length;
        for ( ; ++i < len ; ) {
            // TODO: validate? Duplicated ids are fine?
            this.idsMap[ids[i]] = true;
        }
        this.ids = ids;
        resetResolvedData(this);
    };

    /**
     * ### Matcher.getIds
     *
     * Returns the ids used to created the matching
     *
     * @return {array} ids Ids in use
     *
     * @see Matcher.ids
     */
    Matcher.prototype.getIds = function() {
        return this.ids;
    };

    /**
     * ### Matcher.assignIds
     *
     * Calls the assigner callback to assign ids to positions
     *
     * Ids can be overwritten by parameter. If no ids are found,
     * they will be automatically generated, provided that matches
     * have been generated first.
     *
     * @param {array} ids Optional. Array containing the id of the matches
     *   to pass to Matcher.setIds
     *
     * @see Matcher.ids
     * @see Matcher.setIds
     * @see Matcher.assignedIds
     * @see Matcher.assignedIdsMap
     */
    Matcher.prototype.assignIds = function(ids) {
        var i, len;
        if ('undefined' !== typeof ids) this.setIds(ids);
        if (!J.isArray(this.ids) || !this.ids.length) {
            if (!J.isArray(this.matches) || !this.matches.length) {
                throw new TypeError('Matcher.assignIds: no ids and no ' +
                                    'matches found.');
            }
            this.ids = J.seq(0, this.matches.length -1, 1, function(i) {
                return '' + i;
            });
        }
        this.assignedIds = this.assignerCb(this.ids);
        // Map all ids to its position.
        this.assignedIdsMap = {};
        i = -1, len = this.assignedIds.length;
        for ( ; ++i < len ; ) {
            this.assignedIdsMap[this.assignedIds[i]] = i;
        }
    };

    /**
     * ### Matcher.setAssignerCb
     *
     * Specify a callback to be used to assign existing ids to positions
     *
     * @param {function} cb The assigner cb
     *
     * @see Matcher.ids
     * @see Matcher.matches
     * @see Matcher.assignerCb
     */
    Matcher.prototype.setAssignerCb = function(cb) {
        if ('function' !== typeof cb) {
            throw new TypeError('Matcher.setAssignerCb: cb must be ' +
                                'function. Found: ' + cb);
        }
        this.assignerCb = cb;
    };

    /**
     * ### Matcher.match
     *
     * Substitutes the ids to the matches
     *
     * Populates the indexes:
     *
     *   - `resolvedMatches`,
     *   - `resolvedMatchesObj`,
     *   - `resolvedMatchesById`
     *
     * If the matches array is not already set, an error is thrown.
     *
     * If the ids have not been assigned, it does automatic assignment.
     *
     * @param {boolean|array} assignIds Optional. A flag to force to
     *   re-assign existing ids, or an an array containing new ids to
     *   assign.
     *
     * @see Matcher.assignIds
     * @see Matcher.resolvedMatchesObj
     * @see Matcher.resolvedMatches
     *
     * TODO: creates two lists of matches with bots and without.
     */
    Matcher.prototype.match = function(assignIds) {
        var i, lenI, j, lenJ, pair;
        var matched, matchedObj, matchedId, id1, id2;
        var roles, rolesObj, idRolesObj, r1, r2;

        if (!J.isArray(this.matches) || !this.matches.length) {
            throw new Error('Matcher.match: no matches found');
        }

        // Assign/generate ids if not done before.
        if (!this.assignedIds || assignIds) {
            if (J.isArray(assignIds)) this.assignIds(assignIds);
            else this.assignIds();
        }

        // Parse the matches array and creates two data structures
        // where the absolute position becomes the player id.
        i = -1, lenI = this.matches.length;
        matched = new Array(lenI);
        matchedObj = this.doObjLists ? new Array(lenI) : null;
        matchedId = this.doIdLists ? {} : null;
        if (this.doRoles) {
            roles = new Array(lenI);
            rolesObj = new Array(lenI);
            idRolesObj = new Array(lenI);
        }
        else {
            roles = null;
            rolesObj = null;
            idRolesObj = null;
        }
        for ( ; ++i < lenI ; ) {
            j = -1, lenJ = this.matches[i].length;
            matched[i] = new Array(lenJ);
            if (this.doObjLists) matchedObj[i] = {};
            if (this.doRoles) {
                roles[i] = new Array(lenJ);
                rolesObj[i] = new Array(lenJ);
                idRolesObj[i] = new Array(lenJ);
            }
            for ( ; ++j < lenJ ; ) {
                id1 = null, id2 = null;
                pair = this.matches[i][j];
                // Resolve matches.
                id1 = importMatchItem(i, j,
                                      pair[0],
                                      this.assignedIds,
                                      this.missingId);
                id2 = importMatchItem(i, j,
                                      pair[1],
                                      this.assignedIds,
                                      this.missingId);
                // Create resolved matches:
                // Array.
                matched[i][j] = [id1, id2];
                // Obj.
                if (this.doObjLists) {
                    matchedObj[i][id1] = id2;
                    matchedObj[i][id2] = id1;
                }
                // By Id.
                if (this.doIdLists) {
                    if (!matchedId[id1]) matchedId[id1] = new Array(lenI);
                    if (!matchedId[id2]) matchedId[id2] = new Array(lenI);
                    matchedId[id1][i] = id2;
                    matchedId[id2][i] = id1;
                }
                // Roles.
                if (this.doRoles) {
                    roles[i][j] = this.roler.rolify(matched[i][j], i, j);
                    // TODO: this code is repeated in Roler.rolifyAll.
                    // make it one!
                    r1 = roles[i][j][0];
                    r2 = roles[i][j][1];
                    rolesObj[i][j] = {};
                    if (r1 !== r2) {
                        rolesObj[i][j][r1] = id1;
                        rolesObj[i][j][r2] = id2;
                    }
                    else {
                        rolesObj[i][j][r1] = [ id1, id2 ];
                    }
                    idRolesObj[i][j] = {};
                    idRolesObj[i][j][id1] = r1;
                    idRolesObj[i][j][id2] = r2;
                }
            }
        }
        // Substitute matching-structure.
        this.resolvedMatches = matched;
        this.resolvedMatchesObj = matchedObj;
        this.resolvedMatchesById = matchedId;
        this.roles = roles;
        this.rolesObj = rolesObj;
        if (this.doRoles) {
            this.roler.setRolifiedMatches(roles, false);
            this.roler.setRole2IdMatches(rolesObj, false);
            this.roler.setId2RoleMatches(idRolesObj, false);
        }
        // Set getMatch indexes to 0.
        this.x = null;
        this.y = null;
    };

    /**
     * ### Matcher.hasNext
     *
     * Returns TRUE if there is next match to be returned by getMatch
     *
     * @param {number} x Optional. The x-th round. Default: Matcher.x
     * @param {number} y Optional. The y-th match within the x-th round
     *    Default: Matcher.y
     *
     * @return {bolean} TRUE, if there exists a next match
     *
     * @see Matcher.x
     * @see Matcher.y
     * @see Matcher.resolvedMatches
     * @see hasOrGetNext
     */
    Matcher.prototype.hasNext = function(x, y) {
        return hasOrGetNext.call(this, 'hasNext', 0, x, y);
    };

    /**
     * ### Matcher.getMatch
     *
     * Returns the next match, or the specified match
     *
     * @param {number} x Optional. The x-th round. Default: Matcher.x
     * @param {number} y Optional. The y-th match within the x-th round.
     *    Default: Matcher.y
     *
     * @return {array} The next or requested match, or null if not found
     *
     * @see Matcher.x
     * @see Matcher.y
     * @see Matcher.resolvedMatches
     * @see hasOrGetNext
     */
    Matcher.prototype.getMatch = function(x, y) {
        return hasOrGetNext.call(this, 'getMatch', 1, x, y);
    };

    /**
     * ### Matcher.getMatchFor
     *
     * Returns the id/s of the next or the x-th match for the specified id
     *
     * If id lists are not generated (see `Matcher.doIdLists) an
     * error is thrown.
     *
     * @param {string} id The id to get the matches for
     * @param {number} x Optional. The x-th round. Default: Matcher.x
     *
     * @return {string|array} The next or requested match, or null if not found
     *
     * @see Matcher.x
     * @see Matcher.y
     * @see Matcher.doIdLists
     * @see Matcher.resolvedMatches
     * @see hasOrGetNext
     */
    Matcher.prototype.getMatchFor = function(id, x) {
        var out;
        if ('string' !== typeof id) {
            throw new TypeError('Matcher.getMatchFor: id must be string. ' +
                                'Found:' + id);
        }
        if (!this.resolvedMatchesById) {
            throw new Error('Matcher.getMatchFor: no id-based matches found.');
        }
        out = this.resolvedMatchesById[id];
        if (!out) return null;
        if ('undefined' === typeof x) return out;
        if ('number' === typeof x) {
            if (x >= 0 && !isNaN(x)) return x > (out.length -1) ? null : out[x];
        }
        throw new TypeError('Matcher.getMatchFor: x must be a positive ' +
                            'number or undefined. Found: ' + x);
    };

    /**
     * ### Matcher.getMatchObject
     *
     * Returns all the matches of the next or requested round as key-value pairs
     *
     * If object lists are not generated (see `Matcher.doObjLists) an
     * error is thrown.
     *
     * @param {number} x Optional. The x-th round. Default: Matcher.x
     * @param {number} y Optional. The y-th match within the x-th round.
     *    Default: Matcher.y
     *
     * @return {object|null} The next or requested match, or null if not found
     *
     * @see Matcher.x
     * @see Matcher.y
     * @see Matcher.doObjLists
     * @see Matcher.resolvedMatchesObj
     */
    Matcher.prototype.getMatchObject = function(x, y) {
        if (!this.resolvedMatchesObj) {
            throw new Error('Matcher.getMatchObject: no obj matches found.');
        }
        return hasOrGetNext.call(this, 'getMatchObject', 3, x, y);
    };

    /**
     * ### Matcher.normalizeRound
     *
     * Returns the round index given the current number of matches
     *
     * For example, if the are only 10 matches repeated in cycle,
     * but the game has 20 rounds, round 13th will have normalized
     * round index equal to 3.
     *
     * Important! Matches are 0-based, but rounds are 1-based. This
     * method takes care of it.
     *
     * @param {number} round The round to normalize
     *
     * @return {object} The next or requested match, or null if not found
     *
     * @see Matcher.x
     * @see Matcher.matches
     */
    Matcher.prototype.normalizeRound = function(round) {
        if (!this.matches) {
            throw new TypeError('Matcher.normalizeRound: no matches found.');
        }
        if ('number' !== typeof round || isNaN(round) || round < 1) {
            throw new TypeError('Matcher.normalizeRound: round must be a ' +
                                'number > 0. Found: ' + round);
        }
        return (round-1) % this.matches.length;
    };

    /**
     * ### Matcher.replaceId
     *
     * Replaces an id with a new one in all matches
     *
     * @param {string} oldId The id to be replaced
     * @param {string} newId The replacing id
     *
     * @return {boolean} TRUE, if the oldId was found and replaced
     *
     * @see MatcherManager.replaceId
     * @see Roler.replaceId
     */
    Matcher.prototype.replaceId = function(oldId, newId) {
        var m;
        var i, len, j, lenJ, h, lenH;
        var rowFound;
        if ('string' !== typeof oldId) {
            throw new TypeError('Matcher.replaceId: oldId should be string. ' +
                                'Found: ' + oldId);
        }
        if ('string' !== typeof newId || newId.trim() === '') {
            throw new TypeError('Matcher.replaceId: newId should be a ' +
                                'non-empty string. Found: ' + newId);
        }

        // No id was assigned yet.
        if (!this.resolvedMatches) return false;

        // IdsMap.
        m = this.idsMap[oldId];
        if ('undefined' === typeof m) return false;

        this.idsMap[newId] = true;
        delete this.idsMap[oldId];

        // Ids.
        m = this.ids;
        i = -1, len = m.length;
        for ( ; ++i < len ; ) {
            if (m[i] === oldId) {
                m[i] = newId;
                break;
            }
        }

        // AssignedIds and AssignedIdsMap.
        m = this.assignedIdsMap;
        m[newId] = m[oldId];
        delete m[oldId];
        this.assignedIds[m[newId]] = newId;

        // Update resolvedMatches.
        m = this.resolvedMatches;
        if (!m) return true;

        i = -1, len = m.length;
        for ( ; ++i < len ; ) {
            j = -1, lenJ = m[i].length;
            rowFound = false;
            for ( ; ++j < lenJ ; ) {
                h = -1, lenH = m[i][j].length;
                for ( ; ++h < lenH ; ) {
                    if (m[i][j][h] === oldId) {
                        m[i][j][h] = newId;
                        rowFound = true;
                        break;
                    }
                }
                if (rowFound) break;
            }
        }

        // Update resolvedMatchesObj.
        m = this.resolvedMatchesObj;

        i = -1, len = m.length;
        for ( ; ++i < len ; ) {
            for (j in m[i]) {
                if (m[i].hasOwnProperty(j)) {
                    if (j === oldId) {
                        // Do the swap.
                        m[i][newId] = m[i][oldId];
                        m[i][m[i][oldId]] = newId;
                        delete m[i][oldId];
                        break;
                    }
                }
            }
        }

        // Update resolvedMatchesById.
        m = this.resolvedMatchesById;
        for (i in m) {
            if (m.hasOwnProperty(i)) {
                if (i === oldId) {
                    m[newId] = m[oldId];
                    delete m[oldId];
                }
                else {
                    lenJ = m[i].length;
                    // THIS OPTIMIZATION DOES NOT SEEM TO WORK.
                    // In fact, there might be more matches with the same
                    // partner in sequence.
                    // And also if === 1, it should be checked.
                    // if (lenJ == 1) {
                    //     m[i][0] = newId;
                    // }
                    // else if (lenJ === 2) {
                    //     if (m[i][0] === oldId) m[i][0] = newId;
                    //     else m[i][1] = newId;
                    // }
                    // else {
                    j = -1;
                    for ( ; ++j < lenJ ; ) {
                        if (m[i][j] === oldId) {
                            m[i][j] = newId;
                        }
                    }
                    // }
                }
            }
        }

        return true;
    };

    /**
     * ### Matcher.clear
     *
     * Clears the matcher as it would be a newly created object
     */
    Matcher.prototype.clear = function() {
        this.x = null;
        this.y = null;
        this.matches = null;
        this.resolvedMatches = null;
        this.resolvedMatchesObj = null;
        this.ids = null;
        this.assignedIds = null;
        this.idsMap = null;
        this.assignedIdsMap = null;
        this.assignerCb = Matcher.randomAssigner;
        this.missingId = Matcher.missingId;
        this.bye = Matcher.bye;
    };

    // ## Helper methods.

    /**
     * ### importMatchItem
     *
     * Handles importing items from the matches array
     *
     * Items in matches array must be numbers or strings. If numbers
     * they are translated into an id using the supplied map, otherwise
     * they are considered as already an id.
     *
     * Items that are not numbers neither strings will throw an error.
     *
     * @param {number} i The row-id of the item
     * @param {number} j The position in the row of the item
     * @param {string|number} item The item to check
     * @param {array} map The map of positions to ids
     * @param {string} miss The id of number that cannot be resolved in map
     *
     * @return {string} The resolved id of the item
     */
    function importMatchItem(i, j, item, map, miss) {
        if ('number' === typeof item) {
            return 'undefined' !== typeof map[item] ? map[item] : miss;
        }
        else if ('string' === typeof item) {
            return item;
        }
        throw new TypeError('Matcher.match: items can be only string or ' +
                            'number. Found: ' + item + ' at position ' +
                            i + ',' + j);
    }

    /**
     * ### resetResolvedData
     *
     * Resets resolved data of a matcher object
     *
     * @param {Matcher} matcher The matcher to reset
     */
    function resetResolvedData(matcher) {
        matcher.resolvedMatches = null;
        matcher.resolvedMatchesObj = null;
        matcher.resolvedMatchesById = null;
        matcher.assignedIds = null;
        matcher.assignedIdsMap = null;
    }

    /**
     * ### pairMatcherOld
     *
     * Creates tournament schedules for different algorithms
     *
     * @param {string} alg The name of the algorithm
     * @param {number|array} n The number of participants (>1) or
     *   an array containing the ids of the participants
     * @param {object} options Optional. Configuration object
     *   contains the following options:
     *
     *   - bye: identifier for dummy competitor. Default: -1.
     *   - skypeBye: flag whether players matched with the dummy
     *        competitor should be added or not. Default: true.
     *   - rounds: number of rounds to repeat matching. Default:
     *   - cycle: if there are more rounds than possible combinations
     *        this option specifies how to fill extra rounds. Available
     *        settings:
     *
     *        - 'repeat': repeats all available matches (default)
     *        - 'repeat_invert': repeats all available matches, but inverts
     *             the position of ids in the match
     *        - 'mirror': repeats all available matches in mirrored order.
     *        - 'mirror_invert': repeats all available matches in mirrored
     *              order and also inverts the position of the ids in the match
     *
     * @return {array} matches The matches according to the algorithm
     */
    function pairMatcher(alg, n, options) {
        var ps, matches, bye;
        var i, lenI, j, lenJ, jj;
        var id1, id2;
        var roundsLimit, cycle, cycleI, skipBye;
        var fixedRolesNoSameMatch;

        if ('number' === typeof n && n > 1) {
            ps = J.seq(0, (n-1));
        }
        else if (J.isArray(n) && n.length > 1) {
            ps = n.slice();
            n = ps.length;
        }
        else {
            throw new TypeError('pairMatcher.' + alg + ': n must be ' +
                                'number > 1 or array of length > 1.');
        }
        options = options || {};

        bye = 'undefined' !== typeof options.bye ? options.bye : -1;
        skipBye = options.skipBye || false;

        // Make sure we have even numbers.
        if ((n % 2) === 1) {
            ps.push(bye);
            n += 1;
        }

        // Does not work.
        if (options.fixedRoles && (options.canMatchSameRole === false)) {
            fixedRolesNoSameMatch = true;
        }

        // Limit rounds.
        if ('number' === typeof options.rounds) {
            if (options.rounds <= 0) {
                throw new Error('pairMatcher.' + alg + ': options.rounds ' +
                                'must be a positive number or undefined. ' +
                                'Found: ' + options.rounds);
            }
            if (options.rounds > (n-1)) {
                throw new Error('pairMatcher.' + alg + ': ' +
                                'options.rounds cannot be greater than ' +
                                (n-1) + '. Found: ' + options.rounds);
            }
            // Here roundsLimit does not depend on n (must be smaller).
            roundsLimit = options.rounds;
        }
        else if (fixedRolesNoSameMatch) {
            roundsLimit = Math.floor(n/2);
        }
        else {
            roundsLimit = n-1;
        }

        if ('undefined' !== typeof options.cycle) {
            cycle = options.cycle;
            if (cycle !== 'mirror_invert' && cycle !== 'mirror' &&
                cycle !== 'repeat_invert' && cycle !== 'repeat') {

                throw new Error('pairMatcher.' + alg + ': options.cycle ' +
                                'must be equal to "mirror"/"mirror_invert", ' +
                                '"repeat"/"repeat_invert" or undefined . ' +
                                'Found: ' + options.cycle);
            }

            matches = new Array(roundsLimit*2);
        }
        else {
            matches = new Array(roundsLimit);
        }

        i = -1, lenI = roundsLimit;
        for ( ; ++i < lenI ; ) {
            // Shuffle list of ids for random.
            if (alg === 'random') ps = J.shuffle(ps);
            // Create a new array for round i.
            lenJ = n / 2;
            matches[i] = skipBye ? new Array(lenJ-1) : new Array(lenJ);
            // Check if new need to cycle.
            if (cycle) {
                if (cycle === 'mirror' || cycle === 'mirror_invert') {
                    cycleI = (roundsLimit*2) -i -1;
                }
                else {
                    cycleI = i+roundsLimit;
                }
                matches[cycleI] = skipBye ?
                    new Array(lenJ-1) : new Array(lenJ);
            }
            // Counter jj is updated only if not skipBye,
            // otherwise we create holes in the matches array.
            jj = j = -1;
            for ( ; ++j < lenJ ; ) {
                if (fixedRolesNoSameMatch) {
                    id1 = ps[j*2];
                    id2 = ps[((i*2)+(j*2)+1) % n];
                }
                else {
                    id1 = ps[j];
                    id2 = ps[n - 1 - j];
                }
                if (!skipBye || (id1 !== bye && id2 !== bye)) {
                    jj++;
                    // Insert match.
                    matches[i][jj] = [ id1, id2 ];
                    // Insert cycle match (if any).
                    if (cycle === 'repeat') {
                        matches[cycleI][jj] = [ id1, id2 ];
                    }
                    else if (cycle === 'repeat_invert') {
                        matches[cycleI][jj] = [ id2, id1 ];
                    }
                    else if (cycle === 'mirror') {
                        matches[cycleI][jj] = [ id1, id2 ];
                    }
                    else if (cycle === 'mirror_invert') {
                        matches[cycleI][jj] = [ id2, id1 ];
                    }
                }
            }
            // Permutate for next round.
            if (!fixedRolesNoSameMatch) ps.splice(1, 0, ps.pop());
        }
        return matches;
    }

    /**
     * ## fetchMatch
     *
     * Maps method names to a return function to execute in case of success
     *
     *   - 0: hasNext -> returns true
     *   - 1: getMatch -> returns an array, or array of arrays
     *   - 2: getMatchFor -> returns a string
     *   - 3: getMatchObject -> returns an object
     *
     * @see hasOrGetNext
     */
    fetchMatch = [
        // hasNext.
        function() {
            return true;
        },
        // getMatch.
        function(x, y) {
            return 'number' === typeof y ?
                this.resolvedMatches[x][y] : this.resolvedMatches[x];
        },
        // getMatchFor.
        function(x, y, id) {
            if ('number' === typeof x && 'number' === typeof y) {
                return this.resolvedMatchesById[id][x];
            }
            return this.resolvedMatchesById[id];
        },
        // getMatchObject.
        function(x, y) {
            var match, res;
            if ('number' === typeof y) {
                res = {};
                match = this.resolvedMatches[x][y];
                res[match[0]] = match[1];
                res[match[1]] = match[0];
                return res;
            }
            return this.resolvedMatchesObj[x];
        }
    ];

    /**
     * ### hasOrGetNext
     *
     * Returns TRUE or the match if there is next match
     *
     * If in `get` mode it also updates the x and y indexes.
     *
     * @param {string} m The name of the method invoking it
     * @param {boolean} get TRUE, if the method should return the match
     * @param {number} x Optional. The x-th round. Default: Matcher.x
     * @param {number} y Optional. The y-th match within the x-th round
     *    Default: Matcher.y
     * @param {string} id Optional. Used by method getMatchFor
     *
     * @return {boolean|array|null} TRUE or the next match (if found),
     *   FALSE or null (if not found)
     *
     * @see Matcher.x
     * @see Matcher.y
     * @see Matcher.resolvedMatches
     * @see fetchMatch
     */
    function hasOrGetNext(m, mod, x, y, id) {
        var nRows, nCols;

        // Check if there is any match yet.
        if (!J.isArray(this.resolvedMatches) || !this.resolvedMatches.length) {
            throw new Error('Matcher.' + m + ': no resolved matches found.');
        }

        nRows = this.resolvedMatches.length - 1;

        // No x, No y get the next match.
        if ('undefined' === typeof x) {
            // Check both x and y.
            if ('undefined' !== typeof y) {
                throw new Error('Matcher.' + m +
                                ': cannot specify y without x.');
            }

            // No match was ever requested.
            if (null === this.x) {
                this.x = 0;
                this.y = 0;
                return fetchMatch[mod].call(this, 0, 0, id);
            }

            x = this.x;
            y = this.y + 1;
            if (x <= nRows) {
                nCols = this.resolvedMatches[x].length - 1;
                if (y <= nCols) {
                    if (mod) {
                        this.x = x;
                        this.y = y;
                        return fetchMatch[mod].call(this, x, y, id);
                        // return this.resolvedMatches[x][y];
                    }
                    else {
                        return true;
                    }
                }
                else {
                    x = x + 1;
                    y = 0;
                    if (mod) {
                        this.x = x;
                        this.y = y;
                    }
                    if (x <= nRows) {
                        return fetchMatch[mod].call(this, x, y, id);
                        // return mod ? this.resolvedMatches[x][y] : true;
                    }
                    else {
                        return mod ? null : false;
                    }
                }
            }
            else {
                return mod ? null : false;
            }
        }
        // End undefined x.

        // Validate x.
        if ('number' !== typeof x) {
            throw new TypeError('Matcher.' + m + ': x must be number ' +
                                'or undefined. Found: ' + x);
        }
        else if (x < 0 || isNaN(x)) {
            throw new Error('Matcher.' + m + ': x cannot be negative or NaN. ' +
                            'Found: ' + x);
        }

        if (x > nRows) {
            if (mod) {
                this.x = x;
                this.y = 0;
                return null;
            }
            else {
                return false;
            }
        }

        // Default y (whole row).
        if ('undefined' === typeof y) {
            if (mod) {
                this.x = x;
                this.y = this.resolvedMatches[nRows].length;
                // Return the whole row.
                return fetchMatch[mod].call(this, x, y, id);
                // return this.resolvedMatches[x];
            }
            else {
                return true;
            }
        }

        // Validate y.
        if ('number' !== typeof y) {
            throw new TypeError('Matcher.' + m  + ': y must be number ' +
                                'or undefined.');
        }
        else if (y < 0 || isNaN(y)) {
            throw new Error('Matcher.' + m + ': y cannot be negative or NaN. ' +
                            'Found: ' + y);
        }

        nCols = this.resolvedMatches[x].length - 1;

        // Valid x,y match.
        if (y <= nCols) {
            if (mod) {
                this.x = x;
                this.y = y;
                return fetchMatch[mod].call(this, x, y);
                // return this.resolvedMatches[x][y];
            }
            else {
                return true;
            }
        }
        // Out of bound.
        else {
            if (mod) {
                this.x = x;
                this.y = y;
                return null;
            }
            else {
                return false;
            }
        }
    }

    // ## Closure
})(
    'undefined' !== typeof node ? node : module.exports,
    'undefined' !== typeof node ? node : module.parent.exports
);

/**
 * # NodeGameClient
 * Copyright(c) 2017 Stefano Balietti
 * MIT Licensed
 *
 * nodeGame: Online Real-Time Synchronous Experiments.
 *
 * http://nodegame.org
 */
(function(exports, parent) {

    "use strict";

    // ## Exposing Class
    exports.NodeGameClient = NodeGameClient;

    var ErrorManager = parent.ErrorManager,
        EventEmitterManager = parent.EventEmitterManager,
        GameMsgGenerator = parent.GameMsgGenerator,
        Socket = parent.Socket,
        Game = parent.Game,
        Timer = parent.Timer,
        constants = parent.constants;

    /**
     * ## NodeGameClient constructor
     *
     * Creates a new NodeGameClient object
     */
    function NodeGameClient() {

        this.info('node: loading.');

        /**
         * ### node.nodename
         *
         * The name of this node, used in logging output
         *
         * Default: 'ng'
         */
        this.nodename = 'ng';

        /**
         * ### node.verbosity
         *
         * The minimum level for a log entry to be displayed as output
         *
         * Default: only warnings and errors are displayed
         */
        this.verbosity = constants.verbosity_levels.warn;

        /**
         * ### node.remoteVerbosity
         *
         * The minimum level for a log entry to be reported to the server
         *
         * Default: errors and warnings are reported
         */
        this.remoteVerbosity = constants.verbosity_levels.error;

        /**
         * ### node.remoteVerbosity
         *
         * Maps remotely logged messages to avoid infinite recursion
         *
         * In normal conditions this should always stay empty.
         */
        this.remoteLogMap = {};

        /**
         * ### node.errorManager
         *
         * Catches run-time errors
         *
         * In debug mode errors are re-thrown.
         */
        this.errorManager = new ErrorManager(this);

        /**
         * ### node.events
         *
         * Instance of the EventEmitterManager class
         *
         * Takes care of emitting the events and calling the
         * proper listener functions
         *
         * @see EventEmitter
         */
        this.events = new EventEmitterManager(this);

        /**
         * ### NodeGameClient.emit
         *
         * Emits an event locally on all registered event handlers
         *
         * The first parameter be the name of the event as _string_,
         * followed by any number of parameters that will be passed to the
         * handler callback.
         *
         * @see NodeGameClient.emitAsync
         * @see EventEmitterManager.emit
         */
        this.emit = this.events.emit;

        /**
         * ### NodeGameClient.emitAsync
         *
         * Emits an event locally on all registered event handlers
         *
         * Unlike normal emit, it does not return a value.
         *
         * @see NodeGameClient.emit
         * @see EventEmitterManager.emitSync
         */
        this.emitAsync = this.events.emitAsync;

        /**
         * ### NodeGameClient.on
         *
         * Registers an event listener on the active event emitter
         *
         * Different event emitters are active during the game. For
         * example, before a game is started, e.g. in the init
         * function of the game object, the `game` event emitter is
         * active. Events registered with the `game` event emitter
         * stay valid throughout the whole game. Listeners registered
         * after the game is started will be removed after the game
         * has advanced to its next stage or step.
         *
         * @param {string} event The name of the event
         * @param {function} listener The callback function
         *
         * @see NodeGameClient.off
         */
        this.on = function(event, listener) {
            var ee;
            ee = this.getCurrentEventEmitter();
            ee.on(event, listener);
        };

        /**
         * ### NodeGameClient.once
         *
         * Registers an event listener that will be removed after its first call
         *
         * @param {string} event The name of the event
         * @param {function} listener The callback function
         *
         * @see NodeGameClient.on
         * @see NodeGameClient.off
         */
        this.once = function(event, listener) {
            var ee;
            ee = this.getCurrentEventEmitter();
            ee.once(event, listener);
        };

        /**
         * ### NodeGameClient.off
         *
         * Deregisters one or multiple event listeners
         *
         * @param {string} event The name of the event
         * @param {function} listener The callback function
         *
         * @see NodeGameClient.on
         * @see NodeGameClient.EventEmitter.remove
         */
        this.off = function(event, func) {
            return this.events.remove(event, func);
        };

        /**
         * ### node.msg
         *
         * Factory of game messages
         *
         * @see GameMsgGenerator
         */
        this.msg = new GameMsgGenerator(this);

        /**
         * ### node.socket
         *
         * Instantiates the connection to a nodeGame server
         *
         * @see GameSocketClient
         */
        this.socket = new Socket(this);

        /**
         * ### node.session
         *
         * Contains a reference to all session variables
         *
         * Session variables can be saved and restored at a later stage
         *
         * @experimental
         */
        // TODO: not used for now.
        // this.session = new GameSession(this);

        /**
         * ### node.player
         * Instance of node.Player
         *
         * Contains information about the player
         *
         * @see PlayerList.Player
         */
        this.player = { placeholder: true };

        /**
         * ### node.timer
         *
         * Instance of node.Timer
         *
         * @see Timer
         */
        this.timer = new Timer(this);

        /**
         * ### node.game
         *
         * Instance of node.Game
         *
         * @see Game
         */
        this.game = new Game(this);

        /**
         * ### node.store
         *
         * Makes the nodeGame session persistent, saving it
         * to the browser local database or to a cookie
         *
         * @see shelf.js
         */
        this.store = function() {};

        /**
         * ### node.conf
         *
         * A reference to the current nodegame configuration
         *
         * @see NodeGameClient.setup
         */
        this.conf = {};

        /**
         * ### node.support
         *
         * A collection of features that are supported by the current browser
         */
        this.support = {};

        /**
         * ### node._setup
         *
         * Object containing registered setup functions
         *
         * @see NodeGameClient.setup
         * @see NodeGameClient.registerSetup
         *
         * @api private
         */
        this._setup = {};

        /**
         * ### node._env
         *
         * Object containing registered environmental variables
         *
         * @see NodeGameClient.setup.env
         * @see NodeGameClient.env
         *
         * @api private
         */
        this._env = {};

        // ## Configuration.

        // ### Setup functions.
        this.addDefaultSetupFunctions();
        // ### Aliases.
        this.addDefaultAliases();
        // ### Listeners.
        this.addDefaultIncomingListeners();
        this.addDefaultInternalListeners();

        this.info('node: object created.');
    }

    // ## Closure
})(
    'undefined' != typeof node ? node : module.exports
 ,  'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # Log
 * Copyright(c) 2017 Stefano Balietti
 * MIT Licensed
 *
 * nodeGame logging module
 */
(function(exports, parent) {

    "use strict";

    var NGC = parent.NodeGameClient;
    var constants = parent.constants;

    var LOG = constants.target.LOG;

    var J = parent.JSUS;

    /**
     * ### NodeGameClient.log
     *
     * Default nodeGame standard out, override to redirect
     *
     * Logs entries are displayed to the console if their level is
     * smaller than `this.verbosity`.
     *
     * Logs entries are forwarded to the server if their level is
     * smaller than `this.remoteVerbosity`.
     *
     * @param {string} txt The text to output
     * @param {string} level Optional. The verbosity level of this log.
     *   Default: 'info'
     * @param {string} prefix Optional. A text to display at the beginning of
     *   the log entry. Default: 'ng> '
     */
    NGC.prototype.log = function(txt, level, prefix) {
        var numLevel, info;
        if ('undefined' === typeof txt) return;

        level  = level || 'info';
        numLevel = constants.verbosity_levels[level];

        if (this.verbosity >= numLevel) {
            // Add game stage manually (faster than toString()).
            info = this.nodename + '@' + this.player.stage.stage + '.' +
                this.player.stage.step + '.' + this.player.stage.round +
                ' - ' + J.getTimeM() + ' > ';
            if ('undefined' !== typeof prefix) info = info + prefix;
            console.log(info + txt);
        }
        if (this.remoteVerbosity >= numLevel) {
            // We need to avoid creating errors here,
            // otherwise we enter an infinite loop.
            if (this.socket.isConnected() && !this.player.placeholder) {
                if (!this.remoteLogMap[txt]) {
                    this.remoteLogMap[txt] = true;
                    // There is a chance that the message is not sent,
                    // depending on what the state of the connection is.
                    // TODO: example, error on Init function, socket.io
                    // transport stays in state of `upgrading` and does
                    // not let send messages. If you manually force it
                    // in a debug session, they are actually sent.
                    this.socket.send(this.msg.create({
                        target: LOG,
                        text: level,
                        data: txt,
                        to: 'SERVER'
                    }));
                    this.remoteLogMap[txt] = null;
                }
            }
        }
    };

    /**
     * ### NodeGameClient.info
     *
     * Logs an INFO message
     *
     * @param {string} txt The text to log
     *
     * @see NodeGameClient.log
     */
    NGC.prototype.info = function(txt) {
        this.log(txt, 'info', 'info - ');
    };

    /**
     * ### NodeGameClient.warn
     *
     * Logs a WARNING message
     *
     * @param {string} txt The text to log
     *
     * @see NodeGameClient.log
     */
    NGC.prototype.warn = function(txt) {
        this.log(txt, 'warn', 'warn - ');
    };

    /**
     * ### NodeGameClient.err
     *
     * Logs an ERROR message
     *
     * @param {string} txt The text to log
     *
     * @see NodeGameClient.log
     */
    NGC.prototype.err = function(txt) {
        this.log(txt, 'error', 'error - ');
    };

    /**
     * ### NodeGameClient.silly
     *
     * Logs a SILLY message
     *
     * @param {string} txt The text to log
     *
     * @see NodeGameClient.log
     */
    NGC.prototype.silly = function(txt) {
        this.log(txt, 'silly', 'silly - ');
    };

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # Setup
 * Copyright(c) 2018 Stefano Balietti
 * MIT Licensed
 *
 * `nodeGame` configuration module
 *
 * http://nodegame.org
 */
(function(exports, node) {

    "use strict";

    // ## Global scope

    var J = node.JSUS;
    var NGC = node.NodeGameClient;

    /**
     * ### node.setup
     *
     * Setups the nodeGame object
     *
     * Configures a specific feature of nodeGame and and stores
     * the settings in `node.conf`.
     *
     * Accepts any number of extra parameters that are passed
     * to the callback function.
     *
     * @param {string} property The feature to configure
     *
     * @see node.setup.register
     */
    NGC.prototype.setup = function(property) {
        var res, func;
        var i, len, args;

        if ('string' !== typeof property || property === '') {
            throw new TypeError('node.setup: property must be a non-empty ' +
                                'string. Found: ' + property);
        }

        func = this._setup[property];
        if (!func) {
            throw new Error('node.setup: no such property to configure: ' +
                            property);
        }

        // Setup the property using rest of arguments.
        len = arguments.length;
        switch(len) {
        case 1:
            res = func.call(this);
            break;
        case 2:
            res = func.call(this, arguments[1]);
            break;
        case 3:
            res = func.call(this, arguments[1], arguments[2]);
            break;
        default:
            len = len - 1;
            args = new Array(len);
            for (i = -1 ; ++i < len ; ) {
                args[i] = arguments[i+1];
            }
            res = func.apply(this, args);
        };

        if (property !== 'nodegame') this.conf[property] = res;
    };

    /**
     * ### node.registerSetup
     *
     * Registers a configuration function
     *
     * Setup functions can be invoked remotely with in.say.SETUP messages
     * and the name property stated in `msg.text`.
     *
     * @param {string} property The feature to configure
     * @param {mixed} options The value of the option to configure
     *
     * @see node.setup
     */
    NGC.prototype.registerSetup = function(property, func) {        
        if ('string' !== typeof property || property === '') {
            throw new TypeError('node.setup: property must be a non-empty ' +
                                'string. Found: ' + property);
        }
        if ('function' !== typeof func) {
            throw new TypeError('node.registerSetup: func must be function. ' +
                               'Found: ' + func);
        }
        this._setup[property] = func;
    };

    /**
     * ### node.deregisterSetup
     *
     * Registers a configuration function
     *
     * @param {string} feature The name of the setup feature to deregister
     *
     * @see node.setup
     */
    NGC.prototype.deregisterSetup = function(feature) {
        if ('string' !== typeof feature) {
            throw new TypeError('node.deregisterSetup: property must ' +
                                'be string. Found: ' + feature);
        }
        if (!this._setup[feature]) {
            this.warn('node.deregisterSetup: feature "' + feature + '" not ' +
                      'previously registered');
            return;
        }
        this._setup[feature] = null;
    };

    /**
     * ### node.remoteSetup
     *
     * Sends a setup configuration to a connected client
     *
     * Accepts any number of extra parameters that are sent as option values.
     *
     * @param {string} feature The feature to configure
     * @param {string|array} to The id of the remote client to configure
     *
     * @return{boolean} TRUE, if configuration is successful
     *
     * @see node.setup
     * @see JSUS.stringifyAll
     */
    NGC.prototype.remoteSetup = function(feature, to) {
        var msg, payload;
        var i, len;

        if ('string' !== typeof feature) {
            throw new TypeError('node.remoteSetup: feature must be string. ' +
                                'Found: ' + feature);
        }
        if (!to || ('string' !== typeof to && !J.isArray(to))) {
            throw new TypeError('node.remoteSetup: to must be string or ' +
                                'array. Found: ' + to);
        }
        len = arguments.length;
        if (len > 2) {
            if (len === 3) payload = [arguments[2]];
            else if (len === 4) payload = [arguments[2], arguments[3]];
            else {
                payload = new Array(len - 2);
                for (i = 2; i < len; i++) {
                    payload[i - 2] = arguments[i];
                }
            }
            payload = J.stringifyAll(payload);

            if (!payload) {
                this.err('node.remoteSetup: an error occurred while ' +
                         'stringifying payload.');
                return false;
            }
        }

        msg = this.msg.create({
            target: this.constants.target.SETUP,
            to: to,
            text: feature,
            data: payload
        });

        return this.socket.send(msg);
    };

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # Alias
 * Copyright(c) 2015 Stefano Balietti
 * MIT Licensed
 *
 * `nodeGame` aliasing module
 */
(function(exports, node) {

    "use strict";

    // ## Global scope

    var J = node.JSUS;

    var NGC = node.NodeGameClient;

    /**
     * ### node.alias
     *
     * Creates event listeners aliases
     *
     * This method creates a new property to the `node.on` object named
     * after the alias. The alias can be used as a shortcut to register
     * to new listeners on the given events.
     *
     * Note: aliases cannot return values to the emit call.
     * TODO: node.on aliases could do it without problem, node.once aliases
     * have the problem that the return value is currently used to detect
     * whether the modifier function actually executed the user callback.
     *
     * ```javascript
     *   // The node.on.data alias example with modifier function
     *   // only DATA msg with the right label will be fired.
     *   this.alias('data', ['in.say.DATA', 'in.set.DATA'], function(text, cb) {
     *       return function(msg) {
     *           if (msg.text === text) cb.call(that.game, msg);
     *           else return false;
     *       };
     *   });
     *
     *  node.on.data('myLabel', function() { ... };
     *  node.once.data('myLabel', function() { ... };
     * ```
     *
     * @param {string} alias The name of alias
     * @param {string|array} events The event/s under which the listeners
     *   will be registered
     * @param {function} modifier Optional. A function that makes a closure
     *   around its own input parameters, and returns a function that will
     *   actually be invoked when the aliased event is fired. It should return
     *   FALSE if it does not executes the user callback.
     */
    NGC.prototype.alias = function(alias, events, modifier) {
        var that;
        if ('string' !== typeof alias) {
            throw new TypeError('node.alias: alias must be string. Found: ' +
                                alias);
        }
        if ('string' === typeof events) {
            events = [events];
        }
        if (!J.isArray(events)) {
            throw new TypeError('node.alias: events must be array or string. ' +
                                'Found: ' + events);
        }
        if (modifier && 'function' !== typeof modifier) {
            throw new TypeError(
                'node.alias: modifier must be function or undefined. Found: ' +
                    modifier);
        }

        that = this;

        this.on[alias] = function(func) {
            var i, len, args;

            // If set, we use the callback returned by the modifier.
            // Otherwise, we assume the first parameter is the callback.
            if (modifier) {
                args = [];
                i = -1, len = arguments.length;
                for ( ; ++i < len ; ) {
                    args[i] = arguments[i];
                }
                func = modifier.apply(that.game, args);
            }

            J.each(events, function(event) {
                that.on(event, function() {
                    func.apply(that.game, arguments);
                });
            });

        };
        this.once[alias] = function(func) {
            var i, len, args;

            // If set, we use the callback returned by the modifier.
            // Otherwise, we assume the first parameter is the callback.
            if (modifier) {
                args = [];
                i = -1, len = arguments.length;
                for ( ; ++i < len ; ) {
                    args[i] = arguments[i];
                }
                func = modifier.apply(that.game, args);
            }

            J.each(events, function(event) {
                // We redo the once method manually because otherwise
                // the first call to once will remove all once listeners
                // defined with this alias. Normal one calls the listener
                // that wraps the modifier which may or may not execute the
                // user-defined function. We introduce that if the modifier
                // return false, it means the user-defined function was not
                // executed and therefore it should not be removed.
                function g() {
                    var i, len, args, toRemove;
                    args = [];
                    i = -1, len = arguments.length;
                    for ( ; ++i < len ; ) {
                        args[i] = arguments[i];
                    }
                    toRemove = func.apply(that.game, args);
                    // If a modifier returns false it has not executed the
                    // user-defined listener, so we should not remove it.
                    if (!modifier || toRemove !== false) that.off(event, g);
                }
                that.on(event, g);
            });
        };

        // attachAlias(this, 'on', events, modifier, alias);
        // attachAlias(this, 'once', events, modifier, alias);

        // this.on[alias] = function(func) {
        //     var i, len, args;
        //     args = [];
        //     i = -1, len = arguments.length;
        //     for ( ; ++i < len ; ) {
        //         args[i] = arguments[i];
        //     }
        //     // If set, we use the callback returned by the modifier.
        //     // Otherwise, we assume the first parameter is the callback.
        //     if (modifier) func = modifier.apply(that.game, args);
        //
        //     // Optimized.
        //     if (eventsLen < 3) {
        //         that.on(event[0], function() {
        //             func.apply(that.game, args);
        //         });
        //         if (eventsLen === 2) {
        //             that.on(event[1], function() {
        //                 func.apply(that.game, args);
        //             });
        //         }
        //     }
        //     else {
        //         for ( ; ++i < len ; ) {
        //             that.on(event[i], function() {
        //                 func.apply(that.game, args);
        //             });
        //         }
        //     }
        // };

        // TODO: remove code duplication?
        // this.once[alias] = function(func) {
        //     var i, len, args;
        //     args = [];
        //     i = -1, len = arguments.length;
        //     for ( ; ++i < len ; ) {
        //         args[i] = arguments[i];
        //     }
        //     // If set, we use the callback returned by the modifier.
        //     // Otherwise, we assume the first parameter is the callback.
        //     if (modifier) func = modifier.apply(that.game, args);
        //
        //     // Optimized.
        //     if (eventsLen < 3) {
        //         that.once(event[0], function() {
        //             func.apply(that.game, args);
        //         });
        //         if (eventsLen === 2) {
        //             that.once(event[1], function() {
        //                 func.apply(that.game, args);
        //             });
        //         }
        //     }
        //     else {
        //         for ( ; ++i < len ; ) {
        //             that.once(event[i], function() {
        //                 func.apply(that.game, args);
        //             });
        //         }
        //     }
        // };



    };

    // function attachAlias(that, method, events, modifier, alias) {
    //     var eventsLen = events.length;
    //     that[method][alias] = function(func) {
    //         var i, len, args;
    //         // Cloning arguments array.
    //         i = -1;
    //         len = arguments.length;
    //         args = new Array(len);
    //         for ( ; ++i < len ; ) {
    //             args[i] = arguments[i];
    //         }
    //         // If set, we use the callback returned by the modifier.
    //         // Otherwise, we assume the first parameter is the callback.
    //         if (modifier) func = modifier.apply(that.game, args);
    //
    //         // Optimized.
    //         if (eventsLen < 3) {
    //             that[method](events[0], function() {
    //                 func.apply(that.game, arguments);
    //             });
    //             if (eventsLen === 2) {
    //                 that[method](events[1], function() {
    //                     func.apply(that.game, arguments);
    //                 });
    //             }
    //         }
    //         else {
    //             for ( ; ++i < len ; ) {
    //                 that[method](events[i], function() {
    //                     func.apply(that.game, arguments);
    //                 });
    //             }
    //         }
    //     };
    // }


    // function attachAlias(that, method, events, modifier, alias) {
    //     var eventsLen = events.length;
    //     that[method][alias] = function(func) {
    //         var i;
    //         // Cloning arguments array.
    //         // i = -1;
    //         // len = arguments.length;
    //         // args = new Array(len);
    //         // for ( ; ++i < len ; ) {
    //         //     args[i] = arguments[i];
    //         // }
    //         // If set, we use the callback returned by the modifier.
    //         // Otherwise, we assume the first parameter is the callback.
    //         // if (modifier) func = modifier.apply(that.game, args);
    //
    //         // Optimized.
    //
    //         that[method](events[0], function() {
    //             if (modifier) {
    //                 func = modifier.apply(that.game, arguments);
    //                 if (!func) return;
    //             }
    //             func.apply(that.game, arguments);
    //         });
    //         if (eventsLen === 2) {
    //             that[method](events[1], function() {
    //                 if (modifier) {
    //                     func = modifier.apply(that.game, arguments);
    //                     if (!func) return;
    //                 }
    //                 func.apply(that.game, arguments);
    //             });
    //         }
    //         else {
    //             i = 0;
    //             for ( ; ++i < eventsLen ; ) {
    //                 that[method](events[i], function() {
    //                     if (modifier) {
    //                         func = modifier.apply(that.game, arguments);
    //                         if (!func) return;
    //                     }
    //                     func.apply(that.game, arguments);
    //                 });
    //             }
    //         }
    //     };
    // }
})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # Connect
 * Copyright(c) 2016 Stefano Balietti
 * MIT Licensed
 *
 * `nodeGame` connect module
 */
(function(exports, parent) {

    "use strict";

    var NGC = parent.NodeGameClient;

    /**
     * ### node.connect
     *
     * Establishes a connection with a nodeGame server
     *
     * Depending on the type of socket used (Direct or IO), the
     * channel parameter might be optional.
     *
     * If node is executed in the browser additional checks are performed:
     *
     * 1. If channel does not begin with `http://` or `https://,
     *    then `window.location.origin` will be added in front of
     *    channel to avoid cross-domain errors (as of Socket.io >= 1).
     *
     * 2. If no socketOptions.query parameter is specified any query
     *    parameters found in `location.search(1)` will be passed.
     *
     * @param {string} channel Optional. The channel to connect to
     * @param {object} socketOptions Optional. A configuration object for
     *   the socket connect method. If channel is omitted, then socketOptions
     *   is the first parameter.
     *
     * @emit SOCKET_CONNECT
     * @emit PLAYER_CREATED
     * @emit NODEGAME_READY
     */
    NGC.prototype.connect = function() {
        var channel, socketOptions;
        if (arguments.length >= 2) {
            channel = arguments[0];
            socketOptions = arguments[1];
        }
        else if (arguments.length === 1) {
            if ('string' === typeof arguments[0]) channel = arguments[0];
            else socketOptions = arguments[0];
        }
        // Browser adjustements.
        if ('undefined' !== typeof window) {
            // If no channel is defined use the pathname, and assume
            // that the name of the game is also the name of the endpoint.
            if ('undefined' === typeof channel) {
                if (window.location && window.location.pathname) {
                    channel = window.location.pathname;
                    // Making sure it is consistent with what we expect.
                    if (channel.charAt(0) !== '/') channel = '/' + channel;
                    if (channel.charAt(channel.length-1) === '/') {
                        channel = channel.substring(0, channel.length-1);
                    }
                }
            }
            // Make full path otherwise socket.io will complain.
            if (channel &&
                (channel.substr(0,8) !== 'https://' &&
                 channel.substr(0,7) !== 'http://')) {

                if (window.location && window.location.origin) {
                    channel = window.location.origin + channel;
                }
            }
            // Pass along any query options. (?clientType=...).
            if (!socketOptions || (socketOptions && !socketOptions.query)) {
                if (('undefined' !== typeof location) && location.search) {
                    socketOptions = socketOptions || {};
                    socketOptions.query = location.search.substr(1);
                }
            }
        }
        this.socket.connect(channel, socketOptions);
    };

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # Player
 * Copyright(c) 2017 Stefano Balietti
 * MIT Licensed
 *
 * Player related functions
 */
(function(exports, parent) {

    "use strict";

    var NGC = parent.NodeGameClient,
    Player = parent.Player,
    constants = parent.constants;

    /**
     * ### NodeGameClient.createPlayer
     *
     * Creates player object and places it in node.player
     *
     * @param {object} player A player object with a valid id property
     *
     * @return {object} The player object
     *
     * @see node.setup.player
     * @emit PLAYER_CREATED
     */
    NGC.prototype.createPlayer = function(player) {
        if (this.player &&
            this.player.stateLevel > constants.stateLevels.STARTING &&
            this.player.stateLevel !== constants.stateLevels.GAMEOVER) {
            throw new Error('node.createPlayer: cannot create player ' +
                            'while game is running.');
        }
        if (this.game.pl.exist(player.id)) {
            throw new Error('node.createPlayer: id already found in ' +
                            'playerList: ' + player.id);
        }
        // Cast to player (will perform consistency checks)
        player = new Player(player);
        player.stateLevel = this.player.stateLevel;
        player.stageLevel = this.player.stageLevel;

        this.player = player;
        // Slice because here it is SP/123, and on server it is /123.
        this.player.strippedSid = this.player.sid.slice(2);

        this.emit('PLAYER_CREATED', this.player);

        return this.player;
    };

    /**
     * ### NodeGameClient.setLanguage
     *
     * Sets the language for the client
     *
     * @param {object|string} lang Language information. If string, it must
     *   be the full name, and the the first 2 letters lower-cased are used
     *   as shortName. If object it must have the following format:
     *   ``{
     *      name: 'English',
     *      shortName: 'en',
     *      nativeName: 'English',
     *      path: 'en/' // Optional, default equal to shortName + '/'.
     *   }``
     *
     * @param {boolean} updateUriPrefix Optional. If TRUE, the window uri
     *   prefix isset to the value of lang.path. node.window must be defined,
     *   otherwise a warning is shown. Default, FALSE.
     * @param {boolean} sayIt Optional. If TRUE, a LANG message is sent to
     *   the server to notify the selection. Default: FALSE.
     *
     * @return {object} The language object
     *
     * @see node.setup.lang
     * @see GameWindow.setUriPrefix
     *
     * @emit LANGUAGE_SET
     */
    NGC.prototype.setLanguage = function(lang, updateUriPrefix, sayIt) {
        var language;
        language = 'string' === typeof lang ? makeLanguageObj(lang) : lang;

        if (!language || 'object' !== typeof language) {
            throw new TypeError('node.setLanguage: language must be object ' +
                               'or string. Found: ' + lang);
        }
        if ('string' !== typeof language.shortName) {
            throw new TypeError(
                'node.setLanguage: language.shortName must be string. Found: ' +
                    language.shortName);
        }
        this.player.lang = language;
        if (!this.player.lang.path) {
            this.player.lang.path = language.shortName + '/';
        }

        // Updates the URI prefix.
        if (updateUriPrefix) {
            if ('undefined' !== typeof this.window) {
                this.window.setUriPrefix(this.player.lang.path);
            }
            else {
                node.warn('node.setLanguage: updateUriPrefix is true, ' +
                          'but window not found. Are you in a browser?');
            }
        }

        // Send a message to notify server.
        if (sayIt) {
            node.socket.send(node.msg.create({
                target: 'LANG',
                data: this.player.lang
            }));
        }

        this.emit('LANGUAGE_SET');

        return this.player.lang;
    };

    // ## Helper functions.

    /**
     * ### makeLanguageObj
     *
     * From a language string returns a fully formatted obj
     *
     * @param {string} langStr The language string.
     *
     * @return {object} The language object
     */
    function makeLanguageObj(langStr) {
        var shortName;
        shortName = langStr.toLowerCase().substr(0,2);
        return {
            name: langStr,
            shortName: shortName,
            nativeName: langStr,
            path: shortName + '/'
        };
    }

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # Events
 * Copyright(c) 2015 Stefano Balietti
 * MIT Licensed
 *
 * `nodeGame` events handling
 */

(function(exports, parent) {

    "use strict";

    var NGC = parent.NodeGameClient;

    var GameStage = parent.GameStage;

    var STAGE_INIT = parent.constants.stateLevels.STAGE_INIT;
    var STAGE_EXIT = parent.constants.stateLevels.STAGE_EXIT;

    /**
     * ### NodeGameClient.getCurrentEventEmitter
     *
     * Returns the currently active event emitter
     *
     * The following event emitters are active:
     *
     *  - NodeGame (ng): before a game is created or started.
     *    Events registered here never deleted.
     *
     *  - Game (game): during the initialization of a game
     *    Events registered here are deleted when a new game
     *    is created.
     *
     *  - Stage (stage): during the initialization of a stage.
     *    Events registered here are deleted when entering a
     *    new stage.
     *
     *  - Step (step): during the initialization of a step.
     *    Events registered here are deleted when entering a
     *    new step.
     *
     * @return {EventEmitter} The current event emitter
     *
     * @see EventEmitter
     * @see EventEmitterManager
     */
    NGC.prototype.getCurrentEventEmitter = function() {
        var gameStage, stateL;

        // NodeGame default listeners
        if (!this.game) return this.events.ee.ng;
        gameStage = this.game.getCurrentGameStage();
        if (!gameStage) return this.events.ee.ng;

        // Game listeners.
        if ((GameStage.compare(gameStage, new GameStage()) === 0 )) {
            return this.events.ee.game;
        }

        // Stage listeners.
        stateL = this.game.getStateLevel();
        if (stateL === STAGE_INIT || stateL === STAGE_EXIT) {
            return this.events.ee.stage;
        }

        // Step listeners.
        return this.events.ee.step;
    };

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # SAY, SET, GET, DONE
 *
 * Implementation of node.[say|set|get|done].
 *
 * Copyright(c) 2020 Stefano Balietti
 * MIT Licensed
 */
(function(exports, parent) {

    "use strict";

    var NGC = parent.NodeGameClient;
    var J = parent.JSUS;

    var stageLevels = parent.constants.stageLevels;
    var GETTING_DONE = stageLevels.GETTING_DONE;

    /**
     * ### NodeGameClient.say
     *
     * Sends a DATA message to a specified recipient
     *
     * @param {string} text The label associated to the msg
     * @param {string|array} Optional. to The recipient/s of the msg.
     *   Default: 'SERVER'
     * @param {mixed} payload Optional. Addional data to send along
     *
     * @return {boolean} TRUE, if SAY message is sent
     */
    NGC.prototype.say = function(label, to, payload) {
        var msg;
        if ('string' !== typeof label || label === '') {
            throw new TypeError('node.say: label must be string. Found: ' +
                                label);
        }
        if (to && 'string' !== typeof to && (!J.isArray(to) || !to.length)) {
            throw new TypeError('node.say: to must be a non-empty array, ' +
                                'string or undefined. Found: ' + to);
        }
        msg = this.msg.create({
            target: this.constants.target.DATA,
            to: to,
            text: label,
            data: payload
        });
        return this.socket.send(msg);
    };

    /**
     * ### NodeGameClient.set
     *
     * Stores an object in the server's memory
     *
     * @param {object|string} o The value to set
     * @param {string} to Optional. The recipient. Default `SERVER`
     * @param {string} text Optional. The text property of the message.
     *   If set, it allows one to define on.data listeners on receiver.
     *   Default: undefined
     *
     * @return {boolean} TRUE, if SET message is sent
     */
    NGC.prototype.set = function(o, to, text) {
        var msg, tmp;
        if ('string' === typeof o) {
            tmp = o, o = {}, o[tmp] = true;
        }
        else if ('object' !== typeof o) {
            throw new TypeError('node.set: o must be object or string. ' +
                                'Found: ' + o);
        }
        msg = this.msg.create({
            action: this.constants.action.SET,
            target: this.constants.target.DATA,
            to: to || 'SERVER',
            reliable: 1,
            data: o
        });
        if (text) msg.text = text;
        return this.socket.send(msg);
    };

    /**
     * ### NodeGameClient.get
     *
     * Sends a GET message to a recipient and listen to the reply
     *
     * The receiver of a GET message must be implement an *internal* listener
     * of the type "get.<label>", and return the value requested. For example,
     *
     * ```javascript
     *
     * // Sender.
     * node.get('myLabel, function(reply) {});
     *
     * // Receiver.
     * node.on('get.myLabel', function(msg) { return 'OK'; });
     *
     * ```
     *
     * The label string cannot contain any "." (dot) characther for security
     * reason.
     *
     * The listener function is removed immediately after its first execution.
     * To allow multiple execution, it is possible to specify a positive timeout
     * after which the listener will be removed, or specify the timeout as -1,
     * and in this case the listener will not be removed at all.
     *
     * If a timeout is specified is possible to specify also a timeout-callback,
     * which will be executed if no was reply was received until the end of
     * the timeout.
     *
     * If the socket is not able to send the GET message for any reason, the
     * listener function is never registered.
     *
     * Important: depending on the server settings, GET messages might
     * disclose the real ID of the sender. For this reason, GET messages from
     * admins to players should be used only if necessary.
     *
     * @param {string} key The label of the GET message
     * @param {function} cb The callback function to handle the return message
     * @param {string} to Optional. The recipient of the msg. Default: SERVER
     * @param {object} options Optional. Extra options as follows:
     *
     *      - {number} timeout The number of milliseconds after which
     *            the listener will be removed.
     *      - {function} timeoutCb A callback function to call if
     *            the timeout is fired (no reply received)
     *      - {boolean} executeOnce TRUE if listener should be removed after
     *            one execution. It will also terminate the timeout, if set
     *      - {mixed} data Data field of the GET msg
     *      - {string} target Set to override the default DATA target of msg
     *
     * @return {boolean} TRUE, if GET message is sent and listener registered
     */
    NGC.prototype.get = function(key, cb, to, options) {
        var msg, g, ee;
        var that, res;
        var timer, success;
        var data, timeout, timeoutCb, executeOnce, target;

        if ('string' !== typeof key) {
            throw new TypeError('node.get: key must be string. Found: ' + key);
        }

        if (key === '') {
            throw new TypeError('node.get: key cannot be empty.');
        }

        if (key.split('.') > 1) {
            throw new TypeError(
                'node.get: key cannot contain the dot "." character: ' + key);
        }

        if ('function' !== typeof cb) {
            throw new TypeError('node.get: cb must be function. Found: ' + cb);
        }

        if ('undefined' === typeof to) {
            to = 'SERVER';
        }

        if ('string' !== typeof to) {
            throw new TypeError('node.get: to must be string or ' +
                                'undefined. Found: ' + to);
        }

        if (options) {
            if ('object' !== typeof options) {
                throw new TypeError('node.get: options must be object ' +
                                    'or undefined. Found: ' + options);
            }

            timeout = options.timeout;
            timeoutCb = options.timeoutCb;
            data = options.data;
            executeOnce = options.executeOnce;
            target = options.target;

            if ('undefined' !== typeof timeout) {
                if ('number' !== typeof timeout) {
                    throw new TypeError('node.get: options.timeout must be ' +
                                        'number. Found: ' + timeout);
                }
                if (timeout < 0 && timeout !== -1 ) {
                    throw new TypeError('node.get: options.timeout must be ' +
                                        'positive, 0, or -1. Found: ' +
                                        timeout);
                }
            }

            if (timeoutCb && 'function' !== typeof timeoutCb) {
                throw new TypeError('node.get: options.timeoutCb must be ' +
                                    'function or undefined. Found: ' +
                                    timeoutCb);
            }

            if (target &&
                ('string' !== typeof target || target.trim() === '')) {

                throw new TypeError('node.get: options.target must be ' +
                                    'a non-empty string or undefined. Found: ' +
                                    target);
            }

        }

        msg = this.msg.create({
            action: this.constants.action.GET,
            target: target || this.constants.target.DATA,
            to: to,
            reliable: 1,
            text: key,
            data: data
        });

        // TODO: check potential timing issues. Is it safe to send the GET
        // message before registering the relate listener? (for now yes)
        res = this.socket.send(msg);

        // The key is updated with the id of the message, so
        // that only those who received it can reply.
        key = key + '_' + msg.id;

        if (res) {
            that = this;
            ee = this.getCurrentEventEmitter();

            // Listener function. If a timeout is not set, the listener
            // will be removed immediately after its execution.
            g = function(msg) {
                if (msg.text === key) {
                    success = true;
                    if (executeOnce) {
                        ee.remove('in.say.DATA', g);
                        if ('undefined' !== typeof timer) {
                            that.timer.destroyTimer(timer);
                        }
                    }
                    cb.call(that.game, msg.data);
                }
            };

            ee.on('in.say.DATA', g);

            // If a timeout is set the listener is removed independently,
            // of its execution after the timeout is fired.
            // If timeout === -1, the listener is never removed.
            if (timeout > 0) {
                timer = this.timer.createTimer({
                    milliseconds: timeout,
                    timeup: function() {
                        ee.remove('in.say.DATA', g);
                        if ('undefined' !== typeof timer) {
                            that.timer.destroyTimer(timer);
                        }
                        // success === true we have received a reply.
                        if (timeoutCb && !success) timeoutCb.call(that.game);
                    }
                });
                timer.start();
            }
        }
        return res;
    };

    /**
     * ### NodeGameClient.done
     *
     * Marks the end of a game step
     *
     * It performs the following sequence of operations:
     *
     *  - Checks if `done` was already called in the same stage, and
     *      if so returns with a warning.
     *  - Checks it there a `done` hanlder in the step, and if so
     *      executes. If the return value is falsy procedure stops.
     *  - Marks the step as `willBeDone` and no further calls to
     *      `node.done` are allowed in the same step.
     *  - Creates and send a SET message to server containing the time
     *      passed from the beginning of the step, if `done` was a timeup
     *      event, passing along any other parameter given to `node.done`
     *  - Asynchronously emits 'DONE', which starts the procedure to
     *      evaluate the step rule, and eventually to enter into the next
     *      step.
     *
     * Technical note. The done event needs to be asynchronous because
     * it can be triggered by the callback of a load frame, and in
     * this case it must be emitted last.
     *
     * All input parameters are passed along to `node.emit`.
     *
     * @param {mixed} param Optional. A value or object to send to the server
     *   in a set message.
     *
     * @return {boolean} TRUE, if the method is authorized, FALSE otherwise
     *
     * @see NodeGameClient.emit
     * @emits DONE
     */
    NGC.prototype.done = function(param) {
        var that, game, doneCb;
        var stepTime;
        var args, o;

        // First, get step execution time.
        stepTime = this.timer.getTimeSince('step');

        game = this.game;
        if (game.willBeDone || game.getStageLevel() >= GETTING_DONE) {
            this.err('node.done: done already called in step: ' +
                     game.getCurrentGameStage());
            return false;
        }

        // Check if there are required widgets that are not ready.
        // Widget steps update the done callback, so no need to check them.
        if (!game.isWidgetStep()) {
            if (!game.timer.isTimeup() && this.widgets &&
                this.widgets.isActionRequired({
                    markAttempt: true,
                    highlight: true
                })) {

                this.warn('node.done: there are widgets requiring action');
                return false;
            }
        }

        // Evaluating `done` callback if any.
        doneCb = game.plot.getProperty(game.getCurrentGameStage(), 'done');

        // A done callback can manipulate arguments, add new values to
        // send to server, or even halt the procedure if returning false.
        if (doneCb) {
            args = doneCb.call(game, param);

            // If a `done` callback returns false, exit.
            if (args === false) {
                this.silly('node.done: done callback returned false');
                return false;
            }
        }

        // Keep track that the game will be done (done is asynchronous)
        // to avoid calling `node.done` multiple times in the same stage.
        game.willBeDone = true;

        // TODO: it is possible that DONE messages (in.set.DATA) are sent
        // to server before PLAYING is set. Is this OK?

        if (!args) args = param;

        if (game.plot.getProperty(game.getCurrentGameStage(), 'autoSet')) {

            // Create object.
            if ('object' === typeof args) {
                o = args;
            }
            else {
                o = {};
                if ('string' === typeof args || 'number' === typeof args) {
                    o[args] = true;
                }
            }

            // Time and timeup.
            if (!o.time) o.time = stepTime;
            if ('undefined' === typeof o.timeup) {
                o.timeup = game.timer.isTimeup();
            }

            // Add role and partner info.
            if (game.role && !o.role) o.role = game.role;
            if (game.partner && !o.partner) o.partner = game.partner;

            o.stepId = game.getStepId();
            o.stageId = game.getStageId();

            // Mark done msg.
            o.done = true;

            // Send to server.
            this.set(o, 'SERVER', 'done');
        }

        // Prevents messages in reply to DONE, to be executed before
        // the async stepping procedure starts.
        this.game.setStageLevel(stageLevels.GETTING_DONE);

        that = this;
        setTimeout(function() { that.events.emit('DONE', param); }, 0);

        return true;
    };

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # Commands
 * Copyright(c) 2018 Stefano Balietti
 * MIT Licensed
 *
 * `nodeGame` commands for admins
 *
 * Command messages sent by players will be filtered out by the server.
 *
 */
(function(exports, node) {

    "use strict";

    var NGC = node.NodeGameClient;
    var J = node.JSUS;

    /**
     * ### NodeGameClient.redirect
     *
     * Redirects a client to the specified url
     *
     * Examples:
     *
     * ```javascript
     *
     * // Redirect to http://mydomain/mygame/missing_auth
     * node.redirect('missing_auth', 'xxx');
     *
     * // Redirect to external urls
     * node.redirect('http://www.google.com');
     * ```

     * @param {string} url the url of the redirection
     * @param {string|array} who A player id or any other valid _to_ field
     */
    NGC.prototype.redirect = function(url, who) {
        var msg;
        if ('string' !== typeof url) {
            throw new TypeError('node.redirect: url must be string. Found: ' +
                                url);
        }
        if ('string' !== typeof who && !J.isArray(who)) {
            throw new TypeError('node.redirect: who must be string. Found: ' +
                                who);
        }
        msg = this.msg.create({
            target: this.constants.target.REDIRECT,
            data: url,
            to: who
        });
        this.socket.send(msg);
    };

    /**
     * ### NodeGameClient.remoteCommand
     *
     * Executes a game command on a client
     *
     * @param {string} command The command to execute
     * @param {string|array} to The id or the array of ids of client/s
     * @param {mixed} options Optional Options passed to the command.
     *   If set, options are stringified with JSUS.stringifyAll, therefore
     *   values such as null, undefined and functions are passed.
     *
     * @see JSUS.stringify
     * @see JSUS.stringifyAll
     * @see JSUS.parse
     */
    NGC.prototype.remoteCommand = function(command, to, options) {
        var msg;
        if ('string' !== typeof command) {
            throw new TypeError('node.remoteCommand: command must be string.');
        }
        if (!node.constants.gamecommands[command]) {
            throw new Error('node.remoteCommand: unknown command: ' +
                            command);
        }
        if ('string' !== typeof to && !J.isArray(to)) {
            throw new TypeError('node.remoteCommand: to must be string ' +
                                'or array. Found: ' + to);
        }

        // Stringify options, if any.
        if (options) options = J.stringify(options);

        msg = this.msg.create({
            target: this.constants.target.GAMECOMMAND,
            text: command,
            data: options,
            to: to
        });
        this.socket.send(msg);
    };

    /**
     * ### NodeGameClient.remoteAlert
     *
     * Displays an alert message in the screen of the client
     *
     * Message is effective only if the client has a _window_ object
     * with a global _alert_ method.
     *
     * @param {string} text The text of of the messagex
     * @param {string} to The id of the player to alert
     */
    NGC.prototype.remoteAlert = function(text, to) {
        var msg;
        if ('string' !== typeof text) {
            throw new TypeError('node.remoteAlert: text must be string. ' +
                               'Found: ' + text);
        }
        if ('string' !== typeof to && !J.isArray(to)) {
            throw new TypeError('node.remoteAlert: to must be string ' +
                                'or array. Found: ' + to);
        }
        msg = this.msg.create({
            target: this.constants.target.ALERT,
            text: text,
            to: to
        });
        this.socket.send(msg);
    };

    /**
     * ### NodeGameClient.disconnectClient
     *
     * Disconnects one client by sending a DISCONNECT msg to server
     *
     * @param {object} p The client object containing info about id and sid
     */
    NGC.prototype.disconnectClient = function(p) {
        var msg;
        if ('object' !== typeof p) {
            throw new TypeError('node.disconnectClient: p must be ' +
                                'object. Found: ' + p);
        }

        this.info('node.disconnectClient: ' + p.id);

        msg = this.msg.create({
            target: 'SERVERCOMMAND',
            text: 'DISCONNECT',
            data: {
                id: p.id,
                sid: p.sid
            }
        });
        this.socket.send(msg);
    };

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # Extra
 * Copyright(c) 2016 Stefano Balietti
 * MIT Licensed
 *
 * `nodeGame` extra functions
 */
(function(exports, parent) {

    "use strict";

    var NGC = parent.NodeGameClient;
    var J = parent.JSUS;

    /**
     * ### node.env
     *
     * Fetches an environment variables, and optionally executes a callback
     *
     * Notice: the value of the requested variable is returned after
     * the execution of the callback, that could modify it.
     *
     * @param {string} env The name of the environmental variable
     * @param {function} func Optional A callback to execute if the current
     *   value of env is truthy.
     * @param {object} ctx Optional. The context of execution
     * @param {array} params Optional. An array of parameters for the callback
     *
     * @return {mixed} The current value of the requested variable
     *
     * @see node.setup.env
     * @see node.clearEnv
     */
    NGC.prototype.env = function(env, func, ctx, params) {
        var envValue, args;
        if ('string' !== typeof env) {
            throw new TypeError('node.env: env must be string.');
        }
        if (func && 'function' !== typeof func) {
            throw new TypeError('node.env: func must be function ' +
                                'or undefined.');
        }
        if (ctx && 'object' !== typeof ctx) {
            throw new TypeError('node.env: ctx must be object or undefined.');
        }

        envValue = this._env[env];
        args = [ envValue ];

        if (params) {
            if (!J.isArray(params)) {
                throw new TypeError('node.env: params must be array ' +
                                    'or undefined. Found: ' + params);
            }
            params = params.concat(args);
        }

        // Executes the function conditionally to _envValue_.
        if (func && envValue) func.apply((ctx || this), args);

        // Returns the value of the requested _env_ variable in any case.
        return envValue;
    };

    /**
     * ### node.clearEnv
     *
     * Deletes all previously set enviroment variables
     *
     * @see node.env
     * @see node.setup.env
     */
    NGC.prototype.clearEnv = function() {
        this._env = {};
    };

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # GetJSON
 * Copyright(c) 2015 Stefano Balietti
 * MIT Licensed
 *
 * `nodeGame` JSON fetching
 */
(function(exports, parent) {

    "use strict";

    var NGC = parent.NodeGameClient;

    /**
     * ### NodeGameClient.getJSON
     *
     * Retrieves JSON data via JSONP from one or many URIs
     *
     * The dataCb callback will be called every time the data from one of the
     * URIs has been fetched.
     *
     * This method creates a temporary entry in the node instance,
     * `node.tempCallbacks`, to store a temporary internal callback.
     * This field is deleted again after the internal callbacks are done.
     *
     * @param {array|string} uris The URI(s)
     * @param {function} dataCb The function to call with the data
     * @param {function} doneCb Optional. The function to call after all the
     *   data has been retrieved
     */
    NGC.prototype.getJSON = function(uris, dataCb, doneCb) {
        var that;
        var loadedCount;
        var currentUri, uriIdx;
        var tempCb, cbIdx;
        var scriptTag, scriptTagName;

        // Check input:
        if ('string' === typeof uris) {
            uris = [ uris ];
        }
        else if ('object' !== typeof uris || 'number' !== typeof uris.length) {
            throw new Error('NGC.getJSON: uris must be an array or a string');
        }

        if ('function' !== typeof dataCb) {
            throw new Error('NGC.getJSON: dataCb must be a function');
        }

        if ('undefined' !== typeof doneCb && 'function' !== typeof doneCb) {
            throw new Error('NGC.getJSON: doneCb must be undefined or ' +
                            'function');
        }

        // If no URIs are given, we're done:
        if (uris.length === 0) {
            if (doneCb) doneCb();
            return;
        }

        that = this;

        // Keep count of loaded data:
        loadedCount = 0;

        // Create a temporary JSONP callback, store it with the node instance:
        if ('undefined' === typeof this.tempCallbacks) {
            this.tempCallbacks = { counter: 0 };
        }
        else {
            this.tempCallbacks.counter++;
        }
        cbIdx = this.tempCallbacks.counter;

        tempCb = function(data) {
            dataCb(data);

            // Clean up:
            delete that.tempCallbacks[cbIdx];
            if (JSUS.size(that.tempCallbacks) <= 1) {
                delete that.tempCallbacks;
            }
        };
        this.tempCallbacks[cbIdx] = tempCb;

        for (uriIdx = 0; uriIdx < uris.length; uriIdx++) {
            currentUri = uris[uriIdx];

            // Create a temporary script tag for the current URI:
            scriptTag = document.createElement('script');
            scriptTagName = 'tmp_script_' + cbIdx + '_' + uriIdx;
            scriptTag.id = scriptTagName;
            scriptTag.name = scriptTagName;
            scriptTag.src = currentUri +
                '?callback=node.tempCallbacks[' + cbIdx + ']';
            document.body.appendChild(scriptTag);

            // Register the onload handler:
            scriptTag.onload = (function(uri, thisScriptTag) {
                return function() {
                    // Remove the script tag:
                    document.body.removeChild(thisScriptTag);

                    // Increment loaded URIs counter:
                    loadedCount++;
                    if (loadedCount >= uris.length) {
                        // All requested URIs have been loaded at this point.
                        if (doneCb) doneCb();
                    }
                };
            })(currentUri, scriptTag);
        }
    };

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # incoming
 * Copyright(c) 2016 Stefano Balietti
 * MIT Licensed
 *
 * Listeners for incoming messages
 */
(function(exports, parent) {

    "use strict";

    var NGC = parent.NodeGameClient;

    var PlayerList = parent.PlayerList,
    Player = parent.Player,
    J = parent.JSUS;

    var action = parent.constants.action;

    var say = action.SAY + '.',
    set = action.SET + '.',
    get = action.GET + '.',
    IN = parent.constants.IN;

    /**
     * ## NodeGameClient.addDefaultIncomingListeners
     *
     * Adds a battery of event listeners for incoming messages
     *
     * If executed once, it requires a force flag to re-add the listeners
     *
     * @param {boolean} force Whether to force re-adding the listeners
     *
     * @return {boolean} TRUE on success
     */
    NGC.prototype.addDefaultIncomingListeners = function(force) {
        var node = this;

        if (node.conf.incomingAdded && !force) {
            node.err('node.addDefaultIncomingListeners: listeners already ' +
                     'added. Use "force" to add again');
            return false;
        }

        this.info('node: adding incoming listeners');

        /**
         * ## in.say.BYE
         *
         * Forces disconnection
         */
        node.events.ng.on( IN + say + 'BYE', function(msg) {
            var force;
            if (msg.data) {
                // Options for reconnections, for example.
                // Sending data, do something before disconnect.
            }
            force = true;
            node.socket.disconnect(force);
        });

        /**
         * ## in.say.SESSION
         *
         * Incoming session data from another client
         */
        node.events.ng.on( IN + say + 'SESSION', function(msg) {
            if (msg.data) {
                node.game.session(msg.data.name, msg.data.value, {
                    from: msg.from,
                    to: false
                });
            }
        });

        /**
         * ## in.say.PCONNECT
         *
         * Adds a new player to the player list
         *
         * @emit UPDATED_PLIST
         * @see Game.pl
         */
        node.events.ng.on( IN + say + 'PCONNECT', function(msg) {
            var p;
            if ('object' !== typeof msg.data) {
                node.err('received PCONNECT, but invalid data: ' + msg.data);
                return;
            }
            p = (msg.data instanceof Player) ? node.game.pl.add(msg.data) :
                node.game.pl.add(new Player(msg.data));

            node.emit('UPDATED_PLIST', 'pconnect', p);
            if (node.game.shouldStep()) node.game.step();
        });

        /**
         * ## in.say.PDISCONNECT
         *
         * Removes a player from the player list
         *
         * @emit UPDATED_PLIST
         * @see Game.pl
         */
        node.events.ng.on( IN + say + 'PDISCONNECT', function(msg) {
            var p;
            if ('object' !== typeof msg.data) {
                node.err('received PDISCONNECT, but invalid data: ' + msg.data);
                return;
            }
            p = node.game.pl.remove(msg.data.id);
            node.emit('UPDATED_PLIST', 'pdisconnect', p);
            if (node.game.shouldStep()) node.game.step();
        });

        /**
         * ## in.say.MCONNECT
         *
         * Adds a new monitor to the monitor list
         *
         * @emit UPDATED_MLIST
         * @see Game.ml
         */
        node.events.ng.on( IN + say + 'MCONNECT', function(msg) {
            if ('object' !== typeof msg.data) {
                node.err('received MCONNECT, but invalid data: ' + msg.data);
                return;
            }
            node.game.ml.add(new Player(msg.data));
            node.emit('UPDATED_MLIST');
        });

        /**
         * ## in.say.MDISCONNECT
         *
         * Removes a monitor from the player list
         *
         * @emit UPDATED_MLIST
         * @see Game.ml
         */
        node.events.ng.on( IN + say + 'MDISCONNECT', function(msg) {
            if ('object' !== typeof msg.data) {
                node.err('received MDISCONNECT, but invalid data: ' + msg.data);
                return;
            }
            node.game.ml.remove(msg.data.id);
            node.emit('UPDATED_MLIST');
        });

        /**
         * ## in.say.PLIST
         *
         * Creates a new player-list object
         *
         * @emit UPDATED_PLIST
         * @see Game.pl
         */
        node.events.ng.on( IN + say + 'PLIST', function(msg) {
            if (!msg.data) return;
            node.game.pl = new PlayerList({}, msg.data);
            node.emit('UPDATED_PLIST', 'replace', node.game.pl);
        });

        /**
         * ## in.say.MLIST
         *
         * Creates a new monitor-list object
         *
         * @emit UPDATED_MLIST
         * @see Game.pl
         */
        node.events.ng.on( IN + say + 'MLIST', function(msg) {
            if (!msg.data) return;
            node.game.ml = new PlayerList({}, msg.data);
            node.emit('UPDATED_MLIST');
        });

        /**
         * ## in.get.DATA
         *
         * Re-emits the incoming message, and replies back to the sender
         *
         * Does the following operations:
         *
         * - Validates the msg.text field
         * - Emits a get.<msg.text> event
         * - Replies to sender with the return values of emit, only if
         *     the return value is not "empty"
         *
         * @see JSUS.isEmpty
         */
        node.events.ng.on( IN + get + 'DATA', function(msg) {
            var res;

            if ('string' !== typeof msg.text || msg.text.trim() === '') {
                node.err('"in.get.DATA": msg.data must be a non-empty string.');
                return;
            }
            res = node.emit(get + msg.text, msg);
            if (!J.isEmpty(res)) {
                node.say(msg.text + '_' + msg.id, msg.from, res);
            }
        });

        /**
         * ## in.set.DATA
         *
         * Adds an entry to the memory object
         *
         * Decorates incoming msg.data object with the following properties:
         *
         *   - player: msg.from
         *   - stage: msg.stage
         */
        node.events.ng.on( IN + set + 'DATA', function(msg) {
            var o = msg.data;
            o.player = msg.from, o.stage = msg.stage;
            node.game.memory.add(o);
        });

        /**
         * ## in.say.PLAYER_UPDATE
         *
         * Updates the player's state in the player-list object
         *
         * @emit UPDATED_PLIST
         * @see Game.pl
         */
        node.events.ng.on( IN + say + 'PLAYER_UPDATE', function(msg) {
            var p;
            p = node.game.pl.updatePlayer(msg.from, msg.data);
            node.emit('UPDATED_PLIST', 'pupdate', p);
            if (node.game.shouldStep()) node.game.step();
            else if (node.game.shouldEmitPlaying()) node.emit('PLAYING');
        });

        /**
         * ## in.say.REDIRECT
         *
         * Redirects to a new page
         *
         * @see node.redirect
         */
        node.events.ng.on( IN + say + 'REDIRECT', function(msg) {
            if ('string' !== typeof msg.data) {
                node.err('"in.say.REDIRECT": msg.data must be string: ' +
                         msg.data);
                return false;
            }
            if ('undefined' === typeof window || !window.location) {
                node.err('"in.say.REDIRECT": window.location not found.');
                return false;
            }

            window.location = msg.data;
        });

        /**
         * ## in.say.SETUP
         *
         * Setups a features of nodegame
         *
         * It unstrigifies the payload before calling `node.setup`.
         *
         * @see node.setup
         * @see JSUS.parse
         */
        node.events.ng.on( IN + say + 'SETUP', function(msg) {
            var payload, feature;
            feature = msg.text;
            if ('string' !== typeof feature) {
                node.err('"in.say.SETUP": msg.text must be string: ' +
                         feature);
                return;
            }
            if (!node._setup[feature]) {
                node.err('"in.say.SETUP": no such setup function: ' +
                         feature);
                return;
            }

            payload = 'string' === typeof msg.data ?
                J.parse(msg.data) : msg.data;

            if (!payload) {
                node.err('"in.say.SETUP": error while parsing ' +
                         'payload of incoming remote setup message.');
                return;
            }

            node.setup.apply(node, [feature].concat(payload));
        });

        /**
         * ## in.say.GAMECOMMAND
         *
         * Executes a game command (pause, resume, etc.)
         */
        node.events.ng.on( IN + say + 'GAMECOMMAND', function(msg) {
            emitGameCommandMsg(node, msg);
        });

        /**
         * ## in.get.GAMECOMMAND
         *
         * Executes a game command (pause, resume, etc.) and gives confirmation
         */
        node.events.ng.on( IN + get + 'GAMECOMMAND', function(msg) {
            var res;
            res = emitGameCommandMsg(node, msg);
            if (!J.isEmpty(res)) {
                // New key must contain msg.id.
                node.say(msg.text + '_' + msg.id, msg.from, res);
            }
        });

        /**
         * ## in.say.ALERT
         *
         * Displays an alert message (if in the browser window)
         *
         * If in Node.js, the message will be printed to standard output.
         *
         * @see node.setup
         */
        node.events.ng.on( IN + say + 'ALERT', function(msg) {
            if ('string' !== typeof msg.text || msg.text.trim() === '') {
                node.err('"in.say.ALERT": msg.text must be a non-empty string');
                return;
            }
            if ('undefined' !== typeof window) {
                if ('undefined' === typeof alert) {
                    node.err('"in.say.ALERT": alert is not defined: ' +
                             msg.text);
                    return;
                }
                alert(msg.text);
            }
            else {
                console.log('****** ALERT ******');
                console.log(msg.text);
                console.log('*******************');
            }
        });

// TODO: not used for now.
//         /**
//          * ## in.get.SESSION
//          *
//          * Gets the value of a variable registered in the session
//          *
//          * If msg.text is undefined returns all session variables
//          *
//          * @see GameSession.get
//          */
//         node.events.ng.on( IN + get + 'SESSION', function(msg) {
//             return node.session.get(msg.text);
//         });

        /**
         * ## in.get.PLOT
         *
         * Gets the current plot sequence or the full plot state.
         *
         * @see GamePlot
         * @see Stager
         */
        node.events.ng.on( IN + get + 'PLOT', function(msg) {
            if (!node.game.plot.stager) return null;
            if (msg.text === 'state') {
                return node.game.plot.stager.getState();
            }
            return node.game.plot.stager.getSequence();
        });

        /**
         * ## in.get.PLIST
         *
         * Gets the current _PlayerList_ object
         *
         * @see PlayerList
         * @see node.game.pl
         */
        node.events.ng.on( IN + get + 'PLIST', function() {
            return node.game.pl.db;
        });

        /**
         * ## in.get.PLAYER
         *
         * Gets the current _Player_ object
         *
         * @see Player
         */
        node.events.ng.on( get + 'PLAYER', function() {
            return node.player;
        });

        /**
         * ## in.get.LANG | get.LANG
         *
         * Gets the currently used language
         *
         * @see node.player.lang
         */
        node.events.ng.on( IN + get + 'LANG', function() {
            return node.player.lang;
        });

        node.events.ng.on( get + 'LANG', function() {
            return node.player.lang;
        });

        /**
         * ## in.set.LANG
         *
         * Sets the currently used language
         *
         * @see NodeGameClient.setLanguage
         * @see node.player.lang
         */
        node.events.ng.on( IN + set + 'LANG', function(msg) {
            node.setLanguage(msg.data);
        });

        /**
         * ## get.PING
         *
         * Returns a dummy reply to PING requests
         */
        node.events.ng.on( get + 'PING', function() {
            return 'pong';
        });

        node.conf.incomingAdded = true;
        node.silly('node: incoming listeners added.');
        return true;
    };

    // ## Helper functions.

    /**
     * ### emitGameCommandMsg
     *
     * Checks that the incoming message is valid, parses its data, and emits it
     *
     * @param {GameMsg} msg The incoming message
     *
     * @return {mixed} The return value of the emit call
     *
     * @see JSUS.parse
     * @see node.emit
     */
    function emitGameCommandMsg(node, msg) {
        var opts;
        if ('string' !== typeof msg.text) {
            node.err('"in.' + msg.action + '.GAMECOMMAND": msg.text must be ' +
                     'string. Found: ' + msg.text);
            return false;
        }
        if (!parent.constants.gamecommands[msg.text]) {
            node.err('"in.' + msg.action + '.GAMECOMMAND": unknown game  ' +
                     'command received: ' + msg.text);
            return false;
        }

        opts = 'string' === typeof msg.data ? J.parse(msg.data) : msg.data;
        return node.emit('NODEGAME_GAMECOMMAND_' + msg.text, opts);
    }

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # internal
 * Copyright(c) 2016 Stefano Balietti
 * MIT Licensed
 *
 * Listeners for internal messages.
 *
 * Internal listeners are not directly associated to messages,
 * but they are usually responding to internal nodeGame events,
 * such as progressing in the loading chain, or finishing a game stage.
 *
 * http://nodegame.org
 */
(function(exports, parent) {

    "use strict";

    var NGC = parent.NodeGameClient;

    var GameStage = parent.GameStage,
    constants = parent.constants;

    var stageLevels = constants.stageLevels,
    gcommands = constants.gamecommands;

    var CMD = 'NODEGAME_GAMECOMMAND_';

    /**
     * ## NodeGameClient.addDefaultInternalListeners
     *
     * Adds a battery of event listeners for internal events
     *
     * If executed once, it requires a force flag to re-add the listeners.
     *
     * @param {boolean} force Whether to force re-adding the listeners
     * @return {boolean} TRUE on success
     */
    NGC.prototype.addDefaultInternalListeners = function(force) {
        var node = this;
        if (this.conf.internalAdded && !force) {
            this.err('Default internal listeners already added once. ' +
                     'Use the force flag to re-add.');
            return false;
        }

        this.info('node: adding internal listeners.');

        function done() {
            var res;
            node.game.willBeDone = false;
            node.game.beDone = false;
            node.emit('REALLY_DONE');
            res = node.game.shouldStep(stageLevels.DONE);
            node.game.setStageLevel(stageLevels.DONE);
            // Step forward, if allowed.
            if (res) setTimeout(function() { node.game.step(); }, 0);
        }

        /**
         * ## DONE
         *
         * Registers the stageLevel _DONE_ and eventually steps forward.
         *
         * If a DONE handler is defined in the game-plot, it executes it.
         * In case the handler returns FALSE, the process is stopped.
         *
         * @emit REALLY_DONE
         */
        this.events.ng.on('DONE', function() {
            // Execute done handler before updating stage.

            // If willBeDone is not set, then PLAYING called DONE earlier.
            // Can happen if node.done() is called before PLAYING.
            if (!node.game.willBeDone) return;

            // TODO check >=.
            if (node.game.getStageLevel() >= stageLevels.PLAYING) done();
            else node.game.willBeDone = true;
        });

        /**
         * ## STEP_CALLBACK_EXECUTED
         *
         * @emit LOADED
         */
        this.events.ng.on('STEP_CALLBACK_EXECUTED', function() {
            if (!node.window || node.window.isReady()) {
                node.emit('LOADED');
            }
        });

        /**
         * ## LOADED
         *
         * @emit PLAYING
         */
        this.events.ng.on('LOADED', function() {
            var frame;
            node.game.setStageLevel(constants.stageLevels.LOADED);
            if (node.socket.shouldClearBuffer()) {
                node.socket.clearBuffer();
            }

            // Make the frame visibile (if any).
            // The Window hides it with every new load, so that if the page
            // is manipulated in the step callback, the user still sees it
            // appearing all at once.
            if (node.window) {
                frame = node.window.getFrame();
                if (frame) frame.style.visibility = '';
            }

            if (node.game.shouldEmitPlaying()) {
                node.emit('PLAYING');
            }
        });

        /**
         * ## PLAYING
         *
         * @emit BEFORE_PLAYING
         */
        this.events.ng.on('PLAYING', function() {
            var currentTime;
            node.emit('BEFORE_PLAYING');
            node.game.setStageLevel(stageLevels.PLAYING);
            node.socket.clearBuffer();
            // Last thing to do, is to store time:
            currentTime = (new Date()).getTime();
            node.timer.setTimestamp(node.game.getCurrentGameStage().toString(),
                                    currentTime);
            node.timer.setTimestamp('step', currentTime);

            // DONE was previously emitted, we just execute done handler.
            if (node.game.willBeDone) done();
        });

        /**
         * ## NODEGAME_GAMECOMMAND: start
         */
        this.events.ng.on(CMD + gcommands.start, function(options) {
            if (!node.game.isStartable()) {
                node.warn('"' + CMD + gcommands.start + '": game cannot ' +
                         'be started now.');
                return;
            }
            node.emit('BEFORE_GAMECOMMAND', gcommands.start, options);
            node.game.start(options);
        });

        /**
         * ## NODEGAME_GAMECMD: pause
         */
        this.events.ng.on(CMD + gcommands.pause, function(options) {
            if (!node.game.isPausable()) {
                node.warn('"' + CMD + gcommands.pause + '": game cannot ' +
                         'be paused now.');
                return;
            }
            node.emit('BEFORE_GAMECOMMAND', gcommands.pause, options);
            node.game.pause(options);
        });

        /**
         * ## NODEGAME_GAMECOMMAND: resume
         */
        this.events.ng.on(CMD + gcommands.resume, function(options) {
            if (!node.game.isResumable()) {
                node.warn('"' + CMD + gcommands.resume + '": game cannot ' +
                          'be resumed now.');
                return;
            }
            node.emit('BEFORE_GAMECOMMAND', gcommands.resume, options);
            node.game.resume(options);
        });

        /**
         * ## NODEGAME_GAMECOMMAND: step
         */
        this.events.ng.on(CMD + gcommands.step, function(options) {
            if (!node.game.isSteppable()) {
                node.warn('"' + CMD + gcommands.step + '": game cannot ' +
                          'be stepped now.');
                return;
            }
            node.emit('BEFORE_GAMECOMMAND', gcommands.step, options);
            if (options.breakStage) node.game.breakStage(true);
            node.game.step();
        });

        /**
         * ## NODEGAME_GAMECOMMAND: stop
         */
        this.events.ng.on(CMD + gcommands.stop, function(options) {
            if (!node.game.isStoppable()) {
                node.warn('"' + CMD + gcommands.stop + '": game cannot ' +
                          'be stopped now.');
                return;
            }
            node.emit('BEFORE_GAMECOMMAND', gcommands.stop, options);
            node.game.stop();
        });

        /**
         * ## NODEGAME_GAMECOMMAND: goto_step
         */
        this.events.ng.on(CMD + gcommands.goto_step, function(options) {
            var step;
            if (!node.game.isSteppable()) {
                node.warn('"' + CMD + gcommands.goto_step + '": game cannot ' +
                          'be stepped now');
                return;
            }

            // Adjust parameters.
            if (options.targetStep) {
                step = options.targetStep;
                delete options.targetStep;
            }
            else {
                step = options;
                options = undefined;
            }
            node.emit('BEFORE_GAMECOMMAND', gcommands.goto_step, step, options);
            if (step !== parent.GamePlot.GAMEOVER) {
                step = new GameStage(step);
                if (!node.game.plot.getStep(step)) {
                    node.err('"' + CMD + gcommands.goto_step + '": ' +
                             'step not found: ' + step);
                    return;
                }
            }
            node.game.gotoStep(step, options);
        });

        /**
         * ## NODEGAME_GAMECOMMAND: clear_buffer
         */
        this.events.ng.on(CMD + gcommands.clear_buffer, function() {
            node.emit('BEFORE_GAMECOMMAND', gcommands.clear_buffer);
            node.socket.clearBuffer();
        });

        /**
         * ## NODEGAME_GAMECOMMAND: erase_buffer
         */
        this.events.ng.on(CMD + gcommands.erase_buffer, function() {
            node.emit('BEFORE_GAMECOMMAND', gcommands.clear_buffer);
            node.socket.eraseBuffer();
        });

        /**
         * ## NODEGAME_GAMECOMMAND: push_step
         *
         * If listener is moved to another file, update doc page
         */
        node.events.ng.on(CMD + gcommands.push_step, function() {
            var res, stageLevel;
            node.warn('push_step command. ', node.player.stage);

            // Call timeup, if defined.
            if (!node.game.timer.isTimeup()) node.game.timer.doTimeup();

            // Force node.done.
            if (!node.game.willBeDone) {
                stageLevel = node.game.getStageLevel();

                if (stageLevel !== stageLevels.DONE_CALLED &&
                    stageLevel !== stageLevels.GETTING_DONE &&
                    stageLevel !== stageLevels.DONE) {

                    res = node.done();
                    if (!res) node.emit('DONE');
                }
            }

            return 'ok!';
        });

        this.conf.internalAdded = true;
        this.silly('node: internal listeners added.');
        return true;
    };
})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # setups
 * Copyright(c) 2017 Stefano Balietti
 * MIT Licensed
 *
 * Listeners for incoming messages
 *
 */
(function(exports, parent) {

    "use strict";

    var NGC = parent.NodeGameClient;

    var J = parent.JSUS;

    var constants = parent.constants;

    /**
     * ## NodeGameClient.addDefaultSetupFunctions
     *
     * Adds a battery of setup functions
     *
     * Setup functions also add a listener on `in.say.SETUP` for remote setup
     *
     * @param {boolean} force Whether to force re-adding the listeners
     * @return {boolean} TRUE on success
     */
    NGC.prototype.addDefaultSetupFunctions = function(force) {

        if (this.conf.setupsAdded && !force) {
            this.err('node.addDefaultSetups: setup functions already ' +
                     'added. Use the force flag to re-add.');
            return false;
        }

        this.info('node: registering setup functions.');

        /**
         * ### setup("nodegame")
         *
         * Runs all the registered configuration functions
         *
         * Matches the keys of the configuration objects with the name
         * of the registered functions and executes them.
         * If no match is found, the configuration function will set
         * the default values.
         *
         * @param {object} options The configuration object
         */
        this.registerSetup('nodegame', function(options) {
            var i, setupOptions;

            if (options && 'object' !== typeof options) {
                throw new TypeError('node.setup("nodegame"): options must ' +
                                    'object or undefined.');
            }
            options = options || {};
            for (i in this._setup) {
                if (this._setup.hasOwnProperty(i) &&
                    'function' === typeof this._setup[i]) {

                    // Old Operas loop over the prototype property as well.
                    if (i !== 'nodegame' && i !== 'prototype') {

                        // Like this browsers do not complain in strict mode.
                        setupOptions = 'undefined' === typeof options[i] ?
                            undefined : options[i];

                        this.conf[i] = this._setup[i].call(this, setupOptions);
                    }
                }
            }
        });

        /**
         * ### setup("socket")
         *
         * Configures the socket connection to the nodegame-server
         *
         * @see node.Socket
         * @see node.SocketFactory
         */
        this.registerSetup('socket', function(conf) {
            if ('undefined' === typeof conf) return;
            this.socket.setup(conf);
            return conf;
        });

        /**
         * ### setup("host")
         *
         * Sets the uri of the host
         *
         * If no value is passed, it will try to set the host from
         * the window object in the browser enviroment.
         *
         * TODO: what happens if there is a basedir?
         */
        this.registerSetup('host', function(host) {
            var tokens;
            // URL
            if (!host) {
                if ('undefined' !== typeof window) {
                    if ('undefined' !== typeof window.location) {
                        host = window.location.href;
                    }
                }
            }
            if (host) {
                if ('string' !== typeof host) {
                    throw new TypeError('node.setup("host"): if set, host ' +
                                        'must be string. Found: ' + host);
                }
                tokens = host.split('/').slice(0,-2);
                // url was not of the form '/channel'
                if (tokens.length > 1) {
                    host = tokens.join('/');
                }

                // Add a trailing slash if missing
                if (host.lastIndexOf('/') !== host.length) {
                    host = host + '/';
                }
            }
            return host;
        });

        /**
         * ### setup("verbosity")
         *
         * Sets the verbosity level for nodegame
         */
        this.registerSetup('verbosity', function(level) {
            if ('undefined' === typeof level) return this.verbosity;
            if ('string' === typeof level) {
                if (!constants.verbosity_levels.hasOwnProperty(level)) {
                    throw new Error('setup("verbosity"): level not found: ' +
                                    level);
                }
                this.verbosity = constants.verbosity_levels[level];
            }
            else if ('number' === typeof level) {
                this.verbosity = level;
            }
            else {
                throw new TypeError('node.setup("verbosity"): level must be ' +
                                    'number or string. Found: ' + level);
            }
            return level;
        });

        /**
         * ### setup("nodename")
         *
         * Sets the name for nodegame
         */
        this.registerSetup('nodename', function(newName) {
            newName = newName || constants.nodename;
            if ('string' !== typeof newName) {
                throw new TypeError('setup("nodename"): newName must be ' +
                                    'string. Found: ' + newName);
            }
            this.nodename = newName;
            return newName;
        });

        /**
         * ### setup("debug")
         *
         * Sets the debug flag for nodegame
         */
        this.registerSetup('debug', function(enable) {
            enable = !!enable || false;
            this.debug = enable;
            return enable;
        });

        /**
         * ### setup("env")
         *
         * Setups environmental variables to be accessible in `node.env`
         */
        this.registerSetup('env', function(conf) {
            var i;
            if ('undefined' === typeof conf) return;
            if ('object' !== typeof conf) {
                throw new TypeError('node.setup("env"): conf must be object ' +
                                    'or undefined. Found: ' + conf);
            }
            for (i in conf) {
                if (conf.hasOwnProperty(i)) {
                    this._env[i] = conf[i];
                }
            }
            return conf;
        });

        /**
         * ### setup("events")
         *
         * Configure the EventEmitter object
         *
         * @see node.EventEmitter
         */
        this.registerSetup('events', function(conf) {
            if (conf) {
                if ('object' !== typeof conf) {
                    throw new TypeError('node.setup("events"): conf must be ' +
                                        'object or undefined. Found: ' + conf);
                }
            }
            else {
                conf = {};
            }
            if ('undefined' === typeof conf.history) {
                conf.history = this.conf.history || false;
            }
            if ('undefined' === typeof conf.dumpEvents) {
                conf.dumpEvents = this.conf.dumpEvents || false;
            }
            return conf;
        });

        /**
         * ### setup("settings")
         *
         * Sets up `node.game.settings`
         */
        this.registerSetup('settings', function(settings) {
            if ('undefined' !== typeof settings) {
                if ('object' !== typeof settings) {
                    throw new TypeError('node.setup("settings"): settings ' +
                                        'must be object or undefined. Found: ' +
                                        settings);
                }
                J.mixin(this.game.settings, settings);
            }
            return this.game.settings;
        });

        /**
         * ### setup("metadata")
         *
         * Sets up `node.game.metadata`
         */
        this.registerSetup('metadata', function(metadata) {
            if ('undefined' !== typeof metadata) {
                if ('object' !== typeof metadata) {
                    throw new TypeError('node.setup("metadata"): metadata ' +
                                        'must be object or undefined. Found: ' +
                                        metadata);
                }
                J.mixin(this.game.metadata, metadata);
            }
            return this.game.metadata;
        });

        /**
         * ### setup("player")
         *
         * Creates the `node.player` object
         *
         * @see node.Player
         * @see node.player
         * @see node.createPlayer
         */
        this.registerSetup('player', function(player) {
            if ('undefined' !== typeof player) {
                if ('object' !== typeof player) {
                    throw new TypeError('setup("player"): player must ' +
                                        'be object or undefined. Found: ' +
                                        player);
                }
                this.createPlayer(player);
            }
            return this.player;
        });

        /**
         * ### setup("lang")
         *
         * Setups the language of the client
         *
         * The `lang` parameter can either be an array containing
         * input parameters for the method `setLanguage`, or an object,
         * and in that case, it is only the first parameter (the language
         * object).
         *
         * @see node.player
         * @see node.setLanguage
         */
        this.registerSetup('lang', function(lang) {
            if ('undefined' !== typeof lang) {
                if (J.isArray(lang)) {
                    this.setLanguage(lang[0], lang[1]);
                }
                else if ('string' === typeof lang || 'object' === typeof lang) {
                    this.setLanguage(lang);
                }
                else {
                    throw new TypeError('setup("lang"): lang must be string, ' +
                                        'array, object or undefined. Found: ' +
                                        lang);
                }
            }
            return this.player.lang;
        });

        (function(node) {

            /**
             * ### setup("timer")
             *
             * Setup a timer object
             *
             * Accepts one configuration parameter of the type:
             *
             *  - name: name of the timer. Default: node.game.timer.name
             *  - options: configuration options to pass to the init method
             *  - action: an action to call on the timer (start, stop, etc.)
             *
             * @see node.timer
             * @see node.GameTimer
             */
            node.registerSetup('timer', function(opts) {
                var i, len, res;
                if (!opts) return;
                if ('object' !== typeof opts) {
                    throw new TypeError('setup("timer"): opts must object or ' +
                                        'undefined. Found: ' + opts);
                }
                if (J.isArray(opts)) {
                    res = true;
                    i = -1, len = opts.length;
                    for ( ; ++i < len ; ) {
                        res = res && setupTimer(opts[i]);
                    }
                }
                else {
                    res = setupTimer(opts);
                }

                // Last configured timer options, or null if an error occurred.
                return res ? opts : null;
            });

            // Helper function to setup a single timer.
            function setupTimer(opts) {
                var name, timer;
                name = opts.name || node.game.timer.name;
                timer = node.timer.getTimer(name);

                if (!timer) {
                    node.warn('setup("timer"): timer not found: ' + name);
                    return false;
                }

                if (opts.options) timer.init(opts.options);

                switch (opts.action) {
                case 'start':
                    timer.start();
                    break;
                case 'stop':
                    timer.stop();
                    break;
                case 'restart':
                    timer.restart();
                    break;
                case 'pause':
                    timer.pause();
                    break;
                case 'resume':
                    timer.resume();
                }

                return true;
            }

        })(this);

        /**
         * ### setup("plot")
         *
         * Updates the `node.game.plot` object
         *
         * It can either replace entirely the current plot object,
         * append to it, or update single properties.
         *
         * @param {object} stagerState The update for the stager. Depending
         *   on the rule, it will be passed to `Stager.setState`, or to
         *   `GamePlot.setStepProperty`, `GamePlot.setStageProperty`.
         * @param {string} rule Optional. The update rule. Valid rules:
         *
         *    - 'replace', **default**
         *    - 'append',
         *    - 'updateStep',
         *    - 'updateStage'.
         *
         * @param {string} rule Optional. Accepted: <replace>, <append>,
         *   Default: 'replace'
         *
         * @see node.game.plot
         * @see Stager.setState
         *
         * TODO: check if all options work as described.
         */
        this.registerSetup('plot', function(stagerState, rule, gameStage) {
            var plot, prop;
            stagerState = stagerState || {};
            plot = this.game.plot;
            rule = rule || 'replace';
            switch(rule) {
            case 'replace':
            case 'append':
                plot.stager.setState(stagerState, rule);
                break;
            case 'tmpCache':
                for (prop in stagerState) {
                    if (stagerState.hasOwnProperty(prop)) {
                        plot.tmpCache(prop, stagerState[prop]);
                    }
                }
                break;
            case 'updateStep':
                gameStage = gameStage || this.game.getCurrentGameStage();
                for (prop in stagerState) {
                    if (stagerState.hasOwnProperty(prop)) {
                        plot.setStepProperty(gameStage, prop,
                                             stagerState[prop]);
                    }
                }
                break;
            case 'updateStage':
                gameStage = gameStage || this.game.getCurrentGameStage();
                for (prop in stagerState) {
                    if (stagerState.hasOwnProperty(prop)) {
                        plot.setStageProperty(gameStage, prop,
                                              stagerState[prop]);
                    }
                }
                break;
            default:
                throw new Error('setup("plot"): invalid rule: ' + rule);
            }
            return this.game.plot.stager;
        });

        (function(node) {

            /**
             * ### setup("plist")
             *
             * Updates the player list in Game
             *
             * @param {PlayerList} list The new player list
             * @param {string} updateRule Optional. Accepted: <replace>,
             *   <append>. Default: 'replace'
             */
            node.registerSetup('plist', function(list, updateRule) {
                return updatePlayerList.call(this, 'pl', list, updateRule);
            });

            /**
             * ### setup("mlist")
             *
             * Updates the monitor list in Game
             *
             * @param {PlayerList} list The new monitor list
             * @param {string} updateRule Optional. Accepted: <replace>,
             *   <append>. Default: 'replace'
             */
            node.registerSetup('mlist', function(list, updateRule) {
                return updatePlayerList.call(this, 'ml', list, updateRule);
            });

            // Utility for setup.plist and setup.mlist:
            function updatePlayerList(dstListName, srcList, updateRule) {
                var dstList;
                // Initial setup call. Nothing to do.
                if (!srcList && !updateRule) return;

                dstList = dstListName === 'pl' ? this.game.pl : this.game.ml;
                updateRule = updateRule || 'replace';

                if (updateRule === 'replace') {
                    dstList.clear(true);
                }
                else if (updateRule !== 'append') {
                    throw new Error('setup("' + dstListName + '") is invalid ' +
                                    'updateRule: ' + updateRule + '.');
                }

                // Import clients (if any).
                // Automatic cast from Object to Player.
                if (srcList) dstList.importDB(srcList);

                return { updateRule: updateRule, list: srcList };
            }
        })(this);

        this.conf.setupsAdded = true;
        this.silly('node: setup functions added.');
        return true;
    };

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # aliases
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Event listener aliases.
 *
 */
(function(exports, parent) {

    "use strict";

    var NGC = parent.NodeGameClient;

    /**
     * ## NodeGameClient.addDefaultAliases
     *
     * Adds a battery of setup functions
     *
     * @param {boolean} force Whether to force re-adding the aliases
     *
     * @return {boolean} TRUE on success
     */
    NGC.prototype.addDefaultAliases = function(force) {
        var that;
        if (this.conf.aliasesAdded && !force) {
            this.err('node.addDefaultAliases: aliases already ' +
                     'added. Use the force flag to re-add.');
            return false;
        }
        that = this;

        this.info('node: adding default aliases.');

        // ### node.on.txt
        this.alias('txt', 'in.say.TXT');

        // ### node.on.data
        this.alias('data', ['in.say.DATA', 'in.set.DATA'], function(text, cb) {
            if ('string' !== typeof text || text === '') {
                throw new TypeError('node.on.data: text must be a non-empty ' +
                                    'string. Found: ' + text);
            }
            return function(msg) {
                if (msg.text === text) cb.call(that.game, msg);
                else return false;
            };
        });

        // ### node.on.data
        this.alias('done', 'in.set.DATA', function(step, cb) {
            if ('undefined' === typeof cb && 'function' === typeof step) {
                cb = step;
                step = null;
            }
            return function(msg) {
                if (!msg.data || !msg.data.done ||
                    (step && !that.game.isStep(step, msg.stage))) {

                    return false;
                }
                cb.call(that.game, msg);
            };
        });

        // ### node.on.stage
        this.alias('stage', 'STEPPING', function(cb) {
            return function(curStep, newStep) {
                if (curStep.stage !== newStep.stage) cb(curStep, newStep);
                else return false;
            };
        });

        // ### node.on.stage
        this.alias('step', 'STEPPING');

        // ### node.on.plist
        this.alias('plist', ['in.set.PLIST', 'in.say.PLIST']);

        // ### node.on.pconnect
        this.alias('pconnect', 'in.say.PCONNECT', function(cb) {
            return function(msg) {
                cb.call(that.game, msg.data);
            };
        });

        // ### node.on.pdisconnect
        this.alias('pdisconnect', 'in.say.PDISCONNECT', function(cb) {
            return function(msg) {
                cb.call(that.game, msg.data);
            };
        });

        // ### node.on.preconnect
        this.alias('preconnect', 'in.say.PRECONNECT', function(cb) {
            return function(msg) {
                cb.call(that.game, msg.data);
            };
        });

        // ### node.on.mconnect
        this.alias('mconnect', 'in.say.MCONNECT', function(cb) {
            return function(msg) {
                cb.call(that.game, msg.data);
            };
        });

        // ### node.on.mreconnect
        this.alias('mreconnect', 'in.say.MRECONNECT', function(cb) {
            return function(msg) {
                cb.call(that.game, msg.data);
            };
        });

        // ### node.on.mdisconnect
        this.alias('mdisconnect', 'in.say.MDISCONNECT', function(cb) {
            return function(msg) {
                cb.call(that.game, msg.data);
            };
        });

        // ### node.on.lang
        // Gets language information.
        this.alias('lang','in.say.LANG');

        this.silly('node: aliases added.');
        return true;
    };

})(
    'undefined' != typeof node ? node : module.exports,
    'undefined' != typeof node ? node : module.parent.exports
);

/**
 * # TriggerManager
 * Copyright(c) 2015 Stefano Balietti
 * MIT Licensed
 *
 * Manages a collection of trigger functions to be called sequentially
 *
 * ## Note for developers
 *
 * Triggers are functions that operate on a common object, and each
 * sequentially adds further modifications to it.
 *
 * If the TriggerManager were a beauty saloon, the first trigger function
 * would wash the hair, the second would cut the washed hair, and the third
 * would style it. All these operations needs to be done sequentially, and
 * the TriggerManager takes care of handling this process.
 *
 * If `TriggerManager.returnAt` is set equal to `TriggerManager.first`,
 * the first trigger function returning a truthy value will stop the process
 * and the target object will be immediately returned. In these settings,
 * if a trigger function returns `undefined`, the target is passed to the next
 * trigger function.
 *
 * Notice: TriggerManager works as a *LIFO* queue, i.e. new trigger functions
 * will be executed first.
 */
(function(exports, node) {

    "use strict";

    // ## Global scope

    exports.TriggerManager = TriggerManager;

    TriggerManager.first = 'first';
    TriggerManager.last = 'last';

    /**
     * ## TriggerManager constructor
     *
     * Creates a new instance of TriggerManager
     *
     * @param {object} options Configuration options
     */
    function TriggerManager(options) {
        // ## Public properties

        /**
         * ### TriggerManager.options
         *
         * Reference to current configuration
         */
        this.options = options || {};

        /**
         * ### TriggerManager.triggers
         *
         * Array of trigger functions
         */
        this.triggers = [];

        /**
         * ### TriggerManager.returnAt
         *
         * Controls the behavior of TriggerManager.pullTriggers
         *
         * By default it is equal to `TriggerManager.first`
         */
        this.returnAt = TriggerManager.first;

        this.init();
    };

    // ## TriggerManager methods


    /**
     * ### TriggerManager.size
     *
     * Returns the number of registered trigger functions
     */
    TriggerManager.prototype.size = function() {
        return this.triggers.length;
    };

    /**
     * ### TriggerManager.init
     *
     * Configures the TriggerManager instance
     *
     * Takes the configuration as an input parameter or recycles the settings
     * in `this.options`.
     *
     * The configuration object is of the type:
     *
     *  var options = {
     *      returnAt: 'last',
     *      triggers: [ myFunc, myFunc2 ]
     *  };
     *
     * @param {object} options Optional. Configuration object
     */
    TriggerManager.prototype.init = function(options) {
        if (options && 'object' !== typeof options) {
            throw new TypeError('TriggerManager.init: options must be ' +
                                'object or undefined.');
        }

        if (options) {
            if (options.returnAt) {
                this.setReturnAt(options.returnAt);
            }
            this.options = options;
        }

        this.resetTriggers();
    };


    /**
     * ### TriggerManager.setReturnAt
     *
     * Verifies and sets the returnAt option.x
     *
     * @param {string} returnAt The value of the returnAt policy
     *
     * @see TriggerManager.first
     * @see TriggerManager.last
     */
    TriggerManager.prototype.setReturnAt = function(returnAt) {
        var f =  TriggerManager.first, l = TriggerManager.last;
        if ('string' !== typeof returnAt) {
            throw new TypeError('TriggerManager.setReturnAt: returnAt must ' +
                                'be string.');
        }
        if (returnAt !== f && returnAt !== l) {
            throw new TypeError('TriggerManager.setReturnAt: returnAt must ' +
                                'be ' + f + ' or ' + l + '. Given: ' +
                                returnAt + '.');
        }
        this.returnAt = returnAt;
    };

    /**
     * ### TriggerManager.initTriggers
     *
     * Adds a collection of trigger functions to the trigger array
     *
     * @param {function|array} triggers An array of trigger functions
     *   or a single function.
     */
    TriggerManager.prototype.initTriggers = function(triggers) {
        var i;
        if (!triggers) return;
        if (!(triggers instanceof Array)) {
            triggers = [triggers];
        }
        for (i = 0 ; i < triggers.length ; i++) {
            this.triggers.push(triggers[i]);
        }
    };

    /**
     * ### TriggerManager.resetTriggers
     *
     * Resets the trigger array to initial configuration
     *
     * Delete existing trigger functions and re-add the ones
     * contained in `TriggerManager.options.triggers`.
     */
    TriggerManager.prototype.resetTriggers = function() {
        this.triggers = [];
        if ('undefined' !== typeof this.options.triggers) {
            this.initTriggers(this.options.triggers);
        }
    };

    /**
     * ### TriggerManager.clear
     *
     * Clears the trigger array
     *
     * Requires a boolean parameter to be passed for confirmation
     *
     * @param {boolean} clear TRUE, to confirm clearing
     * @return {boolean} TRUE, if clearing was successful
     */
    TriggerManager.prototype.clear = function(clear) {
        if (!clear) {
            node.warn('Do you really want to clear the current ' +
                      'TriggerManager obj? Please use clear(true)');
            return false;
        }
        this.triggers = [];
        return clear;
    };

    /**
     * ### TriggerManager.addTrigger
     *
     * Pushes a trigger into the trigger array
     *
     * @param {function} trigger The function to add
     * @param {number} pos Optional. The index of the trigger in the array
     * @return {boolean} TRUE, if insertion is successful
     */
    TriggerManager.prototype.addTrigger = function(trigger, pos) {
        if (!trigger) return false;
        if (!('function' === typeof trigger)) return false;
        if (!pos) {
            this.triggers.push(trigger);
        }
        else {
            this.triggers.splice(pos, 0, trigger);
        }
        return true;
    };

    /**
     * ### TriggerManager.removeTrigger
     *
     * Removes a trigger from the trigger array
     *
     * @param {function} trigger The function to remove
     * @return {boolean} TRUE, if removal is successful
     */
    TriggerManager.prototype.removeTrigger = function(trigger) {
        var i;
        if (!trigger) return false;
        for (i = 0 ; i < this.triggers.length ; i++) {
            if (this.triggers[i] == trigger) {
                return this.triggers.splice(i,1);
            }
        }
        return false;
    };

    /**
     * ### TriggerManager.pullTriggers
     *
     * Fires the collection of trigger functions on the target object
     *
     * Triggers are fired according to a LIFO queue, i.e. new trigger
     * functions are fired first.
     *
     * Depending on the value of `TriggerManager.returnAt`, some trigger
     * functions may not be called. In fact a value is returned:
     *
     *  - 'first': after the first trigger returns a truthy value
     *  - 'last': after all triggers have been executed
     *
     * If no trigger is registered the target object is returned unchanged
     *
     * @param {object} o The target object
     * @return {object} The target object after the triggers have been fired
     */
    TriggerManager.prototype.pullTriggers = function(o) {
        var i, out;
        if ('undefined' === typeof o) return;
        if (!this.size()) return o;

        for (i = this.triggers.length; i > 0; i--) {
            out = this.triggers[(i-1)].call(this, o);
            if ('undefined' !== typeof out) {
                if (this.returnAt === TriggerManager.first) {
                    return out;
                }
            }
        }
        // Safety return.
        return ('undefined' !== typeof out) ? out : o;
    };

    // <!-- old pullTriggers
    //TriggerManager.prototype.pullTriggers = function(o) {
    //  if (!o) return;
    //
    //  for (var i = triggersArray.length; i > 0; i--) {
    //          var out = triggersArray[(i-1)].call(this, o);
    //          if (out) {
    //                  if (this.returnAt === TriggerManager.first) {
    //                          return out;
    //                  }
    //          }
    //  }
    //  // Safety return
    //  return o;
    //};
    //-->

})(
    ('undefined' !== typeof node) ? node : module.exports
    , ('undefined' !== typeof node) ? node : module.parent.exports
);

/**
 * Exposing the node object
 */
(function() {
    var tmp = new window.node.NodeGameClient();
    JSUS.mixin(tmp, window.node);
    window.node = tmp;
})();

/**
 * # GameWindow
 * Copyright(c) 2021 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * API to interface nodeGame with the browser window
 *
 * Creates a custom root element inside the HTML page, and insert an
 * iframe element inside it.
 *
 * Dynamic content can be loaded inside the iframe without losing the
 * javascript state inside the page.
 *
 * Defines a number of profiles associated with special page layout.
 *
 * Depends on JSUS and nodegame-client.
 */
(function(window, node) {

    "use strict";

    var DOM;

    var constants, windowLevels, screenLevels;
    var CB_EXECUTED, WIN_LOADING;

    if (!J) throw new Error('GameWindow: JSUS not found');
    DOM = J.require('DOM');
    if (!DOM) throw new Error('GameWindow: J.require("DOM") failed');

    constants = node.constants;
    windowLevels = constants.windowLevels;
    screenLevels = constants.screenLevels;

    CB_EXECUTED = constants.stageLevels.CALLBACK_EXECUTED;

    WIN_LOADING = windowLevels.LOADING;

    GameWindow.prototype = DOM;
    GameWindow.prototype.constructor = GameWindow;

    // Configuration object.
    GameWindow.defaults = {};

    // Default settings.
    GameWindow.defaults.promptOnleaveText = '';
    GameWindow.defaults.promptOnleave = true;
    GameWindow.defaults.noEscape = true;
    GameWindow.defaults.waitScreen = undefined;
    GameWindow.defaults.disableRightClick = false;
    GameWindow.defaults.cacheDefaults = {
        loadCache:       true,
        storeCacheNow:   false,
        storeCacheLater: false
    };
    GameWindow.defaults.infoPanel = undefined;

    function onLoadStd(iframe, cb) {
        var iframeWin;
        iframeWin = iframe.contentWindow;

        function completed() {
            // Detaching the function to avoid double execution.
            iframe.removeEventListener('load', completed, false);
            iframeWin.removeEventListener('load', completed, false);
            if (cb) {
                // Some browsers fire onLoad too early.
                // A small timeout is enough.
                setTimeout(function() { cb(); }, 120);
            }
        }

        // Use the handy event callback
        iframe.addEventListener('load', completed, false);

        // A fallback to window.onload, that will always work
        iframeWin.addEventListener('load', completed, false);
    }

    function onLoadIE(iframe, cb) {
        var iframeWin;
        iframeWin = iframe.contentWindow;
        // We cannot get the iframeDoc here and use it in completed. See below.

        function completed(event) {
            var iframeDoc;

            // IE < 10 (also 11?) gives 'Permission Denied' if trying to access
            // the iframeDoc from the context of the function above.
            // We need to re-get it from the DOM.
            iframeDoc = J.getIFrameDocument(iframe);

            // readyState === "complete" works also in oldIE.
            if (event.type === 'load' ||
                iframeDoc.readyState === 'complete') {

                // Detaching the function to avoid double execution.
                iframe.detachEvent('onreadystatechange', completed );
                iframeWin.detachEvent('onload', completed );

                if (cb) {
                    // Some browsers fire onLoad too early.
                    // A small timeout is enough.
                    setTimeout(function() { cb(); }, 120);
                }
            }
        }

        // Ensure firing before onload, maybe late but safe also for iframes.
        iframe.attachEvent('onreadystatechange', completed);

        // A fallback to window.onload, that will always work.
        iframeWin.attachEvent('onload', completed);
    }

    function onLoad(iframe, cb) {
        // IE
        if (W.isIE) {
            onLoadIE(iframe, cb);
        }
        // Standards-based browsers support DOMContentLoaded.
        else {
            onLoadStd(iframe, cb);
        }
    }

    /**
     * ## GameWindow constructor
     *
     * Creates the GameWindow object
     *
     * @see GameWindow.init
     */
    function GameWindow() {
        this.setStateLevel('UNINITIALIZED');

        if ('undefined' === typeof window) {
            throw new Error('GameWindow: no window found. Are you in a ' +
                            'browser?');
        }

        if ('undefined' === typeof node) {
            throw new Error('GameWindow: nodeGame not found');
        }

        node.silly('node-window: loading...');

        /**
         * ### GameWindow.frameName
         *
         * The name (and also id) of the iframe where the pages are loaded
         */
        this.frameName = null;

        /**
         * ### GameWindow.frameElement
         *
         * A reference to the iframe object of type _HTMLIFrameElement_
         *
         * You can get this element also by:
         *
         * - document.getElementById(this.frameName)
         *
         * This is the element that contains the _Window_ object of the iframe.
         *
         * @see this.frameName
         * @see this.frameWindow
         * @see this.frameDocument
         */
        this.frameElement = null;

        /**
         * ### GameWindow.frameWindow
         *
         * A reference to the iframe Window object
         *
         * You can get this element also by:
         *
         * - window.frames[this.frameName]
         */
        this.frameWindow = null;

        /**
         * ### GameWindow.frameDocument
         *
         * A reference to the iframe Document object
         *
         * You can get this element also by:
         *
         * - JSUS.getIFrameDocument(this.frameElement)
         *
         * @see this.frameElement
         * @see this.frameWindow
         */
        this.frameDocument = null;

        /**
         * ### GameWindow.root
         *
         * A reference to the HTML element to which the iframe is appended
         *
         * Under normal circumstances, this element is a reference to
         * _document.body_.
         */
        this.frameRoot = null;

        /**
         * ### GameWindow.headerElement
         *
         * A reference to the HTMLDivElement representing the header
         */
        this.headerElement = null;

        /**
         * ### GameWindow.headerName
         *
         * The name (id) of the header element
         */
        this.headerName = null;

        /**
         * ### GameWindow.headerRoot
         *
         * The name (id) of the header element
         */
        this.headerRoot = null;

        /**
         * ### GameWindow.headerPosition
         *
         * The relative position of the header on the screen
         *
         * Available positions: 'top', 'bottom', 'left', 'right'.
         *
         * @see GameWindow.setHeaderPosition
         */
        this.headerPosition = null;

        /**
         * ### GameWindow.defaultHeaderPosition
         *
         * The default header position. 'top'.
         */
        this.defaultHeaderPosition = 'top';

        /**
         * ### GameWindow.conf
         *
         * Object containing the current configuration
         */
        this.conf = {};

        /**
         * ### GameWindow.uriChannel
         *
         * The uri of the channel on the server
         *
         * It is not the socket.io channel, but the HTTP address.
         *
         * @see GameWindow.loadFrame
         */
        this.uriChannel = null;

        /**
         * ### GameWindow.areLoading
         *
         * The number of frames currently being loaded
         */
        this.areLoading = 0;

        /**
         * ### GameWindow.cacheSupported
         *
         * Flag that marks whether caching is supported by the browser
         *
         * Caching requires to modify the documentElement.innerHTML property
         * of the iframe document, which is read-only in IE < 9.
         */
        this.cacheSupported = null;

        /**
         * ### GameWindow.cacheSupported
         *
         * Flag that direct access to the iframe content is allowed
         *
         * Usually false, on IEs
         *
         * @see testdirectFrameDocumentAccess
         */
        this.directFrameDocumentAccess = null;

        /**
         * ### GameWindow.cache
         *
         * Cache for loaded iframes
         *
         * Maps URI to a cache object with the following properties:
         *
         * - `contents` (the innerHTML property or null if not cached)
         * - optionally 'cacheOnClose' (a bool telling whether to cache
         *   the frame when it is replaced by a new one)
         */
        this.cache = {};

        /**
         * ### GameWindow.currentURIs
         *
         * Currently loaded URIs in the internal frames
         *
         * Maps frame names (e.g. 'ng_mainframe') to the (processed) URIs
         * that they are showing.
         *
         * @see GameWindow.preCache
         * @see GameWindow.processUri
         *
         * TODO: check: this is still having the test frame, should it be
         * removed instead?
         */
        this.currentURIs = {};

        /**
         * ### GameWindow.unprocessedUri
         *
         * The uri parameter passed to `loadFrame`, still unprocessed
         *
         * @see GameWindow.currentURIs
         * @see GameWindow.processUri
         */
        this.unprocessedUri = null;

        /**
         * ### GameWindow.globalLibs
         *
         * Array of strings with the path of the libraries
         * to be loaded in every frame
         */
        this.globalLibs = [];

        /**
         * ### GameWindow.frameLibs
         *
         * The libraries to be loaded in specific frames
         *
         * Maps frame names to arrays of strings. These strings are the
         * libraries that should be loaded for a frame.
         *
         * @see GameWindow.globalLibs
         */
        this.frameLibs = {};

        /**
         * ### GameWindow.uriPrefix
         *
         * A prefix added to every loaded uri that does not begin with `/`
         *
         * Useful for example to add a language path (e.g. a language
         * directory) that matches a specific context of a view.
         *
         * @see GameWindow.loadFrame
         * @see LanguageSelector (widget)
         */
        this.uriPrefix = null;

        /**
         * ### GameWindow.stateLevel
         *
         * The window's state level
         *
         * @see constants.windowLevels
         */
        this.stateLevel = null;

        /**
         * ### GameWindow.waitScreen
         *
         * Reference to the _WaitScreen_ module
         *
         * @see node.widgets.WaitScreen
         */
        this.waitScreen = null;

        /**
         * ### GameWindow.listenersAdded
         *
         * TRUE, if listeners were added already
         *
         * @see GameWindow.addDefaultListeners
         */
        this.listenersAdded = null;

        /**
         * ### GameWindow.screenState
         *
         * Level describing whether the user can interact with the frame
         *
         * The _screen_ represents all the user can see on screen.
         * It includes the _frame_ area, but also the _header_.
         *
         * @see node.widgets.WaitScreen
         * @see node.constants.screenLevels
         */
        this.screenState = node.constants.screenLevels.ACTIVE;

        /**
         * ### GameWindow.styleElement
         *
         * A style element for on-the-fly styling
         *
         * @see GameWindow.cssRule
         */
        this.styleElement = null;

        /**
         * ### GameWindow.isIE
         *
         * Boolean flag saying whether we are in IE or not
         */
        this.isIE = !!document.createElement('span').attachEvent;

        /**
         * ### GameWindow.headerOffset
         *
         * Contains the current offset (widht or height) for the header
         *
         * Content below/above/next to it needs to be slided accordingly.
         *
         * @see W.adjustHeaderOffset
         */
        this.headerOffset = 0;

        /**
         * ### GameWindow.willResizeFrame
         *
         * Boolean flag saying whether a call to resize the frame is in progress
         *
         * @see W.adjustFrameHeight
         */
        this.willResizeFrame = false;

        // Add setup functions.
        this.addDefaultSetups();

        // Adding listeners.
        this.addDefaultListeners();

        // Hide noscript tag (necessary for IE8).
        setTimeout(function(){
            (function (scriptTag) {
                if (scriptTag.length >= 1) scriptTag[0].style.display = 'none';
            })(document.getElementsByTagName('noscript'));
        }, 1000);

        // Init.
        this.init(GameWindow.defaults);

        node.silly('node-window: created.');
    }

    // ## GameWindow methods

    /**
     * ### GameWindow.init
     *
     * Sets global variables based on local configuration
     *
     * Defaults:
     *  - promptOnleave TRUE
     *  - captures ESC key
     *
     * @param {object} options Optional. Configuration options
     */
    GameWindow.prototype.init = function(options) {
        var stageLevels;
        var stageLevel;

        this.setStateLevel('INITIALIZING');
        options = options || {};
        this.conf = J.merge(this.conf, options);

        if (this.conf.promptOnleave) {
            this.promptOnleave();
        }
        else if (this.conf.promptOnleave === false) {
            this.restoreOnleave();
        }

        if ('undefined' === typeof this.conf.noEscape || this.conf.noEscape) {
            this.noEscape();
        }
        else if (this.conf.noEscape === false) {
            this.restoreEscape();
        }

        if (this.conf.waitScreen !== false) {
            if (this.waitScreen) {
                this.waitScreen.destroy();
                this.waitScreen = null;
            }
            this.waitScreen = new node.WaitScreen(this.conf.waitScreen);

            stageLevels = constants.stageLevels;
            stageLevel = node.game.getStageLevel();
            if (stageLevel !== stageLevels.UNINITIALIZED) {
                if (node.game.paused) {
                    this.lockScreen(this.waitScreen.defaultTexts.paused);
                }
                else {
                    if (stageLevel === stageLevels.DONE) {
                        this.lockScreen(this.waitScreen.defaultTexts.waiting);
                    }
                    else if (stageLevel !== stageLevels.PLAYING) {
                        this.lockScreen(this.waitScreen.defaultTexts.stepping);
                    }
                }
            }
        }
        else if (this.waitScreen) {
            this.waitScreen.destroy();
            this.waitScreen = null;
        }

        if (this.conf.defaultHeaderPosition) {
            this.defaultHeaderPosition = this.conf.defaultHeaderPosition;
        }

        if (this.conf.disableRightClick) {
            this.disableRightClick();
        }
        else if (this.conf.disableRightClick === false) {
            this.enableRightClick();
        }

        if ('undefined' !== typeof this.conf.disableBackButton) {
            this.disableBackButton(this.conf.disableBackButton);
        }

        if ('undefined' !== typeof this.conf.uriPrefix) {
            this.setUriPrefix(this.conf.uriPrefix);
        }

        this.setStateLevel('INITIALIZED');

        node.silly('node-window: inited.');
    };

    /**
     * ### GameWindow.reset
     *
     * Resets the GameWindow to the initial state
     *
     * Clears the frame, header, lock, widgets and cache.
     *
     * @see Widgets.destroyAll
     */
    GameWindow.prototype.reset = function() {
        // Unlock screen, if currently locked.
        if (this.isScreenLocked()) this.unlockScreen();

        // Remove widgets, if widgets exists.
        if (node.widgets) node.widgets.destroyAll();

        // Remove loaded frame, if one is found.
        if (this.getFrame()) this.destroyFrame();

        // Remove header, if one is found.
        if (this.getHeader()) this.destroyHeader();

        this.areLoading = 0;

        // Clear all caches.
        this.clearCache();

        node.silly('node-window: reseted');
    };

    /**
     * ### GameWindow.setStateLevel
     *
     * Validates and sets window's state level
     *
     * @param {string} level The level of the update
     *
     * @see constants.windowLevels
     */
    GameWindow.prototype.setStateLevel = function(level) {
        if ('string' !== typeof level) {
            throw new TypeError('GameWindow.setStateLevel: level must ' +
                                'be string. Found: ' + level);
        }
        if ('undefined' === typeof windowLevels[level]) {
            throw new Error('GameWindow.setStateLevel: unrecognized level: ' +
                            level);
        }
        this.stateLevel = windowLevels[level];
    };

    /**
     * ### GameWindow.getStateLevel
     *
     * Returns the current state level
     *
     * @return {number} The state level
     *
     * @see constants.windowLevels
     */
    GameWindow.prototype.getStateLevel = function() {
        return this.stateLevel;
    };

    /**
     * ### GameWindow.isReady
     *
     * Returns TRUE if the GameWindow is ready
     *
     * The window is ready if its state is either INITIALIZED or LOADED.
     *
     * @return {boolean} TRUE if the window is ready
     */
    GameWindow.prototype.isReady = function() {
        return this.stateLevel === windowLevels.LOADED ||
            this.stateLevel === windowLevels.INITIALIZED;
    };

    /**
     * ### GameWindow.setScreenLevel
     *
     * Validates and sets window's state level
     *
     * @param {string} level The level of the update
     *
     * @see constants.screenLevels
     */
    GameWindow.prototype.setScreenLevel = function(level) {
        if ('string' !== typeof level) {
            throw new TypeError('GameWindow.setScreenLevel: level must ' +
                                'be string. Found: ' + level);
        }
        if ('undefined' === typeof screenLevels[level]) {
            throw new Error('GameWindow.setScreenLevel: unrecognized level: ' +
                            level);
        }

        this.screenState = screenLevels[level];
    };

    /**
     * ### GameWindow.getScreenLevel
     *
     * Returns the current screen level
     *
     * @return {number} The screen level
     *
     * @see constants.screenLevels
     */
    GameWindow.prototype.getScreenLevel = function() {
        return this.screenState;
    };

    /**
     * ### GameWindow.getFrame
     *
     * Returns a reference to the HTML element of the frame of the game
     *
     * If no reference is found, tries to retrieve and update it using the
     * _frameName_ variable.
     *
     * @return {HTMLIFrameElement} The iframe element of the game
     *
     * @see GameWindow.frameName
     */
    GameWindow.prototype.getFrame = function() {
        if (!this.frameElement) {
            if (this.frameName) {
                this.frameElement = document.getElementById(this.frameName);
            }
        }
        return this.frameElement;
    };

    /**
     * ### GameWindow.getFrameName
     *
     * Returns the name of the frame of the game
     *
     * If no name is found, tries to retrieve and update it using the
     *  _GameWindow.getFrame()_.
     *
     * @return {string} The name of the frame of the game.
     *
     * @see GameWindow.getFrame
     */
    GameWindow.prototype.getFrameName = function() {
        var iframe;
        if (!this.frameName || this.stateLevel === WIN_LOADING) {
            iframe = this.getFrame();
            this.frameName = iframe ? iframe.name || iframe.id : null;
        }
        return this.frameName;
    };

    /**
     * ### GameWindow.getFrameWindow
     *
     * Returns a reference to the window object of the frame of the game
     *
     * If no reference is found, tries to retrieve and update it using
     * _GameWindow.getFrame()_.
     *
     * @return {Window} The window object of the iframe of the game
     *
     * @see GameWindow.getFrame
     */
    GameWindow.prototype.getFrameWindow = function() {
        var iframe;
        if (!this.frameWindow || this.stateLevel === WIN_LOADING) {
            iframe = this.getFrame();
            this.frameWindow = iframe ? iframe.contentWindow : null;
        }
        return this.frameWindow;
    };

    /**
     * ### GameWindow.getFrameDocument
     *
     * Returns a reference to the document object of the iframe
     *
     * If no reference is found, tries to retrieve and update it using the
     * _GameWindow.getFrame()_.
     *
     * @return {Document} The document object of the iframe of the game
     *
     * @see GameWindow.getFrame
     * @see GameWindow.testDirectFrameDocumentAccess
     */
    GameWindow.prototype.getFrameDocument = function() {
        var iframe;
        if (!this.frameDocument || this.stateLevel === WIN_LOADING) {
            iframe = this.getFrame();
            if (!iframe) return null;
            this.frameDocument = this.getIFrameDocument(iframe);
        }
        // Some IEs give permission denied when accessing the frame document
        // directly. We need to re-get it from the DOM.
        if (this.directFrameDocumentAccess) return this.frameDocument;
        else return J.getIFrameDocument(this.getFrame());
    };

    /**
     * ### GameWindow.getFrameRoot
     *
     * Returns a reference to the root element for the iframe
     *
     * If none is found tries to retrieve and update it using
     * _GameWindow.getFrame()_.
     *
     * @return {Element} The root element in the iframe
     */
    GameWindow.prototype.getFrameRoot = function() {
        var iframe;
        if (!this.frameRoot) {
            iframe = this.getFrame();
            this.frameRoot = iframe ? iframe.parentNode : null;
        }
        return this.frameRoot;
    };

    /**
     * ### GameWindow.generateFrame
     *
     * Appends a new iframe to _documents.body_ and sets it as the default one
     *
     * @param {Element} root Optional. The HTML element to which the iframe
     *   will be appended. Default: this.frameRoot or document.body
     * @param {string} frameName Optional. The name of the iframe. Default:
     *   'ng_mainframe'
     * @param {boolean} force Optional. Will create the frame even if an
     *   existing one is found. Default: FALSE
     *
     * @return {IFrameElement} The newly created iframe
     *
     * @see GameWindow.frameElement
     * @see GameWindow.frameWindow
     * @see GameWindow.frameDocument
     * @see GameWindow.setFrame
     * @see GameWindow.clearFrame
     * @see GameWindow.destroyFrame
     *
     * @emit FRAME_GENERATED
     */
    GameWindow.prototype.generateFrame = function(root, frameName, force) {
        var iframe;
        if (this.frameElement) {
            if (!force) {
                throw new Error('GameWindow.generateFrame: frame is ' +
                                'already existing. Use force to regenerate.');
            }
            this.destroyFrame();
        }

        root = root || this.frameRoot || document.body;

        if (!J.isElement(root)) {
            throw new Error('GameWindow.generateFrame: root must be ' +
                            'undefined or HTMLElement. Found: ' + root);
        }

        frameName = frameName || 'ng_mainframe';

        if ('string' !== typeof frameName || frameName.trim() === '') {
            throw new Error('GameWindow.generateFrame: frameName must be ' +
                            'undefined or a non-empty string. Found: ' +
                            frameName);
        }

        if (document.getElementById(frameName)) {
            throw new Error('GameWindow.generateFrame: frameName is not ' +
                            'unique in DOM: ' + frameName);
        }

        iframe = W.add('iframe', root, frameName);
        // Method .replace does not add the uri to the history.
        iframe.contentWindow.location.replace('about:blank');

        // For IE8.
        iframe.frameBorder = 0;

        // Avoid scrolling.
        iframe.scrolling = "no";

        this.setFrame(iframe, frameName, root);

        if (this.getHeader()) adaptFrame2HeaderPosition();

        // Emit event.
        node.events.ng.emit('FRAME_GENERATED', iframe);

        // Add listener on resizing the page.
        document.body.onresize = function() {
            W.adjustFrameHeight(0, 120);
        };

        return iframe;
    };

    /**
     * ### GameWindow.generateInfoPanel
     *
     * Appends a configurable div element at to "top" of the page
     *
     * @param {object} opts Optional. Configuration options:
     *
     *    - root: The HTML element (or its id) under which the Info Panel
     *        will be appended. Default: above the main frame, or below the
     *        the header, or under document.body.
     *    - innerHTML: the content of the Info Panel.
     *    - force: It destroys current frame, if existing.
     *    - toggleBtn: If TRUE, it creates a button to toggle the Info Panel.
     *        Default: TRUE.
     *    - toggleBtnRoot: the HTML element (or its id) under which the button
     *        to toggle the Info Panel will be appended. Default: the header.
     *    - toggleBtnLabel: The text on the button to toggle the Info Panel.
     *        Default: 'Info'.
     *
     * @param {boolean} force Optional. Deprecated, use force flag in
     *    options. Default: FALSE
     *
     * @return {InfoPanel} A reference to the InfoPanel object
     *
     * @see GameWindow.infoPanel
     *
     * @emit INFOPANEL_GENERATED
     */
    GameWindow.prototype.generateInfoPanel = function(opts, force) {
        var infoPanelDiv, root, btn;
        opts = opts || {};

        // Backward compatible.
        if ('undefined' === typeof force) force = opts.force;

        if (force && this.infoPanel) {
            this.infoPanel.destroy();
            this.infoPanel = null;
        }

        if (this.infoPanel) {
            if (this.infoPanel.toggleBtn) {
                if ('undefined' === typeof opts.toggleBtn) {
                    opts.toggleBtn = false;
                }
            }
            node.warn('W.generateInfoPanel: Info Panel already existing.')
        }
        else {
            this.infoPanel = new node.InfoPanel(opts);
        }

        infoPanelDiv = this.infoPanel.infoPanelDiv;

        root = opts.root;
        if (root) {
            if ('string' === typeof root) root = W.gid(root);
            if (!J.isElement(root)) {
                throw new Error('GameWindow.generateInfoPanel: root must be ' +
                                'undefined or HTMLElement. Found: ' + root);
            }
            root.appendChild(infoPanelDiv);
        }
        else if (this.frameElement) {
            document.body.insertBefore(infoPanelDiv, this.frameElement);
        }
        else if (this.headerElement) {
           J.insertAfter(this.headerElement, infoPanelDiv);
        }
        else {
            document.body.appendChild(infoPanelDiv);
        }

        // Adds Toggle Button if not false.
        if (opts.toggleBtn !== false) {
            root = null;
            if (!opts.toggleBtnRoot) {
                if (this.headerElement) root = this.headerElement;
            }
            else {
                if ('string' === typeof opts.toggleBtnRoot) {
                    root = W.gid(opts.toggleBtnRoot);
                }
                else {
                    root = opts.toggleBtnRoot;
                }
                if (!J.isElement(root)) {
                    throw new Error('GameWindow.generateInfoPanel: ' +
                                    'toggleBtnRoot did not resolve to a ' +
                                    'valid HTMLElement: ' + opts.toggleBtnRoot);
                }
            }
            if (root) {
                btn = W.infoPanel.createToggleBtn(opts.toggleBtnLabel);
                root.appendChild(btn);
            }
        }

        // Set inner HTML if specified.
        if (opts.innerHTML) {
            W.infoPanel.infoPanelDiv.innerHTML = opts.innerHTML;
        }

        // Emit event.
        node.events.ng.emit('INFOPANEL_GENERATED', this.infoPanel);

        return this.infoPanel;
    };

    /**
     * ### GameWindow.setFrame
     *
     * Sets the new default frame and update other references
     *
     * @param {IFrameElement} iframe The new default frame
     * @param {string} frameName The name of the iframe
     * @param {Element} root The HTML element to which the iframe is appended
     *
     * @return {IFrameElement} The new default iframe
     *
     * @see GameWindow.generateFrame
     */
    GameWindow.prototype.setFrame = function(iframe, iframeName, root) {
        if (!J.isElement(iframe)) {
            throw new TypeError('GameWindow.setFrame: iframe must be ' +
                                'HTMLElement. Found: ' + iframe);
        }
        if ('string' !== typeof iframeName) {
            throw new TypeError('GameWindow.setFrame: iframeName must be ' +
                                'string. Found: ' + iframeName);
        }
        if (!J.isElement(root)) {
            throw new TypeError('GameWindow.setFrame: root must be ' +
                                'HTMLElement. Found: ' + root);
        }

        this.frameRoot = root;
        this.frameName = iframeName;
        this.frameElement = iframe;
        this.frameWindow = iframe.contentWindow;
        this.frameDocument = W.getIFrameDocument(iframe);

        return iframe;
    };

    /**
     * ### GameWindow.destroyFrame
     *
     * Clears the content of the frame and removes the element from the page
     *
     * @see GameWindow.clearFrame
     */
    GameWindow.prototype.destroyFrame = function() {
        this.clearFrame();
        if (this.frameRoot) this.frameRoot.removeChild(this.frameElement);
        this.frameElement = null;
        this.frameWindow = null;
        this.frameDocument = null;
        this.frameRoot = null;

        // Destroy lost widgets.
        node.widgets.garbageCollection();
    };

    /**
     * ### GameWindow.clearFrame
     *
     * Clears the content of the frame
     */
    GameWindow.prototype.clearFrame = function() {
        var iframe, frameName, frameDocument;
        iframe = this.getFrame();
        if (!iframe) {
            throw new Error('GameWindow.clearFrame: frame not found');
        }

        frameName = iframe.name || iframe.id;
        iframe.onload = null;

        // Method .replace does not add the uri to the history.
        //iframe.contentWindow.location.replace('about:blank');

        frameDocument = this.getFrameDocument();
        frameDocument.documentElement.innerHTML = '';

        if (this.directFrameDocumentAccess) {
            frameDocument.documentElement.innerHTML = '';
        }
        else {
            J.removeChildrenFromNode(frameDocument.documentElement);
        }

// TODO: cleanup refactor.
//         try {
//             this.getFrameDocument().documentElement.innerHTML = '';
//         }
//         catch(e) {
//             // IE < 10 gives 'Permission Denied' if trying to access
//             // the iframeDoc from the context of the function above.
//             // We need to re-get it from the DOM.
//             if (J.getIFrameDocument(iframe).documentElement) {
//                 J.removeChildrenFromNode(
//                     J.getIFrameDocument(iframe).documentElement);
//             }
//         }

        this.frameElement = iframe;
        this.frameWindow = window.frames[frameName];
        this.frameDocument = W.getIFrameDocument(iframe);

        // Destroy lost widgets.
        node.widgets.garbageCollection();
    };

    /**
     * ### GameWindow.generateHeader
     *
     * Adds a a div element and sets it as the header of the page
     *
     * @param {Element} root Optional. The HTML element to which the header
     *   will be appended. Default: _document.body_ or
     *   _document.lastElementChild_
     * @param {string} headerName Optional. The name (id) of the header.
     *   Default: 'ng_header'
     * @param {boolean} force Optional. Destroys the existing header,
     *   if found. Default: FALSE
     *
     * @return {Element} The header element
     */
    GameWindow.prototype.generateHeader = function(root, headerName, force) {
        var header;

        if (this.headerElement) {
            if (!force) {
                throw new Error('GameWindow.generateHeader: header is ' +
                                'already existing. Use force to regenerate.');
            }
            this.destroyHeader();
        }

        root = root || document.body || document.lastElementChild;

        if (!J.isElement(root)) {
            throw new Error('GameWindow.generateHeader: root must be ' +
                            'undefined or HTMLElement. Found: ' + root);
        }

        headerName = headerName || 'ng_header';

        if ('string' !== typeof headerName) {
            throw new Error('GameWindow.generateHeader: headerName must be ' +
                            'string. Found: ' + headerName);
        }

        if (document.getElementById(headerName)) {
            throw new Error('GameWindow.generateHeader: headerName is not ' +
                            'unique in DOM: ' + headerName);
        }

        header = this.add('div', root, headerName);

        // If generateHeader is called after generateFrame, and the default
        // header position is not bottom, we need to move the header in front.
        if (this.frameElement && this.defaultHeaderPosition !== 'bottom') {
            this.getFrameRoot().insertBefore(header, this.frameElement);
        }

        this.setHeader(header, headerName, root);
        this.setHeaderPosition(this.defaultHeaderPosition);

        return header;
    };


    /**
     * ### GameWindow.setHeaderPosition
     *
     * Sets the header's position on the screen
     *
     * Positioning of the frame element is also affected, if existing, or if
     * added later.
     *
     * @param {string} position New position, one of
     *   'top', 'bottom', 'left', 'right'
     *
     * @see GameWindow.generateHeader
     * @see GameWindow.headerPosition
     * @see GameWindow.defaultHeaderPosition
     * @see adaptFrame2HeaderPosition
     */
    GameWindow.prototype.setHeaderPosition = (function() {
        var validPositions;
        // Map: position - css class.
        validPositions = {
            top: 'ng_header_position-horizontal-t',
            bottom: 'ng_header_position-horizontal-b',
            right: 'ng_header_position-vertical-r',
            left: 'ng_header_position-vertical-l'
        };

        return function(position) {
            var pos, oldPos;
            if ('string' !== typeof position) {
                throw new TypeError('GameWindow.setHeaderPosition: position ' +
                                    'must be string. Found: ' + position);
            }
            pos = position.toLowerCase();

            // Do something only if there is a change in the position.
            if (this.headerPosition === pos) return;

            if ('undefined' === typeof validPositions[pos]) {
                node.err('GameWindow.setHeaderPosition: invalid header ' +
                         'position: ' + pos);
                return;
            }
            if (!this.headerElement) {
                throw new Error('GameWindow.setHeaderPosition: headerElement ' +
                                'not found.');
            }

            W.removeClass(this.headerElement, 'ng_header_position-[a-z-]*');
            W.addClass(this.headerElement, validPositions[pos]);

            oldPos = this.headerPosition;

            // Store the new position in a reference variable
            // **before** adaptFrame2HeaderPosition is called
            this.headerPosition = pos;

            if (this.frameElement) adaptFrame2HeaderPosition(oldPos);
        };
    })();

    /**
     * ### GameWindow.setHeader
     *
     * Sets the new header element and update related references
     *
     * @param {HTMLElement} header The new header
     * @param {string} headerName The name of the header
     * @param {HTMLElement} root The element to which the header is appended
     *
     * @return {HTMLElement} The header
     *
     * @see GameWindow.generateHeader
     */
    GameWindow.prototype.setHeader = function(header, headerName, root) {
        if (!J.isElement(header)) {
            throw new Error(
                'GameWindow.setHeader: header must be HTMLElement. Found: ' +
                    header);
        }
        if ('string' !== typeof headerName) {
            throw new Error('GameWindow.setHeader: headerName must be ' +
                            'string. Found: ' + headerName);
        }
        if (!J.isElement(root)) {
            throw new Error('GameWindow.setHeader: root must be ' +
                            'HTMLElement. Found: ' + root);
        }

        this.headerElement = header;
        this.headerName = headerName;
        this.headerRoot = root;

        // Emit event.
        node.events.ng.emit('HEADER_GENERATED', header);

        return this.headerElement;
    };

    /**
     * ### GameWindow.getHeader
     *
     * Returns a reference to the header element, if defined
     *
     * @return {Element} The header element
     */
    GameWindow.prototype.getHeader = function() {
        if (!this.headerElement) {
            this.headerElement = this.headerName ?
                document.getElementById(this.headerName) : null;
        }
        return this.headerElement;
    };

    /**
     * ### GameWindow.getHeaderName
     *
     * Returns the name (id) of the header element
     *
     * @return {string} The name (id) of the header
     */
    GameWindow.prototype.getHeaderName = function() {
        var header;
        if (!this.headerName) {
            header = this.getHeader();
            this.headerName = header ? header.id : null;
        }
        return this.headerName;
    };

    /**
     * ### GameWindow.getHeaderRoot
     *
     * Returns the HTML element to which the header is appended
     *
     * @return {HTMLElement} The HTML element to which the header is appended
     */
    GameWindow.prototype.getHeaderRoot = function() {
        var header;
        if (!this.headerRoot) {
            header = this.getHeader();
            this.headerRoot = header ? header.parentNode: null;
        }
        return this.headerRoot;
    };

    /**
     * ### GameWindow.destroyHeader
     *
     * Clears the content of the header and removes the element from the page
     *
     * @see GameWindow.clearHeader
     */
    GameWindow.prototype.destroyHeader = function() {
        this.clearHeader();
        this.headerRoot.removeChild(this.headerElement);
        this.headerElement = null;
        this.headerName = null;
        this.headerRoot = null;
        this.headerPosition = null;
        this.headerOffset = 0;
        this.adjustHeaderOffset(true);
    };

    /**
     * ### GameWindow.clearHeader
     *
     * Clears the content of the header
     */
    GameWindow.prototype.clearHeader = function() {
        var header;
        header = this.getHeader();
        if (!header) {
            throw new Error('GameWindow.clearHeader: cannot detect header');
        }
        this.headerElement.innerHTML = '';

        // Destroy lost widgets.
        node.widgets.garbageCollection();
    };

    /**
     * ### GameWindow.initLibs
     *
     * Specifies the libraries to be loaded automatically in the iframe
     *
     * Multiple calls to _initLibs_ append the new libs to the list.
     * Deletion must be done manually.
     *
     * This method must be called before any call to GameWindow.loadFrame.
     *
     * @param {array} globalLibs Array of strings describing absolute library
     *   paths that should be loaded in every iframe
     * @param {object} frameLibs Map from URIs to string arrays (as above)
     *   specifying libraries that should only be loaded for iframes displaying
     *   the given URI. This must not contain any elements that are also in
     *   globalLibs.
     */
    GameWindow.prototype.initLibs = function(globalLibs, frameLibs) {
        if (globalLibs && !J.isArray(globalLibs)) {
            throw new TypeError('GameWindow.initLibs: globalLibs must be ' +
                                'array or undefined. Found: ' + globalLibs);
        }
        if (frameLibs && 'object' !== typeof frameLibs) {
            throw new TypeError('GameWindow.initLibs: frameLibs must be ' +
                                'object or undefined. Found: ' + frameLibs);
        }
        if (!globalLibs && !frameLibs) {
            throw new Error('GameWindow.initLibs: frameLibs and frameLibs ' +
                            'cannot be both undefined.');
        }
        this.globalLibs = this.globalLibs.concat(globalLibs || []);
        J.mixin(this.frameLibs, frameLibs);
    };

    /**
     * ### GameWindow.preCacheTest
     *
     * Tests whether preChace is supported by the browser
     *
     * Results are stored in _GameWindow.cacheSupported_.
     *
     * @param {function} cb Optional. The function to call once the test if
     *   finished. It will be called regardless of success or failure.
     * @param {string} uri Optional. The URI to test. Default:
     *   '/pages/testpage.htm'
     *
     * @see GameWindow.cacheSupported
     */
    GameWindow.prototype.preCacheTest = function(cb, uri) {
        var iframe, iframeName;
        uri = uri || '/pages/testpage.htm';
        if ('string' !== typeof uri) {
            throw new TypeError('GameWindow.precacheTest: uri must string ' +
                                'or undefined. Found: ' + uri);
        }
        iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        iframeName = 'preCacheTest';
        iframe.id = iframeName;
        iframe.name = iframeName;
        document.body.appendChild(iframe);
        iframe.contentWindow.location.replace(uri);
        onLoad(iframe, function() {
            //var iframe, docElem;
            try {
                W.getIFrameDocument(iframe).documentElement.innerHTML = 'a';
                // This passes in IE8, but the rest of the caching doesn't.
                // We want this test to fail in IE8.
                //iframe = document.getElementById(iframeName);
                //docElem = W.getIFrameDocument(iframe);
                //docElem.innerHTML = 'a';
                W.cacheSupported = true;
            }
            catch(e) {
                W.cacheSupported = false;
            }

            document.body.removeChild(iframe);
            if (cb) cb();
        });
    };

    /**
     * ### GameWindow.preCache
     *
     * Loads the HTML content of the given URI(s) into the cache
     *
     * If caching is not supported by the browser, the callback will be
     * executed anyway.
     *
     * All uri to precache are parsed with `GameWindow.processUri` before
     * being loaded.
     *
     * @param {string|array} uris The URI(s) to cache
     * @param {function} callback Optional. The function to call once the
     *   caching is done
     *
     * @see GameWindow.cacheSupported
     * @see GameWindow.preCacheTest
     * @see GameWindow.processUri
     */
    GameWindow.prototype.preCache = function(uris, callback) {
        var that;
        var loadedCount;
        var currentUri, uriIdx;
        var iframe, iframeName;

        if ('string' === typeof uris) {
            uris = [ uris ];
        }

        if (!J.isArray(uris)) {
            throw new TypeError('GameWindow.preCache: uris must be string ' +
                                'or array. Found: ' + uris);
        }
        if (callback && 'function' !== typeof callback) {
            throw new TypeError('GameWindow.preCache: callback must be ' +
                                'function or undefined. Found: ' + callback);
        }

        // Don't preload if an empty array is passed.
        if (!uris.length) {
            if (callback) callback();
            return;
        }

        that = this;

        // Before proceeding with caching, check if caching is supported.
        if (this.cacheSupported === null) {
            this.preCacheTest(function() {
                that.preCache(uris, callback);
            });
            return;
        }
        else if (this.cacheSupported === false) {
            node.warn('GameWindow.preCache: caching is not supported by ' +
                      'your browser.');
            if (callback) callback();
            return;
        }

        // Keep count of loaded URIs:
        loadedCount = 0;

        for (uriIdx = 0; uriIdx < uris.length; uriIdx++) {
            currentUri = this.processUri(uris[uriIdx]);

            // Create an invisible internal frame for the current URI:
            iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            iframeName = 'tmp_iframe_' + uriIdx;
            iframe.id = iframeName;
            iframe.name = iframeName;
            document.body.appendChild(iframe);

            (function(uri, thisIframe) {
                // Register the onLoad handler:
                onLoad(thisIframe, function() {
                    var frameDocument, frameDocumentElement;

                    frameDocument = W.getIFrameDocument(thisIframe);
                    frameDocumentElement = frameDocument.documentElement;

                    // Store the contents in the cache:
                    that.cache[uri] = {
                        contents: frameDocumentElement.innerHTML,
                        cacheOnClose: false
                    };

                    // Remove the internal frame:
                    document.body.removeChild(thisIframe);

                    // Increment loaded URIs counter:
                    loadedCount++;
                    if (loadedCount >= uris.length) {
                        // All requested URIs have been loaded at this point.
                        if (callback) callback();
                    }
                });
            })(currentUri, iframe);

            // Start loading the page:
            // Method .replace does not add the uri to the history.
            window.frames[iframeName].location.replace(currentUri);
        }
    };

    /**
     * ### GameWindow.clearCache
     *
     * Empties the cache
     */
    GameWindow.prototype.clearCache = function() {
        this.cache = {};
    };

    /**
     * ### GameWindow.getElementById | gid
     *
     * Returns the element with the given id
     *
     * Looks first into the iframe and then into the rest of the page.
     *
     * @param {string} id The id of the element
     *
     * @return {Element|null} The element in the page, or null if none is found
     *
     * @see GameWindow.getElementsByTagName
     */
    GameWindow.prototype.getElementById =
        GameWindow.prototype.gid = function(id) {

        var el, frameDocument;

        frameDocument = this.getFrameDocument();
        el = null;
        if (frameDocument && frameDocument.getElementById) {
            el = frameDocument.getElementById(id);
        }
        if (!el) {
            el = document.getElementById(id);
        }
        return el;
    };

    /**
     * ### GameWindow.getElementsByTagName
     *
     * Returns a list of elements with the given tag name
     *
     * If set, it will look up in iframe, otherwsie into the rest of the page.
     *
     * @param {string} tag The tag of the elements
     *
     * @return {array|null} The elements in the page, or null if none is found
     *
     * @see GameWindow.getElementById
     * @see GameWindow.frameDocument
     */
    GameWindow.prototype.getElementsByTagName = function(tag) {
        var frameDocument;
        frameDocument = this.getFrameDocument();
        return frameDocument ? frameDocument.getElementsByTagName(tag) :
            document.getElementsByTagName(tag);
    };

    /**
     * ### GameWindow.getElementsByClassName
     *
     * Returns a list of elements with given class name
     *
     * If set, it will look up in iframe, otherwsie into the rest of the page.
     *
     * @param {string} className The requested className
     * @param {string} tag Optional. If set only elements with
     *   the specified tag name will be searched
     *
     * @return {array} Array of elements with the requested class name
     *
     * @see GameWindow.getElementByTagName
     * @see GameWindow.frameDocument
     */
    GameWindow.prototype.getElementsByClassName = function(className, tag) {
        var doc;
        doc = this.getFrameDocument() || document;
        return J.getElementsByClassName(doc, className, tag);
    };

    /**
     * ### GameWindow.loadFrame
     *
     * Loads content from an uri (remote or local) into the iframe,
     * and after it is loaded executes the callback function
     *
     * The third parameter is an options object with the following fields
     * (any fields left out assume the default setting):
     *
     *  - cache (object): Caching options. Fields:
     *      * loadMode (string):
     *          'cache' (default; get the page from cache if possible),
     *          'reload' (reload page without the cache)
     *      * storeMode (string):
     *          'off' (default; don't cache page),
     *          'onLoad' (cache given page after it is loaded),
     *          'onClose' (cache given page after it is replaced by a new page)
     *
     * Warning: Security policies may block this method if the content is
     * coming from another domain.
     * Notice: If called multiple times within the same stage/step, it will
     * cause the `VisualTimer` widget to reload the timer.
     *
     * @param {string} uri The uri to load
     * @param {function} func Optional. The function to call once the DOM is
     *   ready
     * @param {object} opts Optional. The options object
     *
     * @see GameWindow.uriPrefix
     * @see GameWindow.uriChannel
     */
    GameWindow.prototype.loadFrame = function(uri, func, opts) {
        var that;
        var loadCache;
        var storeCacheNow, storeCacheLater;
        var scrollUp;
        var autoParse, autoParsePrefix, autoParseMod;
        var iframe, iframeName, iframeDocument, iframeWindow;
        var frameDocumentElement, frameReady;
        var lastURI;

        if ('string' !== typeof uri) {
            throw new TypeError('GameWindow.loadFrame: uri must be ' +
                                'string. Found: ' + uri);
        }
        if (func && 'function' !== typeof func) {
            throw new TypeError('GameWindow.loadFrame: func must be function ' +
                                'or undefined. Found: ' + func);
        }
        if (opts && 'object' !== typeof opts) {
            throw new TypeError('GameWindow.loadFrame: opts must be object ' +
                                'or undefined. Found: ' + opts);
        }
        opts = opts || {};

        iframe = this.getFrame();
        iframeName = this.frameName;

        if (!iframe) {
            throw new Error('GameWindow.loadFrame: no frame found');
        }

        if (!iframeName) {
            throw new Error('GameWindow.loadFrame: frame has no name');
        }

        this.setStateLevel('LOADING');
        that = this;

        // Save ref to iframe window for later.
        iframeWindow = iframe.contentWindow;
        // Query readiness (so we know whether onload is going to be called):
        iframeDocument = W.getIFrameDocument(iframe);
        frameReady = iframeDocument.readyState;
        // ...reduce it to a boolean:
        //frameReady = frameReady === 'interactive'||frameReady === 'complete';
        frameReady = frameReady === 'complete';

        // Begin loadFrame caching section.

        // Default options.
        loadCache = GameWindow.defaults.cacheDefaults.loadCache;
        storeCacheNow = GameWindow.defaults.cacheDefaults.storeCacheNow;
        storeCacheLater = GameWindow.defaults.cacheDefaults.storeCacheLater;

        // Caching options.
        if (opts.cache) {
            if (opts.cache.loadMode) {
                if (opts.cache.loadMode === 'reload') {
                    loadCache = false;
                }
                else if (opts.cache.loadMode === 'cache') {
                    loadCache = true;
                }
                else {
                    throw new Error('GameWindow.loadFrame: unkown cache ' +
                                    'load mode: ' + opts.cache.loadMode);
                }
            }
            if (opts.cache.storeMode) {
                if (opts.cache.storeMode === 'off') {
                    storeCacheNow = false;
                    storeCacheLater = false;
                }
                else if (opts.cache.storeMode === 'onLoad') {
                    storeCacheNow = true;
                    storeCacheLater = false;
                }
                else if (opts.cache.storeMode === 'onClose') {
                    storeCacheNow = false;
                    storeCacheLater = true;
                }
                else {
                    throw new Error('GameWindow.loadFrame: unkown cache ' +
                                    'store mode: ' + opts.cache.storeMode);
                }
            }
        }

        // Parsing options.

        if ('undefined' !== typeof opts.autoParse) {
            if ('object' !== typeof opts.autoParse) {
                throw new TypeError('GameWindow.loadFrame: opts.autoParse ' +
                                    'must be object or undefined. Found: ' +
                                    opts.autoParse);
            }
            if ('undefined' !== typeof opts.autoParsePrefix) {
                if ('string' !== typeof opts.autoParsePrefix) {
                    throw new TypeError('GameWindow.loadFrame: opts.' +
                                        'autoParsePrefix must be string ' +
                                        'or undefined. Found: ' +
                                        opts.autoParsePrefix);
                }
                autoParsePrefix = opts.autoParsePrefix;
            }
            if ('undefined' !== typeof opts.autoParseMod) {
                if ('string' !== typeof opts.autoParseMod) {
                    throw new TypeError('GameWindow.loadFrame: opts.' +
                                        'autoParseMod must be string ' +
                                        'or undefined. Found: ' +
                                        opts.autoParseMod);
                }
                autoParseMod = opts.autoParseMod;
            }
            autoParse = opts.autoParse;
        }

        // Scroll Up.

        scrollUp = 'undefined' === typeof opts.scrollUp ? true : opts.scrollUp;

        // Store unprocessed uri parameter.
        this.unprocessedUri = uri;

        if (this.cacheSupported === null) {
            this.preCacheTest(function() {
                that.loadFrame(uri, func, opts);
            });
            return;
        }

        // Adapt the uri if necessary. Important! Must follow
        // the assignment to unprocessedUri AND preCacheTest.
        uri = this.processUri(uri);

        if (this.cacheSupported === false) {
            storeCacheNow = false;
            storeCacheLater = false;
            loadCache = false;
        }
        else {
            // If the last frame requested to be cached on closing, do that:
            lastURI = this.currentURIs[iframeName];

            if (this.cache.hasOwnProperty(lastURI) &&
                this.cache[lastURI].cacheOnClose) {

                frameDocumentElement = iframeDocument.documentElement;
                this.cache[lastURI].contents = frameDocumentElement.innerHTML;
            }

            // Create entry for this URI in cache object
            // and store cacheOnClose flag:
            if (!this.cache.hasOwnProperty(uri)) {
                this.cache[uri] = { contents: null, cacheOnClose: false };
            }
            this.cache[uri].cacheOnClose = storeCacheLater;

            // Disable loadCache if contents aren't cached:
            if (this.cache[uri].contents === null) loadCache = false;
        }

        // End loadFrame caching section.

        // Update frame's currently showing URI:
        this.currentURIs[iframeName] = uri;

        // Keep track of nested call to loadFrame.
        updateAreLoading(this, 1);

        // Hide iframe content while loading.
        // This way if the page is manipulated in the step callback,
        // the user still sees it appearing all at once.
        // The iframe visibility is reset by nodegame-client listener
        // on LOADED (avoiding registering two listeners this way.)
        iframe.style.visibility = 'hidden';

        // Add the onLoad event listener:
        if (!loadCache || !frameReady) {
            onLoad(iframe, function() {

                // Check if direct access to the content of the frame is
                // allowed. Usually IEs do not allow this. Notice, this
                // is different from preCaching, and that a newly
                // generated frame (about:blank) will always be accessible.
                if (that.directFrameDocumentAccess === null) {
                    testDirectFrameDocumentAccess(that);
                }

                // Handles caching.
                handleFrameLoad(that, uri, iframe, iframeName, loadCache,
                                storeCacheNow, function() {

                                    // Executes callback, autoParses,
                                    // and updates GameWindow state.
                                    that.updateLoadFrameState(func,
                                                              autoParse,
                                                              autoParseMod,
                                                              autoParsePrefix,
                                                              scrollUp);
                                });
            });
        }

        // Cache lookup:
        if (loadCache) {
            // Load iframe contents at this point only if the iframe is already
            // "ready" (see definition of frameReady), otherwise the contents
            // would be cleared once the iframe becomes ready. In that case,
            // iframe.onload handles the filling of the contents.
            if (frameReady) {
                // Handles caching.
                handleFrameLoad(this, uri, iframe, iframeName, loadCache,
                                storeCacheNow, function() {

                                    // Executes callback
                                    // and updates GameWindow state.
                                    that.updateLoadFrameState(func,
                                                              autoParse,
                                                              autoParseMod,
                                                              autoParsePrefix,
                                                              scrollUp);
                                });
            }
        }
        else {
            // Update the frame location:
            iframeWindow.location.replace(uri);
        }

        // Adding a reference to nodeGame also in the iframe.
        iframeWindow.node = node;
    };

    /**
     * ### GameWindow.processUri
     *
     * Parses a uri string and adds channel uri and prefix, if defined
     *
     * @param {string} uri The uri to process
     *
     * @return {string} uri The processed uri
     *
     * @see GameWindow.uriPrefix
     * @see GameWindow.uriChannel
     */
    GameWindow.prototype.processUri = function(uri) {
        if (uri.charAt(0) !== '/' && uri.substr(0,7) !== 'http://') {
            if (this.uriPrefix) uri = this.uriPrefix + uri;
            if (this.uriChannel) uri = this.uriChannel + uri;
        }
        return uri;
    };

    /**
     * ### GameWindow.updateLoadFrameState
     *
     * Sets window state after a new frame has been loaded
     *
     * The method performs the following operations:
     *
     * - decrements the counter of loading iframes
     * - executes a given callback function
     * - auto parses the elements specified (if any)
     * - set the window state as loaded (eventually)
     *
     * @param {function} func Optional. A callback function
     * @param {object} autoParse Optional. An object containing elements
     *    to replace in the HTML DOM.
     * @param {string} autoParseMod Optional. Modifier for search and replace
     * @param {string} autoParsePrefix Optional. Custom prefix to add to the
     *    keys of the elements in autoParse object
     * @param {boolean} scrollUp Optional. If TRUE, scrolls the page to the,
     *    top (if window.scrollTo is defined). Default: FALSE.
     *
     * @see GameWindow.searchReplace
     * @see updateAreLoading
     *
     * @emit FRAME_LOADED
     * @emit LOADED
     */
    GameWindow.prototype.updateLoadFrameState = function(func, autoParse,
                                                         autoParseMod,
                                                         autoParsePrefix,
                                                         scrollUp) {

        var loaded, stageLevel;
        loaded = updateAreLoading(this, -1);
        if (loaded) this.setStateLevel('LOADED');
        if (func) func.call(node.game);
        if (autoParse) {
            this.searchReplace(autoParse, autoParseMod, autoParsePrefix);
        }
        if (scrollUp && window.scrollTo) window.scrollTo(0,0);

        // ng event emitter is not used.
        node.events.ee.game.emit('FRAME_LOADED');
        node.events.ee.stage.emit('FRAME_LOADED');
        node.events.ee.step.emit('FRAME_LOADED');

        if (loaded) {
            stageLevel = node.game.getStageLevel();
            if (stageLevel === CB_EXECUTED) node.emit('LOADED');
        }
        else {
            node.silly('game-window: ' + this.areLoading + ' frames ' +
                       'still loading.');
        }
    };

    /**
     * ### GameWindow.clearPageBody
     *
     * Removes all HTML from body, and resets GameWindow
     *
     * @see GameWindow.reset
     */
    GameWindow.prototype.clearPageBody = function() {
        this.reset();
        document.body.innerHTML = '';
    };

    /**
     * ### GameWindow.clearPage
     *
     * Removes all HTML from page and resets GameWindow
     *
     * @see GameWindow.reset
     */
    GameWindow.prototype.clearPage = function() {
        this.reset();
        try {
            document.documentElement.innerHTML = '';
        }
        catch(e) {
            this.removeChildrenFromNode(document.documentElement);
        }
    };

    /**
     * ### GameWindow.setUriPrefix
     *
     * Sets the variable uriPrefix
     *
     * @see GameWindow.uriPrefix
     */
    GameWindow.prototype.setUriPrefix = function(uriPrefix) {
        if (uriPrefix !== null && 'string' !== typeof uriPrefix) {
            throw new TypeError('GameWindow.setUriPrefix: uriPrefix must be ' +
                                'string or null. Found: ' + uriPrefix);
        }
        this.conf.uriPrefix = this.uriPrefix = uriPrefix;
    };

    /**
     * ### GameWindow.setUriChannel
     *
     * Sets the variable uriChannel
     *
     * Trailing and preceding slashes are added if missing.
     *
     * @param {string|null} uriChannel The current uri of the channel,
     *   or NULL to delete it
     *
     * @see GameWindow.uriChannel
     */
    GameWindow.prototype.setUriChannel = function(uriChannel) {
        if ('string' === typeof uriChannel) {
            if (uriChannel.charAt(0) !== '/') uriChannel = '/' + uriChannel;
            if (uriChannel.charAt(uriChannel.length-1) !== '/') {
                uriChannel = uriChannel + '/';
            }
        }
        else if (uriChannel !== null) {
            throw new TypeError('GameWindow.uriChannel: uriChannel must be ' +
                                'string or null. Found: ' + uriChannel);
        }

        this.uriChannel = uriChannel;
    };

    /**
     * ### GameWindow.adjustFrameHeight
     *
     * Resets the min-height style of the iframe to fit its content properly
     *
     * Takes into the available height of the page, and the actual
     * content of the iframe, which is stretched to either:
     *
     *  - (almost) till the end of the page,
     *  - or to fit its content, if larger than page height (with scrollbar).
     *
     * @param {number} userMinHeight Optional. If set minHeight cannot be
     *   less than this value. Default: 0
     * @param {number} delay. If set, a timeout is created before the
     *   the frame is actually adjusted. Multiple calls will be
     *   evaluated only once at the end of a new timeout. Default: undefined
     *
     * @see W.willResizeFrame
     * @see W.adjustHeaderOffset
     */
    GameWindow.prototype.adjustFrameHeight = (function() {
        var nextTimeout, adjustIt;

        adjustIt = function(userMinHeight) {
            var iframe, minHeight, contentHeight;

            W.adjustHeaderOffset();

            iframe = W.getFrame();
            // Iframe might have been destroyed already, e.g. in a test.
            if (!iframe || !iframe.contentWindow) return;
            // Frame might be loading slowly, let's try again later.
            if (!iframe.contentWindow.document.body) {
                W.adjustFrameHeight(userMinHeight, 120);
                return;
            }


            if (W.conf.adjustFrameHeight === false) {
                minHeight = '100vh';
            }
            else {

                // Try to find out how tall the frame should be.
                minHeight = window.innerHeight || window.clientHeight;

                contentHeight = iframe.contentWindow.document.body.offsetHeight;
                // Rule of thumb.
                contentHeight += 60;

                if (W.headerPosition === "top") contentHeight += W.headerOffset;

                if (minHeight < contentHeight) minHeight = contentHeight;
                if (minHeight < (userMinHeight || 0)) minHeight = userMinHeight;
                minHeight += 'px';
            }

            // Adjust min-height based on content.
            iframe.style['min-height'] = minHeight;
        };

        return function(userMinHeight, delay) {
            if ('undefined' === typeof delay) {
                adjustIt(userMinHeight);
                return;
            }
            if (W.willResizeFrame) {
                nextTimeout = true;
                return;
            }
            W.willResizeFrame = setTimeout(function() {
                W.willResizeFrame = null;
                // If another timeout call was requested, do nothing now.
                if (nextTimeout) {
                    nextTimeout = false;
                    W.adjustFrameHeight(userMinHeight, delay);
                }
                else {
                    adjustIt(userMinHeight);
                }
            }, delay);
        };

    })();

    /**
     * ### GameWindow.adjustHeaderOffset
     *
     * Slides frame and/or infoPanel so that the header does not overlap
     *
     * Adjusts the CSS padding of the elements depending of the header
     * position, but only if the size of of the header has changed from
     * last time.
     *
     * @param {boolean} force Optional. If TRUE, padding is adjusted
     *   regardless of whether the size of the header has changed
     *   from last time
     *
     * @see W.headerOffset
     */
    GameWindow.prototype.adjustHeaderOffset = function(force) {
        var position, frame, header, infoPanel, offset, offsetPx;

        header = W.getHeader();
        position = W.headerPosition;

        // Do not apply padding if nothing has changed.
        if (!force &&
            (!header && W.headerOffset ||
             (position === "top" &&
              header.offsetHeight === W.headerOffset))) {

            return;
        }

        frame = W.getFrame();
        infoPanel = W.infoPanel;
        // No frame nor infoPanel, nothing to do.
        if (!frame && !infoPanel) return;

        switch(position) {
        case 'top':
            offset = header ? header.offsetHeight : 0;
            offsetPx = offset + 'px';
            if (infoPanel && infoPanel.isVisible) {
                infoPanel.infoPanelDiv.style['padding-top'] = offsetPx;
                frame.style['padding-top'] = 0;
            }
            else {
                if (infoPanel && infoPanel.infoPanelDiv) {
                    infoPanel.infoPanelDiv.style['padding-top'] = 0;
                }
                frame.style['padding-top'] = offsetPx;
            }
            break;
        case 'bottom':
            offset = header ? header.offsetHeight : 0;
            offsetPx = offset + 'px';
            frame.style['padding-bottom'] = offsetPx;
            if (infoPanel && infoPanel.infoPanelDiv) {
                infoPanel.infoPanelDiv.style['padding-top'] = 0;
            }
            break;
        case 'right':
            offset = header ? header.offsetWidth : 0;
            offsetPx = offset + 'px';
            if (frame) frame.style['padding-right'] = offsetPx;
            if (infoPanel && infoPanel.isVisible) {
                infoPanel.infoPanelDiv.style['padding-right'] = offsetPx;
            }
            break;
        case 'left':
            offset = header ? header.offsetWidth : 0;
            offsetPx = offset + 'px';
            if (frame) frame.style['padding-left'] = offsetPx;
            if (infoPanel && infoPanel.isVisible) {
                infoPanel.infoPanelDiv.style['padding-left'] = offsetPx;
            }
            break;
        default:
            // When header is destroyed, for example.
            if (position !== null) {
                throw new Error('GameWindow.adjustHeaderOffset: invalid ' +
                                'header position. Found: ' + position);
            }
            if (header) {
                throw new Error('GameWindow.adjustHeaderOffset: something ' +
                                'is wrong. Header found, but position is ' +
                                'null.');
            }
            // Remove all padding.
            if (frame) frame.style.padding = 0;
            if (infoPanel && infoPanel.infoPanelDiv) {
                infoPanel.infoPanelDiv.padding = 0;
            }
        }

        // Store the value of current offset.
        W.headerOffset = offset;
    };


    // ## Helper functions

    /**
     * ### handleFrameLoad
     *
     * Handles iframe contents loading
     *
     * A helper method of GameWindow.loadFrame.
     * Puts cached contents into the iframe or caches new contents if requested.
     * Handles reloading of script tags and injected libraries.
     * Must be called with the current GameWindow instance.
     * Updates the references to _frameWindow_ and _frameDocument_ if the
     * iframe name is equal to _frameName_.
     *
     * @param {GameWindow} that The GameWindow instance
     * @param {uri} uri URI to load
     * @param {iframe} iframe The target iframe
     * @param {string} frameName ID of the iframe
     * @param {bool} loadCache Whether to load from cache
     * @param {bool} storeCache Whether to store to cache
     * @param {function} func Callback
     *
     * @see GameWindow.loadFrame
     *
     * @api private
     */
    function handleFrameLoad(that, uri, iframe, frameName, loadCache,
                             storeCache, func) {

        var iframeDocumentElement;
        var afterScripts;

        // Needed for IE8.
        iframe = W.getElementById(frameName);
        iframeDocumentElement = W.getIFrameDocument(iframe).documentElement;

        if (loadCache) {
            // Load frame from cache:
            iframeDocumentElement.innerHTML = that.cache[uri].contents;
        }

        // Update references to frameWindow and frameDocument
        // if this was the frame of the game.
        if (frameName === that.frameName) {
            that.frameWindow = iframe.contentWindow;
            that.frameDocument = that.getIFrameDocument(iframe);
            // Disable right click in loaded iframe document, if necessary.
            if (that.conf.rightClickDisabled) {
                J.disableRightClick(that.frameDocument);
            }
            // Track onkeydown Escape.
            if (that.conf.noEscape) {
                that.frameDocument.onkeydown = document.onkeydown;
            }
        }

        // Remove on-the-fly style element reference.
        that.styleElement = null;

        // (Re-)Inject libraries and reload scripts:
        removeLibraries(iframe);
        afterScripts = function() {
            injectLibraries(iframe, that.globalLibs.concat(
                that.frameLibs.hasOwnProperty(uri) ? that.frameLibs[uri] : []));

            if (storeCache) {
                // Store frame in cache:
                that.cache[uri].contents = iframeDocumentElement.innerHTML;
            }

            func();

            adjustFrameHeightAfterLoad();

        };

        if (loadCache) reloadScripts(iframe, afterScripts);
        else afterScripts();
    }

    /**
     * ### removeLibraries
     *
     * Removes injected scripts from iframe
     *
     * Takes out all the script tags with the className "injectedlib"
     * that were inserted by injectLibraries.
     *
     * @param {HTMLIFrameElement} iframe The target iframe
     *
     * @see injectLibraries
     *
     * @api private
     */
    function removeLibraries(iframe) {
        var idx;
        var contentDocument;
        var scriptNodes, scriptNode;

        contentDocument = W.getIFrameDocument(iframe);

        // Old IEs do not have getElementsByClassName.
        scriptNodes = W.getElementsByClassName(contentDocument, 'injectedlib',
                                               'script');

        // It was. To check.
        // scriptNodes = contentDocument.getElementsByClassName('injectedlib');
        for (idx = 0; idx < scriptNodes.length; idx++) {
            scriptNode = scriptNodes[idx];
            scriptNode.parentNode.removeChild(scriptNode);
        }
    }

    /**
     * ### reloadScripts
     *
     * Reloads all script nodes in iframe
     *
     * Deletes and reinserts all the script tags, effectively reloading the
     * scripts. The placement of the tags can change, but the order is kept.
     *
     * @param {HTMLIFrameElement} iframe The target iframe
     * @param {function} func Callback
     *
     * @api private
     */
    function reloadScripts(iframe, func) {
        var contentDocument;
        var headNode;
        var tag, scriptNodes, scriptNodeIdx, scriptNode;
        var attrIdx, attr;
        var numLoading;
        var needsLoad;

        contentDocument = W.getIFrameDocument(iframe);
        headNode = W.getIFrameAnyChild(iframe);

        // Start counting loading tags at 1 instead of 0 and decrement the
        // count after the loop.
        // This way the callback cannot be called before the loop finishes.
        numLoading = 1;

        scriptNodes = contentDocument.getElementsByTagName('script');
        for (scriptNodeIdx = 0; scriptNodeIdx < scriptNodes.length;
             scriptNodeIdx++) {

            // Remove tag:
            tag = scriptNodes[scriptNodeIdx];
            tag.parentNode.removeChild(tag);

            // Reinsert tag for reloading:
            scriptNode = document.createElement('script');
            if (tag.innerHTML) scriptNode.innerHTML = tag.innerHTML;
            needsLoad = false;
            for (attrIdx = 0; attrIdx < tag.attributes.length; attrIdx++) {
                attr = tag.attributes[attrIdx];
                scriptNode.setAttribute(attr.name, attr.value);
                if (attr.name === 'src') needsLoad = true;
            }
            if (needsLoad) {
                //scriptNode.async = true;
                ++numLoading;
                scriptNode.onload = function(sn) {
                    return function() {
                        sn.onload = null;
                        --numLoading;
                        if (numLoading <= 0) func();
                    };
                }(scriptNode);
            }
            headNode.appendChild(scriptNode);
        }
        --numLoading;
        if (numLoading <= 0) func();
    }

    /**
     * ### injectLibraries
     *
     * Injects scripts into the iframe
     *
     * Inserts `<script class="injectedlib" src="...">` lines into given
     * iframe object, one for every given library.
     *
     * @param {HTMLIFrameElement} iframe The target iframe
     * @param {array} libs An array of strings giving the "src" attribute for
     *   the `<script>` lines to insert
     *
     * @api private
     */
    function injectLibraries(iframe, libs) {
        var headNode;
        var scriptNode;
        var libIdx, lib;

        headNode = W.getIFrameAnyChild(iframe);

        for (libIdx = 0; libIdx < libs.length; libIdx++) {
            lib = libs[libIdx];
            scriptNode = document.createElement('script');
            scriptNode.className = 'injectedlib';
            scriptNode.src = lib;
            headNode.appendChild(scriptNode);
        }
    }

    /**
     * ### updateAreLoading
     *
     * Updates the counter of loading frames
     *
     * @param {GameWindow} that A reference to the GameWindow instance
     * @param {number} update The number to add to the counter
     *
     * @api private
     */
    function updateAreLoading(that, update) {
        that.areLoading = that.areLoading + update;
        return that.areLoading === 0;
    }

    /**
     * ### adaptFrame2HeaderPosition
     *
     * Sets a CSS class to the frame element depending on the header position
     *
     * The frame element must exists or an error will be thrown.
     *
     * @param {string} oldHeaderPos Optional. The previous position of the
     *   header
     *
     * @api private
     */
    function adaptFrame2HeaderPosition(oldHeaderPos) {
        var position, frame, header;

        frame = W.getFrame();
        if (!frame) return;

        header = W.getHeader();

        // If no header is found, simulate the 'top' position
        // to better fit the whole screen.
        position = W.headerPosition || 'top';

        // When we move from bottom to any other configuration,
        // we need to move the header before the frame.
        if (oldHeaderPos === 'bottom' && position !== 'bottom') {
            W.getFrameRoot().insertBefore(W.headerElement, frame);
        }

        W.removeClass(frame, 'ng_mainframe-header-[a-z-]*');
        switch(position) {
        case 'right':
            W.addClass(frame, 'ng_mainframe-header-vertical-r');
            break;
        case 'left':
            W.addClass(frame, 'ng_mainframe-header-vertical-l');
            break;
        case 'top':
            W.addClass(frame, 'ng_mainframe-header-horizontal-t');
            if (header) W.getFrameRoot().insertBefore(header, frame);
            break;
        case 'bottom':
            W.addClass(frame, 'ng_mainframe-header-horizontal-b');
            if (header) {
                W.getFrameRoot().insertBefore(header, frame.nextSibling);
            }
            break;
        }
    }

    /**
     * ### testDirectFrameDocumentAccess
     *
     * Tests whether the content of the frameDocument can be accessed directly
     *
     * The value of the test is stored under `directFrameDocumentAccess`.
     *
     * Some IEs give 'Permission denied' when accessing the frame document
     * directly. In such a case, we need to re-get it from the DOM.
     *
     * @param {GameWindow} that This instance
     *
     * @see GameWindow.directFrameDocumentAccess
     */
    function testDirectFrameDocumentAccess(that) {
        try {
            that.frameDocument.getElementById('test');
            that.directFrameDocumentAccess = true;
        }
        catch(e) {
            that.directFrameDocumentAccess = false;
        }
    }

    /**
     * ### adjustFrameHeightAfterLoad
     *
     * Adjusts the frame height after frame is loaded
     *
     * It waits 120ms or until all images are loaded.
     *
     * @see handleFrameLoad
     */
    function adjustFrameHeightAfterLoad() {

        // Kudos:
        // https://stackoverflow.com/questions/11071314/
        // javascript-execute-after-all-images-have-loaded

        var doc, imgs, len, counter, increment;
        doc = W.getFrameDocument();
        if (doc) {
            imgs = doc.images;
            len = imgs.length;
        }

        // If there are no images, we wait a fixed 120 milliseconds.
        if (!len) {
            // Important. We need a timeout (2nd param), because some changes
            // might take time to be reflected in the DOM.
            W.adjustFrameHeight(0, 120);
            return;
        }

        // Else we wait until all images are loaded.
        counter = 0;
        increment = function() {
            if (++counter === len) W.adjustFrameHeight();
        };

        [].forEach.call(imgs, function(img) {
            if (img.complete) increment();
            else img.addEventListener('load', increment, false);
        });
    }

    //Expose GameWindow prototype to the global object.
    node.GameWindow = GameWindow;

})(
    // GameWindow works only in the browser environment. The reference
    // to the node.js module object is for testing purpose only
    ('undefined' !== typeof window) ? window : module.parent.exports.window,
    ('undefined' !== typeof window) ? window.node : module.parent.exports.node
);

/**
 * # setup.window
 * Copyright(c) 2017 Stefano Balietti
 * MIT Licensed
 *
 * GameWindow setup functions
 *
 * http://www.nodegame.org
 */
(function(window, node) {

    var GameWindow = node.GameWindow;

    /**
     * ### GameWindow.addDefaultSetups
     *
     * Registers setup functions for GameWindow, the frame and the header
     */
    GameWindow.prototype.addDefaultSetups = function() {

        /**
         * ### node.setup.window
         *
         * Setup handler for the node.window object
         *
         * @see node.setup
         */
        node.registerSetup('window', function(conf) {
            this.window.init(conf);
            return conf;
        });

        /**
         * ### node.setup.page
         *
         * Manipulates the HTML page
         *
         * @see node.setup
         */
        node.registerSetup('page', function(conf) {
            var tmp, body;
            if (!conf) return;

            // Clear.
            if (conf.clearBody) this.window.clearPageBody();
            if (conf.clear) this.window.clearPage();
            if ('string' === typeof conf.title) {
                conf.title = { title: conf.title };
            }
            if ('object' === typeof conf.title) {
                // TODO: add option to animate it.
                document.title = conf.title.title;
                if (conf.title.addToBody) {
                    tmp = document.createElement('h1');
                    tmp.className = 'ng-page-title';
                    tmp.innerHTML = conf.title.title;
                    body = document.body;
                    if (body.innerHTML === '') body.appendChild(tmp);
                    else body.insertBefore(tmp, body.firstChild);
                }
            }
            return conf;
        });

        /**
         * ### node.setup.frame
         *
         * Manipulates the frame object
         *
         * @see node.setup
         */
        node.registerSetup('frame', function(conf) {
            var url, cb, options;
            var frameName, force, root, rootName;
            if (!conf) return;

            // Generate.
            if (conf.generate) {
                if ('object' === typeof conf.generate) {
                    if (conf.generate.root) {
                        if ('string' !== typeof conf.generate.root) {
                            node.warn('node.setup.frame: conf.generate.root ' +
                                      'must be string or undefined.');
                            return;
                        }
                        rootName = conf.generate.root;
                        force = conf.generate.force;
                        frameName = conf.generate.name;
                    }
                }
                else {
                    node.warn('node.setup.frame: conf.generate must be ' +
                              'object or undefined.');
                    return;
                }

                root = this.window.getElementById(rootName);
                if (!root) root = this.window.getScreen();
                if (!root) {
                    node.warn('node.setup.frame: could not find valid ' +
                              'root element to generate new frame.');
                    return;
                }

                this.window.generateFrame(root, frameName, force);
            }

            // Uri prefix.
            if ('undefined' !== typeof conf.uriPrefix) {
                this.window.setUriPrefix(conf.uriPrefix);
            }

            // Load.
            if (conf.load) {
                if ('object' === typeof conf.load) {
                    url = conf.load.url;
                    cb = conf.load.cb;
                    options = conf.load.options;
                }
                else if ('string' === typeof conf.load) {
                    url = conf.load;
                }
                else {
                    node.warn('node.setup.frame: conf.load must be string, ' +
                              'object or undefined.');
                    return;
                }
                this.window.loadFrame(url, cb, options);
            }

            // Clear and destroy.
            if (conf.clear) this.window.clearFrame();
            if (conf.destroy) this.window.destroyFrame();

            return conf;
        });

        /**
         * ### node.setup.header
         *
         * Manipulates the header object
         *
         * @see node.setup
         */
        node.registerSetup('header', function(conf) {
            var headerName, force, root, rootName;
            if (!conf) return;

            // Generate.
            if (conf.generate) {
                if ('object' === typeof conf.generate) {
                    if (conf.generate.root) {
                        if ('string' !== typeof conf.generate.root) {
                            node.warn('node.setup.header: conf.generate.root ' +
                                      'must be string or undefined.');
                            return;
                        }
                        rootName = conf.generate.root;
                        force = conf.generate.force;
                        headerName = conf.generate.name;
                    }
                }
                else {
                    node.warn('node.setup.header: conf.generate must be ' +
                              'object or undefined.');
                    return;
                }

                root = this.window.getElementById(rootName);
                if (!root) root = this.window.getScreen();
                if (!root) {
                    node.warn('node.setup.header: could not find valid ' +
                              'root element to generate new header.');
                    return;
                }

                this.window.generateHeader(root, headerName, force);
            }

            // Position.
            if (conf.position) {
                if ('string' !== typeof conf.position) {
                    node.warn('node.setup.header: conf.position ' +
                              'must be string or undefined.');
                    return;
                }
                this.window.setHeaderPosition(conf.position);
            }

            // Clear and destroy.
            if (conf.clear) this.window.clearHeader();
            if (conf.destroy) this.window.destroyHeader();

            return conf;
        });

    };
})(
    // GameWindow works only in the browser environment. The reference
    // to the node.js module object is for testing purpose only
    ('undefined' !== typeof window) ? window : module.parent.exports.window,
    ('undefined' !== typeof window) ? window.node : module.parent.exports.node
);

/**
 * # ui-behavior
 * Copyright(c) 2015 Stefano Balietti
 * MIT Licensed
 *
 * GameWindow UI Behavior module
 *
 * Handles default behavior of the browser on certain DOM Events.
 *
 * http://www.nodegame.org
 */
(function(window, node) {

    "use strict";

    var GameWindow = node.GameWindow;
    var J = node.JSUS;

    /**
     * ### GameWindow.noEscape
     *
     * Binds the ESC key to a function that always returns FALSE
     *
     * This prevents socket.io to break the connection with the server.
     */
    GameWindow.prototype.noEscape = function() {
        var frameDocument;
        // AddEventListener seems not to work
        // as it does not stop other listeners.
        window.document.onkeydown = function(e) {
            var keyCode = (window.event) ? event.keyCode : e.keyCode;
            if (keyCode === 27) return false;
        };
        frameDocument = this.getFrameDocument();
        if (frameDocument) frameDocument.onkeydown = window.document.onkeydown;
        this.conf.noEscape = true;
    };

    /**
     * ### GameWindow.restoreEscape
     *
     * Removes the the listener on the ESC key
     *
     * @see GameWindow.noEscape
     */
    GameWindow.prototype.restoreEscape = function() {
        var frameDocument;
        window.document.onkeydown = null;
        frameDocument = this.getFrameDocument();
        if (frameDocument) frameDocument.onkeydown = null;
        this.conf.noEscape = false;
    };

    /**
     * ### GameWindow.promptOnleave
     *
     * Displays a confirmation box upon closing the window or tab
     *
     * Listens on the onbeforeunload event.
     *
     * @param {object} windowObj Optional. The window container in which
     *   to bind the ESC key
     * @param {string} text Optional. A text to be displayed with the alert
     *
     * @see https://developer.mozilla.org/en/DOM/window.onbeforeunload
     */
    GameWindow.prototype.promptOnleave = function(windowObj, text) {
        windowObj = windowObj || window;
        text = 'undefined' !== typeof text ? text : this.conf.promptOnleaveText;

        windowObj.onbeforeunload = function(e) {
            e = e || window.event;
            // For IE<8 and Firefox prior to version 4
            if (e) {
                e.returnValue = text;
            }
            // For Chrome, Safari, IE8+ and Opera 12+
            return text;
        };

        this.conf.promptOnleave = true;
    };

    /**
     * ### GameWindow.restoreOnleave
     *
     * Removes the onbeforeunload event listener
     *
     * @param {object} windowObj Optional. The window container in which
     *   to bind the ESC key
     *
     * @see GameWindow.promptOnleave
     * @see https://developer.mozilla.org/en/DOM/window.onbeforeunload
     */
    GameWindow.prototype.restoreOnleave = function(windowObj) {
        windowObj = windowObj || window;
        windowObj.onbeforeunload = null;
        this.conf.promptOnleave = false;
    };

    /**
     * ### GameWindow.disableRightClick
     *
     * Disables the right click in the main page and in the iframe, if found
     *
     * @see GameWindow.enableRightClick
     * @see JSUS.disableRightClick
     */
    GameWindow.prototype.disableRightClick = function() {
        if (this.frameElement) {
            J.disableRightClick(this.getFrameDocument());
        }
        J.disableRightClick(document);
        this.conf.rightClickDisabled = true;
    };

    /**
     * ### GameWindow.enableRightClick
     *
     * Enables the right click in the main page and in the iframe, if found
     *
     * @see GameWindow.disableRightClick
     * @see JSUS.enableRightClick
     */
    GameWindow.prototype.enableRightClick = function() {
        if (this.frameElement) {
             J.enableRightClick(this.getFrameDocument());
        }
        J.enableRightClick(document);
        this.conf.rightClickDisabled = false;
    };

    /**
     * ### GameWindow.disableBackButton
     *
     * Disables/re-enables backward navigation in history of browsed pages
     *
     * When disabling, it inserts twice the current url.
     *
     * @param {boolean} disable Optional. If TRUE disables back button,
     *   if FALSE, re-enables it. Default: TRUE.
     *
     * @see JSUS.disableBackButton
     */
    GameWindow.prototype.disableBackButton = function(disable) {
        this.conf.backButtonDisabled = J.disableBackButton(disable);
    };

})(
    // GameWindow works only in the browser environment. The reference
    // to the node.js module object is for testing purpose only
    ('undefined' !== typeof window) ? window : module.parent.exports.window,
    ('undefined' !== typeof window) ? window.node : module.parent.exports.node
);

/**
 * # lockScreen
 * Copyright(c) 2015 Stefano Balietti
 * MIT Licensed
 *
 * Locks / Unlocks the screen
 *
 * The _screen_ represents all the user can see on screen.
 * It includes the _frame_ area, but also the _header_.
 *
 * http://www.nodegame.org
 */
(function(window, node) {

    "use strict";

    var GameWindow = node.GameWindow;
    var screenLevels = node.constants.screenLevels;

    /**
     * ### GameWindow.lockScreen
     *
     * Locks the screen by opening the waitScreen widget on top
     *
     * Requires the waitScreen widget to be loaded.
     *
     * @param {string} text Optional. The text to be shown in the locked screen
     * @param {number} countdown Optional. The expected max total time the
     *   the screen will stay locked (in ms). A countdown will be displayed
     *
     * @see WaitScreen.lock
     * TODO: check if this can be called in any stage.
     */
    GameWindow.prototype.lockScreen = function(text, countdown) {
        if (!this.waitScreen) {
            throw new Error('GameWindow.lockScreen: waitScreen not found');
        }
        if (text && 'string' !== typeof text) {
            throw new TypeError('GameWindow.lockScreen: text must be string ' +
                                'or undefined. Found: ' + text);
        }
        if (countdown && 'number' !== typeof countdown || countdown < 0) {
            throw new TypeError('GameWindow.lockScreen: countdown must be ' +
                                'a positive number or undefined. Found: ' +
                                countdown);
        }
        this.setScreenLevel('LOCKING');
        this.waitScreen.lock(text, countdown);
        this.setScreenLevel('LOCKED');
    };

    /**
     * ### GameWindow.unlockScreen
     *
     * Unlocks the screen by removing the waitScreen widget on top
     *
     * Requires the waitScreen widget to be loaded.
     */
    GameWindow.prototype.unlockScreen = function() {
        if (!this.waitScreen) {
            throw new Error('GameWindow.unlockScreen: waitScreen not found.');
        }
        if (!this.isScreenLocked()) {
            throw new Error('GameWindow.unlockScreen: screen is not locked.');
        }
        this.setScreenLevel('UNLOCKING');
        this.waitScreen.unlock();
        this.setScreenLevel('ACTIVE');
    };

    /**
     * ### GameWindow.isScreenLocked
     *
     * Checks whether the screen is locked
     *
     * @return {boolean} TRUE if the screen is locked
     *
     * @see GameWindow.screenState
     */
    GameWindow.prototype.isScreenLocked = function() {
        return this.getScreenLevel() !== screenLevels.ACTIVE;
    };
})(
    // GameWindow works only in the browser environment. The reference
    // to the node.js module object is for testing purpose only
    ('undefined' !== typeof window) ? window : module.parent.exports.window,
    ('undefined' !== typeof window) ? window.node : module.parent.exports.node
);

/**
 * # listeners
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * GameWindow listeners
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    // var J = node.JSUS;

    // function getElement(idOrObj, prefix) {
    //     var el;
    //     if ('string' === typeof idOrObj) {
    //         el = W.getElementById(idOrObj);
    //     }
    //     else if (J.isElement(idOrObj)) {
    //         el = idOrObj;
    //     }
    //     else {
    //         throw new TypeError(prefix + ': idOrObj must be string ' +
    //                             ' or HTML Element.');
    //     }
    //     return el;
    // }

    var GameWindow = node.GameWindow;

    /**
     * ## GameWindow.addDefaultListeners
     *
     * Adds a battery of event listeners for incoming messages
     *
     * If executed once, it requires a force flag to re-add the listeners
     *
     * @param {boolean} force Whether to force re-adding the listeners
     * @return {boolean} TRUE on success
     */
    GameWindow.prototype.addDefaultListeners = function(force) {

        if (this.listenersAdded && !force) {
            node.err('node.window.addDefaultListeners: listeners already ' +
                     'added once. Use the force flag to re-add.');
            return false;
        }

        node.on('NODEGAME_GAME_CREATED', function() {
            W.init(node.conf.window);
        });

//         node.on('HIDE', function(idOrObj) {
//             var el;
//             console.log('***GameWindow.on.HIDE is deprecated. Use ' +
//                         'GameWindow.hide() instead.***');
//             el = getElement(idOrObj, 'GameWindow.on.HIDE');
//             if (el) el.style.display = 'none';
//         });
//
//         node.on('SHOW', function(idOrObj) {
//             var el;
//             console.log('***GameWindow.on.SHOW is deprecated. Use ' +
//                         'GameWindow.show() instead.***');
//             el = getElement(idOrObj, 'GameWindow.on.SHOW');
//             if (el) el.style.display = '';
//         });
//
//         node.on('TOGGLE', function(idOrObj) {
//             var el;
//             console.log('***GameWindow.on.TOGGLE is deprecated. Use ' +
//                         'GameWindow.toggle() instead.***');
//             el = getElement(idOrObj, 'GameWindow.on.TOGGLE');
//             if (el) {
//                 if (el.style.display === 'none') {
//                     el.style.display = '';
//                 }
//                 else {
//                     el.style.display = 'none';
//                 }
//             }
//         });

        // Disable all the input forms found within a given id element.
        node.on('INPUT_DISABLE', function(id) {
            W.toggleInputs(id, true);
        });

        // Disable all the input forms found within a given id element.
        node.on('INPUT_ENABLE', function(id) {
            W.toggleInputs(id, false);
        });

        // Disable all the input forms found within a given id element.
        node.on('INPUT_TOGGLE', function(id) {
            W.toggleInputs(id);
        });

        /**
         * Force disconnection upon page unload
         *
         * This makes browsers using AJAX to signal disconnection immediately.
         *
         * Kudos:
         * http://stackoverflow.com/questions/1704533/intercept-page-exit-event
         */
        window.onunload = function() {
            var i;
            node.socket.disconnect();
            // Do nothing, but gain time.
            for (i = -1 ; ++i < 100000 ; ) { }
        };

        // Mark listeners as added.
        this.listenersAdded = true;

        node.silly('node-window: listeners added.');
        return true;
    };

})(
    'undefined' !== typeof node ? node : undefined
);

/**
 * # WaitScreen
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Overlays the screen, disables inputs, and displays a message/timer
 *
 * www.nodegame.org
 */
(function(exports, window) {

    "use strict";

    // Append under window.node.
    exports.WaitScreen = WaitScreen;

    // ## Meta-data

    WaitScreen.version = '0.10.0';
    WaitScreen.description = 'Shows a waiting screen';

    // ## Helper functions

    var inputTags, len;
    inputTags = [ 'button', 'select', 'textarea', 'input' ];
    len = inputTags.length;

    /**
     * ### lockUnlockedInputs
     *
     * Scans a container HTML Element for active input tags and disables them
     *
     * Stores a references into W.waitScreen.lockedInputs so that they can
     * be re-activated later.
     *
     * @param {Document|Element} container The target to scan for input tags
     * @param {boolean} disable Optional. Lock inputs if TRUE, unlock if FALSE.
     *   Default: TRUE
     *
     * @api private
     */
    function lockUnlockedInputs(container, disable) {
        var j, i, inputs, nInputs;

        if ('undefined' === typeof disable) disable = true;

        for (j = -1; ++j < len; ) {
            inputs = container.getElementsByTagName(inputTags[j]);
            nInputs = inputs.length;
            for (i = -1 ; ++i < nInputs ; ) {
                if (disable) {
                    if (!inputs[i].disabled) {
                        inputs[i].disabled = true;
                        W.waitScreen.lockedInputs.push(inputs[i]);
                    }
                }
                else {
                    if (inputs[i].disabled) {
                        inputs[i].disabled = false;
                    }
                }
            }
        }

        if (!disable) W.waitScreen.lockedInputs = [];
    }

    function event_REALLY_DONE(text) {
        var countdown;
        text = text || W.waitScreen.defaultTexts.waiting;
        if (!node.game.shouldStep()) {
            if (W.isScreenLocked()) {
                W.waitScreen.updateText(text);
            }
            else {
                if (node.game.timer.milliseconds) {
                    // 2000 to make sure it does reach 0 and stays there.
                    countdown = node.game.timer.milliseconds -
                        node.timer.getTimeSince('step', true) + 2000;
                    if (countdown < 0) countdown = 0;
                }
                W.lockScreen(text, countdown);
            }
        }
    }

    function event_STEPPING() {
        var text;
        text = W.waitScreen.defaultTexts.stepping;
        if (W.isScreenLocked()) W.waitScreen.updateText(text);
        else W.lockScreen(text);
    }

    function event_PLAYING() {
        if (W.isScreenLocked()) W.unlockScreen();
    }

    function event_PAUSED(text) {
        text = text || W.waitScreen.defaultTexts.paused;
        if (W.isScreenLocked()) {
            W.waitScreen.beforePauseInnerHTML =
                W.waitScreen.contentDiv.innerHTML;
            W.waitScreen.updateText(text);
        }
        else {
            W.lockScreen(text);
        }
    }

    function event_RESUMED() {
        if (W.isScreenLocked()) {
            if (W.waitScreen.beforePauseInnerHTML !== null) {
                W.waitScreen.updateText(W.waitScreen.beforePauseInnerHTML);
                W.waitScreen.beforePauseInnerHTML = null;
            }
            else {
                W.unlockScreen();
            }
        }
    }

    /**
     * ## WaitScreen constructor
     *
     * Instantiates a new WaitScreen object
     *
     * @param {object} opts Optional. Configuration options
     */
    function WaitScreen(opts) {
        opts = opts || {};

        /**
         * ### WaitScreen.id
         *
         * The id of _waitingDiv_. Default: 'ng_waitScreen'
         *
         * @see WaitScreen.waitingDiv
         */
        this.id = opts.id || 'ng_waitScreen';

        /**
         * ### WaitScreen.root
         *
         * Reference to the root element under which _waitingDiv is appended
         *
         * @see WaitScreen.waitingDiv
         */
        this.root = opts.root || null;

        /**
         * ### WaitScreen.waitingDiv
         *
         * Reference to the HTML Element that actually locks the screen
         */
        this.waitingDiv = null;

        /**
         * ### WaitScreen.beforePauseText
         *
         * Flag if the screen should stay locked after a RESUMED event
         *
         * Contains the value of the innerHTML attribute of the waiting div.
         */
        this.beforePauseInnerHTML = null;

        /**
         * ### WaitScreen.enabled
         *
         * Flag is TRUE if the listeners are registered
         *
         * @see WaitScreen.enable
         */
        this.enabled = false;

        /**
         * ### WaitScreen.contentDiv
         *
         * Div containing the main content of the wait screen
         */
        this.contentDiv = null;

        /**
         * ### WaitScreen.countdownDiv
         *
         * Div containing the countdown span and other text
         *
         * @see WaitScreen.countdown
         * @see WaitScreen.countdownSpan
         */
        this.countdownDiv = null;

        /**
         * ### WaitScreen.countdownSpan
         *
         * Span containing a countdown timer for the max waiting
         *
         * @see WaitScreen.countdown
         * @see WaitScreen.countdownDiv
         */
        this.countdownSpan = null;

        /**
         * ### WaitScreen.countdown
         *
         * Countdown of max waiting time
         */
        this.countdown = null;

        /**
         * ### WaitScreen.displayCountdown
         *
         * If FALSE, countdown is never displayed by lock
         *
         * @see WaitScreen.lock
         */
        this.displayCountdown =
            'undefined' !== typeof opts.displayCountdown ?
                !!opts.displayCountdown : true;

        /**
         * ### WaitScreen.text
         *
         * Default texts for default events
         */
        this.defaultTexts = {

            // Default text for locked screen.
            locked: opts.lockedText ||
                'Screen locked. Please wait...',

            // When player is DONE and waiting for others.
            waiting: opts.waitingText ||
                'Waiting for other players to be done...',

            // When entering a new step after DONE (displayed quickly usually).
            stepping: opts.steppingText ||
                'Initializing game step, will be ready soon...',

            // Game paused.
            paused: opts.pausedText ||
                'Game is paused. Please wait.',

            // Countdown text displayed under waiting text.
            countdown: opts.countdownResumingText ||
                '<br>Do not refresh the page!<br>Maximum Waiting Time: ',

            // Displayed after resuming from waiting.
            countdownResuming: opts.countdownResumingText ||
                'Resuming soon...',

            // Formats the countdown in minutes and seconds.
            formatCountdown: function(time) {
                var out;
                out = '';
                time = J.parseMilliseconds(time);
                if (time[2]) out += time[2] + ' min ';
                if (time[3]) out += time[3] + ' sec';
                return out || 0;
            }
        };

        /**
         * ## WaitScreen.lockedInputs
         *
         * List of locked inputs by the _lock_ method
         *
         * @see WaitScreen.lock
         */
        this.lockedInputs = [];

        // Registers the event listeners.
        this.enable();
    }

    /**
     * ### WaitScreen.enable
     *
     * Registers default event listeners
     */
    WaitScreen.prototype.enable = function() {
        if (this.enabled) return;
        node.events.ee.game.on('REALLY_DONE', event_REALLY_DONE);
        node.events.ee.game.on('STEPPING', event_STEPPING);
        node.events.ee.game.on('PLAYING', event_PLAYING);
        node.events.ee.game.on('PAUSED', event_PAUSED);
        node.events.ee.game.on('RESUMED', event_RESUMED);
        this.enabled = true;
    };

    /**
     * ### WaitScreen.disable
     *
     * Unregisters default event listeners
     */
    WaitScreen.prototype.disable = function() {
        if (!this.enabled) return;
        node.events.ee.game.off('REALLY_DONE', event_REALLY_DONE);
        node.events.ee.game.off('STEPPING', event_STEPPING);
        node.events.ee.game.off('PLAYING', event_PLAYING);
        node.events.ee.game.off('PAUSED', event_PAUSED);
        node.events.ee.game.off('RESUMED', event_RESUMED);
        this.enabled = false;
    };

    /**
     * ### WaitScreen.lock
     *
     * Locks the screen
     *
     * Overlays a gray div on top of the page and disables all inputs
     *
     * If called on an already locked screen, the previous text is destroyed.
     * Use `WaitScreen.updateText` to modify an existing text.
     *
     * @param {string} text Optional. If set, displays the text on top of the
     *   gray string
     * @param {number} countdown Optional. The expected max total time the
     *   the screen will stay locked (in ms). A countdown will be displayed,
     *   at the end of which a text replaces the countdown, but the screen
     *   stays locked until the unlock command is received.
     *
     * @see WaitScreen.unlock
     * @see WaitScren.updateText
     */
    WaitScreen.prototype.lock = function(text, countdown) {
        var frameDoc, t;
        t = this.defaultTexts;
        if ('undefined' === typeof text) text = t.locked;
        if ('undefined' === typeof document.getElementsByTagName) {
            node.warn('WaitScreen.lock: cannot lock inputs');
        }
        // Disables all input forms in the page.
        lockUnlockedInputs(document);

        frameDoc = W.getFrameDocument();
        if (frameDoc) lockUnlockedInputs(frameDoc);

        if (!this.waitingDiv) {
            if (!this.root) {
                this.root = W.getFrameRoot() || document.body;
            }
            this.waitingDiv = W.add('div', this.root, this.id);

            this.contentDiv = W.add('div', this.waitingDiv,
                                    'ng_waitscreen-content-div');
        }
        if (this.waitingDiv.style.display === 'none') {
            this.waitingDiv.style.display = '';
        }
        this.contentDiv.innerHTML = text;

        if (this.displayCountdown && countdown) {

            if (!this.countdownDiv) {
                this.countdownDiv = W.add('div', this.waitingDiv,
                                          'ng_waitscreen-countdown-div');

                this.countdownDiv.innerHTML = t.countdown;

                this.countdownSpan = W.add('span', this.countdownDiv,
                                           'ng_waitscreen-countdown-span');
            }

            this.countdown = countdown;
            this.countdownSpan.innerHTML = t.formatCountdown(countdown);
            this.countdownDiv.style.display = '';

            this.countdownInterval = setInterval(function() {
                var w;
                w = W.waitScreen;
                if (!W.isScreenLocked()) {
                    clearInterval(w.countdownInterval);
                    return;
                }

                w.countdown -= 1000;
                if (w.countdown < 0) {
                    clearInterval(w.countdownInterval);
                    w.countdownDiv.style.display = 'none';
                    w.contentDiv.innerHTML = t.countdownResuming;
                }
                else {
                    w.countdownSpan.innerHTML = t.formatCountdown(w.countdown);
                }
            }, 1000);
        }
        else if (this.countdownDiv) {
            this.countdownDiv.style.display = 'none';
        }
    };

    /**
     * ### WaitScreen.unlock
     *
     * Removes the overlayed gray div and re-enables the inputs on the page
     *
     * @see WaitScreen.lock
     */
    WaitScreen.prototype.unlock = function() {
        var i, len;

        if (this.waitingDiv) {
            if (this.waitingDiv.style.display === '') {
                this.waitingDiv.style.display = 'none';
            }
        }
        if (this.countdownInterval) clearInterval(this.countdownInterval);

        // Re-enables all previously locked input forms in the page.
        try {
            len = this.lockedInputs.length;
            for (i = -1 ; ++i < len ; ) {
                this.lockedInputs[i].removeAttribute('disabled');
            }
            this.lockedInputs = [];
        }
        catch(e) {
            // For IE8.
            lockUnlockedInputs(W.getIFrameDocument(W.getFrame()), false);
        }
    };

    /**
     * ### WaitScreen.updateText
     *
     * Updates the text displayed on the current waiting div
     *
     * @param {string} text The text to be displayed
     * @param {boolean} append Optional. If TRUE, the text is appended. By
     *   default the old text is replaced
     */
    WaitScreen.prototype.updateText = function(text, append) {
        append = append || false;
        if ('string' !== typeof text) {
            throw new TypeError('WaitScreen.updateText: text must be ' +
                                'string. Found: ' + text);
        }
        if (append) this.contentDiv.innerHTML += text;
        else this.contentDiv.innerHTML = text;
    };

    /**
     * ### WaitScreen.destroy
     *
     * Removes the waiting div from the HTML page and unlocks the screen
     *
     * @see WaitScreen.unlock
     */
    WaitScreen.prototype.destroy = function() {
        if (W.isScreenLocked()) {
            W.setScreenLevel('UNLOCKING');
            this.unlock();
            W.setScreenLevel('ACTIVE');
        }
        if (this.waitingDiv) {
            // It might have gotten destroyed in the meantime.
            if (this.waitingDiv.parentNode) {
                this.waitingDiv.parentNode.removeChild(this.waitingDiv);
            }
        }
        // Removes previously registered listeners.
        this.disable();
    };

})(
    ('undefined' !== typeof node) ? node : module.parent.exports.node,
    ('undefined' !== typeof window) ? window : module.parent.exports.window
);

/**
 * # InfoPanel
 * Copyright(c) 2021 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Adds a configurable extra panel at the top of the screen
 *
 * InfoPanel is normally placed between header and main frame.
 *
 * www.nodegame.org
 */
(function(exports, window) {

    "use strict";

    exports.InfoPanel = InfoPanel;

    function InfoPanel(options) {
        this.init(options || {});
    }

    /**
     * ### InfoPanel.init
     *
     * Inits the Info panel
     *
     * @param {object} options Optional. Configuration options.
     *   Available options (defaults):
     *
     *    - 'className': a class name for the info panel div (''),
     *    - 'isVisible': if TRUE, the info panel is open immediately (false),
     *    - 'onStep:' an action to perform every new step (null),
     *    - 'onStage:' an action to perform every new stage (null).
     */
    InfoPanel.prototype.init = function(options) {
        var that;
        options = options || {};

        this.infoPanelDiv = document.createElement('div');
        this.infoPanelDiv.id = 'ng_info-panel';

        /**
         * ### InfoPanel.actionsLog
         *
         * Array containing the list of open/close events and a timestamp
         *
         * Entries in the actions log are objects: with keys 'create',
         * 'open', 'close', 'clear', 'destroy' and a timestamp.
         *
         * @see InfoPanel.open
         * @see InfoPanel.close
         */
        this.actionsLog = [];

        /**
         * ### InfoPanel._buttons
         *
         * Collection of buttons created via `createToggleButton` method
         *
         * @see InfoPanel.createToggleButton
         */
        this._buttons = [];

        /**
        * ### InfoPanel._buttons
        *
        * Reference to the last created toggle button
        *
        * @see InfoPanel.createToggleButton
        */
        this.toggleBtn = null;

        /**
         * ### InfoPanel.className
         *
         * Class name of info panel
         *
         * Default: ''
         */
        if ('undefined' === typeof options.className) {
            this.infoPanelDiv.className = '';
        }
        else if ('string' === typeof options.className) {
            this.infoPanelDiv.className = options.className;
        }
        else {
            throw new TypeError('InfoPanel constructor: options.className ' +
                                'must be a string or undefined. ' +
                                'Found: ' + options.className);
        }

        /**
         * ### InfoPanel.isVisible
         *
         * Boolean indicating visibility of info panel div
         *
         * Default: FALSE
         */
        if ('undefined' === typeof options.isVisible) {
            this.isVisible = false;
        }
        else if ('boolean' === typeof options.isVisible) {
            this.isVisible = options.isVisible;
        }
        else {
            throw new TypeError('InfoPanel constructor: options.isVisible ' +
                                'must be a boolean or undefined. ' +
                                'Found: ' + options.isVisible);
        }

        this.infoPanelDiv.style.display = this.isVisible ? 'block' : 'none';
        this.actionsLog.push({ created: J.now() });

        /**
         * ### InfoPanel.onStep
         *
         * Performs an action ('clear', 'open', 'close') at every new step
         *
         * Default: null
         */
        if ('undefined' !== typeof options.onStep) {
            if ('open' === options.onStep ||
                'close' === options.onStep ||
                'clear' ===  options.onStep) {

                this.onStep = options.onStep;
            }
            else {
                throw new TypeError('InfoPanel constructor: options.onStep ' +
                                    'must be string "open", "close", "clear" ' +
                                    'or undefined. Found: ' + options.onStep);
            }
        }
        else {
            options.onStep = null;
        }

        /**
         * ### InfoPanel.onStage
         *
         * Performs an action ('clear', 'open', 'close') at every new stage
         *
         * Default: null
         */
        if ('undefined' !== typeof options.onStage) {
            if ('open' === options.onStage ||
                'close' === options.onStage ||
                'clear' ===  options.onStage) {

                this.onStage = options.onStage;
            }
            else {
                throw new TypeError('InfoPanel constructor: options.onStage ' +
                                    'must be string "open", "close", "clear" ' +
                                    'or undefined. Found: ' + options.onStage);
            }
        }
        else {
            options.onStage = null;
        }

        if (this.onStep || this.onStage) {
            that = this;
            node.events.game.on('STEPPING', function(curStep, newStep) {
                var newStage;
                newStage = curStep.stage !== newStep.stage;

                if ((that.onStep === 'close' && that.isVisible) ||
                    (newStage && that.onStage === 'close')) {

                    that.close();
                }
                else if (that.onStep === 'open' ||
                         (newStage && that.onStage === 'open')) {

                    that.open();
                }
                else if (that.onStep === 'clear' ||
                         (newStage && that.onStage === 'clear')) {

                    that.clear();
                }
            });
        }
    };

    /**
     * ### InfoPanel.clear
     *
     * Clears the content of the Info Panel
     */
    InfoPanel.prototype.clear = function() {
        this.infoPanelDiv.innerHTML = '';
        this.actionsLog.push({ clear: J.now() });
        W.adjustHeaderOffset(true);
    };

    /**
     * ### InfoPanel.getPanel
     *
     * Returns the HTML element of the panel (div)
     *
     * @return {HTMLElement} The Info Panel
     *
     * @see InfoPanel.infoPanelDiv
     */
    InfoPanel.prototype.getPanel = function() {
        return this.infoPanelDiv;
    };

    /**
     * ### InfoPanel.destroy
     *
     * Removes the Info Panel from the DOM and the internal references to it
     *
     * @param {actionsLog} If TRUE, also the actions log is deleted, otherwise
     *   the destroy action is added. Default: false.
     *
     * @see InfoPanel.infoPanelDiv
     * @see InfoPanel._buttons
     */
    InfoPanel.prototype.destroy = function(actionsLog) {
        var i, len;
        if (actionsLog) this.actionsLog = [];
        else this.actionsLog.push({ destroy: J.now() });

        if (this.infoPanelDiv.parentNode) {
            this.infoPanelDiv.parentNode.removeChild(this.infoPanelDiv);
        }
        this.isVisible = false;
        this.infoPanelDiv = null;
        i = -1, len = this._buttons.length;
        for ( ; ++i < len ; ) {
            if (this._buttons[i].parentNode) {
                this._buttons[i].parentNode.removeChild(this._buttons[i]);
            }
        }
        W.adjustHeaderOffset(true);
    };

    /**
     * ### InfoPanel.toggle
     *
     * Toggles the visibility of the Info Panel
     *
     * @see InfoPanel.open
     * @see InfoPanel.close
     */
    InfoPanel.prototype.toggle = function() {
        if (this.isVisible) this.close();
        else this.open();
    };

    /**
     * ### InfoPanel.open
     *
     * Opens the Info Panel (if not already open)
     *
     * @see InfoPanel.toggle
     * @see InfoPanel.close
     * @see InfoPanel.isVisible
     */
    InfoPanel.prototype.open = function() {
        if (this.isVisible) return;
        this.actionsLog.push({ open: J.now() });
        this.infoPanelDiv.style.display = 'block';
        this.isVisible = true;
        // Must be at the end.
        W.adjustHeaderOffset(true);
        // Scroll into view.
        if ('function' === typeof this.infoPanelDiv.scrollIntoView) {
            this.infoPanelDiv.scrollIntoView({ behavior: 'smooth' });
        }
    };

    /**
     * ### InfoPanel.close
     *
     * Closes the Info Panel (if not already closed)
     *
     * @see InfoPanel.toggle
     * @see InfoPanel.open
     * @see InfoPanel.isVisible
     */
    InfoPanel.prototype.close = function() {
        if (!this.isVisible) return;
        this.actionsLog.push({ close: J.now() });
        this.infoPanelDiv.style.display = 'none';
        this.isVisible = false;
        // Must be at the end.
        W.adjustHeaderOffset(true);
    };

    /**
     * ### InfoPanel.createToggleButton
     *
     * Creates an HTML button with a listener to toggle the InfoPanel
     *
     * Adds the button to the internal collection `_buttons`. All buttons
     * are destroyed if the Info Panel is destroyed. Stores a reference to the
     * last created button under `toggleBtn`.
     *
     * @param {string} label Optional. A text to be displayed on the button.
     *    Default: 'Info'.
     *
     * @return {HTMLElement} button A button that toggles info panel
     *
     * @see InfoPanel._buttons
     * @see InfoPanel.toggleBtn
     * @see InfoPanel.toggle
     */
    InfoPanel.prototype.createToggleBtn =
    InfoPanel.prototype.createToggleButton = function(label) {
        var that, button;

        label = label || 'Info';
        if ('string' !== typeof label || label.trim() === '') {
            throw new Error('InfoPanel.createToggleButton: label ' +
                            'must be undefined or a non-empty string. Found: ' +
                            label);
        }
        button = document.createElement('button');
        button.className = 'btn btn-lg btn-warning';
        button.innerHTML = label ;

        that = this;
        button.onclick = function() { that.toggle(); };

        // Store references.
        this._buttons.push(button);
        this.toggleBtn = button;

        return button;
    };

})(
    ('undefined' !== typeof node) ? node : module.parent.exports.node,
    ('undefined' !== typeof window) ? window : module.parent.exports.window
);

/**
 * # selector
 * Copyright(c) 2017 Stefano Balietti
 * MIT Licensed
 *
 * Utility functions to create and manipulate HTML select lists
 *
 * Extra methods relevant for nodeGame variables are added.
 *
 * http://www.nodegame.org
 */
(function(window, node) {

    "use strict";

    var constants = node.constants;
    var GameWindow = node.GameWindow;

    /**
     * ### GameWindow.getRecipientSelector
     *
     * Creates an HTML select element populated with the data of other players
     *
     * @param {string} id Optional. The id of the element
     *
     * @return The newly created select element
     *
     * @see GameWindow.addRecipientSelector
     * @see GameWindow.addStandardRecipients
     * @see GameWindow.populateRecipientSelector
     *
     * TODO: add options to control which players/servers to add.
     */
    GameWindow.prototype.getRecipientSelector = function(id) {
        var toSelector;

        toSelector = document.createElement('select');
        if ('undefined' !== typeof id) {
            toSelector.id = id;
        }
        this.addStandardRecipients(toSelector);
        return toSelector;
    };

    /**
     * ### GameWindow.addRecipientSelector
     *
     * Appends a RecipientSelector element to the specified root element
     *
     * @param {Element} root The root element
     * @param {string} id The id of the selector
     *
     * @return {boolean} FALSE if no valid root element is found, TRUE otherwise
     *
     * @see GameWindow.addRecipientSelector
     * @see GameWindow.addStandardRecipients
     * @see GameWindow.populateRecipientSelector
     *
     * TODO: adds options to control which players/servers to add.
     */
    GameWindow.prototype.addRecipientSelector = function(root, id) {
        var toSelector;

        if (!root) return false;
        toSelector = this.getRecipientSelector(id);
        return root.appendChild(toSelector);
    };

    /**
     * ### GameWindow.addStandardRecipients
     *
     * Adds valid _to_ recipient options to a specified select element
     *
     * @param {object} toSelector An HTML `<select>` element
     *
     * @see GameWindow.populateRecipientSelector
     *
     * TODO: adds options to control which players/servers to add.
     */
    GameWindow.prototype.addStandardRecipients = function(toSelector) {
        var opt;

        opt = document.createElement('option');
        opt.value = 'ALL';
        opt.appendChild(document.createTextNode('ALL'));
        toSelector.appendChild(opt);

        opt = document.createElement('option');
        opt.value = 'CHANNEL';
        opt.appendChild(document.createTextNode('CHANNEL'));
        toSelector.appendChild(opt);

        opt = document.createElement('option');
        opt.value = 'ROOM';
        opt.appendChild(document.createTextNode('ROOM'));
        toSelector.appendChild(opt);

        opt = document.createElement('option');
        opt.value = 'SERVER';
        opt.appendChild(document.createTextNode('SERVER'));
        toSelector.appendChild(opt);
    };

    /**
     * ### GameWindow.populateRecipientSelector
     *
     * Adds all the players from a specified playerList object to a given
     * select element
     *
     * @param {object} toSelector An HTML `<select>` element
     * @param {PlayerList} playerList The PlayerList object
     *
     * @see GameWindow.addStandardRecipients
     */
    GameWindow.prototype.populateRecipientSelector =
    function(toSelector, playerList) {
        var players, opt;

        if ('object' !== typeof playerList || 'object' !== typeof toSelector) {
            return;
        }

        this.removeChildrenFromNode(toSelector);
        this.addStandardRecipients(toSelector);

        // check if it is a DB or a PlayerList object
        players = playerList.db || playerList;

        J.each(players, function(p) {
            opt = document.createElement('option');
            opt.value = p.id;
            opt.appendChild(document.createTextNode(p.name || p.id));
            toSelector.appendChild(opt);
        });
    };

    /**
     * ### GameWindow.getActionSelector
     *
     * Creates an HTML select element with all the predefined actions
     * (SET,GET,SAY,SHOW*) as options
     *
     * @param {string} id The id of the selector
     *
     * @return {Element} The newly created selector
     *
     * @see GameWindow.addActionSelector
     */
    GameWindow.prototype.getActionSelector = function(id) {
        var actionSelector = document.createElement('select');
        if ('undefined' !== typeof id) {
            actionSelector.id = id;
        }
        this.populateSelect(actionSelector, constants.action);
        return actionSelector;
    };

    /**
     * ### GameWindow.addActionSelector
     *
     * Appends an ActionSelector element to the specified root element
     *
     * @param {Element} root The root element
     * @param {string} id The id of the selector
     *
     * @return {Element} The newly created selector
     *
     * @see GameWindow.getActionSelector
     */
    GameWindow.prototype.addActionSelector = function(root, id) {
        var actionSelector;

        if (!root) return;
        actionSelector = this.getActionSelector(id);
        return root.appendChild(actionSelector);
    };

    /**
     * ### GameWindow.getTargetSelector
     *
     * Creates an HTML select element with all the predefined targets
     * (HI,TXT,DATA, etc.) as options
     *
     * @param {string} id The id of the selector
     *
     * @return {Element} The newly created selector
     *
     * @see GameWindow.addActionSelector
     */
    GameWindow.prototype.getTargetSelector = function(id) {
        var targetSelector;

        targetSelector = document.createElement('select');
        if ('undefined' !== typeof id ) {
            targetSelector.id = id;
        }
        this.populateSelect(targetSelector, constants.target);
        return targetSelector;
    };

    /**
     * ### GameWindow.addTargetSelector
     *
     * Appends a target selector element to the specified root element
     *
     * @param {Element} root The root element
     * @param {string} id The id of the selector
     *
     * @return {Element} The newly created selector
     *
     * @see GameWindow.getTargetSelector
     */
    GameWindow.prototype.addTargetSelector = function(root, id) {
        if (!root) return;
        var targetSelector = this.getTargetSelector(id);
        return root.appendChild(targetSelector);
    };
})(
    // GameWindow works only in the browser environment. The reference
    // to the node.js module object is for testing purpose only
    ('undefined' !== typeof window) ? window : module.parent.exports.window,
    ('undefined' !== typeof window) ? window.node : module.parent.exports.node
);

/**
 * # extra
 * Copyright(c) 2022 Stefano Balietti
 * MIT Licensed
 *
 * GameWindow extras
 *
 * http://www.nodegame.org
 */
(function(window, node) {

    "use strict";

    var GameWindow = node.GameWindow;
    var DOM = J.require('DOM');

    /**
     * ### GameWindow.getScreen
     *
     * Returns the "screen" of the game
     *
     * i.e. the innermost element inside which to display content
     *
     * In the following order the screen can be:
     *
     * - the body element of the iframe
     * - the document element of the iframe
     * - the body element of the document
     * - the last child element of the document
     *
     * @return {Element} The screen
     */
    GameWindow.prototype.getScreen = function() {
        var el;
        el = this.getFrameDocument();
        if (el) el = el.body || el;
        else el = document.body || document.lastElementChild;
        return el;
    };

    /**
     * ### GameWindow.cssRule
     *
     * Add a css rule to the page
     *
     * @param {string} rule The css rule
     * @param {boolean} clear Optional. TRUE to clear all previous rules
     *   added with this method to the page
     *
     * @return {Element} The HTML style element where the rules were added
     *
     * @see handleFrameLoad
     */
    GameWindow.prototype.cssRule = function(rule, clear) {
        var root;
        if ('string' !== typeof rule) {
            throw new TypeError('Game.execStep: style property must be ' +
                                'string. Found: ' + rule);
        }
        if (!this.styleElement) {
            root = W.getFrameDocument() || window.document;
            this.styleElement = W.append('style', root.head, {
                type: 'text/css',
                id: 'ng_style'
            });
        }
        else if (clear) {
            this.styleElement.innerHTML = '';
        }
        this.styleElement.innerHTML += rule;
        return this.styleElement;
    };

    /**
     * ### GameWindow.write
     *
     * Appends content inside a root element
     *
     * The content can be a text string, an HTML node or element.
     * If no root element is specified, the default screen is used.
     *
     * @param {string|object} text The content to write
     * @param {Element|string} root Optional. The root element or its id
     *
     * @return {string|object} The content written
     *
     * @see GameWindow.writeln
     */
    GameWindow.prototype.write = function(text, root) {
        if ('string' === typeof root) root = this.getElementById(root);
        else if (!root) root = this.getScreen();

        if (!root) {
            throw new
                Error('GameWindow.write: could not determine where to write');
        }
        return DOM.write(root, text);
    };

    /**
     * ### GameWindow.writeln
     *
     * Appends content inside a root element followed by a break element
     *
     * The content can be a text string, an HTML node or element.
     * If no root element is specified, the default screen is used.
     *
     * @param {string|object} text The content to write
     * @param {Element|string} root Optional. The root element or its id
     *
     * @return {string|object} The content written
     *
     * @see GameWindow.write
     */
    GameWindow.prototype.writeln = function(text, root, br) {
        if ('string' === typeof root) root = this.getElementById(root);
        else if (!root) root = this.getScreen();

        if (!root) {
            throw new Error('GameWindow.writeln: ' +
                            'could not determine where to write');
        }
        return DOM.writeln(root, text, br);
    };

    /**
     * ### GameWindow.generateUniqueId
     *
     * Generates a unique id
     *
     * Overrides JSUS.DOM.generateUniqueId.
     *
     * @param {string} prefix Optional. The prefix to use
     *
     * @return {string} The generated id
     *
     * @experimental
     * TODO: it is not always working fine.
     */
    GameWindow.prototype.generateUniqueId = function(prefix) {
        var id, found;

        id = '' + (prefix || J.randomInt(0, 1000));
        found = this.getElementById(id);

        while (found) {
            id = '' + prefix + '_' + J.randomInt(0, 1000);
            found = this.getElementById(id);
        }
        return id;
    };

    /**
     * ### GameWindow.toggleInputs
     *
     * Enables / disables the input forms
     *
     * If an id is provided, only input elements that are children
     * of the element with the specified id are toggled.
     *
     * If id is not given, it toggles the input elements on the whole page,
     * including the frame document, if found.
     *
     * If a state parameter is given, all the input forms will be either
     * disabled or enabled (and not toggled).
     *
     * @param {string} id Optional. The id of the element container
     *   of the forms. Default: the whole page, including the frame document
     * @param {boolean} disabled Optional. Forces all the inputs to be either
     *   disabled or enabled (not toggled)
     *
     * @return {boolean} FALSE, if the method could not be executed
     *
     * @see GameWindow.getFrameDocument
     * @see toggleInputs
     */
    GameWindow.prototype.toggleInputs = function(id, disabled) {
        var container;
        if (!document.getElementsByTagName) {
            node.err(
                'GameWindow.toggleInputs: getElementsByTagName not found');
            return false;
        }
        if (id && 'string' === typeof id) {
            throw new Error('GameWindow.toggleInputs: id must be string or ' +
                            'undefined. Found: ' + id);
        }
        if (id) {
            container = this.getElementById(id);
            if (!container) {
                throw new Error('GameWindow.toggleInputs: no elements found ' +
                                'with id ' + id);
            }
            toggleInputs(disabled, container);
        }
        else {
            // The whole page.
            toggleInputs(disabled);
            container = this.getFrameDocument();
            // If there is a frame, apply it there too.
            if (container) toggleInputs(disabled, container);
        }
        return true;
    };

    /**
     * ### GameWindow.getLoadingDots
     *
     * Creates and returns a span element with incrementing dots inside
     *
     * New dots are added every second until the limit is reached, then it
     * starts from the beginning.
     *
     * Gives the impression of a loading time.
     *
     * @param {number} len Optional. The maximum length of the loading dots.
     *   Default: 5
     * @param {string} id Optional The id of the span
     *
     * @return {object} An object containing two properties: the span element
     *   and a method stop, that clears the interval
     */
    GameWindow.prototype.getLoadingDots = function(len, id) {
        var spanDots, counter, intervalId;
        if (len & len < 0) {
            throw new Error('GameWindow.getLoadingDots: len cannot be < 0. ' +
                            'Found: ' + len);
        }
        spanDots = document.createElement('span');
        spanDots.id = id || 'span_dots';
        // Refreshing the dots...
        counter = 0;
        len = len || 5;
        // So the height does not change.
        spanDots.innerHTML = '&nbsp;';
        intervalId = setInterval(function() {
            if (counter < len) {
                counter++;
                spanDots.innerHTML = spanDots.innerHTML + '.';
            }
            else {
                counter = 0;
                spanDots.innerHTML = '.';
            }
        }, 1000);

        function stop() {
            spanDots.innerHTML = '.';
            clearInterval(intervalId);
        }

        return {
            span: spanDots,
            stop: stop
        };
    };

    /**
     * ### GameWindow.addLoadingDots
     *
     * Appends _loading dots_ to an HTML element
     *
     * By invoking this method you lose access to the _stop_ function of the
     * _loading dots_ element.
     *
     * @param {HTMLElement} root The element to which the loading dots will be
     *   appended
     * @param {number} len Optional. The maximum length of the loading dots.
     *   Default: 5
     * @param {string} id Optional The id of the span
     *
     * @return {object} An object containing two properties: the span element
     *   and a method stop, that clears the interval
     *
     * @see GameWindow.getLoadingDots
     */
    GameWindow.prototype.addLoadingDots = function(root, len, id) {
        var ld;
        ld = this.getLoadingDots(len, id);
        root.appendChild(ld.span);
        return ld;
    };

     /**
     * ### GameWindow.getEventButton
     *
     * Creates an HTML button element that will emit an event when clicked
     *
     * @param {string} event The event to emit when clicked
     * @param {string|object} attributes Optional. The attributes of the
     *   button, or if string the text to display inside the button.
     *
     * @return {Element} The newly created button
     *
     * @see GameWindow.get
     */
    GameWindow.prototype.getEventButton = function(event, attributes) {
        var b;
        if ('string' !== typeof event) {
            throw new TypeError('GameWindow.getEventButton: event must ' +
                                'be string. Found: ' + event);
        }
        if ('string' === typeof attributes) {
            attributes = { innerHTML: attributes };
        }
        else if (!attributes) {
            attributes = {};
        }
        if (!attributes.innerHTML) attributes.innerHTML = event;
        b = this.get('button', attributes);
        b.onclick = function() { node.emit(event); };
        return b;
    };

    /**
     * ### GameWindow.addEventButton
     *
     * Adds an EventButton to the specified root element
     *
     * @param {string} event The event to emit when clicked
     * @param {Element} root Optional. The root element. Default: last element
     * on the page
     * @param {string|object} attributes Optional. The attributes of the
     *   button, or if string the text to display inside the button.
     *
     * @return {Element} The newly created button
     *
     * @see GameWindow.get
     * @see GameWindow.getEventButton
     */
    GameWindow.prototype.addEventButton = function(event, root, attributes) {
        var eb;
        eb = this.getEventButton(event, attributes);
        if (!root) root = this.getScreen();
        return root.appendChild(eb);
    };

    /**
     * ### GameWindow.searchReplace
     *
     * Replaces the innerHTML of the element/s with matching id or class name
     *
     * It iterates through each element and passes it to
     * `GameWindow.setInnerHTML`.
     *
     * If elements is array, each item in the array must be of the type:
     *
     * ```javascript
     *
     *   { search: 'key', replace: 'value' }
     *
     *   // or
     *
     *   { search: 'key', replace: 'value', mod: 'id' }
     * ```
     *
     * If elements is object, it must be of the type:
     *
     * ```javascript
     *
     *    {
     *      search1: value1, search2: value 2 // etc.
     *    }
     * ```
     *
     * It accepts a variable number of input parameters. The first is always
     * _elements_. If there are 2 input parameters, the second is _prefix_,
     * while if there are 3 input parameters, the second is _mod_ and the third
     * is _prefix_.
     *
     * @param {object|array} Elements to search and replace
     * @param {string} mod Optional. Modifier passed to GameWindow.setInnerHTML
     * @param {string} prefix Optional. Prefix added to the search string.
     *    Default: 'ng_replace_', null or '' equals no prefix.
     *
     * @see GameWindow.setInnerHTML
     */
    GameWindow.prototype.searchReplace = function() {
        var elements, mod, prefix;
        var name, len, i;

        if (arguments.length === 2) {
            mod = 'g';
            prefix = arguments[1];
        }
        else if (arguments.length > 2) {
            mod = arguments[1];
            prefix = arguments[2];
        }

        if ('undefined' === typeof prefix) {
            prefix = 'ng_replace_';
        }
        else if (null === prefix) {
            prefix = '';
        }
        else if ('string' !== typeof prefix) {
            throw new TypeError('GameWindow.searchReplace: prefix ' +
                                'must be string, null or undefined. Found: ' +
                                prefix);
        }

        elements = arguments[0];
        if (J.isArray(elements)) {
            i = -1, len = elements.length;
            for ( ; ++i < len ; ) {
                this.setInnerHTML(prefix + elements[i].search,
                                  elements[i].replace,
                                  elements[i].mod || mod);
            }

        }
        else if ('object' !== typeof elements) {
            for (name in elements) {
                if (elements.hasOwnProperty(name)) {
                    this.setInnerHTML(prefix + name, elements[name], mod);
                }
            }
        }
        else {
            throw new TypeError('GameWindow.setInnerHTML: elements must be ' +
                                'object or arrray. Found: ' + elements);
        }

    };

    GameWindow.prototype.setInnerHTML = function(search, replace, mod) {
        // console.log('***deprecated: use W.html instead of W.setInnerHTML');
        this.html(search, replace, mod);
    };

    /**
     * ### GameWindow.html
     *
     * Replaces the innerHTML of the element with matching id or class name
     *
     * @param {string|number} search Element id or className
     * @param {string|number} replace The new value of the property innerHTML
     * @param {string} mod Optional. A modifier defining how to use the
     *    search parameter. Values:
     *
     *    - 'id': replaces at most one element with the same id (default)
     *    - 'className': replaces all elements with same class name
     *    - 'g': replaces globally, both by id and className
     */
    GameWindow.prototype.html = function(search, replace, mod) {
        var el, i, len;

        // Only process strings or numbers.
        if ('string' !== typeof search && 'number' !== typeof search) {
            throw new TypeError('GameWindow.setInnerHTML: search must be ' +
                                'string or number. Found: ' + search +
                                " (replace = " + replace + ")");
        }

        // Only process strings or numbers.
        if ('string' !== typeof replace && 'number' !== typeof replace) {
            throw new TypeError('GameWindow.setInnerHTML: replace must be ' +
                                'string or number. Found: ' + replace +
                                " (search = " + search + ")");
        }

        if ('undefined' === typeof mod) {
            mod = 'id';
        }
        else if ('string' === typeof mod) {
            if (mod !== 'g' && mod !== 'id' && mod !== 'className') {
                throw new Error('GameWindow.setInnerHTML: invalid ' +
                                'mod value: ' + mod  +
                                " (search = " + search + ")");
            }
        }
        else {
            throw new TypeError('GameWindow.setInnerHTML: mod must be ' +
                                'string or undefined. Found: ' + mod  +
                                " (search = " + search + ")");
        }

        if (mod === 'id' || mod === 'g') {
            // Look by id.
            el = W.getElementById(search);
            if (el && el.className !== search) el.innerHTML = replace;
        }

        if (mod === 'className' || mod === 'g') {
            // Look by class name.
            el = W.getElementsByClassName(search);
            len = el.length;
            if (len) {
                i = -1;
                for ( ; ++i < len ; ) {
                    el[i].innerHTML = replace;
                }
            }
        }
    };

    /**
     * ## GameWindow.hide
     *
     * Gets and hides an HTML element
     *
     * Sets the style of the display to 'none' and adjust the frame
     * height as necessary.
     *
     * @param {string|HTMLElement} idOrObj The id of or the HTML element itself
     *
     * @return {HTMLElement} The hidden element, if found
     *
     * @see getElement
     */
    GameWindow.prototype.hide = function(idOrObj) {
        var el;
        el = getElement(idOrObj, 'GameWindow.hide');
        if (el) {
            el.style.display = 'none';
            W.adjustFrameHeight(0, 0);
        }
        return el;
    };

    /**
     * ## GameWindow.show
     *
     * Gets and shows (makes visible) an HTML element
     *
     * Sets the style of the display to '' and adjust the frame height
     * as necessary.
     *
     * @param {string|HTMLElement} idOrObj The id of or the HTML element itself
     * @param {string} display Optional. The value of the display attribute.
     *    Default: '' (empty string).
     *
     * @return {HTMLElement} The shown element, if found
     *
     * @see getElement
     */
    GameWindow.prototype.show = function(idOrObj, display) {
        var el;
        display = display || '';
        if ('string' !== typeof display) {
            throw new TypeError('GameWindow.show: display must be ' +
                                'string or undefined. Found: ' + display);
        }
        el = getElement(idOrObj, 'GameWindow.show');
        if (el) {
            el.style.display = display;
            W.adjustFrameHeight(0, 0);
        }
        return el;
    };

   /**
     * ## GameWindow.toggle
     *
     * Gets and toggles the visibility of an HTML element
     *
     * Sets the style of the display to '' or 'none'  and adjust
     * the frame height as necessary.
     *
     * @param {string|HTMLElement} idOrObj The id of or the HTML element itself
     * @param {string} display Optional. The value of the display attribute
     *    in case it will be set visible. Default: '' (empty string).
     *
     * @return {HTMLElement} The toggled element, if found
     *
     * @see getElement
     */
    GameWindow.prototype.toggle = function(idOrObj, display) {
        var el;
        display = display || '';
        if ('string' !== typeof display) {
            throw new TypeError('GameWindow.toggle: display must ' +
                                'be string or undefined. Found: ' + display);
        }
        el = getElement(idOrObj, 'GameWindow.toggle');
        if (el) {
            if (el.style.display === 'none') el.style.display = display;
            else el.style.display = 'none';
            W.adjustFrameHeight(0, 0);
        }
        return el;
    };

    // ## Helper Functions

    /**
     * ### toggleInputs
     *
     * @api private
     */
    function toggleInputs(state, container) {
        var inputTags, j, len, i, inputs, nInputs;
        container = container || document;
        inputTags = ['button', 'select', 'textarea', 'input'];
        len = inputTags.length;
        for (j = 0; j < len; j++) {
            inputs = container.getElementsByTagName(inputTags[j]);
            nInputs = inputs.length;
            for (i = 0; i < nInputs; i++) {
                // Set to state, or toggle.
                if ('undefined' === typeof state) {
                    state = inputs[i].disabled ? false : true;
                }
                if (state) {
                    inputs[i].disabled = state;
                }
                else {
                    inputs[i].removeAttribute('disabled');
                }
            }
        }
    }

    /**
     * ### getElement
     *
     * Gets the element or returns it
     *
     * @param {string|HTMLElement} The id or the HTML element itself
     *
     * @return {HTMLElement} The HTML Element
     *
     * @see GameWindow.getElementById
     * @api private
     */
    function getElement(idOrObj, prefix) {
        var el;
        if ('string' === typeof idOrObj) {
            el = W.getElementById(idOrObj);
        }
        else if (J.isElement(idOrObj)) {
            el = idOrObj;
        }
        else {
            throw new TypeError(prefix + ': idOrObj must be string ' +
                                ' or HTML Element. Found: ' + idOrObj);
        }
        return el;
    }

})(
    // GameWindow works only in the browser environment. The reference
    // to the node.js module object is for testing purpose only
    ('undefined' !== typeof window) ? window : module.parent.exports.window,
    ('undefined' !== typeof window) ? window.node : module.parent.exports.node
);

// Creates a new GameWindow instance in the global scope.
(function() {
    "use strict";
    node.window = new node.GameWindow();
    if ('undefined' !== typeof window) window.W = node.window;
})();

/**
 * # Canvas
 * Copyright(c) 2016 Stefano Balietti
 * MIT Licensed
 *
 * Creates an HTML canvas that can be manipulated by an api
 *
 * www.nodegame.org
 */
(function(exports) {

    "use strict";

    exports.Canvas = Canvas;

    function Canvas(canvas) {

        this.canvas = canvas;
        // 2D Canvas Context.
        this.ctx = canvas.getContext('2d');

        this.centerX = canvas.width / 2;
        this.centerY = canvas.height / 2;

        this.width = canvas.width;
        this.height = canvas.height;
    }

    Canvas.prototype = {

        constructor: Canvas,

        drawOval: function(settings) {

            // We keep the center fixed.
            var x = settings.x / settings.scale_x;
            var y = settings.y / settings.scale_y;

            var radius = settings.radius || 100;

            this.ctx.lineWidth = settings.lineWidth || 1;
            this.ctx.strokeStyle = settings.color || '#000000';

            this.ctx.save();
            this.ctx.scale(settings.scale_x, settings.scale_y);
            this.ctx.beginPath();
            this.ctx.arc(x, y, radius, 0, Math.PI*2, false);
            this.ctx.stroke();
            this.ctx.closePath();
            this.ctx.restore();
        },

        drawLine: function(settings) {

            var from_x = settings.x;
            var from_y = settings.y;

            var length = settings.length;
            var angle = settings.angle;

            // Rotation.
            var to_x = - Math.cos(angle) * length + settings.x;
            var to_y =  Math.sin(angle) * length + settings.y;

            this.ctx.lineWidth = settings.lineWidth || 1;
            this.ctx.strokeStyle = settings.color || '#000000';

            this.ctx.save();
            this.ctx.beginPath();
            this.ctx.moveTo(from_x,from_y);
            this.ctx.lineTo(to_x,to_y);
            this.ctx.stroke();
            this.ctx.closePath();
            this.ctx.restore();
        },

        scale: function(x, y) {
            this.ctx.scale(x,y);
            this.centerX = this.canvas.width / 2 / x;
            this.centerY = this.canvas.height / 2 / y;
        },

        clear: function() {
            this.ctx.clearRect(0, 0, this.width, this.height);
            // For IE.
            var w = this.canvas.width;
            this.canvas.width = 1;
            this.canvas.width = w;
        }
    };

})(node.window);

/**
 * # HTMLRenderer
 * Copyright(c) 2019 Stefano Balietti
 * MIT Licensed
 *
 * Renders javascript objects into HTML following a pipeline
 * of decorator functions
 *
 * The default pipeline always looks for a `content` property and
 * performs the following operations:
 *
 * - if it is already an HTML element, returns it;
 * - if it contains a  #parse() method, tries to invoke it to generate HTML;
 * - if it is an object, tries to render it as a table of key:value pairs;
 * - finally, creates an HTML text node with it and returns it
 *
 * Depends on the nodegame-client add-on TriggerManager
 *
 * www.nodegame.org
 */
(function(exports, window, node) {

    "use strict";

    // ## Global scope

    var document = window.document;

    var TriggerManager = node.TriggerManager;

    if (!TriggerManager) {
        throw new Error('HTMLRenderer requires node.TriggerManager to load.');
    }

    exports.HTMLRenderer = HTMLRenderer;
    exports.HTMLRenderer.Entity = Entity;

    /**
     * ## HTMLRenderer constructor
     *
     * Creates a new instance of HTMLRenderer
     *
     * @param {object} options A configuration object
     */
    function HTMLRenderer (options) {
        // ### HTMLRenderer.options
        this.options = options || {};

        // ### HTMLRenderer.tm
        // TriggerManager instance
        this.tm = new TriggerManager();

        this.init(this.options);
    }

    // ## HTMLRenderer methods

    /**
     * ### HTMLRenderer.init
     *
     * Configures the HTMLRenderer instance
     *
     * Takes the configuration as an input parameter or
     * recycles the settings in `this.options`.
     *
     * The configuration object is of the type
     *
     * ```
     * var options = {
     *     returnAt: 'first',  // or 'last'
     *     render: [ myFunc, myFunc2 ]
     * }
     * ```
     *
     * @param {object} options Optional. Configuration object
     */
    HTMLRenderer.prototype.init = function(options) {
        options = options || this.options;
        this.options = options;

        this.reset();

        if (options.returnAt) {
            this.tm.returnAt = options.returnAt;
        }

        if (options.pipeline) {
            this.tm.initTriggers(options.pipeline);
        }
    };



    /**
     * ### HTMLRenderer.reset
     *
     * Deletes all registered render function and restores the default
     * pipeline
     */
    HTMLRenderer.prototype.reset = function() {
        this.clear(true);
        this.addDefaultPipeline();
    };

    /**
     * ### HTMLRenderer.addDefaultPipeline
     *
     * Registers the set of default render functions
     */
    HTMLRenderer.prototype.addDefaultPipeline = function() {
        this.tm.addTrigger(function(el){
            return document.createTextNode(el.content);
        });

        this.tm.addTrigger(function(el) {
            var div, spanType, spanContent, span2, key, str;
            if (!el) return;
            if (el.content &&
                ('object' === typeof el.content ||
                 'function' === typeof el.content)) {

                div = document.createElement('div');
                spanType = W.add('span', div);
                spanType.innerHTML = typeof el.content;
                spanType.className = 'ng_clickable bold';

                spanContent = W.add('span', div);
                spanContent.style.display = 'none';
                spanContent.className = 'ng_clickable';

                if ('object' === typeof el.content) {
                    for (key in el.content) {
                        if (el.content.hasOwnProperty(key)) {
                            str = key + ':\t' + el.content[key];
                            spanContent.appendChild(
                                    document.createTextNode(str));
                            spanContent.appendChild(
                                    document.createElement('br'));
                        }
                    }
                }
                else {
                    spanContent.innerHTML = el.content.toString();
                }
                spanType.onclick = function() {
                    spanContent.style.display = '';
                    spanType.style.display = 'none';
                };

                spanContent.onclick = function() {
                    spanContent.style.display = 'none';
                    spanType.style.display = '';
                };

                return div;
            }
        });

        this.tm.addTrigger(function(el) {
            var html;
            if (!el) return;
            if (el.content && el.content.parse &&
                'function' === typeof el.content.parse) {

                html = el.content.parse();
                if (J.isElement(html) || J.isNode(html)) {
                    return html;
                }
            }
        });

        this.tm.addTrigger(function(el) {
            if (!el) return;
            if (J.isElement(el.content) || J.isNode(el.content)) {
                return el.content;
            }
        });
    };


    /**
     * ### HTMLRenderer.clear
     *
     * Deletes all registered render functions
     *
     * @param {boolean} clear Whether to confirm the clearing
     *
     * @return {boolean} TRUE, if clearing is successful
     */
    HTMLRenderer.prototype.clear = function(clear) {
        return this.tm.clear(clear);
    };

    /**
     * ### HTMLRenderer.addRenderer
     *
     * Registers a new render function
     *
     * @param {function} renderer The function to add
     * @param {number} pos Optional. The position of the renderer in the
     *   pipeline
     *
     * @return {boolean} TRUE, if insertion is successful
     */
    HTMLRenderer.prototype.addRenderer = function(renderer, pos) {
        return this.tm.addTrigger(renderer, pos);
    };

    /**
     * ### HTMLRenderer.removeRenderer
     *
     * Removes a render function from the pipeline
     *
     * @param {function} renderer The function to remove
     *
     * @return {boolean} TRUE, if removal is successful
     */
    HTMLRenderer.prototype.removeRenderer = function(renderer) {
        return this.tm.removeTrigger(renderer);
    };

    /**
     * ### HTMLRenderer.render
     *
     * Runs the pipeline of render functions on a target object
     *
     * @param {object} o The target object
     *
     * @return {object} The target object after exiting the pipeline
     *
     * @see TriggerManager.pullTriggers
     */
    HTMLRenderer.prototype.render = function(o) {
        return this.tm.pullTriggers(o);
    };

    /**
     * ### HTMLRenderer.size
     *
     * Counts the number of render functions in the pipeline
     *
     * @return {number} The number of render functions in the pipeline
     */
    HTMLRenderer.prototype.size = function() {
        return this.tm.triggers.length;
    };

    /**
     * # Entity
     *
     * Abstract representation of an HTML entity
     */

    /**
     * ## Entity constructor
     *
     * Creates a new instace of Entity
     *
     * An `Entity` is an abstract representation of an HTML element.
     *
     * May contains the following properties:
     *
     *   - `content` (that will be processed upon rendering),
     *   - `id` (if specified)
     *   - 'className` (if specified)
     *
     * @param {object} e The object to transform in entity
     */
    function Entity(o) {
        o = o || {};

        this.content = 'undefined' !== typeof o.content ? o.content : '';

        if ('string' === typeof o.id) {
            this.id = o.id;
        }
        else if ('undefined' !== typeof o.id) {
            throw new TypeError('Entity: id must ' +
                                'be string or undefined.');
        }
        if ('string' === typeof o.className) {
            this.className = o.className;
        }
        else if (J.isArray(o.className)) {
            this.className = o.join(' ');
        }
        else if ('undefined' !== typeof o.className) {
            throw new TypeError('Entity: className must ' +
                                'be string, array, or undefined.');
        }
    }

})(
    ('undefined' !== typeof node) ? node.window || node : module.exports,
    ('undefined' !== typeof window) ? window : module.parent.exports.window,
    ('undefined' !== typeof node) ? node : module.parent.exports.node
);

/**
 * # List
 * Copyright(c) 2015 Stefano Balietti
 * MIT Licensed
 *
 * Creates an HTML list that can be manipulated by an api
 *
 * www.nodegame.org
 */
(function(exports, node) {

    "use strict";

    var NDDB = node.NDDB;

    var HTMLRenderer = node.window.HTMLRenderer;
    var Entity = node.window.HTMLRenderer.Entity;

    exports.List = List;

    List.prototype = new NDDB();
    List.prototype.constructor = List;

    function List(options, data) {
        options = options || {};
        this.options = options;

        NDDB.call(this, options, data);

        this.id = options.id || 'list_' + Math.round(Math.random() * 1000);

        this.DL = null;
        this.auto_update = this.options.auto_update || false;
        this.htmlRenderer = null;
        this.lifo = false;

        this.init(this.options);
    }

    // TODO: improve init
    List.prototype.init = function(options) {
        options = options || this.options;

        this.FIRST_LEVEL = options.first_level || 'dl';
        this.SECOND_LEVEL = options.second_level || 'dt';
        this.THIRD_LEVEL = options.third_level || 'dd';

        this.last_dt = 0;
        this.last_dd = 0;
        this.auto_update = ('undefined' !== typeof options.auto_update) ?
            options.auto_update : this.auto_update;

        var lifo = this.lifo = ('undefined' !== typeof options.lifo) ?
            options.lifo : this.lifo;

        this.globalCompare = function(o1, o2) {
            if (!o1 && !o2) return 0;
            if (!o2) return 1;
            if (!o1) return -1;

            // FIFO
            if (!lifo) {
                if (o1.dt < o2.dt) return -1;
                if (o1.dt > o2.dt) return 1;
            }
            else {
                if (o1.dt < o2.dt) return 1;
                if (o1.dt > o2.dt) return -1;
            }
            if (o1.dt === o2.dt) {
                if ('undefined' === typeof o1.dd) return -1;
                if ('undefined'=== typeof o2.dd) return 1;
                if (o1.dd < o2.dd) return -1;
                if (o1.dd > o2.dd) return 1;
                if (o1.nddbid < o2.nddbid) return 1;
                if (o1.nddbid > o2.nddbid) return -1;
            }
            return 0;
        };


        this.DL = options.list || document.createElement(this.FIRST_LEVEL);
        this.DL.id = options.id || this.id;
        if (options.className) {
            this.DL.className = options.className;
        }
        if (this.options.title) {
            this.DL.appendChild(document.createTextNode(options.title));
        }

        // was
        //this.htmlRenderer = new HTMLRenderer({renderers: options.renderer});
        this.htmlRenderer = new HTMLRenderer(options.render);
    };

    List.prototype._add = function(node) {
        if (!node) return;
        //              console.log('about to add node');
        //              console.log(node);
        this.insert(node);
        if (this.auto_update) {
            this.parse();
        }
    };

    List.prototype.addDT = function(elem, dt) {
        if ('undefined' === typeof elem) return;
        this.last_dt++;
        dt = ('undefined' !== typeof dt) ? dt: this.last_dt;
        this.last_dd = 0;
        var node = new Node({dt: dt, content: elem});
        return this._add(node);
    };

    List.prototype.addDD = function(elem, dt, dd) {
        if ('undefined' === typeof elem) return;
        dt = ('undefined' !== typeof dt) ? dt: this.last_dt;
        dd = ('undefined' !== typeof dd) ? dd: this.last_dd++;
        var node = new Node({dt: dt, dd: dd, content: elem});
        return this._add(node);
    };

    List.prototype.parse = function() {
        this.sort();
        var old_dt = null;
        var old_dd = null;

        var appendDT = function() {
            var node = document.createElement(this.SECOND_LEVEL);
            this.DL.appendChild(node);
            old_dd = null;
            old_dt = node;
            return node;
        };

        var appendDD = function() {
            var node = document.createElement(this.THIRD_LEVEL);
            //                  if (old_dd) {
            //                          old_dd.appendChild(node);
            //                  }
            //                  else if (!old_dt) {
            //                          old_dt = appendDT.call(this);
            //                  }
            //                  old_dt.appendChild(node);
            this.DL.appendChild(node);
            //                  old_dd = null;
            //                  old_dt = node;
            return node;
        };

        // Reparse all every time
        // TODO: improve this
        if (this.DL) {
            while (this.DL.hasChildNodes()) {
                this.DL.removeChild(this.DL.firstChild);
            }
            if (this.options.title) {
                this.DL.appendChild(
                    document.createTextNode(this.options.title));
            }
        }

        for (var i=0; i<this.db.length; i++) {
            var el = this.db[i];
            var node;
            if ('undefined' === typeof el.dd) {
                node = appendDT.call(this);
                //console.log('just created dt');
            }
            else {
                node = appendDD.call(this);
            }
            var content = this.htmlRenderer.render(el);
            node.appendChild(content);
        }
        return this.DL;
    };

    List.prototype.getRoot = function() {
        return this.DL;
    };

    // Cell Class
    Node.prototype = new Entity();
    Node.prototype.constructor = Node;

    function Node (node) {
        Entity.call(this, node);
        this.dt = ('undefined' !== typeof node.dt) ? node.dt : null;
        if ('undefined' !== typeof node.dd) {
            this.dd = node.dd;
        }
    }

})(
    ('undefined' !== typeof node) ? (('undefined' !== typeof node.window) ?
        node.window : node) : module.parent.exports,
    ('undefined' !== typeof node) ? node : module.parent.exports
);

/**
 * # Table
 * Copyright(c) 2017 Stefano Balietti
 * MIT Licensed
 *
 * Creates an HTML table that can be manipulated by an api.
 *
 * Elements can be added individually, as a row, or as column.
 * They are tranformed into `Cell` objects containining the original
 * element and a reference to the HTMLElement (e.g. td, th, etc.)
 *
 * Internally, data is organized as a `NDDB` database.
 *
 * When `.parse()` method is called the current databaase structure is
 * processed to create the real HTML table. Each cell is passed to the
 * `HTMLRenderer` instance which tranforms it the correspondent HTML
 * element based on a user-defined render function.
 *
 * The HTML-renderer object renders cells into HTML following a pipeline
 * of decorator functions. By default, the following rendering operations
 * are applied to a cell in order:
 *
 * - if it is already an HTML element, returns it;
 * - if it contains a  #parse() method, tries to invoke it to generate HTML;
 * - if it is an object, tries to render it as a table of key:value pairs;
 * - if it is a string or number, creates an HTML text node and returns it
 *
 * @see NDDB
 * @see HTMLRendered
 *
 * www.nodegame.org
 */
(function(exports, window, node) {

    "use strict";

    var document = window.document;

    exports.Table = Table;
    exports.Table.Cell = Cell;

    var NDDB = node.NDDB;
    var HTMLRenderer = node.window.HTMLRenderer;
    var Entity = node.window.HTMLRenderer.Entity;

    Table.prototype = new NDDB();
    Table.prototype.constructor = Table;

    /**
     * ## Tan;e.
     *
     * Returns a new cell
     *
     */
    Table.cell = function(o) {
        return new Cell(o);
    };

    /**
     * ## Table constructor
     *
     * Creates a new Table object
     *
     * @param {object} options Optional. Configuration for NDDB
     * @param {array} data Optional. Array of initial items
     */
    function Table(options, data) {
        options = options || {};

        // Updates indexes on the fly.
        if (!options.update) options.update = {};

        if ('undefined' === typeof options.update.indexes) {
            options.update.indexes = true;
        }

        NDDB.call(this, options, data);

//         // ### Table.row
//         // NDDB hash containing elements grouped by row index
//         // @see NDDB.hash
//         if (!this.row) {
//             this.hash('row', function(c) {
//                 return c.x;
//             });
//         }
//
//         // ### Table.col
//         // NDDB hash containing elements grouped by column index
//         // @see NDDB.hash
//         if (!this.col) {
//             this.hash('col', function(c) {
//                 return c.y;
//             });
//         }

        // ### Table.rowcol
        // NDDB index to access elements with row.col notation
        // @see NDDB.hash
        if (!this.rowcol) {
            this.index('rowcol', function(c) {
                return c.x + '.' + c.y;
            });
        }

        /**
         * ### Table.pointers
         *
         * References to last inserted cell coordinates
         */
        this.pointers = {
            x: options.pointerX || null,
            y: options.pointerY || null
        };

        /**
         * ### Table.header
         *
         * Array containing the header elements of the table
         */
        this.header = [];

        /**
         * ### Table.footer
         *
         * Array containing the footer elements of the table
         */
        this.footer = [];

        /**
         * ### Table.left
         *
         * Array containing elements to keep on the left border of the table
         */
        this.left = [];

        /**
         * ### Table.table
         *
         * Reference to the HTMLElement Table
         */
        this.table = options.table || document.createElement('table');

        if ('string' === typeof options.id) {
            this.table.id = options.id;
        }
        else if (options.id) {
            throw new TypeError('Table constructor: options.id must be ' +
                                'string or undefined.');
        }

        if ('string' === typeof options.className) {
            this.table.className = options.className;
        }
        else if (J.isArray(options.className)) {
            this.table.className = options.className.join(' ');
        }
        else if (options.className) {
            throw new TypeError('Table constructor: options.className must ' +
                                'be string, array, or undefined.');
        }

        /**
         * ### Table.missingClassName
         *
         * Class name for "missing" cells
         *
         * "Missing" cells are cells that are added automatically to complete
         * the table because one or more cells have been added with higher
         * row and column indexes.
         */
        this.missingClassName = 'missing';

        if ('string' === typeof options.missingClassName) {
            this.missingClassName = options.missingClassName;
        }
        else if (J.isArray(options.missingClassName)) {
            this.missingClassName = options.missingClassName.join(' ');
        }
        else if (options.missingClassName) {
            throw new TypeError('Table constructor: options.className must ' +
                                'be string, array, or undefined.');
        }

        /**
         * ### Table.autoParse
         *
         * If TRUE, whenever a new cell is added the table is updated.
         * Default: FALSE
         */
        this.autoParse = 'undefined' !== typeof options.autoParse ?
            options.autoParse : false;

        /**
         * ### Table.trs
         *
         * List of TR elements indexed by their order in the parsed table
         */
        this.trs = {};

        /**
         * ### Table.trCb
         *
         * Callback function applied to each TR HTML element
         *
         * Callback receives the HTML element, and the row index, or
         * 'thead' and 'tfoot' for header and footer.
         */
        if ('function' === typeof options.tr) {
            this.trCb = options.tr;
        }
        else if ('undefined' === typeof options.tr) {
            this.trCb = null;
        }
        else {
            throw new TypeError('Table constructor: options.tr must be ' +
                                'function or undefined.');
        }

        // Init renderer.
        this.initRenderer(options.render);
    }

    // ## Table methods

    /**
     * ### Table.initRenderer
     *
     * Creates the `HTMLRenderer` object and adds a renderer for objects
     *
     * Every cell in the table will be rendered according to the criteria
     * added to the renderer object.
     *
     * @param {object} options Optional. Configuration for the renderer
     *
     * @see HTMLRenderer
     * @see HTMLRenderer.addRenderer
     */
    Table.prototype.initRenderer = function(options) {
        options = options || {};
        this.htmlRenderer = new HTMLRenderer(options);
        this.htmlRenderer.addRenderer(function(el) {
            var tbl, key;
            if (el.content && 'object' === typeof el.content) {
                tbl = new Table();
                for (key in el.content) {
                    if (el.content.hasOwnProperty(key)) {
                        tbl.addRow([key, el.content[key]]);
                    }
                }
                return tbl.parse();
            }
        }, 2);
    };

    /**
     * ### Table.renderCell
     *
     * Create a cell element (td, th, etc.) and renders its content
     *
     * It also adds an internal reference to the newly created TD/TH element,
     * stored under a `.HTMLElement` key.
     *
     * If the cell contains a `.className` attribute, this is added to
     * the HTML element.
     *
     * @param {Cell} cell The cell to transform in element
     * @param {string} tagName The name of the tag. Default: 'td'
     *
     * @return {HTMLElement} The newly created HTML Element (TD/TH)
     *
     * @see Table.htmlRenderer
     * @see Cell
     */
    Table.prototype.renderCell = function(cell, tagName) {
        var TD, content;
        if (!cell) return;
        tagName = tagName || 'td';
        TD = document.createElement(tagName);
        content = this.htmlRenderer.render(cell);
        TD.appendChild(content);
        if (cell.className) TD.className = cell.className;
        if (cell.id) TD.id = cell.id;
        if (cell.colspan) TD.setAttribute('colSpan', cell.colspan);
        cell.HTMLElement = TD;
        return TD;
    };

    /**
     * ### Table.get
     *
     * Returns the element at row column (row,col)
     *
     * @param {number} row The row number
     * @param {number} col The column number
     *
     * @return {Cell|array} The Cell or array of cells specified by indexes
     */
    Table.prototype.get = function(row, col) {
        validateXY('get', row, col, 'any');

        // TODO: check if we can use hashes.
        if ('undefined' === typeof row) {
            return this.select('y', '=', col);
        }
        if ('undefined' === typeof col) {
            return this.select('x', '=', row);
        }

        return this.rowcol.get(row + '.' + col);
    };

    /**
     * ### Table.getTR
     *
     * Returns a reference to the TR element at row (row)
     *
     * TR elements are generated only after the table is parsed.
     *
     * Notice! If the table structure is manipulated externally,
     * the return value of this method might be inaccurate.
     *
     * @param {number} row The row number
     *
     * @return {HTMLElement|boolean} The requested TR object, or FALSE if it
     *   cannot be found
     */
    Table.prototype.getTR = function(row) {
        if (row !== 'thead' && row !== 'tfoot') {
            validateXY('getTR', row, undefined, 'x');
        }
        return this.trs[row] || false;
    };

    /**
     * ### Table.setHeader
     *
     * Sets the names of the header elements on top of the table
     *
     * @param {string|array} header Array of strings representing the names
     *   of the header elements
     */
    Table.prototype.setHeader = function(header) {
        validateInput('setHeader', header, undefined, undefined, true);
        this.header = addSpecialCells(header);
    };

    /**
     * ### Table.setLeft
     *
     * Sets the element of a column that will be added to the left of the table
     *
     * @param {string|array} left Array of strings representing the names
     *   of the left elements
     */
    Table.prototype.setLeft = function(left) {
        validateInput('setLeft', left, undefined, undefined, true);
        this.left = addSpecialCells(left);
    };

    /**
     * ### Table.setFooter
     *
     * Sets the names of the footer elements at the bottom of the table
     *
     * @param {string|array} footer Array of strings representing the names
     *   of the footer elements
     */
    Table.prototype.setFooter = function(footer) {
        validateInput('setFooter', footer, undefined, undefined, true);
        this.footer = addSpecialCells(footer);
    };

    /**
     * ### Table.updatePointer
     *
     * Updates the reference to the foremost element in the table
     *
     * The pointer is updated only if the suggested value is larger than
     * the current one.
     *
     * @param {string} pointer The name of pointer ('x', 'y')
     * @param {number} value The new value for the pointer
     *
     * @return {boolean|number} The updated value of the pointer, or FALSE,
     *   if an invalid pointer was selected
     *
     * @see Table.pointers
     */
    Table.prototype.updatePointer = function(pointer, value) {
        if ('undefined' === typeof this.pointers[pointer]) {
            throw new Error('Table.updatePointer: invalid pointer: ' + pointer);
        }
        if (this.pointers[pointer] === null || value > this.pointers[pointer]) {
            this.pointers[pointer] = value;
        }
        return this.pointers[pointer];
    };

    /**
     * ### Table.addMultiple
     *
     * Primitive to add multiple cells in column or row form
     *
     * @param {array} data The cells to add
     * @param {string} dim The dimension of followed by the insertion:
     *   'y' inserts as a row, and 'x' inserts as a column.
     * @param {number} x Optional. The row at which to start the insertion.
     *   Default: the current x pointer
     * @param {number} y Optional. The column at which to start the insertion.
     *   Default: the current y pointer
     */
    Table.prototype.addMultiple = function(data, dim, x, y) {
        var i, lenI, j, lenJ;
        validateInput('addMultiple', data, x, y);
        if ((dim && 'string' !== typeof dim) ||
            (dim && 'undefined' === typeof this.pointers[dim])) {
            throw new TypeError('Table.addMultiple: dim must be a valid ' +
                                'dimension (x or y) or undefined.');
        }
        dim = dim || 'x';

        // Horizontal increment: dim === y.
        x = this.getCurrPointer('x', x);
        y = this.getNextPointer('y', y);

        // By default, only the second dimension is incremented, so we move
        x = 'undefined' !== typeof x ? x :
            this.pointers.x === null ? 0 : this.pointers.x;
        y = 'undefined' !== typeof y ? y :
            this.pointers.y === null ? 0 : this.pointers.y;

        if (!J.isArray(data)) data = [data];

        // Loop Dim 1.
        i = -1;
        lenI = data.length;
        for ( ; ++i < lenI ; ) {

            if (!J.isArray(data[i])) {
                if (dim === 'x') this.add(data[i], x, y + i, 'x');
                else this.add(data[i], x + i, y, 'y');
            }
            else {
                // Loop Dim 2.
                j = -1;
                lenJ = data[i].length;
                for ( ; ++j < lenJ ; ) {
                    if (dim === 'x') this.add(data[i][j], x + i, y + j, 'x');
                    else this.add(data[i][j], x + j, y + i, 'y');
                }
            }
        }
        // Auto-parse.
        if (this.autoParse) this.parse();
    };

    /**
     * ### Table.add
     *
     * Adds a single cell to the table
     *
     * @param {object} content The content of the cell or Cell object
     */
    Table.prototype.add = function(content, x, y, dim) {
        var cell;
        validateInput('add', content, x, y);
        if ((dim && 'string' !== typeof dim) ||
            (dim && 'undefined' === typeof this.pointers[dim])) {
            throw new TypeError('Table.add: dim must be a valid string ' +
                                '(x, y) or undefined.');
        }
        dim = dim || 'x';

        // Horizontal increment: dim === y.
        x = dim === 'y' ?
            this.getCurrPointer('x', x) : this.getNextPointer('x', x);
        y = dim === 'y' ?
            this.getNextPointer('y', y) : this.getCurrPointer('y', y);

        if (content && 'object' === typeof content &&
            'undefined' !== typeof content.content) {

            if ('undefined' === typeof content.x) content.x = x;
            if ('undefined' === typeof content.y) content.y = y;

            cell = new Cell(content);
        }
        else {
            cell = new Cell({
                x: x,
                y: y,
                content: content
            });
        }

        this.insert(cell);

        this.updatePointer('x', x);
        this.updatePointer('y', y);
    };

    /**
     * ### Table.addColumn
     *
     * Adds a new column into the table
     *
     * @param {array} data The array of data to add in column form
     * @param {number} x Optional. The row to which the column will be added.
     *   Default: row 0
     * @param {number} y Optional. The column next to which the new column
     *   will be added. Default: the last column in the table
     */
    Table.prototype.addColumn = function(data, x, y) {
        validateInput('addColumn', data, x, y);
        return this.addMultiple(data, 'y', x || 0, this.getNextPointer('y', y));
    };

    /**
     * ### Table.addRow
     *
     * Adds a new row into the table
     *
     * @param {array} data The array of data to add in row form
     * @param {number} x Optional. The row index at which the new row will be
     *   added. Default: after the last row
     * @param {number} y Optional. The column next to which the new row
     *   will be added. Default: column 0
     */
    Table.prototype.addRow = function(data, x, y) {
        validateInput('addRow', data, x, y);
        return this.addMultiple(data, 'x', this.getNextPointer('x', x), y || 0);
    };

    /**
     * ### Table.getNextPointer
     *
     * Returns the value of the pointer plus 1 for the requested dimension (x,y)
     *
     * @param {string} dim The dimension x or y
     * @param {value} value Optional. If set, returns this value
     *
     * @return {number} The requested pointer
     */
    Table.prototype.getNextPointer = function(dim, value) {
        if ('undefined' !== typeof value) return value;
        return this.pointers[dim] === null ? 0 : this.pointers[dim] + 1;
    };

    /**
     * ### Table.getCurrPointer
     *
     * Returns the value of the pointer for the requested dimension (x,y)
     *
     * @param {string} dim The dimension x or y
     * @param {value} value Optional. If set, returns this value
     *
     * @return {number} The requested pointer
     */
    Table.prototype.getCurrPointer = function(dim, value) {
        if ('undefined' !== typeof value) return value;
        return this.pointers[dim] === null ? 0 : this.pointers[dim];
    };

    /**
     * ### Table.parse
     *
     * Reads cells currently in database and builds up an HTML table
     *
     * It destroys the existing table, before parsing the database again.
     *
     * @see Table.db
     * @see Table.table
     * @see Cell
     */
    Table.prototype.parse = function() {
        var TABLE, TR, TD, THEAD, TBODY, TFOOT;
        var i, j, len;
        var trid, f, old_y, old_left;
        var diff;

        // TODO: we could find a better way to update a table, instead of
        // removing and re-inserting everything.
        if (this.table && this.table.children) {
            this.table.innerHTML = '';
            // TODO: which one is faster?
            // while (this.table.hasChildNodes()) {
            //     this.table.removeChild(this.table.firstChild);
            // }
        }

        TABLE = this.table;

        // HEADER
        if (this.header && this.header.length) {
            THEAD = document.createElement('thead');

            TR = document.createElement('tr');
            if (this.trCb) this.trCb(TR, 'thead');
            this.trs.thead = TR;

            // Add an empty cell to balance the left header column.
            if (this.left && this.left.length) {
                TR.appendChild(document.createElement('th'));
            }
            i = -1;
            len = this.header.length;
            for ( ; ++i < len ; ) {
                TR.appendChild(this.renderCell(this.header[i], 'th'));
            }
            THEAD.appendChild(TR);
            TABLE.appendChild(THEAD);
        }

        // BODY
        if (this.size()) {
            TBODY = document.createElement('tbody');

            this.sort(['x','y']);

            // Forces to create a new TR element.
            trid = -1;

            // TODO: What happens if the are missing at the beginning ??
            f = this.first();
            old_y = f.y;
            old_left = 0;


            i = -1;
            len = this.db.length;
            for ( ; ++i < len ; ) {

                if (trid !== this.db[i].x) {
                    TR = document.createElement('tr');
                    if (this.trCb) this.trCb(TR, (trid+1));
                    this.trs[(trid+1)] = TR;

                    TBODY.appendChild(TR);

                    // Keep a reference to current TR idx.
                    trid = this.db[i].x;

                    old_y = f.y - 1; // must start exactly from the first

                    // Insert left header, if any.
                    if (this.left && this.left.length) {
                        TD = document.createElement('td');
                        //TD.className = this.missing;
                        TR.appendChild(this.renderCell(this.left[old_left]));
                        old_left++;
                    }
                }

                // Insert missing cells.
                if (this.db[i].y > old_y + 1) {
                    diff = this.db[i].y - (old_y + 1);
                    for (j = 0; j < diff; j++ ) {
                        TD = document.createElement('td');
                        TD.className = this.missingClassName;
                        TR.appendChild(TD);
                    }
                }
                // Normal insert.
                TR.appendChild(this.renderCell(this.db[i]));

                // Update old refs.
                old_y = this.db[i].y;
            }
            TABLE.appendChild(TBODY);
        }


        // FOOTER.
        if (this.footer && this.footer.length) {
            TFOOT = document.createElement('tfoot');

            TR = document.createElement('tr');
            if (this.trCb) this.trCb(TR, 'tfoot');
            this.trs.tfoot = TR;

            if (this.header && this.header.length) {
                TD = document.createElement('td');
                TR.appendChild(TD);
            }

            i = -1;
            len = this.footer.length;
            for ( ; ++i < len ; ) {
                TR.appendChild(this.renderCell(this.footer[i]));
            }
            TFOOT.appendChild(TR);
            TABLE.appendChild(TFOOT);
        }

        return TABLE;
    };

    /**
     * ### Table.resetPointers
     *
     * Reset all pointers to 0 or to the value of the input parameter
     *
     * @param {object} pointers Optional. Objects contains the new pointers
     */
    Table.prototype.resetPointers = function(pointers) {
        if (pointers && 'object' !== typeof pointers) {
            throw new TypeError('Table.resetPointers: pointers must be ' +
                                'object or undefined.');
        }
        pointers = pointers || {};
        this.pointers = {
            x: pointers.pointerX || 0,
            y: pointers.pointerY || 0
        };
    };

    /**
     * ### Table.addClass
     *
     * Adds a CSS class to each HTML element in the table
     *
     * Cells not containing an HTML elements are skipped.
     *
     * @param {string|array} className The name of the class/classes.
     * @param {number} x Optional. Subsets only on dimension x
     * @param {number} y Optional. Subsets only on dimension y
     *
     * @return {Table} This instance for chaining
     */
    Table.prototype.addClass = function(className, x, y) {
        var db;
        if (J.isArray(className)) {
            className = className.join(' ');
        }
        else if ('string' !== typeof className) {
            throw new TypeError('Table.addClass: className must be string ' +
                                'or array.');
        }
        validateXY('addClass', x, y);

        db = this;
        if (!('undefined' === typeof x && 'undefined' === typeof y)) {
            if ('undefined' !== typeof x) db = db.select('x', '=', x);
            if ('undefined' !== typeof y) db = db.and('y', '=', y);
        }

        db.each(function(el) {
            W.addClass(el, className, true);
            if (el.HTMLElement) el.HTMLElement.className = el.className;
        });

        return this;
    };

    /**
     * ### Table.removeClass
     *
     * Removes a CSS class from each element cell in the table
     *
     * @param {string|array|null} className Optional. The name of the
     *   class/classes, or  null to remove all classes. Default: null.
     * @param {number} x Optional. Subsets only on dimension x
     * @param {number} y Optional. Subsets only on dimension y
     *
     * @return {Table} This instance for chaining
     */
    Table.prototype.removeClass = function(className, x, y) {
        var func, db;
        if (J.isArray(className)) {
            func = function(el, className) {
                for (var i = 0; i < className.length; i++) {
                    W.removeClass(el, className[i]);
                }
            };
        }
        else if ('string' === typeof className) {
            func = W.removeClass;
        }
        else if (null === className) {
            func = function(el) { el.className = ''; };
        }
        else {
            throw new TypeError('Table.removeClass: className must be ' +
                                'string, array, or null.');
        }

        validateXY('removeClass', x, y);

        db = this;
        if (!('undefined' === typeof x && 'undefined' === typeof y)) {
            if ('undefined' !== typeof x) db = db.select('x', '=', x);
            if ('undefined' !== typeof y) db = db.and('y', '=', y);
        }

        db.each(function(el) {
            func.call(this, el, className);
            if (el.HTMLElement) el.HTMLElement.className = el.className;
        });

        return this;
    };

    /**
     * ### Table.clear
     *
     * Removes all entries and indexes, and resets the pointers
     *
     * @see NDDB.clear
     */
    Table.prototype.clear = function() {
        NDDB.prototype.clear.call(this, true);
        this.resetPointers();
    };

    // ## Helper functions


    /**
     * ### validateXY
     *
     * Validates if x and y are correctly specified or throws an error
     *
     * @param {string} method The name of the method validating the input
     * @param {number} x Optional. The row index
     * @param {number} y Optional. The column index
     * @param {string} mode Optional. Additionally check for: 'both',
     *   'either', 'any', 'x', or 'y' parameter to be defined.
     */
    function validateXY(method, x, y, mode) {
        var xOk, yOk;
        if ('undefined' !== typeof x) {
            if ('number' !== typeof x || x < 0) {
                throw new TypeError('Table.' + method + ': x must be ' +
                                    'a non-negative number or undefined.');
            }
            xOk = true;
        }
        if ('undefined' !== typeof y) {
            if ('number' !== typeof y || y < 0) {
                throw new TypeError('Table.' + method + ': y must be ' +
                                    'a non-negative number or undefined.');
            }
            yOk = true;
        }
        if (mode === 'either' && xOk && yOk) {
            throw new Error('Table.' + method + ': either x OR y can ' +
                            'be defined.');
        }
        else if (mode === 'both' && (!xOk || !yOk)) {
            throw new Error('Table.' + method + ': both x AND y must ' +
                            'be defined.');
        }
        else if (mode === 'any' && (!xOk && !yOk)) {
            throw new Error('Table.' + method + ': either x or y must ' +
                            'be defined.');
        }
        else if (mode === 'x' && !xOk) {
            throw new Error('Table.' + method + ': x must be defined.');
        }
        else if (mode === 'y' && !yOk) {
            throw new Error('Table.' + method + ': y be defined.');
        }
    }

    /**
     * ### validateInput
     *
     * Validates user input and throws an error if input is not correct
     *
     * @param {string} method The name of the method validating the input
     * @param {mixed} data The data that will be inserted in the database
     * @param {number} x Optional. The row index
     * @param {number} y Optional. The column index
     * @param {boolean} dataArray TRUE, if data should be an array
     *
     * @return {boolean} TRUE, if input passes validation
     *
     * @see validateXY
     */
    function validateInput(method, data, x, y, dataArray) {
        validateXY(method, x, y);
        if (dataArray && !J.isArray(data)) {
            throw new TypeError('Table.' + method + ': data must be array.');
        }
    }

    /**
     * ### addSpecialCells
     *
     * Parses an array of data and returns an array of cells
     *
     * @param {array} data Array containing data to transform into cells
     *
     * @return {array} The array of cells
     */
    function addSpecialCells(data) {
        var out, i, len;
        out = [];
        i = -1;
        len = data.length;
        for ( ; ++i < len ; ) {
            out.push({content: data[i]});
        }
        return out;
    }


    // # Cell

    Cell.prototype = new Entity();
    Cell.prototype.constructor = Cell;

    /**
     * ## Cell constructor
     *
     * Creates a new Table Cell
     *
     * @param {object} cell An object containing the coordinates in the table
     *
     * @see Entity
     * @see Table
     */
    function Cell(cell) {
        // Adds property: className and content.
        Entity.call(this, cell);

        /**
         * ### Cell.x
         *
         * The row number
         */
        this.x = 'undefined' !== typeof cell.x ? cell.x : null;

        /**
         * ### Cell.y
         *
         * The column number
         */
        this.y = 'undefined' !== typeof cell.y ? cell.y : null;

        /**
         * ### Cell.tdElement
         *
         * Reference to the TD/TH element, if built already
         */
        this.HTMLElement = cell.HTMLElement || null;

        /**
         * ### Cell.colspan
         *
         * The colspan property, only if truthy
         */
        if (cell.colspan) this.colspan = cell.colspan;
    }

})(
    ('undefined' !== typeof node) ? node.window || node : module.exports,
    ('undefined' !== typeof window) ? window : module.parent.exports.window,
    ('undefined' !== typeof node) ? node : module.parent.exports.node
);

/**
 * # Widget
 * Copyright(c) 2021 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Prototype of a widget class
 *
 * Prototype methods will be injected in every new widget, if missing.
 *
 * Additional properties can be automatically, depending on configuration.
 *
 * @see Widgets.get
 * @see Widgets.append
 */
(function(node) {

    "use strict";

    var J = node.JSUS;
    var NDDB = node.NDDB;

    node.Widget = Widget;

    /**
     * ### Widget constructor
     *
     * Creates a new instance of widget
     *
     * Should create all widgets properties, but the `init` method
     * initialize them. Some properties are added automatically
     * by `Widgets.get` after the constructor has been called,
     * but before `init`.
     *
     * @see Widgets.get
     * @see Widget.init
     */
    function Widget() {}

    /**
     * ### Widget.init
     *
     * Inits the widget after constructor and default properties are added
     *
     * @param {object} opts Configuration options
     *
     * @see Widgets.get
     */
    Widget.prototype.init = function(opts) {};

    /**
     * ### Widget.listeners
     *
     * Wraps calls event listeners registration
     *
     * Event listeners registered here are automatically removed
     * when widget is destroyed (if still active)
     *
     * @see EventEmitter.setRecordChanges
     * @see Widgets.destroy
     */
    Widget.prototype.listeners = function() {};

    /**
     * ### Widget.append
     *
     * Creates HTML elements and appends them to the `panelDiv` element
     *
     * The method is called by `Widgets.append` which evaluates user-options
     * and adds the default container elements of a widget:
     *
     *    - panelDiv:   the outer container
     *    - headingDiv: the title container
     *    - bodyDiv:    the main container
     *    - footerDiv:  the footer container
     *
     * To ensure correct destroyal of the widget, all HTML elements should
     * be children of Widget.panelDiv
     *
     * @see Widgets.append
     * @see Widgets.destroy
     * @see Widget.panelDiv
     * @see Widget.footerDiv
     * @see Widget.headingDiv
     */
    Widget.prototype.append = function() {};

    /**
     * ### Widget.getValues
     *
     * Returns the values currently stored by the widget
     *
     * @param {mixed} opts Settings controlling the content of return value
     *
     * @return {mixed} The values of the widget
     */
    Widget.prototype.getValues = function(opts) {};

    /**
     * ### Widget.setValues
     *
     * Set the stored values directly
     *
     * The method should not set the values, if widget is disabled
     *
     * @param {mixed} values The values to store
     */
    Widget.prototype.setValues = function(values) {};

    /**
     * ### Widget.reset
     *
     * Resets the widget
     *
     * Deletes current selection, any highlighting, and other data
     * that the widget might have collected to far.
     */
    Widget.prototype.reset = function(opts) {};

    /**
     * ### Widget.highlight
     *
     * Hightlights the user interface of the widget in some way
     *
     * By default, it adds a red border around the bodyDiv.
     *
     * If widget was not appended, i.e., no `panelDiv` has been created,
     * nothing happens.
     *
     * @param {mixed} options Settings controlling the type of highlighting
     */
    Widget.prototype.highlight = function(border) {
        if (border && 'string' !== typeof border) {
            throw new TypeError(J.funcName(this.constructor) + '.highlight: ' +
                                'border must be string or undefined. Found: ' +
                                border);
        }
        if (!this.isAppended() || this.isHighlighted()) return;
        this.highlighted = true;
        this.bodyDiv.style.border = border  || '3px solid red';
        this.emit('highlighted', border);
    };

    /**
     * ### Widget.highlight
     *
     * Hightlights the user interface of the widget in some way
     *
     * Should mark the state of widget as not `highlighted`.
     *
     * If widget was not appended, i.e., no `panelDiv` has been created,
     * nothing happens.
     *
     * @see Widget.highlight
     */
    Widget.prototype.unhighlight = function() {
        if (!this.isHighlighted()) return;
        this.highlighted = false;
        this.bodyDiv.style.border = '';
        this.emit('unhighlighted');
    };

    /**
     * ### Widget.isHighlighted
     *
     * Returns TRUE if widget is currently highlighted
     *
     * @return {boolean} TRUE, if widget is currently highlighted
     */
    Widget.prototype.isHighlighted = function() {
        return !!this.highlighted;
    };

    /**
     * ### Widget.isDocked
     *
     * Returns TRUE if widget is currently docked
     *
     * @return {boolean} TRUE, if widget is currently docked
     */
    Widget.prototype.isDocked = function() {
        return !!this.docked;
    };

    /**
     * ### Widget.isActionRequired
     *
     * Returns TRUE if widget if the widget does not required action from user
     *
     * If the widget does not have the `required` flag it returns FALSE,
     * otherwise it invokes Widget.getValues and looks in the response for
     * incorrect or missing values.
     *
     * @param {object} opts Optional. Options to pass to Widget.getValues.
     *   Default: { markAttempt: false, highlight: false };
     *
     * @return {boolean} TRUE, if action is required
     */
    Widget.prototype.isActionRequired = function(opts) {
        var values;
        if (!this.required) return false;
        opts = opts || {};
        opts.markAttempt = opts.markAttempt || false;
        opts.highlight = opts.highlight || false;
        values = this.getValues(opts);
        if (!values) return false; // Safety check.
        // TODO: check removed: values.missValues === true ||
        return values.choice === null || values.isCorrect === false;
    };

    /**
     * ### Widget.collapse
     *
     * Collapses the widget (hides the body and footer)
     *
     * Only, if it was previously appended to DOM
     *
     * @see Widget.uncollapse
     * @see Widget.isCollapsed
     */
    Widget.prototype.collapse = function() {
        if (!this.panelDiv) return;
        this.bodyDiv.style.display = 'none';
        this.collapsed = true;
        if (this.collapseButton) {
            this.collapseButton.src = '/images/maximize_small2.png';
            this.collapseButton.title = 'Restore';
        }
        if (this.footer) this.footer.style.display = 'none';
        // Move into collapse target, if one is specified.
        if (this.collapseTarget) this.collapseTarget.appendChild(this.panelDiv);
        this.emit('collapsed');
    };

    /**
     * ### Widget.uncollapse
     *
     * Uncollapses the widget (shows the body and footer)
     *
     * Only if it was previously appended to DOM
     *
     * @see Widget.collapse
     * @see Widget.isCollapsed
     */
    Widget.prototype.uncollapse = function() {
        if (!this.panelDiv) return;
        if (this.collapseTarget) {
            this.originalRoot.appendChild(this.panelDiv);
        }
        this.bodyDiv.style.display = '';
        this.collapsed = false;
        if (this.collapseButton) {
            this.collapseButton.src = '/images/maximize_small.png';
            this.collapseButton.title = 'Minimize';
        }
        if (this.footer) this.footer.style.display = '';
        this.emit('uncollapsed');
    };

    /**
     * ### Widget.isCollapsed
     *
     * Returns TRUE if widget is currently collapsed
     *
     * @return {boolean} TRUE, if widget is currently collapsed
     */
    Widget.prototype.isCollapsed = function() {
        return !!this.collapsed;
    };

    /**
     * ### Widget.enable
     *
     * Enables the widget
     *
     * An enabled widget allows the user to interact with it
     */
    Widget.prototype.enable = function(options) {
        if (!this.disabled) return;
        this.disabled = false;
        this.emit('enabled', options);
    };

    /**
     * ### Widget.disable
     *
     * Disables the widget
     *
     * A disabled widget is still visible, but user cannot interact with it
     */
    Widget.prototype.disable = function(options) {
        if (this.disabled) return;
        this.disabled = true;
        this.emit('disabled', options);
    };

    /**
     * ### Widget.isDisabled
     *
     * Returns TRUE if widget is disabled
     *
     * @return {boolean} TRUE if widget is disabled
     *
     * @see Widget.enable
     * @see Widget.disable
     * @see Widget.disabled
     */
    Widget.prototype.isDisabled = function() {
        return !!this.disabled;
    };

    /**
     * ### Widget.hide
     *
     * Hides the widget, if it was previously appended to DOM
     *
     * Sets the 'display' property of `panelDiv` to 'none'
     *
     * @see Widget.show
     * @see Widget.toggle
     */
    Widget.prototype.hide = function() {
        if (!this.panelDiv) return;
        if (this.hidden) return;
        this.panelDiv.style.display = 'none';
        this.hidden = true;
        this.emit('hidden');
    };

    /**
     * ### Widget.show
     *
     * Shows the widget, if it was previously appended and hidden
     *
     * Sets the 'display' property of `panelDiv` to ''
     *
     * @param {string} display Optional. The value of the display
     *    property. Default: ''
     *
     * @see Widget.hide
     * @see Widget.toggle
     */
    Widget.prototype.show = function(opts) {
        if (this.panelDiv && this.panelDiv.style.display === 'none') {
            // Backward compatible.
            opts = opts || {};
            if ('string' === typeof opts) opts = { display: opts };
            this.panelDiv.style.display = opts.display || '';
            this.hidden = false;

            W.adjustFrameHeight();
            if (opts.scroll !== false) {
                // Scroll into the slider.
                if ('function' === typeof this.bodyDiv.scrollIntoView) {
                    this.bodyDiv.scrollIntoView({ behavior: 'smooth' });
                }
                else if (window.scrollTo) {
                    // Scroll to bottom of page.
                    window.scrollTo(0, document.body.scrollHeight);
                }
            }

            this.emit('shown');
        }
    };

    /**
     * ### Widget.toggle
     *
     * Toggles the display of the widget, if it was previously appended
     *
     * @param {string} display Optional. The value of the display
     *    property in case the widget is currently hidden. Default: ''
     *
     * @see Widget.hide
     */
    Widget.prototype.toggle = function(display) {
        if (!this.panelDiv) return;
        if (this.hidden) this.show();
        else this.hide();
    };

    /**
     * ### Widget.isHidden
     *
     * TRUE if widget is hidden or not yet appended
     *
     * @return {boolean} TRUE if widget is hidden, or if it was not
     *   appended to the DOM yet
     */
    Widget.prototype.isHidden = function() {
        return !!this.hidden;
    };

    /**
     * ### Widget.destroy
     *
     * Performs cleanup operations
     *
     * `Widgets.get` wraps this method in an outer callback performing
     * default cleanup operations.
     *
     * @see Widgets.get
     */
    Widget.prototype.destroy = null;

    /**
     * ### Widget.setTitle
     *
     * Creates/removes an heading div with a given title
     *
     * Adds/removes a div with class `panel-heading` to the `panelDiv`.
     *
     * @param {string|HTMLElement|false} Optional. The title for the heading,
     *    div an HTML element, or false to remove the header completely.
     * @param {object} Optional. Options to be passed to `W.add` if a new
     *    heading div is created. Default: { className: 'panel-heading' }
     *
     * @see Widget.headingDiv
     * @see GameWindow.add
     */
    Widget.prototype.setTitle = function(title, options) {
        var tmp;
        if (!this.panelDiv) {
            throw new Error('Widget.setTitle: panelDiv is missing.');
        }

        // Remove heading with false-ish argument.
        if (!title) {
            if (this.headingDiv) {
                this.panelDiv.removeChild(this.headingDiv);
                this.headingDiv = null;
            }
        }
        else {
            if (!this.headingDiv) {
                // Add heading.
                if (!options) {
                    // Bootstrap 3
                    // options = { className: 'panel-heading' };
                    options = { className: 'card-header' };
                }
                else if ('object' !== typeof options) {
                    throw new TypeError('Widget.setTitle: options must ' +
                                        'be object or undefined. Found: ' +
                                        options);
                }
                this.headingDiv = W.add('div', this.panelDiv, options);
                // Move it to before the body (IE cannot have undefined).
                tmp = (this.bodyDiv && this.bodyDiv.childNodes[0]) || null;
                this.panelDiv.insertBefore(this.headingDiv, tmp);
            }

            // Set title.
            if (W.isElement(title)) {
                // The given title is an HTML element.
                this.headingDiv.innerHTML = '';
                this.headingDiv.appendChild(title);
            }
            else if ('string' === typeof title) {
                this.headingDiv.innerHTML = title;
            }
            else {
                throw new TypeError(J.funcName(this.constructor) +
                                    '.setTitle: title must be string, ' +
                                    'HTML element or falsy. Found: ' + title);
            }
            if (this.collapsible) {
                // Generates a button that hides the body of the panel.
                (function(that) {
                    var link, img;
                    link = document.createElement('span');
                    link.className = 'panel-collapse-link';
                    img = document.createElement('img');
                    img.src = '/images/minimize_small.png';
                    link.appendChild(img);
                    link.onclick = function() {
                        if (that.isCollapsed()) that.uncollapse();
                        else that.collapse();
                    };
                    that.headingDiv.appendChild(link);
                })(this);
            }
            if (this.closable) {
                (function(that) {
                    var link, img;
                    link = document.createElement('span');
                    link.className = 'panel-collapse-link';
                    // link.style['margin-right'] = '8px';
                    img = document.createElement('img');
                    img.src = '/images/close_small.png';
                    link.appendChild(img);
                    link.onclick = function() {
                        that.destroy();
                    };
                    that.headingDiv.appendChild(link);
                })(this);
            }
            if (this.info) {
                (function(that) {
                    var link, img, a;

                    link = W.add('span', that.headingDiv);
                    link.className = 'panel-collapse-link';

                    // link.style['margin-right'] = '8px';
                    a = W.add('a', link);
                    a.href = that.info;
                    a.target = '_blank';

                    img = W.add('img', a);
                    img.src = '/images/info.png';

                })(this);
            }
        }
    };

    /**
     * ### Widget.setFooter
     *
     * Creates/removes a footer div with a given content
     *
     * Adds/removes a div with class `panel-footer` to the `panelDiv`.
     *
     * @param {string|HTMLElement|false} Optional. The title for the header,
     *    an HTML element, or false to remove the header completely.
     * @param {object} Optional. Options to be passed to `W.add` if a new
     *    footer div is created. Default: { className: 'panel-footer' }
     *
     * @see Widget.footerDiv
     * @see GameWindow.add
     */
    Widget.prototype.setFooter = function(footer, options) {
        if (!this.panelDiv) {
            throw new Error('Widget.setFooter: panelDiv is missing.');
        }

        // Remove footer with false-ish argument.
        if (!footer) {
            if (this.footerDiv) {
                this.panelDiv.removeChild(this.footerDiv);
                delete this.footerDiv;
            }
        }
        else {
            if (!this.footerDiv) {
                // Add footer.
                if (!options) {
                    // Bootstrap 3.
                    // options = { className: 'panel-footer' };
                    // Bootstrap 5.
                    options = { className: 'card-footer' };
                }
                else if ('object' !== typeof options && 'function') {
                    throw new TypeError('Widget.setFooter: options must ' +
                                        'be object or undefined. Found: ' +
                                        options);
                }
                this.footerDiv = W.add('div', this.panelDiv, options);
            }

            // Set footer contents.
            if (W.isElement(footer)) {
                // The given footer is an HTML element.
                this.footerDiv.innerHTML = '';
                this.footerDiv.appendChild(footer);
            }
            else if ('string' === typeof footer) {
                this.footerDiv.innerHTML = footer;
            }
            else if ('function' === typeof footer) {
                footer.call(this, this.footerDiv);
            }
            else {
                throw new TypeError(J.funcName(this.constructor) +
                                    '.setFooter: footer must be string, ' +
                                    'HTML element or falsy. Found: ' + footer);
            }
        }
    };

    /**
     * ### Widget.setContext
     *
     * @deprecated
     */
    Widget.prototype.setContext = function() {
        console.log('*** Deprecation warning: setContext no longer ' +
                    'available in Bootstrap5.');
    };

    /**
     * ### Widget.addFrame
     *
     * Adds a border and margins around the bodyDiv element
     *
     * @param {string} context The type of bootstrap context.
     *   Default: 'default'
     *
     * @see Widget.panelDiv
     * @see Widget.bodyDiv
     */
    Widget.prototype.addFrame = function(context) {
        if ('undefined' === typeof context) {
            context = 'default';
        }
        else if ('string' !== typeof context || context.trim() === '') {
            throw new TypeError(J.funcName(this.constructor) +
                                '.addFrame: context must be a non-empty ' +
                                'string or undefined. Found: ' + context);
        }
        if (this.panelDiv) {
            if (this.panelDiv.className.indexOf('panel-') === -1) {
                W.addClass(this.panelDiv, 'panel-' + context);
            }
        }
        if (this.bodyDiv) {
            if (this.bodyDiv.className.indexOf('panel-body') === -1) {
                W.addClass(this.bodyDiv, 'panel-body');
            }
        }
    };

    /**
     * ### Widget.removeFrame
     *
     * Removes the border and the margins around the bodyDiv element
     *
     * @see Widget.panelDiv
     * @see Widget.bodyDiv
     */
    Widget.prototype.removeFrame = function() {
        if (this.panelDiv) W.removeClass(this.panelDiv, 'panel-[a-z]*');
        if (this.bodyDiv) W.removeClass(this.bodyDiv, 'panel-body');
    };

    /**
     * ### Widget.isAppended
     *
     * Returns TRUE if widget was appended to DOM (using Widget API)
     *
     * Checks if the panelDiv element has been created.
     *
     * @return {boolean} TRUE, if node.widgets.append was called
     */
    Widget.prototype.isAppended = function() {
        return !!this.panelDiv;
    };

    /**
     * ### Widget.isDestroyed
     *
     * Returns TRUE if widget has been destroyed
     *
     * @return {boolean} TRUE, if the widget has been destroyed
     */
    Widget.prototype.isDestroyed = function() {
        return !!this.destroyed;
    };

    /**
     * ### Widget.setSound
     *
     * Checks and assigns the value of a sound to play to user
     *
     * Throws an error if value is invalid
     *
     * @param {string} name The name of the sound to check
     * @param {mixed} path Optional. The path to the audio file. If undefined
     *    the default value from Widget.sounds is used
     *
     * @see Widget.sounds
     * @see Widget.getSound
     * @see Widget.setSounds
     * @see Widget.getSounds
     */
    Widget.prototype.setSound = function(name, value) {
        strSetter(this, name, value, 'sounds', 'Widget.setSound');
    };

    /**
     * ### Widget.setSounds
     *
     * Assigns multiple sounds at the same time
     *
     * @param {object} sounds Optional. Object containing sound paths
     *
     * @see Widget.sounds
     * @see Widget.setSound
     * @see Widget.getSound
     * @see Widget.getSounds
     */
    Widget.prototype.setSounds = function(sounds) {
        strSetterMulti(this, sounds, 'sounds', 'setSound',
                       J.funcName(this.constructor) + '.setSounds');
    };

    /**
     * ### Widget.getSound
     *
     * Returns the requested sound path
     *
     * @param {string} name The name of the sound variable.
     * @param {mixed} param Optional. Additional info to pass to the
     *   callback, if any
     *
     * @return {string} The requested sound
     *
     * @see Widget.sounds
     * @see Widget.setSound
     * @see Widget.getSound
     * @see Widget.getSounds
     */
    Widget.prototype.getSound = function(name, param) {
        return strGetter(this, name, 'sounds',
                         J.funcName(this.constructor) + '.getSound', param);
    };

    /**
     * ### Widget.getSounds
     *
     * Returns an object with selected sounds (paths)
     *
     * @param {object|array} keys Optional. An object whose keys, or an array
     *   whose values, are used of  to select the properties to return.
     *   Default: all properties in the collection object.
     * @param {object} param Optional. Object containing parameters to pass
     *   to the sounds functions (if any)
     *
     * @return {object} Selected sounds (paths)
     *
     * @see Widget.sounds
     * @see Widget.setSound
     * @see Widget.getSound
     * @see Widget.setSounds
     */
    Widget.prototype.getSounds = function(keys, param) {
        return strGetterMulti(this, 'sounds', 'getSound',
                              J.funcName(this.constructor)
                              + '.getSounds', keys, param);
    };

    /**
     * ### Widget.getAllSounds
     *
     * Returns an object with all current sounds
     *
     * @param {object} param Optional. Object containing parameters to pass
     *   to the sounds functions (if any)
     *
     * @return {object} All current sounds
     *
     * @see Widget.getSound
     */
    Widget.prototype.getAllSounds = function(param) {
        return strGetterMulti(this, 'sounds', 'getSound',
                              J.funcName(this.constructor) + '.getAllSounds',
                              undefined, param);
    };

    /**
     * ### Widget.setText
     *
     * Checks and assigns the value of a text to display to user
     *
     * Throws an error if value is invalid
     *
     * @param {string} name The name of the property to check
     * @param {mixed} value Optional. The value for the text. If undefined
     *    the default value from Widget.texts is used
     *
     * @see Widget.texts
     * @see Widget.getText
     * @see Widget.setTexts
     * @see Widget.getTexts
     */
    Widget.prototype.setText = function(name, value) {
        strSetter(this, name, value, 'texts',
                  J.funcName(this.constructor) + '.setText');
    };

    /**
     * ### Widget.setTexts
     *
     * Assigns all texts
     *
     * @param {object} texts Optional. Object containing texts
     *
     * @see Widget.texts
     * @see Widget.setText
     * @see Widget.getText
     * @see Widget.getTexts
     */
    Widget.prototype.setTexts = function(texts) {
        strSetterMulti(this, texts, 'texts', 'setText',
                       J.funcName(this.constructor) + '.setTexts');
    };

    /**
     * ### Widget.getText
     *
     * Returns the requested text
     *
     * @param {string} name The name of the text variable.
     * @param {mixed} param Optional. Additional to pass to the callback, if any
     *
     * @return {string} The requested text
     *
     * @see Widget.texts
     * @see Widget.setText
     * @see Widget.setTexts
     * @see Widget.getTexts
     */
    Widget.prototype.getText = function(name, param) {
        return strGetter(this, name, 'texts',
                         J.funcName(this.constructor) + '.getText', param);
    };

    /**
     * ### Widget.getTexts
     *
     * Returns an object with selected texts
     *
     * @param {object|array} keys Optional. An object whose keys, or an array
     *   whose values, are used of  to select the properties to return.
     *   Default: all properties in the collection object.
     * @param {object} param Optional. Object containing parameters to pass
     *   to the sounds functions (if any)
     *
     * @return {object} Selected texts
     *
     * @see Widget.texts
     * @see Widget.setText
     * @see Widget.getText
     * @see Widget.setTexts
     * @see Widget.getAllTexts
     */
    Widget.prototype.getTexts = function(keys, param) {
        return strGetterMulti(this, 'texts', 'getText',
                              J.funcName(this.constructor)
                              + '.getTexts', keys, param);
    };

    /**
     * ### Widget.getAllTexts
     *
     * Returns an object with all current texts
     *
     * @param {object|array} param Optional. Object containing parameters
     *   to pass to the texts functions (if any)
     *
     * @return {object} All current texts
     *
     * @see Widget.texts
     * @see Widget.setText
     * @see Widget.setTexts
     * @see Widget.getText
     */
    Widget.prototype.getAllTexts = function(param) {
        return strGetterMulti(this, 'texts', 'getText',
                              J.funcName(this.constructor)
                              + '.getAllTexts', undefined, param);
    };

    // ## Event-Emitter methods borrowed from NDDB

    /**
     * ### Widget.on
     *
     * Registers an event listener for the widget
     *
     * @see NDDB.off
     */
    Widget.prototype.on = function() {
        NDDB.prototype.on.apply(this, arguments);
    };

    /**
     * ### Widget.off
     *
     * Removes and event listener for the widget
     *
     * @see NDDB.off
     */
    Widget.prototype.off = function() {
        NDDB.prototype.off.apply(this, arguments);
    };

    /**
     * ### Widget.emit
     *
     * Emits an event within the widget
     *
     * @see NDDB.emit
     */
    Widget.prototype.emit = function() {
        NDDB.prototype.emit.apply(this, arguments);
    };

    /**
     * ### Widget.throwErr
     *
     * Get the name of the actual widget and throws the error
     *
     * It does **not** perform type checking on itw own input parameters.
     *
     * @param {string} type Optional. The error type, e.g. 'TypeError'.
     *   Default, 'Error'
     * @param {string} method Optional. The name of the method
     * @param {string|object} err Optional. The error. Default, 'generic error'
     *
     * @see NDDB.throwErr
     */
    Widget.prototype.throwErr = function(type, method, err) {
        var errMsg;
        errMsg = J.funcName(this.constructor) + '.' + method + ': ';
        if ('object' === typeof err) errMsg += err.stack || err;
        else if ('string' === typeof err) errMsg += err;
        if (type === 'TypeError') throw new TypeError(errMsg);
        throw new Error(errMsg);
    };

    /**
     * ### Widget.next
     *
     * Updates the widget with the next visualization within the same step
     *
     * @param {boolean} FALSE if there is no next visualization.
     *
     * @see Widget.prev
     */
    Widget.prototype.next = function() { return false; };

    /**
     * ### Widget.prev
     *
     * Updates the widget with the previous visualization within the same step
     *
     * @param {boolean} FALSE if there is no prev visualization.
     *
     * @see Widget.next
     */
    Widget.prototype.prev = function() { return false; };

    // ## Helper methods.

    /**
     * ### strGetter
     *
     * Returns the value a property from a collection in instance/constructor
     *
     * If the string is not found in the live instance, the default value
     * from the same collection inside the contructor is returned instead.
     *
     * If the property is not found in the corresponding static
     * collection in the constructor of the instance, an error is thrown.
     *
     * @param {object} that The main instance
     * @param {string} name The name of the property inside the collection
     * @param {string} collection The name of the collection inside the instance
     * @param {string} method The name of the invoking method (for error string)
     * @param {mixed} param Optional. If the value of the requested property
     *   is a function, this parameter is passed to it to get a return value.
     *
     * @return {string} res The value of requested property as found
     *   in the instance, or its default value as found in the constructor
     */
    function strGetter(that, name, collection, method, param) {
        var res;
        res = 'undefined' !== typeof that[collection][name] ?
            that[collection][name] : that.constructor[collection][name];
        if ('undefined' === typeof res) {
            throw new Error(method + ': name not found: ' + name);
        }

        if ('function' === typeof res) {
            res = res(that, param);
            if ('string' !== typeof res && res !== false) {
                throw new TypeError(method + ': cb "' + name + '" did not ' +
                                    'return neither string or false. Found: ' +
                                    res);
            }
        }
        return res;
    }

    /**
     * ### strGetterMulti
     *
     * Same as strGetter, but returns multiple values at once
     *
     * @param {object} that The main instance
     * @param {string} collection The name of the collection inside the instance
     * @param {string} getMethod The name of the method to get each value
     * @param {string} method The name of the invoking method (for error string)
     * @param {object|array} keys Optional. An object whose keys, or an array
     *   whose values, are used of this object are to select the properties
     *   to return. Default: all properties in the collection object.
     * @param {mixed} param Optional. If the value of the requested property
     *    is a function, this parameter is passed to it, when invoked to get
     *    a return value. Default: undefined
     *
     * @return {string} out The requested value.
     *
     * @see strGetter
     */
    function strGetterMulti(that, collection, getMethod, method, keys, param) {
        var out, k, len;
        if (!keys) keys = that.constructor[collection];
        if ('undefined' === typeof param) {
            param = {};
        }
        out = {};
        if (J.isArray(keys)) {
            k = -1, len = keys.length;
            for ( ; ++k < len;) {
                out[keys[k]] = that[getMethod](keys[k], param);
            }
        }
        else {
            for (k in keys) {
                if (keys.hasOwnProperty(k)) {
                    out[k] = that[getMethod](k, param);
                }
            }
        }
        return out;
    }

    /**
     * ### strSetterMulti
     *
     * Same as strSetter, but sets multiple values at once
     *
     * @param {object} that The main instance
     * @param {object} obj List of properties to set and their values
     * @param {string} collection The name of the collection inside the instance
     * @param {string} setMethod The name of the method to set each value
     * @param {string} method The name of the invoking method (for error string)
     *
     * @see strSetter
     */
    function strSetterMulti(that, obj, collection, setMethod, method) {
        var i;
        if ('object' !== typeof obj && 'undefined' !== typeof obj) {
            throw new TypeError(method + ': ' + collection +
                                ' must be object or undefined. Found: ' + obj);
        }
        for (i in obj) {
            if (obj.hasOwnProperty(i)) {
                that[setMethod](i, obj[i]);
            }
        }
    }

    /**
     * ### strSetter
     *
     * Sets the value of a property in a collection if string, function or false
     *
     * @param {object} that The main instance
     * @param {string} name The name of the property to set
     * @param {string|function|false} value The value for the property
     * @param {string} collection The name of the collection inside the instance
     * @param {string} method The name of the invoking method (for error string)
     *
     * @see strSetter
     */
    function strSetter(that, name, value, collection, method) {
        if ('undefined' === typeof that.constructor[collection][name]) {
            throw new TypeError(method + ': name not found: ' + name);
        }
        if ('string' === typeof value ||
            'function' === typeof value ||
            false === value) {

            that[collection][name] = value;
        }
        else {
            throw new TypeError(method + ': value for item "' + name +
                                '" must be string, function or false. ' +
                                'Found: ' + value);
        }
    }



})(
    // Widgets works only in the browser environment.
    ('undefined' !== typeof node) ? node : module.parent.exports.node
);

/**
 * # Widgets
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Helper class to interact with nodeGame widgets
 *
 * http://nodegame.org
 */
(function(window, node) {

    "use strict";

    // ## Widgets constructor

    function Widgets() {
        var that;

        /**
         * ### Widgets.widgets
         *
         * Container of currently registered widgets
         *
         * @see Widgets.register
         */
        this.widgets = {};

        /**
         * ### Widgets.instances
         *
         * Container of appended widget instances
         *
         * @see Widgets.append
         * @see Widgets.last
         */
        this.instances = [];

        /**
        * ### Widgets.last|lastAppended
         *
         * Reference to lastAppended widget
         *
         * @see Widgets.append
         */
        this.last = this.lastAppended = null;

        /**
         * ### Widgets.docked
         *
         * List of docked widgets
         */
        this.docked = [];

        /**
         * ### Widgets.dockedHidden
         *
         * List of hidden docked widgets (cause not enough space on page)
         */
        this.dockedHidden = [];

        /**
         * ### Widgets.boxSelector
         *
         * A box selector widget containing hidden docked widgets
         */
        this.boxSelector = null;

        /**
         * ### Widgets.collapseTarget
         *
         * Collapsed widgets are by default moved inside element
         */
        this.collapseTarget = null;

        that = this;
        node.registerSetup('widgets', function(conf) {
            var name, root, collapseTarget;
            if (!conf) return;

            // Add new widgets.
            if (conf.widgets) {
                for (name in conf.widgets) {
                    if (conf.widgets.hasOwnProperty(name)) {
                        that.register(name, conf.widgets[name]);
                    }
                }
            }

            // Destroy all existing widgets.
            if (conf.destroyAll) that.destroyAll();

            // Append existing widgets.
            if (conf.append) {
                for (name in conf.append) {
                    if (conf.append.hasOwnProperty(name)) {
                        // Determine root.
                        root = conf.append[name].root;
                        if ('function' === typeof root) {
                            root = root();
                        }
                        else if ('string' === typeof root) {
                            root = W.getElementById(root);
                        }
                        if (!root) root = W.getScreen();

                        if (!root) {
                            node.warn('setup widgets: could not find a root ' +
                                      'for widget ' + name + '. Requested: ' +
                                      conf.append[name].root);
                        }
                        else {
                            that.append(name, root, conf.append[name]);
                        }
                    }
                }
            }

            if (conf.collapseTarget) {
                if ('function' === typeof conf.collapseTarget) {
                    collapseTarget = conf.collapseTarget();
                }
                else if ('string' === typeof conf.collapseTarget) {
                    collapseTarget = W.getElementById(conf.collapseTarget);
                }
                else if (J.isElement(conf.collapseTarget)) {
                    collapseTarget = conf.collapseTarget;
                }
                if (!collapseTarget) {
                    node.warn('setup widgets: could not find collapse target.');
                }
                else {
                    that.collapseTarget = collapseTarget;
                }
            }

            return conf;
        });

        // Garbage collection.
        node.on('FRAME_LOADED', function() {
            node.widgets.garbageCollection();
        });

        node.info('node-widgets: loading');
    }

    // ## Widgets methods

    /**
     * ### Widgets.register
     *
     * Registers a new widget in the collection
     *
     * A name and a prototype class must be provided. All properties
     * that are present in `node.Widget`, but missing in the prototype
     * are added.
     *
     * Registered widgets can be loaded with Widgets.get or Widgets.append.
     *
     * @param {string} name The id under which to register the widget
     * @param {function} w The widget to add
     *
     * @return {object|boolean} The registered widget,
     *   or FALSE if an error occurs
     */
    Widgets.prototype.register = function(name, w) {
        if ('string' !== typeof name) {
            throw new TypeError('Widgets.register: name must be string. ' +
                                'Found: ' + name);
        }
        if ('function' !== typeof w) {
            throw new TypeError('Widgets.register: w must be function.' +
                               'Found: ' + w);
        }
        if ('undefined' === typeof w.sounds) w.sounds = {};
        if ('undefined' === typeof w.texts) w.texts = {};
        // Add default properties to widget prototype.
        J.mixout(w.prototype, new node.Widget());
        this.widgets[name] = w;
        return this.widgets[name];
    };

    /**
     * ### Widgets.get
     *
     * Retrieves, instantiates and returns the specified widget
     *
     * Performs the following checkings:
     *
     *   - dependencies, as specified by widget prototype, must exist
     *   - id, if specified in options, must be string
     *
     * and throws an error if conditions are not met.
     *
     * Adds the following properties to the widget object:
     *
     *   - title: as specified by the user or as found in the prototype
     *   - footer: as specified by the user or as found in the prototype
     *   - context: as specified by the user or as found in the prototype
     *   - className: as specified by the user or as found in the prototype
     *   - id: user-defined id
     *   - wid: random unique widget id
     *   - hooks: object containing event listeners
     *   - disabled: boolean flag indicating the widget state, set to FALSE
     *   - highlighted: boolean flag indicating whether the panelDiv is
     *        highlighted, set to FALSE
     *   - collapsible: boolean flag, TRUE if the widget can be collapsed
     *        and a button to hide body is added to the header
     *   - collapsed: boolan flag, TRUE if widget is collapsed (body hidden)
     *   - closable: boolean flag, TRUE if the widget can be closed (destroyed)
     *
     * Calls the `listeners` method of the widget. Any event listener
     * registered here will be automatically removed when the widget
     * is destroyed. !Important: it will erase previously recorded changes
     * by the event listener. If `options.listeners` is equal to false, the
     * listeners method is skipped.
     *
     * A `.destroy` method is added to the widget that perform the
     * following operations:
     *
     *   - removes the widget from DOM (if it was appended),
     *   - removes listeners defined during the creation,
     *   - and remove the widget from Widget.instances,
     *   - invoke the event 'destroyed'.
     *
     *
     * Finally, a reference to the widget is added in `Widgets.instances`.
     *
     * @param {string} widgetName The name of the widget to load
     * @param {object} opts Optional. Configuration options, will be
     *    mixed out with attributes in the `defaults` property
     *    of the widget prototype.
     *
     * @return {object} widget The requested widget
     *
     * @see Widgets.append
     * @see Widgets.instances
     */
    Widgets.prototype.get = function(widgetName, opts) {
        var WidgetProto, widget, changes, tmp, err;

        err = 'Widgets.get';

        if ('string' !== typeof widgetName) {
            throw new TypeError(err + ': widgetName must be string.' +
                               'Found: ' + widgetName);
        }

        err += widgetName + ': ';

        if (!opts) {
            opts = {};
        }
        else if ('object' !== typeof opts) {
            throw new TypeError(err + ' opts must be object or undefined. ' +
                                'Found: ' + opts);
        }

        WidgetProto = J.getNestedValue(widgetName, this.widgets);

        if (!WidgetProto) throw new Error(err + ' not found');

        node.info('creating widget ' + widgetName  + ' v.' +
                  WidgetProto.version);

        if (opts.storeRef === false) {
            if (opts.docked === true || WidgetProto.docked) {
                node.warn(err + ' storeRef=false ignored, widget is docked');
            }
        }

        if (!this.checkDependencies(WidgetProto)) {
            throw new Error(err + ' has unmet dependencies');
        }

        // Create widget.
        widget = new WidgetProto(opts);

        // Set ID.
        tmp = opts.id;
        if ('undefined' !== typeof tmp) {
            if ('number' === typeof tmp) tmp += '';
            if ('string' === typeof tmp) {

                if ('undefined' !== typeof opts.idPrefix) {
                    if ('string' === typeof opts.idPrefix &&
                        'number' !== typeof opts.idPrefix) {

                        tmp = opts.idPrefix + tmp;
                    }
                    else {
                        throw new TypeError('Widgets.get: opts.idPrefix ' +
                                            'must be string, number or ' +
                                            'undefined. Found: ' +
                                            opts.idPrefix);
                    }
                }

                widget.id = tmp;
            }
            else {
                throw new TypeError('Widgets.get: opts.id must be ' +
                                    'string, number or undefined. Found: ' +
                                    tmp);
            }
        }
        // Assign step id as widget id, if widget step and no custom id.
        else if (opts.widgetStep) {
            widget.id = node.game.getStepId();
        }

        // Set prototype values or opts values.
        if ('undefined' !== typeof opts.title) {
            widget.title = opts.title;
        }
        else if ('undefined' !== typeof WidgetProto.title) {
            widget.title = WidgetProto.title;
        }
        else {
            widget.title = '&nbsp;';
        }
        widget.panel = 'undefined' === typeof opts.panel ?
            WidgetProto.panel : opts.panel;
        widget.footer = 'undefined' === typeof opts.footer ?
            WidgetProto.footer : opts.footer;
        widget.className = WidgetProto.className;
        if (J.isArray(opts.className)) {
            widget.className += ' ' + opts.className.join(' ');
        }
        else if ('string' === typeof opts.className) {
            widget.className += ' ' + opts.className;
        }
        else if ('undefined' !== typeof opts.className) {
            throw new TypeError('Widgets.get: className must be array, ' +
                                'string, or undefined. Found: ' +
                                opts.className);
        }
        widget.context = 'undefined' === typeof opts.context ?
            WidgetProto.context : opts.context;
        widget.sounds = 'undefined' === typeof opts.sounds ?
            WidgetProto.sounds : opts.sounds;
        widget.texts = 'undefined' === typeof opts.texts ?
            WidgetProto.texts : opts.texts;

        widget.docked = 'undefined' === typeof opts.docked ?
            WidgetProto.docked : opts.docked;

        widget.collapsible = opts.collapsible || false;
        widget.closable = opts.closable || false;
        widget.collapseTarget =
            opts.collapseTarget || this.collapseTarget || null;
        widget.info = opts.info || false;

        widget.hooks = {
            hidden: [],
            shown: [],
            collapsed: [],
            uncollapsed: [],
            disabled: [],
            enabled: [],
            destroyed: [],
            highlighted: [],
            unhighlighted: []
        };

        // By default destroy widget on exit step.
        widget.destroyOnExit = opts.destroyOnExit !== false;

        // Required widgets require action from user, otherwise they will
        // block node.done().
        if (opts.required === false) {
            widget.required = false;
        }
        else if (opts.required || opts.requiredChoice ||
            ('undefined' !== typeof opts.correctChoice &&
             opts.correctChoice !== false)) {

            // Flag required is undefined, if not set to false explicitely.
            widget.required = true;
        }

        // Fixed properties.

        // Widget Name.
        widget.widgetName = widgetName;
        // Add random unique widget id.
        widget.wid = '' + J.randomInt(0,10000000000000000000);

        // UI properties.

        widget.disabled = null;
        widget.highlighted = null;
        widget.collapsed = null;
        widget.hidden = null;

        // Properties that will modify the UI of the widget once appended.

        // Option already checked.
        if (widget.docked) widget._docked = true;

        if (opts.bootstrap5) widget._bootstrap5 = true;
        if (opts.disabled) widget._disabled = true;
        if (opts.highlighted) widget._highlighted = true;
        if (opts.collapsed) widget._collapsed = true;
        if (opts.hidden) widget._hidden = true;


        // Call init.
        widget.init(opts);

        // Call listeners.
        if (opts.listeners !== false) {

            // TODO: future versions should pass the right event listener
            // to the listeners method. However, the problem is that it
            // does not have `on.data` methods, those are aliases.

         //  if ('undefined' === typeof opts.listeners) {
         //      ee = node.getCurrentEventEmitter();
         //  }
         //  else if ('string' === typeof opts.listeners) {
         //      if (opts.listeners !== 'game' &&
         //          opts.listeners !== 'stage' &&
         //          opts.listeners !== 'step') {
         //
         //          throw new Error('Widget.get: widget ' + widgetName +
         //                          ' has invalid value for option ' +
         //                          'listeners: ' + opts.listeners);
         //      }
         //      ee = node.events[opts.listeners];
         //  }
         //  else {
         //      throw new Error('Widget.get: widget ' + widgetName +
         //                      ' opts.listeners must be false, string ' +
         //                      'or undefined. Found: ' + opts.listeners);
         //  }

            // Start recording changes.
            node.events.setRecordChanges(true);

            widget.listeners.call(widget);

            // Get registered listeners, clear changes, and stop recording.
            changes = node.events.getChanges(true);
            node.events.setRecordChanges(false);
        }

        // If any listener was added or removed, the original situation will
        // be restored when the widget is destroyed.
        // The widget is also automatically removed from parent.
        widget.destroy = function() {
            var i, len, ee, eeName;

            (function() {
                try {
                    // Remove the widget's div from its parent.
                    if (widget.panelDiv && widget.panelDiv.parentNode) {
                        widget.panelDiv.parentNode.removeChild(widget.panelDiv);
                    }
                }
                catch(e) {
                    node.warn(widgetName + '.destroy: error caught: ' + e);
                }
            })();

            if (changes) {
                for (eeName in changes) {
                    if (changes.hasOwnProperty(eeName)) {
                        ee = changes[eeName];
                        i = -1, len = ee.added.length;
                        for ( ; ++i < len ; ) {
                            node.events.ee[eeName].off(ee.added[i].type,
                                                       ee.added[i].listener);
                        }
                        i = -1, len = changes[eeName].removed.length;
                        for ( ; ++i < len ; ) {
                            node.events.ee[eeName].on(ee.removed[i].type,
                                                      ee.removed[i].listener);
                        }
                    }
                }
            }

            // Remove widget from current instances, if found.
            if (widget.storeRef !== false) {
                i = -1, len = node.widgets.instances.length;
                for ( ; ++i < len ; ) {
                    if (node.widgets.instances[i].wid === widget.wid) {
                        node.widgets.instances.splice(i,1);
                        break;
                    }
                }
                // Remove from lastAppended.
                if (node.widgets.last &&
                    node.widgets.last.wid === this.wid) {

                    node.warn('node.widgets.last destroyed.');
                    node.widgets.lastAppended = node.widgets.last = null;
                }
            }

            // Remove from docked or adjust frame height.
            if (this.docked) closeDocked(widget.wid, false);
            else if (node.window) node.window.adjustFrameHeight(undefined, 120);

            // In case the widget is stored somewhere else, set destroyed.
            this.destroyed = true;

            this.emit('destroyed');
        };

        // Store widget instance (e.g., used for destruction).
        if (opts.storeRef !== false) this.instances.push(widget);
        else widget.storeRef = false;

        return widget;
    };

    /**
     * ### Widgets.append|add
     *
     * Appends a widget to the specified root element
     *
     * If no root element is specified the widget is append to the global root.
     *
     * The first parameter can be string representing the name of the widget or
     * a valid widget already loaded, for example through Widgets.get.
     * In the latter case, dependencies are checked, and it returns FALSE if
     * conditions are not met.
     *
     * @param {string|object} w The name of the widget to load or a loaded
     *   widget object
     * @param {object|string} root Optional. The HTML element (or its id) under
     *   which the widget will be appended. Default: `document.body` of the
     *   frame (if one is defined) or of the page
     * @param {options} options Optional. Configuration options to be passed
     *   to the widget
     *
     * @return {object|boolean} The requested widget, or FALSE is an error
     *   occurs
     *
     * @see Widgets.get
     */
    Widgets.prototype.add =
    Widgets.prototype.append = function(w, root, options) {
        var tmp;

        if ('string' !== typeof w && 'object' !== typeof w) {
            throw new TypeError('Widgets.append: w must be string or object. ' +
                               'Found: ' + w);
        }

        // If no root is defined, use the body element of the main frame,
        // if none is found, use the document.body.
        if (!root) {
            root = W.getFrameDocument();
            if (root) root = root.body;
            if (!root) root = document.body;
        }
        else if ('string' === typeof root) {
            tmp = W.gid(root);
            if (!tmp) {
                throw new Error('Widgets.append: element with id "' + root +
                                '" not found');
            }
            root = tmp;
        }
        if (!J.isElement(root)) {
            throw new TypeError('Widgets.append: root must be HTMLElement, ' +
                                'string or undefined. Found: ' + root);
        }

        if (options && 'object' !== typeof options) {
            throw new TypeError('Widgets.append: options must be object or ' +
                                'undefined. Found: ' + options);
        }

        // Init default values.
        options = options || {};
        if ('undefined' === typeof options.panel) {
            if (root === W.getHeader()) options.panel = false;
        }

        // Check if it is a object (new widget).
        // If it is a string is the name of an existing widget.
        // In this case a dependencies check is done.
        if ('string' === typeof w) w = this.get(w, options);

        // Add panelDiv (with or without panel).
        tmp = options.panel === false ? true : w.panel === false;

        if (w._bootstrap5) {
            // Bootstrap 5
            tmp = {
                className: tmp ? [ 'ng_widget', 'no-panel', w.className ] :
                    [ 'ng_widget', 'card', w.className ]
            };
        }
        else {
            // Bootstrap 3
            tmp = {
                className: tmp ? [ 'ng_widget',  'no-panel', w.className ] :
                    [ 'ng_widget', 'panel', 'panel-default', w.className ]
            };
        }

        // Dock it.
        if (options.docked || w._docked) {
            tmp.className.push('docked');
            this.docked.push(w);
            w.docked = true;
        }

        // Add div inside widget.
        w.panelDiv = W.get('div', tmp);

        // Optionally add title (and div).
        if (options.title !== false && w.title) {

            if (w._bootstrap5) {
                // Bootstrap 5.
                tmp = options.panel === false ?
                    'no-panel-heading' : 'card-header';
            }
            else {
                // Bootstrap 3.
                tmp = options.panel === false ?
                    'no-panel-heading' : 'panel-heading';
            }

            w.setTitle(w.title, { className: tmp });
        }

        // Add body (with or without panel).
        if (w._bootstrap5) {
            // Bootstrap 5.
            tmp = options.panel !== false ? 'card-body' : 'no-panel-body';
        }
        else {
            // Bootstrap 3.
            tmp = options.panel !== false ? 'panel-body' : 'no-panel-body';
        }

        w.bodyDiv = W.append('div', w.panelDiv, { className: tmp });

        // Optionally add footer.
        if (w.footer) {
            if (w._bootstrap5) {
                // Bootstrap 5.
                tmp = options.panel === false ?
                    'no-panel-heading' : 'card-footer';
            }
            else {
                    // Bootstrap 3.
                    tmp = options.panel === false ?
                        'no-panel-heading' : 'panel-heading';
            }

            w.setFooter(w.footer);
        }

        // Optionally set context.
        if (w.context) w.setContext(w.context);

        // Adapt UI 1: visibility.
        if (options.hidden || w._hidden) w.hide();
        if (options.collapsed || w._collapsed) w.collapse();

        // Append.
        root.appendChild(w.panelDiv);
        w.originalRoot = root;
        w.append();

        // Adapt UI 2: changes to elements. Needs to be after append, because
        // some elements needs to be created by append and then disabled.
        if (options.highlighted || w._highlighted) w.highlight();
        if (options.disabled || w._disabled) w.disable();

        if (w.docked) {
            // Make sure the distance from the right side is correct.
            setRightStyle(w);
        }
        else if (!w.isHidden() && !w.isCollapsed()) {
            W.adjustFrameHeight(undefined, 150);
        }

        // Store reference of last appended widget (.get method set storeRef).
        if (w.storeRef !== false) this.lastAppended = this.last = w;

        return w;
    };

    /**
     * ### Widgets.isWidget
     *
     * Returns TRUE if the object is a widget-like
     *
     * @param {object} w The object to test
     * @param {boolean} strict If TRUE, it checks if object is an
     *   instance of the Widget class. If FALSE, it just have to
     *   implement some of its methods (append and getValues).
     *
     * @return {boolean} TRUE, if the widget was found and destroyed.
     *
     * @see Widgets.get
     *
     * @api experimental
     */
    Widgets.prototype.isWidget = function(w, strict) {
        if (strict) return w instanceof node.Widget;
        return ('object' === typeof w &&
                'function' === typeof w.append &&
                'function' === typeof w.getValues &&
                // Used by widgets.append
                'function' === typeof w.isHidden &&
                'function' === typeof w.isCollapsed
            );
    };

    /**
     * ### Widgets.destroyAll
     *
     * Removes all widgets that have been created through Widgets.get
     *
     * @see Widgets.instances
     */
    Widgets.prototype.destroyAll = function() {
        var i, len;
        i = -1, len = this.instances.length;
        // Nested widgets can be destroyed by previous calls to destroy,
        // and each call to destroy modify the array of instances.
        for ( ; ++i < len ; ) {
            this.instances[0].destroy();
        }
        this.lastAppended = this.last = null;
        if (this.instances.length) {
            node.warn('node.widgets.destroyAll: some widgets could ' +
                      'not be destroyed.');
        }
    };

    /**
     * ### Widgets.checkDependencies
     *
     * Checks if all the dependencies are already loaded
     *
     * Dependencies are searched for in the following objects:
     *
     * - window
     * - node
     * - this.widgets
     * - node.window
     *
     * TODO: Check for version and other constraints.
     *
     * @param {object} w The widget to check
     * @param {boolean} quiet Optional. If TRUE, no warning will be raised.
     *   Default: FALSE
     * @return {boolean} TRUE, if all dependencies are met
     */
    Widgets.prototype.checkDependencies = function(w, quiet) {
        var parents, d, lib, found, i;
        if (!w.dependencies) return true;

        parents = [window, node, this.widgets, node.window];

        d = w.dependencies;
        for (lib in d) {
            if (d.hasOwnProperty(lib)) {
                found = false;
                for (i = 0; i < parents.length; i++) {
                    if (J.getNestedValue(lib, parents[i])) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    if (!quiet) checkDepErrMsg(w, lib);
                    return false;
                }
            }
        }
        return true;
    };

    /**
     * ### Widgets.garbageCollection
     *
     * Destroys previously appended widgets nowehere to be found on page
     *
     * @return {array} res List of destroyed widgets
     */
    Widgets.prototype.garbageCollection = (function() {

        // Some IE were missing .contains, so we fallback gracefully.
        function contains(target, widget) {
            var parentNode;
            if (target.contains) return target.contains(widget.panelDiv);
            parentNode = widget.panelDiv.parentNode;
            while (parentNode != null) {
                if (parentNode == target) return true;
                parentNode = parentNode.parentNode;
            }
            return false;
        }

        return function() {
            var w, i, fd, res;
            res = [];
            fd = W.getFrameDocument();
            w = node.widgets.instances;
            for (i = 0; i < w.length; i++) {
                // Check if widget is not on page any more.
                if (w[i].isAppended() &&
                (fd && !contains(fd, w[i])) &&
                !contains(document.body, w[i])) {

                    res.push(w[i]);
                    w[i].destroy();
                    i--;
                }
            }
            return res;
        };
    })();

    /**
     * ### Widgets.isActionRequired
     *
     * Returns TRUE, if any widget currently requires user action
     *
     * Loops trough all widgets that have the `required` flag.
     *
     * @param {object} opts Optional. Options to pass to Widget.getValues.
     *   Default: { markAttempt: false, highlight: false };
     *
     * @return {boolean} TRUE, if any widget requires action
     *
     * @see Widget.isActionRequired
     */
    Widgets.prototype.isActionRequired = function(opts) {
        var w, i, lastErrored, res;
        w = node.widgets.instances;
        res = false;
        for (i = 0; i < w.length; i++) {
            if (w[i].required) {
                if (w[i].isActionRequired(opts)) {
                    res = true;
                    lastErrored = w[i];
                }
            }
        }
        // Scroll to error.
        if (lastErrored && opts.highlight &&
            'function' === typeof lastErrored.bodyDiv.scrollIntoView) {

            lastErrored.bodyDiv.scrollIntoView({ behavior: 'smooth' });
        }
        return res;
    };

    // ## Helper functions

    // ### checkDepErrMsg
    //
    // Prints out an error message for a dependency not met.
    //
    // @param {Widget} w The widget
    // @param {string} d The dependency
    function checkDepErrMsg(w, d) {
        var name = w.name || w.id;
        node.err(d + ' not found. ' + name + ' cannot be loaded');
    }

    // ### closeDocked
    //
    // Shifts docked widgets on page and remove a widget from the docked list
    //
    // @param {string} wid The widget id
    // @param {boolean} remove TRUE, if widget should be removed from
    //    docked list. Default: FALSE.
    //
    // @return {boolean} TRUE if a widget with given wid was found
    //
    // @see BoxSelector
    function closeDocked(wid, hide) {
        var d, i, len, width, closed;
        d = node.widgets.docked;
        len = d.length;
        for (i = 0; i < len; i++) {
            if (width) {
                d[i].panelDiv.style.right =
                    (getPxNum(d[i].panelDiv.style.right) - width) + 'px';
            }
            else if (d[i].wid === wid) {
                width = d[i].dockedOffsetWidth;
                // Remove from docked list.
                closed = node.widgets.docked.splice(i, 1)[0];
                if (hide) {
                    node.widgets.dockedHidden.push(closed);
                    closed.hide();

                    if (!node.widgets.boxSelector) {
                        node.widgets.boxSelector =
                            node.widgets.append('BoxSelector', document.body, {
                                className: 'docked-left',
                                getId: function(i) { return i.wid; },
                                getDescr: function(i) { return i.title; },
                                onclick: function(i, id) {
                                    i.show();
                                    // First add back to docked list,
                                    // then set right style.
                                    node.widgets.docked.push(i);
                                    setRightStyle(i);
                                    this.removeItem(id);
                                    if (this.items.length === 0) {
                                        this.destroy();
                                        node.widgets.boxSelector = null;
                                    }
                                },
                            });

                    }
                    node.widgets.boxSelector.addItem(closed);
                }
                // Decrement len and i.
                len--;
                i--;
            }
        }
        return !!width;
    }

    // ### setRightStyle
    //
    // Sets the right property of the panelDiv of a docked widget
    //
    // May close docked widgets to make space to this one.
    //
    // @param {Widget} w The widget
    function setRightStyle(w) {
        var dockedMargin, safeMargin;
        var lastDocked, right, ws, tmp;

        safeMargin = 200;
        dockedMargin = 20;

        ws = node.widgets;

        right = 0;
        // The widget w has been already added to the docked list.
        if (ws.docked.length > 1) {
            lastDocked = ws.docked[(ws.docked.length - 2)];
            right = getPxNum(lastDocked.panelDiv.style.right);
            right += lastDocked.panelDiv.offsetWidth;
        }
        right += dockedMargin;

        w.panelDiv.style.right = (right + "px");

        // Check if there is enough space on page?
        tmp = 0;
        right += w.panelDiv.offsetWidth + safeMargin;
        while (ws.docked.length > 1 &&
               right > window.innerWidth &&
               tmp < (ws.docked.length - 1)) {

            // Make some space...
            closeDocked(ws.docked[tmp].wid, true);
            tmp++;
        }
        // Store final offsetWidth in widget, because we need it after
        // it is destroyed.
        w.dockedOffsetWidth = w.panelDiv.offsetWidth + dockedMargin;
    }

    // ### getPxNum
    //
    // Returns the numeric value of string containg 'px' at the end, e.g. 20px.
    //
    // @param {string} The value of a css property containing 'px' at the end
    //
    // @return {number} The numeric value of the css property
    function getPxNum(str) {
        return parseInt(str.substring(0, str.length - 2), 10);
    }

    // Expose Widgets to the global object.
    node.widgets = new Widgets();

})(
    // Widgets works only in the browser environment.
    ('undefined' !== typeof window) ? window : module.parent.exports.window,
    ('undefined' !== typeof window) ? window.node : module.parent.exports.node
);

/**
 * # BackButton
 * Copyright(c) 2020 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Creates a button that if pressed goes to the previous step
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('BackButton', BackButton);

    // ## Meta-data

    BackButton.version = '0.5.0';
    BackButton.description = 'Creates a button that if ' +
        'pressed goes to the previous step.';

    BackButton.title = false;
    BackButton.panel = false;
    BackButton.className = 'backbutton';
    BackButton.texts.back = 'Back';

    /**
     * ## BackButton constructor
     *
     * Creates a new instance of BackButton
     *
     * @param {object} options Optional. Configuration options.
     *   If a `button` option is specified, it sets it as the clickable
     *   button. All other options are passed to the init method.
     *
     * @see BackButton.init
     */
    function BackButton(options) {
        var that;
        that = this;

        /**
         * ### BackButton.button
         *
         * The HTML element.
         */
        if ('object' === typeof options.button) {
            this.button = options.button;
        }
        else if ('undefined' === typeof options.button) {
            this.button = document.createElement('input');
            this.button.type = 'button';
        }
        else {
            throw new TypeError('BackButton constructor: options.button must ' +
                                'be object or undefined. Found: ' +
                                options.button);
        }

        this.button.onclick = function() {
            var res;
            that.disable();
            if (that.onclick && false === that.onclick()) return;
            if (node.game.isWidgetStep()) {
                // Widget has a next visualization in the same step.
                if (node.widgets.last.prev() !== false) {
                    that.enable();
                    return;
                }
            }
            res = node.game.stepBack(that.stepOptions);
            if (res === false) that.enable();
        };

        this.stepOptions = {

            /**
             * #### BackButton.stepOptions.acrossStages
             *
             * If TRUE, it allows to go back to previous stages
             *
             * Default: FALSE
             */
            acrossStages: null,

            /**
             * #### BackButton.stepOptions.acrossRounds
             *
             * If TRUE, it allows to go back previous rounds in the same stage
             *
             * Default: TRUE
             */
            acrossRounds: null,


            // ## @api: private.
            noZeroStep: true
        };


        /**
         * #### BackButton.onclick
         *
         * A callback function executed when the button is clicked
         *
         * If the function returns FALSE, the procedure is aborted.
         *
         * Default: TRUE
         */
        this.onclick = null;
    }

    // ## BackButton methods

    /**
     * ### BackButton.init
     *
     * Initializes the instance
     *
     * Available options are:
     *
     * - id: id of the HTML button, or false to have none. Default:
     *     BackButton.className
     * - className: the className of the button (string, array), or false
     *     to have none. Default bootstrap classes: 'btn btn-lg btn-primary'
     * - text: the text on the button. Default: BackButton.text
     * - acrossStages: if TRUE, allows going back to previous stages.
     *     Default: FALSE
     * - acrossRounds: if TRUE, allows going back to previous rounds in
     *     the same stage. Default: TRUE
     *
     * @param {object} options Optional. Configuration options
     */
    BackButton.prototype.init = function(opts) {
        var tmp;
        opts = opts || {};

        //Button
        if ('undefined' === typeof opts.id) {
            tmp = BackButton.className;
        }
        else if ('string' === typeof opts.id) {
            tmp = opts.id;
        }
        else if (false === opts.id) {
            tmp = '';
        }
        else {
            throw new TypeError('BackButton.init: opts.id must ' +
                                'be string, false, or undefined. Found: ' +
                                opts.id);
        }
        this.button.id = tmp;

        if ('undefined' === typeof opts.className) {
            tmp  = 'btn btn-lg btn-secondary';
        }
        else if (opts.className === false) {
            tmp = '';
        }
        else if ('string' === typeof opts.className) {
            tmp = opts.className;
        }
        else if (J.isArray(opts.className)) {
            tmp = opts.className.join(' ');
        }
        else  {
            throw new TypeError('BackButton.init: opts.className must ' +
                                'be string, array, or undefined. Found: ' +
                                opts.className);
        }
        this.button.className = tmp;

        // Button text.
        this.button.value = 'string' === typeof opts.text ?
            opts.text : this.getText('back');

        this.stepOptions.acrossStages =
            'undefined' === typeof opts.acrossStages ?
            false : !!opts.acrossStages;
        this.stepOptions.acrossRounds =
            'undefined' === typeof opts.acrossRounds ?
            true : !!opts.acrossRounds;

        setOnClick(this, opts.onclick);
    };

    BackButton.prototype.append = function() {
        if (!node.game.getPreviousStep(1, this.stepOptions)) this.disable();
        this.bodyDiv.appendChild(this.button);
    };

    BackButton.prototype.listeners = function() {
        var that = this;

        node.events.game.on('DONE', function() {
            that.disable();
        });

        // Locks the back button in case of a timeout.
        node.events.game.on('PLAYING', function() {
            var prop, step;

            // Check options.
            step = node.game.getPreviousStep(1, that.stepOptions);
            prop = node.game.getProperty('backbutton');

            if (prop !== true &&
                (!step || prop === false ||
                (prop && prop.enableOnPlaying === false))) {

                // It might be disabled already, but we do it again.
                that.disable();
            }
            else {
                // It might be enabled already, but we do it again.
                if (prop === true || step) that.enable();
            }

            if ('string' === typeof prop) that.button.value = prop;
            else if (prop && prop.text) that.button.value = prop.text;

            if (prop) {
                setOnClick(that, prop.onclick, true);
                if (prop.enable) that.enable();
            }
        });

        // Catch those events.
        node.events.game.on('WIDGET_NEXT', function() {
            that.enable();
        });
    };

    /**
     * ### BackButton.disable
     *
     * Disables the back button
     */
    BackButton.prototype.disable = function() {
        if (this.disabled) return;
        this.disabled = true;
        this.button.disabled = true;
        this.emit('disabled');
    };

    /**
     * ### BackButton.enable
     *
     * Enables the back button
     */
    BackButton.prototype.enable = function() {
        if (!this.disabled) return;
        this.disabled = false;
        this.button.disabled = false;
        this.emit('enabled');
    };

    // ## Helper functions.

    // Checks and sets the onclick function.
    function setOnClick(that, onclick, step) {
        var str;
        if ('undefined' !== typeof onclick) {
            if ('function' !== typeof onclick && onclick !== null) {
                str = 'BackButton.init';
                if (step) str += ' (step property)';
                throw new TypeError(str + ': onclick must be function, null,' +
                                    ' or undefined. Found: ' + onclick);
            }
            that.onclick = onclick;
        }
    }

})(node);

/**
 * # BoxSelector
 * Copyright(c) 2019 Stefano Balietti
 * MIT Licensed
 *
 * Creates a simple box that opens a menu of items to choose from
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    var NDDB =  node.NDDB;

    node.widgets.register('BoxSelector', BoxSelector);

    // ## Meta-data

    BoxSelector.version = '1.0.0';
    BoxSelector.description = 'Creates a simple box that opens a menu ' +
        'of items to choose from.';

    BoxSelector.panel = false;
    BoxSelector.title = false;
    BoxSelector.className = 'boxselector';

    // ## Dependencies

    BoxSelector.dependencies = {
        JSUS: {}
    };

    /**
     * ## BoxSelector constructor
     *
     * `BoxSelector` is a simple configurable chat
     *
     * @see BoxSelector.init
     */
    function BoxSelector() {

        /**
         * ### BoxSelector.button
         *
         * The button that if pressed shows the items
         *
         * @see BoxSelector.ul
         */
        this.button = null;

        /**
         * ### BoxSelector.buttonText
         *
         * The text on the button
         *
         * @see BoxSelector.button
         */
        this.buttonText = '';

        /**
         * ### BoxSelector.items
         *
         * List of items to choose from
         */
        this.items = [];

        /**
         * ### BoxSelector.onclick
         *
         * A callback to call when an item from the list is clicked
         *
         * Callback is executed with the BoxSelector instance as context.
         *
         * Optional. If not specified, items won't be clickable.
         *
         * @see BoxSelector.items
         */
        this.onclick = null;

        /**
         * ### BoxSelector.getDescr
         *
         * A callback that renders an element into a text
         */
        this.getDescr = null;

        /**
         * ### BoxSelector.getId
         *
         * A callback that returns the id of an item
         *
         * Default: returns item.id.
         */
        this.getId = function(item) { return item.id; };

        /**
         * ### BoxSelector.ul
         *
         * The HTML UL element displaying the list of items
         *
         * @see BoxSelector.items
         */
        this.ul = null;
    }

    // ## BoxSelector methods

    /**
     * ### BoxSelector.init
     *
     * Initializes the widget
     *
     * @param {object} options Configuration options.
     */
    BoxSelector.prototype.init = function(options) {
        if (options.onclick) {
            if ('function' !== typeof options.onclick) {
                throw new Error('BoxSelector.init: options.getId must be ' +
                                'function or undefined. Found: ' +
                                options.getId);
            }
            this.onclick = options.onclick;
        }

        if ('function' !== typeof options.getDescr) {
            throw new Error('BoxSelector.init: options.getDescr must be ' +
                            'function. Found: ' + options.getDescr);
        }
        this.getDescr = options.getDescr;

        if (options.getId && 'function' !== typeof options.getId) {
            throw new Error('BoxSelector.init: options.getId must be ' +
                            'function or undefined. Found: ' + options.getId);
        }
        this.getId = options.getId;


    };


    BoxSelector.prototype.append = function() {
        var that, ul, btn, btnGroup, toggled;

        btnGroup = W.add('div', this.bodyDiv);
        btnGroup.role = 'group';
        btnGroup['aria-label'] = 'Select Items';
        btnGroup.className = 'btn-group dropup';

        // Here we create the Button holding the treatment.
        btn = this.button = W.add('button', btnGroup);
        btn.className = 'btn btn-default btn dropdown-toggle';
        btn['data-toggle'] = 'dropdown';
        btn['aria-haspopup'] = 'true';
        btn['aria-expanded'] = 'false';
        btn.innerHTML = this.buttonText + '&nbsp;';

        W.add('span', btn, { className: 'caret' });

        // Here the create the UL of treatments.
        // It will be populated later.
        ul = this.ul = W.add('ul', btnGroup);
        ul.className = 'dropdown-menu';
        ul.style.display = 'none';

        // Variable toggled controls if the dropdown menu
        // is displayed (we are not using bootstrap js files)
        // and we redo the job manually here.
        toggled = false;
        btn.onclick = function() {
            if (toggled) {
                ul.style.display = 'none';
                toggled = false;
            }
            else {
                ul.style.display = 'block';
                toggled = true;
            }
        };

        if (this.onclick) {
            that = this;
            ul.onclick = function(eventData) {
                var id, i, len;
                id = eventData.target;
                // When '' is hidden by bootstrap class.
                ul.style.display = '';
                toggled = false;
                id = id.parentNode.id;
                // Clicked on description?
                if (!id) id = eventData.target.parentNode.parentNode.id;
                // Nothing relevant clicked (e.g., header).
                if (!id) return;
                len = that.items.length;
                // Call the onclick.
                for ( i = 0 ; i < len ; i++) {
                    if (that.getId(that.items[i]) === id) {
                        that.onclick.call(that, that.items[i], id);
                        break;
                    }
                }
            };
        }
    };

    /**
     * ### BoxSelector.addItem
     *
     * Adds an item to the list and renders it
     *
     * @param {mixed} item The item to add
     */
    BoxSelector.prototype.addItem = function(item) {
        var ul, li, a, tmp;
        ul = this.ul;
        li = document.createElement('li');
        // Text.
        tmp = this.getDescr(item);
        if (!tmp || 'string' !== typeof tmp) {
            throw new Error('BoxSelector.addItem: getDescr did not return a ' +
                            'string. Found: ' + tmp + '. Item: ' + item);
        }
        if (this.onclick) {
            a = document.createElement('a');
            a.href = '#';
            a.innerHTML = tmp;
            li.appendChild(a);
        }
        else {
            li.innerHTML = tmp;
        }
        // Id.
        tmp = this.getId(item);
        if (!tmp || 'string' !== typeof tmp) {
            throw new Error('BoxSelector.addItem: getId did not return a ' +
                            'string. Found: ' + tmp + '. Item: ' + item);
        }
        li.id = tmp;
        li.className = 'dropdown-header';
        ul.appendChild(li);
        this.items.push(item);
    };

    /**
     * ### BoxSelector.removeItem
     *
     * Removes an item with given id from the list and the dom
     *
     * @param {mixed} item The item to add
     *
     * @return {mixed|boolean} The removed item or false if not found
     */
    BoxSelector.prototype.removeItem = function(id) {
        var i, len, elem;
        len = this.items.length;
        for ( i = 0 ; i < len ; i++) {
            if (this.getId(this.items[i]) === id) {
                elem = W.gid(id);
                this.ul.removeChild(elem);
                return this.items.splice(i, 1);
            }
        }
        return false;
    };

    BoxSelector.prototype.getValues = function() {
        return this.items;
    };

    // ## Helper functions.


})(node);

/**
 * # Chat
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Creates a simple configurable chat
 *
 * // TODO: add bootstrap badge to count msg when collapsed
 * // TODO: check on data if message comes back
 * // TODO: highlight better incoming msg. Play sound?
 * // TODO: removeParticipant and addParticipant methods.
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    var NDDB =  node.NDDB;

    node.widgets.register('Chat', Chat);

    // ## Texts.

    Chat.texts = {
        outgoing: function(w, data) {
            return data.msg;
            // return '<span class="chat_msg_me">' + data.msg + '</span>';
        },
        incoming: function(w, data) {
            var str;
            str = '<span>';
            if (w.recipientsIds.length > 1) {
                str += '<span class="chat_id_other">' +
                    (w.senderToNameMap[data.id] || data.id) + '</span>: ';
            }
            str += data.msg + '</span>';
            return str;
        },
        quit: function(w, data) {
            return (w.senderToNameMap[data.id] || data.id) + ' left the chat';
        },
        noMoreParticipants: function() {
            return 'No active participant left. Chat disabled.';
        },
        // For both collapse and uncollapse.
        collapse: function(w, data) {
            return (w.senderToNameMap[data.id] || data.id) + ' ' +
                (data.collapsed ? 'mini' : 'maxi') + 'mized the chat';
        },
        textareaPlaceholder: function(w) {
            return w.useSubmitEnter ?
                'Type something and press enter to send' : 'Type something';
        },
        submitButton: 'Send',
        isTyping: 'is typing...'
    };

    // ## Meta-data

    Chat.version = '1.5.0';
    Chat.description = 'Offers a uni-/bi-directional communication interface ' +
        'between players, or between players and the server.';

    Chat.title = 'Chat';
    Chat.className = 'chat';

    Chat.panel = false;

    // ## Dependencies

    Chat.dependencies = {
        JSUS: {}
    };

    /**
     * ## Chat constructor
     *
     * `Chat` is a simple configurable chat
     *
     * @see Chat.init
     */
    function Chat() {

        /**
         * ### Chat.chatEvent
         *
         * The suffix used to fire chat events
         *
         * Default: 'CHAT'
         */
        this.chatEvent = null;

        /**
         * ### Chat.stats
         *
         * Some basic statistics about message counts
         */
        this.stats = {
            received: 0,
            sent: 0,
            unread: 0
        };

        /**
         * ### Chat.submitButton
         *
         * Button to send a text to server
         *
         * @see Chat.useSubmitButton
         */
        this.submitButton = null;

        /**
         * ### Chat.useSubmitButton
         *
         * If TRUE, a button is added to send messages
         *
         * By default, this is TRUE on mobile devices.
         *
         * @see Chat.submitButton
         * @see Chat.receiverOnly
         */
        this.useSubmitButton = null;

        /**
         * ### Chat.useSubmitButton
         *
         * If TRUE, pressing ENTER sends the msg
         *
         * By default, TRUE
         *
         * @see Chat.submitButton
         * @see Chat.receiverOnly
         */
        this.useSubmitEnter = null;

        /**
         * ### Chat.receiverOnly
         *
         * If TRUE, users cannot send messages (no textarea and submit button)
         *
         * @see Chat.textarea
         */
        this.receiverOnly = false;

        /**
         * ### Chat.storeMsgs
         *
         * If TRUE, a copy of sent and received messages is stored in db
         *
         * @see Chat.db
         */
        this.storeMsgs = false;

        /**
         * ### Chat.db
         *
         * An NDDB database for storing incoming and outgoing messages
         *
         * @see Chat.storeMsgs
         */
        this.db = null;

        /**
         * ### Chat.chatDiv
         *
         * The DIV wherein to display the chat
         */
        this.chatDiv = null;

        /**
         * ### Chat.textarea
         *
         * The textarea wherein to write and read
         */
        this.textarea = null;

        /**
         * ### Chat.initialMsg
         *
         * An object with an initial msg and the id of sender (if not self)
         *
         * Example:
         *
         * ```
         * {
         *   id: '1234', // Optional, add only this is an 'incoming' msg.
         *   msg: 'the text'
         * }
         */
        this.initialMsg = null;

        /**
         * ### Chat.recipientsIds
         *
         * Array of ids of current recipients of messages
         */
        this.recipientsIds = null;

        /**
         * ### Chat.recipientsIdsQuitted
         *
         * Array of ids of  recipients that have previously quitted the chat
         */
        this.recipientsIdsQuitted = null;

        /**
         * ### Chat.senderToNameMap
         *
         * Map sender id (msg.from) to display name
         *
         * Note: The 'from' field of a message can be different
         * from the 'to' field of its reply (e.g., for MONITOR)
         */
        this.senderToNameMap = null;

        /**
         * ### Chat.recipientToNameMap
         *
         * Map recipient id (msg.to) to display name
         */
        this.recipientToNameMap = null;

        /**
         * ### Chat.senderToRecipientMap
         *
         * Map sender id (msg.from) to recipient id (msg.to)
         */
        this.senderToRecipientMap = null;

        /**
         * ### Chat.recipientToSenderMap
         *
         * Map recipient id (msg.to) to sender id (msg.from)
         */
        this.recipientToSenderMap = null;

        /**
         * ### Chat.showIsTyping
         *
         * TRUE, if "is typing" notice is shown
         */
        this.showIsTyping = null;

        /**
         * ### Chat.amTypingTimeout
         *
         * Timeout to send an own "isTyping" notification
         *
         * Timeout is added as soon as the user start typing, cleared when
         * a message is sent.
         */
        this.amTypingTimeout = null;

        /**
         * ### Chat.isTypingTimeouts
         *
         * Object containing timeouts for all participants currently typing
         *
         * A new timeout is added when an IS_TYPING msg is received and
         * cleared when a msg arrives or at expiration.
         */
        this.isTypingTimeouts = {};

        /**
         * ### Chat.isTypingDivs
         *
         * Object containing divs where "is typing" is diplayed
         *
         * Once created
         */
        this.isTypingDivs = {};

        /**
         * ### Chat.preprocessMsg
         *
         * A function that process the msg before being displayed
         *
         * It does not preprocess the initial message
         * and "is typing" notifications.
         *
         * Example:
         *
         * ```js
         * function(data, code) {
         *     data.msg += '!';
         * }
         * ```
         */
        this.preprocessMsg = null;

    }

    // ## Chat methods

    /**
     * ### Chat.init
     *
     * Initializes the widget
     *
     * @param {object} opts Optional. Configuration options.
     *
     * The options object can have the following attributes:
     *   - `receiverOnly`: If TRUE, no message can be sent
     *   - `chatEvent`: The event to fire when sending/receiving a message
     *   - `useSubmitButton`: If TRUE, a submit button is added.
     *        Default: TRUE on mobile
     *   - `useSubmitEnter`: If TRUE, pressing ENTER sends a msg.
     *        Default: TRUE
     *   - `showIsTyping: If TRUE, a notice is displayed when users are
     *        typing. Default: TRUE
     *   - `storeMsgs`: If TRUE, a copy of every message is stored in
     *        a local db
     *   - `participants`: An array containing the ids of participants,
     *        cannot be empty
     *   - `initialMsg`: Initial message to be displayed as soon as the chat
     *        is opened.
     *   - `uncollapseOnMsg`: If TRUE, a minimized chat will automatically
     *        open when receiving a msg. Default: FALSE.
     *   - `printStartTime`: If TRUE, the initial time of the chat is
     *        printed at the beginning of the chat. Default: FALSE.
     *   - `printNames`: If TRUE, the names of the participants of the chat
     *        is printed at the beginning of the chat. Default: FALSE.
     */
    Chat.prototype.init = function(opts) {
        var tmp, i, rec, sender, that;
        opts = opts || {};
        that = this;

        // Receiver Only.
        this.receiverOnly = !!opts.receiverOnly;

        tmp = opts.preprocessMsg;
        if ('function' === typeof tmp) {
            this.preprocessMsg = tmp;
        }
        else if (tmp) {
            throw new TypeError('Chat.init: preprocessMsg must be function ' +
                                'or undefined. Found: ' + tmp);
        }

        // Chat id.
        tmp = opts.chatEvent;
        if (tmp) {
            if ('string' !== typeof tmp) {
                throw new TypeError('Chat.init: chatEvent must be a non-' +
                                    'empty string or undefined. Found: ' + tmp);
            }
            this.chatEvent = opts.chatEvent;
        }
        else {
            this.chatEvent = 'CHAT';
        }

        // Store.
        this.storeMsgs = !!opts.storeMsgs;
        if (this.storeMsgs) {
            if (!this.db) this.db = new NDDB();
        }

        // Button to send msg.
        this.useSubmitButton = 'undefined' === typeof opts.useSubmitButton ?
            J.isMobileAgent() : !!opts.useSubmitButton;

        // Enter to send msg (does not exclude button).
        this.useSubmitEnter = 'undefined' === typeof opts.useSubmitEnter ?
            true : !!opts.useSubmitEnter;

        // Participants.
        tmp = opts.participants;
        if (!J.isArray(tmp) || !tmp.length) {
            throw new TypeError('Chat.init: participants must be ' +
                                'a non-empty array. Found: ' + tmp);
        }

        // Build maps.
        this.recipientsIds = new Array(tmp.length);
        this.recipientsIdsQuitted = [];
        this.recipientToSenderMap = {};
        this.recipientToNameMap = {};
        this.senderToNameMap = {};
        this.senderToRecipientMap = {};

        for (i = 0; i < tmp.length; i++) {
            // Everything i the same if string.
            if ('string' === typeof tmp[i]) {
                this.recipientsIds[i] = tmp[i];
                this.recipientToNameMap[tmp[i]] = tmp[i];
                this.recipientToSenderMap[tmp[i]] = tmp[i];
                this.senderToRecipientMap[tmp[i]] = tmp[i];
                this.senderToNameMap[tmp[i]] = tmp[i];
            }
            // Sender may be different from receiver if object.
            else if ('object' === typeof tmp[i]) {
                rec = tmp[i].recipient;
                sender = tmp[i].sender;
                this.recipientsIds[i] = rec;
                this.recipientToSenderMap[rec] = sender || rec;
                this.recipientToNameMap[rec] = tmp[i].name || rec;
                this.senderToRecipientMap[sender] = rec;
                this.senderToNameMap[sender] = this.recipientToNameMap[rec];
            }
            else {
                throw new TypeError('Chat.init: participants array must ' +
                                    'contain string or object. Found: ' +
                                    tmp[i]);
            }
        }

        // Other.
        this.uncollapseOnMsg = opts.uncollapseOnMsg || false;

        this.printStartTime = opts.printStartTime || false;
        this.printNames = opts.printNames || false;

        if (opts.initialMsg) {
            if ('object' !== typeof opts.initialMsg) {
                throw new TypeError('Chat.init: initialMsg must be ' +
                                    'object or undefined. Found: ' +
                                    opts.initialMsg);
            }
            this.initialMsg = opts.initialMsg;
        }

        this.on('uncollapsed', function() {
            // Make sure that we do not have the title highlighted any more.
            that.setTitle(that.title);
            if (that.recipientsIds.length) {
                node.say(that.chatEvent + '_COLLAPSE',
                         that.recipientsIds, false);
            }
        });

        this.on('collapsed', function() {
            if (that.recipientsIds.length) {
                node.say(that.chatEvent + '_COLLAPSE',
                         that.recipientsIds, true);
            }
        });

        this.on('destroyed', function() {
            if (that.recipientsIds.length) {
                node.say(that.chatEvent + '_QUIT', that.recipientsIds);
            }
        });

        this.showIsTyping = 'undefined' === typeof opts.showIsTyping ?
            true : !!opts.showIsTyping;
    };

    Chat.prototype.append = function() {
        var that, inputGroup, initialText;
        that = this;

        this.chatDiv = W.get('div', { className: 'chat_chat' });
        this.bodyDiv.appendChild(this.chatDiv);

        if (!this.receiverOnly) {

            // Input group.
            inputGroup = document.createElement('div');
            inputGroup.className = 'chat_inputgroup';

            this.textarea = W.get('textarea', {
                className: 'chat_textarea form-control',
                placeholder: this.getText('textareaPlaceholder')
            });
            inputGroup.appendChild(this.textarea);

            if (this.useSubmitButton) {
                this.submitButton = W.get('button', {
                    className: 'btn-sm btn-info form-control chat_submit',
                    innerHTML: this.getText('submitButton')
                });
                this.submitButton.onclick = function() {
                    that.sendMsg();
                    if ('function' === typeof that.textarea.focus) {
                        that.textarea.focus();
                    }
                };
                inputGroup.appendChild(this.submitButton);
            }
            if (this.useSubmitEnter || this.showIsTyping) {
                this.textarea.onkeydown = function(e) {
                    if (that.useSubmitEnter) {
                        e = e || window.event;
                        if ((e.keyCode || e.which) === 13) that.sendMsg();
                        else sendAmTyping(that);
                    }
                    else if (that.showIsTyping) {
                        sendAmTyping(that);
                    }
                };
            }

            this.bodyDiv.appendChild(inputGroup);
        }

        if (this.printStartTime) {
            W.add('div', this.chatDiv, {
                innerHTML: Date(J.getDate()),
                className: 'chat_event'
            });
            initialText = true;
        }

        if (this.printNames) {
            W.add('div', this.chatDiv, {
                className: 'chat_event',
                innerHTML: 'Participants: ' +
                    J.keys(this.senderToNameMap).join(', ')
            });
            initialText = true;
        }

        if (initialText) {
            W.add('div', this.chatDiv, {
                className: 'chat_event',
                innerHTML: '&nbsp;'
            });
        }

        if (this.initialMsg) {
            this.writeMsg(this.initialMsg.id ? 'incoming' : 'outgoing',
                          this.initialMsg);
        }
    };

    /**
     * ### Chat.readTextarea
     *
     * Reads the value of the textarea, trims it, and removes it from textarea
     *
     * @return {string} The current value in the textarea
     */
    Chat.prototype.readTextarea = function() {
        var txt;
        txt = this.textarea.value;
        this.textarea.value = '';
        return txt.trim();
    };

    /**
     * ### Chat.writeMsg
     *
     * Writes (and formats) a message (or an event) in the message area
     *
     * Chat is scrolled up so that the message is last always on focus.
     *
     * @param {string} code A value indicating the the type of msg. Available:
     *   'incoming', 'outgoing', and anything else.
     * @param {object} data The content of the message and the id of the sender
     *
     * @return {HTMLElement} c The div just inserted with the msg
     *
     * @see Chat.chatDiv
     */
    Chat.prototype.writeMsg = function(code, data) {
        var c;
        c = (code === 'incoming' || code === 'outgoing') ? code : 'event';
        c = W.add('div', this.chatDiv, {
            innerHTML: this.getText(code, data),
            className: 'chat_msg chat_msg_' + c
        });
        this.scrollToBottom();
        return c;
    };

    /**
     * ### Chat.writeMsg
     *
     * It calls preprocess and renders a msg from data
     *
     * If msg is a function it executes it to render it.
     *
     * @param {object} data The content of the message
     * @param {string} code A value indicating the the type of msg. Available:
     *   'incoming', 'outgoing', and anything else.
     *
     * @return {string} msg The rendered msg
     *
     * @see Chat.chatDiv
     */
    Chat.prototype.renderMsg = function(data, code) {
        var msg;
        if ('function' === typeof this.preprocessMsg) {
            this.preprocessMsg(data, code);
        }
        if ('function' === typeof data.msg) {
            msg = data.msg(data, code);
        }
        else {
            msg = data.msg;
        }
        return msg;
    };

    /**
     * ### Chat.scrollToBottom
     *
     * Scrolls the chat to the last message
     */
    Chat.prototype.scrollToBottom = function() {
        this.chatDiv.scrollTop = this.chatDiv.scrollHeight;
    };

    Chat.prototype.listeners = function() {
        var that = this;

        node.on.data(this.chatEvent, function(msg) {
            if (!that.handleMsg(msg)) return;

            that.stats.received++;
            // Store message if so requested.
            if (that.storeMsgs) {
                that.db.insert({
                    from: msg.from,
                    text: msg.data,
                    time: node.timer.getTimeSince('step'),
                    timestamp: J.now()
                });
            }
            // Remove is typing sign, if any.
            that.clearIsTyping(msg.from);
            msg = {
                msg: that.renderMsg(msg.data, 'incoming'),
                id: msg.from
            };
            that.writeMsg('incoming', msg);
        });

        node.on.data(this.chatEvent + '_QUIT', function(msg) {
            var i, len, rec;
            if (!that.handleMsg(msg)) return;
            that.writeMsg('quit', { id: msg.from });
            len = that.recipientsIds.length;
            for ( i = 0 ; i < len ; i++) {
                if (that.recipientsIds[i] ===
                    that.senderToRecipientMap[msg.from]) {

                    rec = that.recipientsIds.splice(i, 1);
                    that.recipientsIdsQuitted.push(rec);

                    if (that.recipientsIds.length === 0) {
                        that.writeMsg('noMoreParticipants');
                        that.disable();
                    }
                    break;
                }
            }
            node.warn('Chat: participant quitted not found: ' + msg.from);
        });

        node.on.data(this.chatEvent + '_COLLAPSE', function(msg) {
            if (!that.handleMsg(msg)) return;
            that.writeMsg('collapse', { id: msg.from, collapsed: msg.data});
        });

        node.on.data(this.chatEvent + '_TYPING', function(msg) {
            if (!that.handleMsg(msg)) return;
            that.addIsTyping(msg.from);
        });
    };

    Chat.prototype.addIsTyping = function(id) {
        var t, div, that;
        // Stop existing timeouts.
        t = this.isTypingTimeouts[id];
        if (t) clearTimeout(t);
        // Make or show the div.
        div = this.isTypingDivs[id];
        if (div) {
            // Move last and show..
            this.chatDiv.appendChild(div);
            div.style.display = '';
        }
        else {
            this.isTypingDivs[id] = this.writeMsg('incoming', {
                msg: this.getText('isTyping'),
                id: id
            });
        }
        this.scrollToBottom();
        // Add new timeout (msg are sent every 4000).
        that = this;
        this.isTypingTimeouts[id] = setTimeout(function() {
            that.clearIsTyping(id);
            that.isTypingTimeouts[id] = null;
        }, 3000);
    };

    Chat.prototype.clearIsTyping = function(id) {
        if (this.isTypingTimeouts[id]) {
            clearTimeout(this.isTypingTimeouts[id]);
            this.isTypingTimeouts[id] = null;
        }
        // Keep the div element, just hide it, it will be recycled.
        if (this.isTypingDivs[id]) {
            this.isTypingDivs[id].style.display = 'none';
        }
    };

    /**
     * ### Chat.handleMsg
     *
     * Checks a (incoming) message and takes some actions
     *
     * If chat is minimized, it maximizes it if option `uncollapseOnMsg`
     * it TRUE; otherwise, it increments the stats for unread messages.
     *
     * @param {string} msg The content of the message
     *
     * @return {boolean} TRUE if the message is valid
     *
     * @see Chat.chatDiv
     */
    Chat.prototype.handleMsg = function(msg) {
        var from;
        from = msg.from;
        if (from === node.player.id || from === node.player.sid) {
            node.warn('Chat: your own message came back: ' + msg.id);
            return false;
        }
        if (this.isCollapsed()) {
            if (this.uncollapseOnMsg) {
                this.uncollapse();
                this.stats.unread = 0;
            }
            else {
                this.setTitle('<strong>' + this.title + '</strong>');
                this.stats.unread++;
            }
        }
        return true;
    };

    Chat.prototype.disable = function() {
        if (this.submitButton) this.submitButton.disabled = true;
        this.textarea.disabled = true;
        this.disabled = true;
    };

    Chat.prototype.enable = function() {
        if (this.submitButton) this.submitButton.disabled = false;
        this.textarea.disabled = false;
        this.disabled = false;
    };

    Chat.prototype.getValues = function() {
        var out;
        out = {
            participants: this.participants,
            totSent: this.stats.sent,
            totReceived: this.stats.received,
            totUnread: this.stats.unread,
            initialMsg: this.initialMsg
        };
        if (this.db) out.msgs = this.db.fetch();
        return out;
    };

    /* ### Chat.sendMsg
     *
     * Delivers a msg to the server
     *
     * If no options are specified, it reads the textarea.
     *
     * @param {object} opts Optional. Configutation options:
     *   - msg: the msg to send. If undefined, it reads the value from textarea;
     *          if function it executes it and uses the return value.
     *   - recipients: array of recipients. Default: this.recipientsIds.
     *   - silent: does not write the msg on the chat.
     */
    Chat.prototype.sendMsg = function(opts) {
        var to, ids, that;

        // No msg sent.
        if (this.isDisabled()) {
            node.warn('Chat is disable, msg not sent.');
            return;
        }

        if ('object' === typeof opts) {
            if ('undefined' !== typeof opts.msg) {
                if ('object' === typeof opts.msg) {
                    throw new TypeError('Chat.sendMsg: opts.msg cannot be ' +
                                        'object. Found: ' + opts.msg);
                }
            }
        }
        else {
            if ('undefined' === typeof opts) {
                opts = { msg: this.readTextarea() };
            }
            else if ('string' === typeof opts || 'number' === typeof opts) {
                opts = { msg: opts };
            }
            else {
                throw new TypeError('Chat.sendMsg: opts must be string, ' +
                                    'number, object, or undefined. Found: ' +
                                     opts);
            }
        }

        // Calls preprocessMsg and if opts.msg is function, executes it.
        opts.msg = this.renderMsg(opts, 'outgoing');

        // Move cursor at the beginning.
        if (opts.msg === '') {
            node.warn('Chat: message has no text, not sent.');
            return;
        }
        // Simplify things, if there is only one recipient.
        ids = opts.recipients || this.recipientsIds;
        if (ids.length === 0) {
            node.warn('Chat: empty recipient list, message not sent.');
            return;
        }
        // Make it a number if array of size 1, so it is faster.
        to = ids.length === 1 ? ids[0] : ids;

        node.say(this.chatEvent, to, opts);

        if (!opts.silent) {
            that = this;
            // TODO: check the comment: // to not used now.
            this.writeMsg('outgoing', opts);

            // Make sure the cursor goes back to top.
            if (that.textarea) {
                setTimeout(function() { that.textarea.value = ''; });
            }
        }

        // Clear any typing timeout.
        if (this.amTypingTimeout) {
            clearTimeout(this.amTypingTimeout);
            this.amTypingTimeout = null;
        }
    }

    // ## Helper functions.

    // ### sendMsg
    // Reads the textarea and delivers the msg to the server.
    function sendAmTyping(that) {
        var to;
        if (that.isDisabled()) return;
        // Do not send too many notifications.
        if (that.amTypingTimeout) return;
        // Simplify things, if there is only one recipient.
        to = that.recipientsIds;
        if (!to.length) return;
        else if (to.length === 1) to = to[0];
        // No new notifications for 4s.
        that.amTypingTimeout = setTimeout(function() {
            that.amTypingTimeout = null;
        }, 4000);
        node.say(that.chatEvent + '_TYPING', to);
    }

})(node);

/**
 * # ChernoffFaces
 * Copyright(c) 2017 Stefano Balietti
 * MIT Licensed
 *
 * Displays multidimensional data in the shape of a Chernoff Face.
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    var Table = W.Table;

    node.widgets.register('ChernoffFaces', ChernoffFaces);

    // ## Meta-data

    ChernoffFaces.version = '0.6.2';
    ChernoffFaces.description =
        'Display parametric data in the form of a Chernoff Face.';

    ChernoffFaces.title = 'ChernoffFaces';
    ChernoffFaces.className = 'chernofffaces';

    // ## Dependencies
    ChernoffFaces.dependencies = {
        JSUS: {},
        Table: {},
        Canvas: {},
        SliderControls: {}
    };

    ChernoffFaces.FaceVector = FaceVector;
    ChernoffFaces.FacePainter = FacePainter;
    ChernoffFaces.width = 100;
    ChernoffFaces.height = 100;
    ChernoffFaces.onChange = 'CF_CHANGE';

    /**
     * ## ChernoffFaces constructor
     *
     * Creates a new instance of ChernoffFaces
     *
     * @see Canvas constructor
     */
    function ChernoffFaces(options) {
        var that = this;

        // ## Public Properties

        // ### ChernoffFaces.options
        // Configuration options
        this.options = null;

        // ### ChernoffFaces.table
        // The table containing everything
        this.table = null;

        // ### ChernoffFaces.sc
        // The slider controls of the interface
        // Can be set manually via options.controls.
        // @see SliderControls
        this.sc = null;

        // ### ChernoffFaces.fp
        // The object generating the Chernoff faces
        // @see FacePainter
        this.fp = null;

        // ### ChernoffFaces.canvas
        // The HTMLElement canvas where the faces are created
        this.canvas = null;

        // ### ChernoffFaces.changes
        // History all the changes (if options.trackChanges is TRUE).
        // Each time the `draw` method is called, the input parameters
        // and a time measurement will be added here.
        this.changes = [];

        // ### ChernoffFaces.onChange
        // Name of the event to emit to update the canvas (falsy disabled)
        this.onChange = null;

        // ### ChernoffFaces.onChangeCb
        // Updates the canvas when the onChange event is emitted
        //
        // @param {object} f Optional. The list of features to change.
        //    Can be a complete set or subset of all the features. If
        //    not specified, it will try to get the features from the
        //    the controls object, and if not found, a random vector
        //    will be created.
        // @param {boolean} updateControls Optional. If TRUE, controls
        //    are updated with the new values. Default, FALSE.
        //
        // @see ChernoffFaces.draw
        this.onChangeCb = function(f, updateControls) {
            if ('undefined' === typeof updateControls) updateControls = false;
            if (!f) {
                if (that.sc) f = that.sc.getValues();
                else f = FaceVector.random();
            }
            that.draw(f, updateControls);
        };

        /**
         * ### ChoiceTable.timeFrom
         *
         * Name of the event to measure time from for each change
         *
         * Default event is a new step is loaded (user can interact with
         * the screen). Set it to FALSE, to have absolute time.
         *
         * @see node.timer.getTimeSince
         */
        this.timeFrom = 'step';

        // ### ChernoffFaces.features
        // The object containing all the features to draw Chernoff faces
        this.features = null;
    }

    /**
     * ### ChernoffFaces.init
     *
     * Inits the widget
     *
     * Stores the reference to options, most of the operations are done
     * by the `append` method.
     *
     * @param {object} options Configuration options. Accepted options:
     *
     * - canvas {object} containing all options for canvas
     *
     * - width {number} width of the canvas (read only if canvas is not set)
     *
     * - height {number} height of the canvas (read only if canvas is not set)
     *
     * - features {FaceVector} vector of face-features. Default: random
     *
     * - onChange {string|boolean} The name of the event that will trigger
     *      redrawing the canvas, or null/false to disable event listener
     *
     * - controls {object|false} the controls (usually a set of sliders)
     *      offering the user the ability to manipulate the canvas. If equal
     *      to false no controls will be created. Default: SlidersControls.
     *      Any custom implementation must provide the following methods:
     *
     *          - getValues: returns the current features vector
     *          - refresh: redraws the current feature vector
     *          - init: accepts a configuration object containing a
     *               features and onChange as specified above.
     *
     */
    ChernoffFaces.prototype.init = function(options) {

        this.options = options;

        // Face Painter.
        if (options.features) {
            this.features = new FaceVector(options.features);
        }
        else if (!this.features) {
            this.features = FaceVector.random();
        }

        // Draw features, if facepainter was already created.
        if (this.fp) this.fp.draw(this.features);

        // onChange event.
        if (options.onChange === false || options.onChange === null) {
            if (this.onChange) {
                node.off(this.onChange, this.onChangeCb);
                this.onChange = null;
            }
        }
        else {
            this.onChange = 'undefined' === typeof options.onChange ?
                ChernoffFaces.onChange : options.onChange;
            node.on(this.onChange, this.onChangeCb);
        }
    };

    /**
     * ## ChernoffFaces.getCanvas
     *
     * Returns the reference to current wrapper Canvas object
     *
     * To get to the HTML Canvas element use `canvas.canvas`.
     *
     * @return {Canvas} Canvas object
     *
     * @see Canvas
     */
    ChernoffFaces.prototype.getCanvas = function() {
        return this.canvas;
    };

    /**
     * ## ChernoffFaces.buildHTML
     *
     * Builds HTML objects, but does not append them
     *
     * Creates the table, canvas, draw the current image, and
     * eventually adds the controls.
     *
     * If the table was already built, it returns immediately.
     */
    ChernoffFaces.prototype.buildHTML = function() {
        var controlsOptions, f;
        var tblOptions, options;

        if (this.table) return;

        options = this.options;

        // Table.
        tblOptions = {};
        if (this.id) tblOptions.id = this.id;

        if ('string' === typeof options.className) {
            tblOptions.className = options.className;
        }
        else if (options.className !== false) {
            tblOptions.className = 'cf_table';
        }

        this.table = new Table(tblOptions);

        // Canvas.
        if (!this.canvas) this.buildCanvas();

        // Controls.
        if ('undefined' === typeof options.controls || options.controls) {
            // Sc options.
            f = J.mergeOnKey(FaceVector.defaults, this.features, 'value');
            controlsOptions = {
                id: 'cf_controls',
                features: f,
                onChange: this.onChange,
                submit: 'Send'
            };
            // Create them.
            if ('object' === typeof options.controls) {
                this.sc = options.controls;
            }
            else {
                this.sc = node.widgets.get('SliderControls', controlsOptions);
            }
        }

        // Table.
        if (this.sc) {
            this.table.addRow(
                [{
                    content: this.sc,
                    id: this.id + '_td_controls'
                },{
                    content: this.canvas,
                    id: this.id + '_td_cf'
                }]
            );
        }
        else {
            this.table.add({
                content: this.canvas,
                id: this.id + '_td_cf'
            });
        }

        // Create and append table.
        this.table.parse();
    };

    /**
     * ## ChernoffFaces.buildCanvas
     *
     * Builds the canvas object and face painter
     *
     * All the necessary to draw faces
     *
     * If the canvas was already built, it simply returns it.
     *
     * @return {canvas}
     */
    ChernoffFaces.prototype.buildCanvas = function() {
        var options;
        if (!this.canvas) {
            options = this.options;

            if (!options.canvas) {
                options.canvas = {};
                if ('undefined' !== typeof options.height) {
                    options.canvas.height = options.height;
                }
                if ('undefined' !== typeof options.width) {
                    options.canvas.width = options.width;
                }
            }
            this.canvas = W.get('canvas', options.canvas);
            this.canvas.id = 'ChernoffFaces_canvas';

            // Face Painter.
            this.fp = new FacePainter(this.canvas);
            this.fp.draw(this.features);
        }
    };

    /**
     * ## ChernoffFaces.append
     *
     * Appends the widget
     *
     * Creates table, canvas, face painter (fp) and controls (sc), according
     * to current options.
     *
     * @see ChernoffFaces.buildHTML
     * @see ChernoffFaces.fp
     * @see ChernoffFaces.sc
     * @see ChernoffFaces.table
     * @see Table
     * @see Canvas
     * @see SliderControls
     * @see FacePainter
     * @see FaceVector
     */
    ChernoffFaces.prototype.append = function() {
        if (!this.table) this.buildHTML();
        this.bodyDiv.appendChild(this.table.table);
    };

    /**
     * ### ChernoffFaces.draw
     *
     * Draw a face on canvas and optionally updates the controls
     *
     * Stores the current value of the drawn image under `.features`.
     *
     * @param {object} features The features to draw (If not a complete
     *   set of features, they will be merged with current values)
     * @param {boolean} updateControls Optional. If equal to false,
     *    controls are not updated. Default: true
     *
     * @see ChernoffFaces.sc
     * @see ChernoffFaces.features
     */
    ChernoffFaces.prototype.draw = function(features, updateControls) {
        var time;
        if ('object' !== typeof features) {
            throw new TypeError('ChernoffFaces.draw: features must be object.');
        }
        if (this.options.trackChanges) {
            // Relative time.
            if ('string' === typeof this.timeFrom) {
                time = node.timer.getTimeSince(this.timeFrom);
            }
            // Absolute time.
            else {
                time = Date.now ? Date.now() : new Date().getTime();
            }
            this.changes.push({
                time: time,
                change: features
            });
        }

        // Create a new FaceVector, if features is not one, mixing-in
        // new features and old ones.
        this.features = (features instanceof FaceVector) ? features :
            new FaceVector(features, this.features);

        this.fp.redraw(this.features);
        if (this.sc && (updateControls !== false)) {
            // Without merging wrong values are passed as attributes.
            this.sc.init({
                features: J.mergeOnKey(FaceVector.defaults, features, 'value')
            });
            this.sc.refresh();
        }
    };

    ChernoffFaces.prototype.getValues = function(options) {
        if (options && options.changes) {
            return {
                changes: this.changes,
                cf: this.features
            };
        }
        else {
            return this.fp.face;
        }
    };

     /**
     * ### ChernoffFaces.randomize
     *
     * Draws a random image and updates controls accordingly (if found)
     *
     * @see ChernoffFaces.sc
     */
    ChernoffFaces.prototype.randomize = function() {
        var fv;
        fv = FaceVector.random();
        this.fp.redraw(fv);
        // If controls are visible, updates them.
        if (this.sc) {
            this.sc.init({
                features: J.mergeOnValue(FaceVector.defaults, fv),
                onChange: this.onChange
            });
            this.sc.refresh();
        }
        return true;
    };


    /**
     * # FacePainter
     *
     * Draws faces on a Canvas
     *
     * @param {HTMLCanvas} canvas The canvas
     * @param {object} settings Optional. Settings (not used).
     */
    function FacePainter(canvas, settings) {

        /**
         * ### FacePainter.canvas
         *
         * The wrapper element for the HTML canvas
         *
         * @see Canvas
         */
        this.canvas = new W.Canvas(canvas);

        /**
         * ### FacePainter.scaleX
         *
         * Scales images along the X-axis of this proportion
         */
        this.scaleX = canvas.width / ChernoffFaces.width;

        /**
         * ### FacePainter.scaleX
         *
         * Scales images along the X-axis of this proportion
         */
        this.scaleY = canvas.height / ChernoffFaces.heigth;

        /**
         * ### FacePainter.face
         *
         * The last drawn face
         */
        this.face = null;
    }

    // ## Methods

    /**
     * ### FacePainter.draw
     *
     * Draws a face into the canvas and stores it as reference
     *
     * @param {object} face Multidimensional vector of features
     * @param {number} x Optional. The x-coordinate to center the image.
     *   Default: the center of the canvas
     * @param {number} y Optional. The y-coordinate to center the image.
     *   Default: the center of the canvas
     *
     * @see Canvas
     * @see Canvas.centerX
     * @see Canvas.centerY
     */
    FacePainter.prototype.draw = function(face, x, y) {
        if (!face) return;
        this.face = face;

        this.fit2Canvas(face);
        this.canvas.scale(face.scaleX, face.scaleY);

        //console.log('Face Scale ' + face.scaleY + ' ' + face.scaleX );

        x = x || this.canvas.centerX;
        y = y || this.canvas.centerY;

        this.drawHead(face, x, y);

        this.drawEyes(face, x, y);

        this.drawPupils(face, x, y);

        this.drawEyebrow(face, x, y);

        this.drawNose(face, x, y);

        this.drawMouth(face, x, y);
    };

    FacePainter.prototype.redraw = function(face, x, y) {
        this.canvas.clear();
        this.draw(face, x, y);
    };

    FacePainter.prototype.scale = function(x, y) {
        this.canvas.scale(this.scaleX, this.scaleY);
    };

    // TODO: Improve. It eats a bit of the margins
    FacePainter.prototype.fit2Canvas = function(face) {
        var ratio;
        if (!this.canvas) {
            console.log('No canvas found');
            return;
        }

        if (this.canvas.width > this.canvas.height) {
            ratio = this.canvas.width / face.head_radius * face.head_scale_x;
        }
        else {
            ratio = this.canvas.height / face.head_radius * face.head_scale_y;
        }

        face.scaleX = ratio / 2;
        face.scaleY = ratio / 2;
    };

    FacePainter.prototype.drawHead = function(face, x, y) {

        var radius = face.head_radius;

        this.canvas.drawOval({
            x: x,
            y: y,
            radius: radius,
            scale_x: face.head_scale_x,
            scale_y: face.head_scale_y,
            color: face.color,
            lineWidth: face.lineWidth
        });
    };

    FacePainter.prototype.drawEyes = function(face, x, y) {

        var height = FacePainter.computeFaceOffset(face, face.eye_height, y);
        var spacing = face.eye_spacing;

        var radius = face.eye_radius;
        //console.log(face);
        this.canvas.drawOval({
            x: x - spacing,
            y: height,
            radius: radius,
            scale_x: face.eye_scale_x,
            scale_y: face.eye_scale_y,
            color: face.color,
            lineWidth: face.lineWidth

        });
        //console.log(face);
        this.canvas.drawOval({
            x: x + spacing,
            y: height,
            radius: radius,
            scale_x: face.eye_scale_x,
            scale_y: face.eye_scale_y,
            color: face.color,
            lineWidth: face.lineWidth
        });
    };

    FacePainter.prototype.drawPupils = function(face, x, y) {

        var radius = face.pupil_radius;
        var spacing = face.eye_spacing;
        var height = FacePainter.computeFaceOffset(face, face.eye_height, y);

        this.canvas.drawOval({
            x: x - spacing,
            y: height,
            radius: radius,
            scale_x: face.pupil_scale_x,
            scale_y: face.pupil_scale_y,
            color: face.color,
            lineWidth: face.lineWidth
        });

        this.canvas.drawOval({
            x: x + spacing,
            y: height,
            radius: radius,
            scale_x: face.pupil_scale_x,
            scale_y: face.pupil_scale_y,
            color: face.color,
            lineWidth: face.lineWidth
        });

    };

    FacePainter.prototype.drawEyebrow = function(face, x, y) {

        var height = FacePainter.computeEyebrowOffset(face,y);
        var spacing = face.eyebrow_spacing;
        var length = face.eyebrow_length;
        var angle = face.eyebrow_angle;

        this.canvas.drawLine({
            x: x - spacing,
            y: height,
            length: length,
            angle: angle,
            color: face.color,
            lineWidth: face.lineWidth


        });

        this.canvas.drawLine({
            x: x + spacing,
            y: height,
            length: 0-length,
            angle: -angle,
            color: face.color,
            lineWidth: face.lineWidth
        });

    };

    FacePainter.prototype.drawNose = function(face, x, y) {

        var height = FacePainter.computeFaceOffset(face, face.nose_height, y);
        var nastril_r_x = x + face.nose_width / 2;
        var nastril_r_y = height + face.nose_length;
        var nastril_l_x = nastril_r_x - face.nose_width;
        var nastril_l_y = nastril_r_y;

        this.canvas.ctx.lineWidth = face.lineWidth;
        this.canvas.ctx.strokeStyle = face.color;

        this.canvas.ctx.save();
        this.canvas.ctx.beginPath();
        this.canvas.ctx.moveTo(x,height);
        this.canvas.ctx.lineTo(nastril_r_x,nastril_r_y);
        this.canvas.ctx.lineTo(nastril_l_x,nastril_l_y);
        //this.canvas.ctx.closePath();
        this.canvas.ctx.stroke();
        this.canvas.ctx.restore();

    };

    FacePainter.prototype.drawMouth = function(face, x, y) {

        var height = FacePainter.computeFaceOffset(face, face.mouth_height, y);
        var startX = x - face.mouth_width / 2;
        var endX = x + face.mouth_width / 2;

        var top_y = height - face.mouth_top_y;
        var bottom_y = height + face.mouth_bottom_y;

        // Upper Lip
        this.canvas.ctx.moveTo(startX,height);
        this.canvas.ctx.quadraticCurveTo(x, top_y, endX, height);
        this.canvas.ctx.stroke();

        //Lower Lip
        this.canvas.ctx.moveTo(startX,height);
        this.canvas.ctx.quadraticCurveTo(x, bottom_y, endX, height);
        this.canvas.ctx.stroke();

    };


    //TODO Scaling ?
    FacePainter.computeFaceOffset = function(face, offset, y) {
        y = y || 0;
        //var pos = y - face.head_radius * face.scaleY +
        //          face.head_radius * face.scaleY * 2 * offset;
        var pos = y - face.head_radius + face.head_radius * 2 * offset;
        //console.log('POS: ' + pos);
        return pos;
    };

    FacePainter.computeEyebrowOffset = function(face, y) {
        y = y || 0;
        var eyemindistance = 2;
        return FacePainter.computeFaceOffset(face, face.eye_height, y) -
            eyemindistance - face.eyebrow_eyedistance;
    };


    /**
     * FaceVector.defaults
     *
     * Numerical description of all the components of a standard Chernoff Face
     */
    FaceVector.defaults = {
        // Head
        head_radius: {
            // id can be specified otherwise is taken head_radius
            min: 10,
            max: 100,
            step: 0.01,
            value: 30,
            label: 'Face radius'
        },
        head_scale_x: {
            min: 0.2,
            max: 2,
            step: 0.01,
            value: 0.5,
            label: 'Scale head horizontally'
        },
        head_scale_y: {
            min: 0.2,
            max: 2,
            step: 0.01,
            value: 1,
            label: 'Scale head vertically'
        },
        // Eye
        eye_height: {
            min: 0.1,
            max: 0.9,
            step: 0.01,
            value: 0.4,
            label: 'Eye height'
        },
        eye_radius: {
            min: 2,
            max: 30,
            step: 0.01,
            value: 5,
            label: 'Eye radius'
        },
        eye_spacing: {
            min: 0,
            max: 50,
            step: 0.01,
            value: 10,
            label: 'Eye spacing'
        },
        eye_scale_x: {
            min: 0.2,
            max: 2,
            step: 0.01,
            value: 1,
            label: 'Scale eyes horizontally'
        },
        eye_scale_y: {
            min: 0.2,
            max: 2,
            step: 0.01,
            value: 1,
            label: 'Scale eyes vertically'
        },
        // Pupil
        pupil_radius: {
            min: 1,
            max: 9,
            step: 0.01,
            value: 1,  //this.eye_radius;
            label: 'Pupil radius'
        },
        pupil_scale_x: {
            min: 0.2,
            max: 2,
            step: 0.01,
            value: 1,
            label: 'Scale pupils horizontally'
        },
        pupil_scale_y: {
            min: 0.2,
            max: 2,
            step: 0.01,
            value: 1,
            label: 'Scale pupils vertically'
        },
        // Eyebrow
        eyebrow_length: {
            min: 1,
            max: 30,
            step: 0.01,
            value: 10,
            label: 'Eyebrow length'
        },
        eyebrow_eyedistance: {
            min: 0.3,
            max: 10,
            step: 0.01,
            value: 3, // From the top of the eye
            label: 'Eyebrow from eye'
        },
        eyebrow_angle: {
            min: -2,
            max: 2,
            step: 0.01,
            value: -0.5,
            label: 'Eyebrow angle'
        },
        eyebrow_spacing: {
            min: 0,
            max: 20,
            step: 0.01,
            value: 5,
            label: 'Eyebrow spacing'
        },
        // Nose
        nose_height: {
            min: 0.4,
            max: 1,
            step: 0.01,
            value: 0.4,
            label: 'Nose height'
        },
        nose_length: {
            min: 0.2,
            max: 30,
            step: 0.01,
            value: 15,
            label: 'Nose length'
        },
        nose_width: {
            min: 0,
            max: 30,
            step: 0.01,
            value: 10,
            label: 'Nose width'
        },
        // Mouth
        mouth_height: {
            min: 0.2,
            max: 2,
            step: 0.01,
            value: 0.75,
            label: 'Mouth height'
        },
        mouth_width: {
            min: 2,
            max: 100,
            step: 0.01,
            value: 20,
            label: 'Mouth width'
        },
        mouth_top_y: {
            min: -10,
            max: 30,
            step: 0.01,
            value: -2,
            label: 'Upper lip'
        },
        mouth_bottom_y: {
            min: -10,
            max: 30,
            step: 0.01,
            value: 20,
            label: 'Lower lip'
        },

        scaleX: {
            min: 0,
            max: 20,
            step: 0.01,
            value: 0.2,
            label: 'Scale X'
        },

        scaleY: {
            min: 0,
            max: 20,
            step: 0.01,
            value: 0.2,
            label: 'Scale Y'
        },

        color: {
            min: 0,
            max: 20,
            step: 0.01,
            value: 0.2,
            label: 'color'
        },

        lineWidth: {
            min: 0,
            max: 20,
            step: 0.01,
            value: 0.2,
            label: 'lineWidth'
        }

    };

    // Compute range for each feature.
    (function(defaults) {
        var key;
        for (key in defaults) {
            if (defaults.hasOwnProperty(key)) {
                defaults[key].range = defaults[key].max - defaults[key].min;
            }
        }
    })(FaceVector.defaults);

    // Constructs a random face vector.
    FaceVector.random = function() {
        console.log('*** FaceVector.random is deprecated. ' +
                    'Use new FaceVector() instead.');
        return new FaceVector();
    };

    function FaceVector(faceVector, defaults) {
        var key;
        // Make random vector.
        if ('undefined' === typeof faceVector) {
            for (key in FaceVector.defaults) {
                if (FaceVector.defaults.hasOwnProperty(key)) {
                    if (key === 'color') {
                        this.color = 'red';
                    }
                    else if (key === 'lineWidth') {
                        this.lineWidth = 1;
                    }
                    else if (key === 'scaleX') {
                        this.scaleX = 1;
                    }
                    else if (key === 'scaleY') {
                        this.scaleY = 1;
                    }
                    else {
                        this[key] = FaceVector.defaults[key].min +
                            Math.random() * FaceVector.defaults[key].range;
                    }
                }
            }
        }
        // Mixin values.
        else if ('object' === typeof faceVector) {

            this.scaleX = faceVector.scaleX || 1;
            this.scaleY = faceVector.scaleY || 1;

            this.color = faceVector.color || 'green';
            this.lineWidth = faceVector.lineWidth || 1;

            defaults = defaults || FaceVector.defaults;

            // Merge on key.
            for (key in defaults) {
                if (defaults.hasOwnProperty(key)){
                    if (faceVector.hasOwnProperty(key)) {
                        this[key] = faceVector[key];
                    }
                    else {
                        this[key] = defaults ? defaults[key] :
                            FaceVector.defaults[key].value;
                    }
                }
            }
        }
        else {
            throw new TypeError('FaceVector constructor: faceVector must be ' +
                                'object or undefined.');
        }
    }

//     //Constructs a random face vector.
//     FaceVector.prototype.shuffle = function() {
//         for (var key in this) {
//             if (this.hasOwnProperty(key)) {
//                 if (FaceVector.defaults.hasOwnProperty(key)) {
//                     if (key !== 'color') {
//                         this[key] = FaceVector.defaults[key].min +
//                             Math.random() * FaceVector.defaults[key].max;
//                     }
//                 }
//             }
//         }
//     };

//     //Computes the Euclidean distance between two FaceVectors.
//     FaceVector.prototype.distance = function(face) {
//         return FaceVector.distance(this, face);
//     };
//
//
//     FaceVector.distance = function(face1, face2) {
//         var sum = 0.0;
//         var diff;
//
//         for (var key in face1) {
//             if (face1.hasOwnProperty(key)) {
//                 diff = face1[key] - face2[key];
//                 sum = sum + diff * diff;
//             }
//         }
//
//         return Math.sqrt(sum);
//     };
//
//     FaceVector.prototype.toString = function() {
//         var out = 'Face: ';
//         for (var key in this) {
//             if (this.hasOwnProperty(key)) {
//                 out += key + ' ' + this[key];
//             }
//         }
//         return out;
//     };

})(node);

/**
 * # ChernoffFacesSimple
 * Copyright(c) 2017 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Displays multidimensional data in the shape of a Chernoff Face.
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    var Table = W.Table;

    node.widgets.register('ChernoffFacesSimple', ChernoffFaces);

    // ## Defaults

    ChernoffFaces.defaults = {};
    ChernoffFaces.defaults.id = 'ChernoffFaces';
    ChernoffFaces.defaults.canvas = {};
    ChernoffFaces.defaults.canvas.width = 100;
    ChernoffFaces.defaults.canvas.heigth = 100;

    // ## Meta-data

    ChernoffFaces.version = '0.4';
    ChernoffFaces.description =
        'Display parametric data in the form of a Chernoff Face.';

    // ## Dependencies
    ChernoffFaces.dependencies = {
        JSUS: {},
        Table: {},
        Canvas: {},
        'Controls.Slider': {}
    };

    ChernoffFaces.FaceVector = FaceVector;
    ChernoffFaces.FacePainter = FacePainter;

    function ChernoffFaces (options) {
        this.options = options;
        this.id = options.id;
        this.table = new Table({id: 'cf_table'});
        this.root = options.root || document.createElement('div');
        this.root.id = this.id;

        this.sc = node.widgets.get('Controls.Slider');  // Slider Controls
        this.fp = null;         // Face Painter
        this.canvas = null;
        this.dims = null;       // width and height of the canvas

        this.change = 'CF_CHANGE';
        var that = this;
        this.changeFunc = function() {
            that.draw(that.sc.getAllValues());
        };

        this.features = null;
        this.controls = null;
    }

    ChernoffFaces.prototype.init = function(options) {
        this.id = options.id || this.id;
        var PREF = this.id + '_';

        this.features = options.features || this.features ||
            FaceVector.random();

        this.controls = ('undefined' !== typeof options.controls) ?
                        options.controls : true;

        var idCanvas = (options.idCanvas) ? options.idCanvas : PREF + 'canvas';

        this.dims = {
            width:  options.width ?
                options.width : ChernoffFaces.defaults.canvas.width,
            height: options.height ?
                options.height : ChernoffFaces.defaults.canvas.heigth
        };

        this.canvas = W.getCanvas(idCanvas, this.dims);
        this.fp = new FacePainter(this.canvas);
        this.fp.draw(new FaceVector(this.features));

        var sc_options = {
            id: 'cf_controls',
            features:
                J.mergeOnKey(FaceVector.defaults, this.features, 'value'),
            change: this.change,
            fieldset: {id: this.id + '_controls_fieldest',
                       legend: this.controls.legend || 'Controls'
                      },
            submit: 'Send'
        };

        this.sc = node.widgets.get('Controls.Slider', sc_options);

        // Controls are always there, but may not be visible
        if (this.controls) {
            this.table.add(this.sc);
        }

        // Dealing with the onchange event
        if ('undefined' === typeof options.change) {
            node.on(this.change, this.changeFunc);
        } else {
            if (options.change) {
                node.on(options.change, this.changeFunc);
            }
            else {
                node.removeListener(this.change, this.changeFunc);
            }
            this.change = options.change;
        }


        this.table.add(this.canvas);
        this.table.parse();
        this.root.appendChild(this.table.table);
    };

    ChernoffFaces.prototype.getRoot = function() {
        return this.root;
    };

    ChernoffFaces.prototype.getCanvas = function() {
        return this.canvas;
    };

    ChernoffFaces.prototype.append = function(root) {
        root.appendChild(this.root);
        this.table.parse();
        return this.root;
    };

    ChernoffFaces.prototype.listeners = function() {};

    ChernoffFaces.prototype.draw = function(features) {
        if (!features) return;
        var fv = new FaceVector(features);
        this.fp.redraw(fv);
        // Without merging wrong values are passed as attributes
        this.sc.init({
            features: J.mergeOnKey(FaceVector.defaults, features, 'value')
        });
        this.sc.refresh();
    };

    ChernoffFaces.prototype.getAllValues = function() {
        //if (this.sc) return this.sc.getAllValues();
        return this.fp.face;
    };

    ChernoffFaces.prototype.randomize = function() {
        var fv = FaceVector.random();
        this.fp.redraw(fv);

        var sc_options = {
            features: J.mergeOnKey(FaceVector.defaults, fv, 'value'),
            change: this.change
        };
        this.sc.init(sc_options);
        this.sc.refresh();

        return true;
    };

    // FacePainter
    // The class that actually draws the faces on the Canvas
    function FacePainter(canvas, settings) {
        this.canvas = new W.Canvas(canvas);
        this.scaleX = canvas.width / ChernoffFaces.defaults.canvas.width;
        this.scaleY = canvas.height / ChernoffFaces.defaults.canvas.heigth;
    }

    // Draws a Chernoff face.
    FacePainter.prototype.draw = function(face, x, y) {
        if (!face) return;
        this.face = face;
        this.fit2Canvas(face);
        this.canvas.scale(face.scaleX, face.scaleY);

        //console.log('Face Scale ' + face.scaleY + ' ' + face.scaleX );

        x = x || this.canvas.centerX;
        y = y || this.canvas.centerY;

        this.drawHead(face, x, y);

        this.drawEyes(face, x, y);

        this.drawPupils(face, x, y);

        this.drawEyebrow(face, x, y);

        this.drawNose(face, x, y);

        this.drawMouth(face, x, y);

    };

    FacePainter.prototype.redraw = function(face, x, y) {
        this.canvas.clear();
        this.draw(face,x,y);
    };

    FacePainter.prototype.scale = function(x, y) {
        this.canvas.scale(this.scaleX, this.scaleY);
    };

    // TODO: Improve. It eats a bit of the margins
    FacePainter.prototype.fit2Canvas = function(face) {
        var ratio;
        if (!this.canvas) {
            console.log('No canvas found');
            return;
        }

        if (this.canvas.width > this.canvas.height) {
            ratio = this.canvas.width / face.head_radius * face.head_scale_x;
        }
        else {
            ratio = this.canvas.height / face.head_radius * face.head_scale_y;
        }

        face.scaleX = ratio / 2;
        face.scaleY = ratio / 2;
    };

    FacePainter.prototype.drawHead = function(face, x, y) {

        var radius = face.head_radius;

        this.canvas.drawOval({
            x: x,
            y: y,
            radius: radius,
            scale_x: face.head_scale_x,
            scale_y: face.head_scale_y,
            color: face.color,
            lineWidth: face.lineWidth
        });
    };

    FacePainter.prototype.drawEyes = function(face, x, y) {

        var height = FacePainter.computeFaceOffset(face, face.eye_height, y);
        var spacing = face.eye_spacing;

        var radius = face.eye_radius;
        //console.log(face);
        this.canvas.drawOval({
            x: x - spacing,
            y: height,
            radius: radius,
            scale_x: face.eye_scale_x,
            scale_y: face.eye_scale_y,
            color: face.color,
            lineWidth: face.lineWidth

        });
        //console.log(face);
        this.canvas.drawOval({
            x: x + spacing,
            y: height,
            radius: radius,
            scale_x: face.eye_scale_x,
            scale_y: face.eye_scale_y,
            color: face.color,
            lineWidth: face.lineWidth
        });
    };

    FacePainter.prototype.drawPupils = function(face, x, y) {

        var radius = face.pupil_radius;
        var spacing = face.eye_spacing;
        var height = FacePainter.computeFaceOffset(face, face.eye_height, y);

        this.canvas.drawOval({
            x: x - spacing,
            y: height,
            radius: radius,
            scale_x: face.pupil_scale_x,
            scale_y: face.pupil_scale_y,
            color: face.color,
            lineWidth: face.lineWidth
        });

        this.canvas.drawOval({
            x: x + spacing,
            y: height,
            radius: radius,
            scale_x: face.pupil_scale_x,
            scale_y: face.pupil_scale_y,
            color: face.color,
            lineWidth: face.lineWidth
        });

    };

    FacePainter.prototype.drawEyebrow = function(face, x, y) {

        var height = FacePainter.computeEyebrowOffset(face,y);
        var spacing = face.eyebrow_spacing;
        var length = face.eyebrow_length;
        var angle = face.eyebrow_angle;

        this.canvas.drawLine({
            x: x - spacing,
            y: height,
            length: length,
            angle: angle,
            color: face.color,
            lineWidth: face.lineWidth


        });

        this.canvas.drawLine({
            x: x + spacing,
            y: height,
            length: 0-length,
            angle: -angle,
            color: face.color,
            lineWidth: face.lineWidth
        });

    };

    FacePainter.prototype.drawNose = function(face, x, y) {

        var height = FacePainter.computeFaceOffset(face, face.nose_height, y);
        var nastril_r_x = x + face.nose_width / 2;
        var nastril_r_y = height + face.nose_length;
        var nastril_l_x = nastril_r_x - face.nose_width;
        var nastril_l_y = nastril_r_y;

        this.canvas.ctx.lineWidth = face.lineWidth;
        this.canvas.ctx.strokeStyle = face.color;

        this.canvas.ctx.save();
        this.canvas.ctx.beginPath();
        this.canvas.ctx.moveTo(x,height);
        this.canvas.ctx.lineTo(nastril_r_x,nastril_r_y);
        this.canvas.ctx.lineTo(nastril_l_x,nastril_l_y);
        //this.canvas.ctx.closePath();
        this.canvas.ctx.stroke();
        this.canvas.ctx.restore();

    };

    FacePainter.prototype.drawMouth = function(face, x, y) {

        var height = FacePainter.computeFaceOffset(face, face.mouth_height, y);
        var startX = x - face.mouth_width / 2;
        var endX = x + face.mouth_width / 2;

        var top_y = height - face.mouth_top_y;
        var bottom_y = height + face.mouth_bottom_y;

        // Upper Lip
        this.canvas.ctx.moveTo(startX,height);
        this.canvas.ctx.quadraticCurveTo(x, top_y, endX, height);
        this.canvas.ctx.stroke();

        //Lower Lip
        this.canvas.ctx.moveTo(startX,height);
        this.canvas.ctx.quadraticCurveTo(x, bottom_y, endX, height);
        this.canvas.ctx.stroke();

    };


    //TODO Scaling ?
    FacePainter.computeFaceOffset = function(face, offset, y) {
        y = y || 0;
        //var pos = y - face.head_radius * face.scaleY +
        //          face.head_radius * face.scaleY * 2 * offset;
        var pos = y - face.head_radius + face.head_radius * 2 * offset;
        //console.log('POS: ' + pos);
        return pos;
    };

    FacePainter.computeEyebrowOffset = function(face, y) {
        y = y || 0;
        var eyemindistance = 2;
        return FacePainter.computeFaceOffset(face, face.eye_height, y) -
            eyemindistance - face.eyebrow_eyedistance;
    };


    /*!
     *
     * A description of a Chernoff Face.
     *
     * This class packages the 11-dimensional vector of numbers from 0 through
     * 1 that completely describe a Chernoff face.
     *
     */


    FaceVector.defaults = {
        // Head
        head_radius: {
            // id can be specified otherwise is taken head_radius
            min: 10,
            max: 100,
            step: 0.01,
            value: 30,
            label: 'Face radius'
        },
        head_scale_x: {
            min: 0.2,
            max: 2,
            step: 0.01,
            value: 0.5,
            label: 'Scale head horizontally'
        },
        head_scale_y: {
            min: 0.2,
            max: 2,
            step: 0.01,
            value: 1,
            label: 'Scale head vertically'
        },
        // Eye
        eye_height: {
            min: 0.1,
            max: 0.9,
            step: 0.01,
            value: 0.4,
            label: 'Eye height'
        },
        eye_radius: {
            min: 2,
            max: 30,
            step: 0.01,
            value: 5,
            label: 'Eye radius'
        },
        eye_spacing: {
            min: 0,
            max: 50,
            step: 0.01,
            value: 10,
            label: 'Eye spacing'
        },
        eye_scale_x: {
            min: 0.2,
            max: 2,
            step: 0.01,
            value: 1,
            label: 'Scale eyes horizontally'
        },
        eye_scale_y: {
            min: 0.2,
            max: 2,
            step: 0.01,
            value: 1,
            label: 'Scale eyes vertically'
        },
        // Pupil
        pupil_radius: {
            min: 1,
            max: 9,
            step: 0.01,
            value: 1,  //this.eye_radius;
            label: 'Pupil radius'
        },
        pupil_scale_x: {
            min: 0.2,
            max: 2,
            step: 0.01,
            value: 1,
            label: 'Scale pupils horizontally'
        },
        pupil_scale_y: {
            min: 0.2,
            max: 2,
            step: 0.01,
            value: 1,
            label: 'Scale pupils vertically'
        },
        // Eyebrow
        eyebrow_length: {
            min: 1,
            max: 30,
            step: 0.01,
            value: 10,
            label: 'Eyebrow length'
        },
        eyebrow_eyedistance: {
            min: 0.3,
            max: 10,
            step: 0.01,
            value: 3, // From the top of the eye
            label: 'Eyebrow from eye'
        },
        eyebrow_angle: {
            min: -2,
            max: 2,
            step: 0.01,
            value: -0.5,
            label: 'Eyebrow angle'
        },
        eyebrow_spacing: {
            min: 0,
            max: 20,
            step: 0.01,
            value: 5,
            label: 'Eyebrow spacing'
        },
        // Nose
        nose_height: {
            min: 0.4,
            max: 1,
            step: 0.01,
            value: 0.4,
            label: 'Nose height'
        },
        nose_length: {
            min: 0.2,
            max: 30,
            step: 0.01,
            value: 15,
            label: 'Nose length'
        },
        nose_width: {
            min: 0,
            max: 30,
            step: 0.01,
            value: 10,
            label: 'Nose width'
        },
        // Mouth
        mouth_height: {
            min: 0.2,
            max: 2,
            step: 0.01,
            value: 0.75,
            label: 'Mouth height'
        },
        mouth_width: {
            min: 2,
            max: 100,
            step: 0.01,
            value: 20,
            label: 'Mouth width'
        },
        mouth_top_y: {
            min: -10,
            max: 30,
            step: 0.01,
            value: -2,
            label: 'Upper lip'
        },
        mouth_bottom_y: {
            min: -10,
            max: 30,
            step: 0.01,
            value: 20,
            label: 'Lower lip'
        }
    };

    //Constructs a random face vector.
    FaceVector.random = function() {
        var out = {};
        for (var key in FaceVector.defaults) {
            if (FaceVector.defaults.hasOwnProperty(key)) {
                if (!J.inArray(key,
                            ['color', 'lineWidth', 'scaleX', 'scaleY'])) {

                    out[key] = FaceVector.defaults[key].min +
                        Math.random() * FaceVector.defaults[key].max;
                }
            }
        }

        out.scaleX = 1;
        out.scaleY = 1;

        out.color = 'green';
        out.lineWidth = 1;

        return new FaceVector(out);
    };

    function FaceVector(faceVector) {
        faceVector = faceVector || {};

        this.scaleX = faceVector.scaleX || 1;
        this.scaleY = faceVector.scaleY || 1;


        this.color = faceVector.color || 'green';
        this.lineWidth = faceVector.lineWidth || 1;

        // Merge on key
        for (var key in FaceVector.defaults) {
            if (FaceVector.defaults.hasOwnProperty(key)){
                if (faceVector.hasOwnProperty(key)){
                    this[key] = faceVector[key];
                }
                else {
                    this[key] = FaceVector.defaults[key].value;
                }
            }
        }

    }

    //Constructs a random face vector.
    FaceVector.prototype.shuffle = function() {
        for (var key in this) {
            if (this.hasOwnProperty(key)) {
                if (FaceVector.defaults.hasOwnProperty(key)) {
                    if (key !== 'color') {
                        this[key] = FaceVector.defaults[key].min +
                            Math.random() * FaceVector.defaults[key].max;
                    }
                }
            }
        }
    };

    //Computes the Euclidean distance between two FaceVectors.
    FaceVector.prototype.distance = function(face) {
        return FaceVector.distance(this,face);
    };


    FaceVector.distance = function(face1, face2) {
        var sum = 0.0;
        var diff;

        for (var key in face1) {
            if (face1.hasOwnProperty(key)) {
                diff = face1[key] - face2[key];
                sum = sum + diff * diff;
            }
        }

        return Math.sqrt(sum);
    };

    FaceVector.prototype.toString = function() {
        var out = 'Face: ';
        for (var key in this) {
            if (this.hasOwnProperty(key)) {
                out += key + ' ' + this[key];
            }
        }
        return out;
    };

})(node);

/**
 * # ChoiceManager
 * Copyright(c) 2022 Stefano Balietti
 * MIT Licensed
 *
 * Creates and manages a set of selectable choices forms (e.g., ChoiceTable).
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('ChoiceManager', ChoiceManager);

    // ## Meta-data

    ChoiceManager.version = '1.8.0';
    ChoiceManager.description = 'Groups together and manages a set of ' +
        'survey forms (e.g., ChoiceTable).';

    ChoiceManager.title = false;
    ChoiceManager.className = 'choicemanager';

    // ## Dependencies

    ChoiceManager.dependencies = {
        BackButton: {}, DoneButton: {}
    };

    /**
     * ## ChoiceManager constructor
     *
     * Creates a new instance of ChoiceManager
     */
    function ChoiceManager() {
        /**
         * ### ChoiceManager.dl
         *
         * The clickable list containing all the forms
         */
        this.dl = null;

        /**
         * ### ChoiceManager.mainText
         *
         * The main text introducing the choices
         *
         * @see ChoiceManager.spanMainText
         */
        this.mainText = null;

        /**
         * ### ChoiceManager.spanMainText
         *
         * The span containing the main text
         */
        this.spanMainText = null;

        /**
         * ### ChoiceManager.forms
         *
         * The array available forms
         *
         * @see ChoiceManager.formsById
         */
        this.forms = null;

        /**
         * ### ChoiceManager.forms
         *
         * A map form id to form
         *
         * Note: if a form does not have an id, it will not be added here.
         *
         * @see ChoiceManager.forms
         */
        this.formsById = null;

        /**
         * ### ChoiceManager.order
         *
         * The order of the forms as displayed (if shuffled)
         */
        this.order = null;

        /**
         * ### ChoiceManager.shuffleForms
         *
         * TRUE, if forms have been shuffled
         */
        this.shuffleForms = null;

        /**
         * ### ChoiceManager.group
         *
         * The name of the group where the list belongs, if any
         */
        this.group = null;

        /**
         * ### ChoiceManager.groupOrder
         *
         * The order of the list within the group
         */
        this.groupOrder = null;

        // TODO: rename in sharedOptions.
        /**
         * ### ChoiceManager.formsOptions
         *
         * An object containing options to be added to every form
         *
         * Options are added only if forms are specified as object literals,
         * and can be overriden by each individual form.
         */
        this.formsOptions =  {
            title: false,
            frame: false,
            storeRef: false
        };


        /**
         * ### ChoiceManager.simplify
         *
         * If TRUE, it returns getValues() returns forms.values
         *
         * @see ChoiceManager.getValue
         */
        this.simplify = null;

        /**
         * ### ChoiceManager.freeText
         *
         * If truthy, a textarea for free-text comment will be added
         *
         * If 'string', the text will be added inside the the textarea
         */
        this.freeText = null;

        /**
         * ### ChoiceManager.textarea
         *
         * Textarea for free-text comment
         */
        this.textarea = null;

        /**
         * ### ChoiceManager.required
         *
         * If TRUE, the widget is checked upon node.done.
         */
        this.required = null;

        /**
         * ### ChoiceManager.oneByOne
         *
         * If, TRUE the widget displays only one form at the time
         *
         * Calling node.done will display the next form.
         */
        this.oneByOne = null;

        /**
         * ### ChoiceManager.oneByOneCounter
         *
         * Index the currently displayed form if oneByOne is TRUE
         */
        this.oneByOneCounter = 0;

        /**
         * ### ChoiceManager.oneByOneResults
         *
         * Contains partial results from forms if OneByOne is true
         */
        this.oneByOneResults = {};

        /**
         * ### ChoiceManager.conditionals
         *
         * Contains conditions to display or hide forms based on other forms
         */
        this.conditionals = {};

        /**
         * ### ChoiceManager.doneBtn
         *
         * Button to go to the next visualization/step
         */
        this.doneBtn = null;

        /**
         * ### ChoiceManager.backBtn
         *
         * Button to go to the previous visualization/step
         */
        this.backBtn = null;

        /**
         * ### ChoiceManager.honeypot
         *
         * Array of unused input forms to detect bots.
         */
        this.honeypot = null;

    }

    // ## ChoiceManager methods

    /**
     * ### ChoiceManager.init
     *
     * Initializes the instance
     *
     * Available options are:
     *
     *   - className: the className of the list (string, array), or false
     *       to have none.
     *   - group: the name of the group (number or string), if any
     *   - groupOrder: the order of the list in the group, if any
     *   - mainText: a text to be displayed above the list
     *   - shuffleForms: if TRUE, forms are shuffled before being added
     *       to the list
     *   - freeText: if TRUE, a textarea will be added under the list,
     *       if 'string', the text will be added inside the the textarea
     *   - forms: the forms to displayed, formatted as explained in
     *       `ChoiceManager.setForms`
     *   - formsOptions: a set of default options to add to every form
     *
     * @param {object} options Configuration options
     *
     * @see ChoiceManager.setForms
     */
    ChoiceManager.prototype.init = function(options) {
        var tmp;

        // Option shuffleForms, default false.
        if ('undefined' === typeof options.shuffleForms) tmp = false;
        else tmp = !!options.shuffleForms;
        this.shuffleForms = tmp;


        // Set the group, if any.
        if ('string' === typeof options.group ||
            'number' === typeof options.group) {

            this.group = options.group;
        }
        else if ('undefined' !== typeof options.group) {
            throw new TypeError('ChoiceManager.init: options.group must ' +
                                'be string, number or undefined. Found: ' +
                                options.group);
        }

        // Set the groupOrder, if any.
        if ('number' === typeof options.groupOrder) {

            this.groupOrder = options.groupOrder;
        }
        else if ('undefined' !== typeof options.group) {
            throw new TypeError('ChoiceManager.init: options.groupOrder must ' +
                                'be number or undefined. Found: ' +
                                options.groupOrder);
        }

        // Set the mainText, if any.
        if ('string' === typeof options.mainText) {
            this.mainText = options.mainText;
        }
        else if ('undefined' !== typeof options.mainText) {
            throw new TypeError('ChoiceManager.init: options.mainText must ' +
                                'be string or undefined. Found: ' +
                                options.mainText);
        }

        // formsOptions.
        if ('undefined' !== typeof options.formsOptions) {
            if ('object' !== typeof options.formsOptions) {
                throw new TypeError('ChoiceManager.init: options.formsOptions' +
                                    ' must be object or undefined. Found: ' +
                                    options.formsOptions);
            }
            if (options.formsOptions.hasOwnProperty('name')) {
                throw new Error('ChoiceManager.init: options.formsOptions ' +
                                'cannot contain property name. Found: ' +
                                options.formsOptions);
            }
            this.formsOptions = J.mixin(this.formsOptions,
                                        options.formsOptions);
        }

        this.freeText = 'string' === typeof options.freeText ?
            options.freeText : !!options.freeText;

        if ('undefined' !== typeof options.required) {
            this.required = !!options.required;
        }

        // If TRUE, it returns getValues returns forms.values.
        this.simplify = !!options.simplify;

        // If TRUE, forms are displayed one by one.
        this.oneByOne = !!options.oneByOne;

        // If truthy, a next button is added at the bottom. If object, it
        // is passed as conf object to DoneButton.
        this.doneBtn = options.doneBtn;

        // If truthy, a back button is added at the bottom. If object, it
        // is passed as conf object to BackButton.
        this.backBtn = options.backBtn;

        // If truthy a useless form is added to detect bots.
        this.honeypot = options.honeypot;

        // After all configuration options are evaluated, add forms.

        if ('undefined' !== typeof options.forms) this.setForms(options.forms);

    };

    /**
     * ### ChoiceManager.setForms
     *
     * Sets the available forms
     *
     * Each form element can be:
     *
     *   - an instantiated widget
     *   - a "widget-like" element (`append` and `getValues` methods must exist)
     *   - an object with the `name` of the widget and optional settings, e.g.:
     *
     *  ```
     *     {
     *        name: 'ChoiceTable',
     *        mainText: 'Did you commit the crime?',
     *        choices: [ 'Yes', 'No' ],
     *     }
     *  ```
     *
     * @param {array|function} forms The array of forms or a function
     *   returning an array of forms
     *
     * @see ChoiceManager.order
     * @see ChoiceManager.isWidget
     * @see ChoiceManager.shuffleForms
     * @see ChoiceManager.buildForms
     * @see ChoiceManager.buildTableAndForms
     */
    ChoiceManager.prototype.setForms = function(forms) {
        var i, len, parsedForms;
        if ('function' === typeof forms) {
            parsedForms = forms.call(node.game);
            if (!J.isArray(parsedForms)) {
                throw new TypeError('ChoiceManager.setForms: forms is a ' +
                                    'callback, but did not returned an ' +
                                    'array. Found: ' + parsedForms);
            }
        }
        else if (J.isArray(forms)) {
            parsedForms = forms;
        }
        else {
            throw new TypeError('ChoiceManager.setForms: forms must be array ' +
                                'or function. Found: ' + forms);
        }

        len = parsedForms.length;
        if (!len) {
            throw new Error('ChoiceManager.setForms: forms is an empty array.');
        }

        // Manual clone forms.
        this.formsById = {};
        this.order = new Array(len);
        this.forms = new Array(len);
        i = -1;
        for ( ; ++i < len ; ) {
            this.addForm(parsedForms[i], false, i);
            // Save the order in which the choices will be added.
            this.order[i] = i;
        }

        // Shuffle, if needed.
        if (this.shuffleForms) this.order = J.shuffle(this.order);
    };

    /**
     * ### ChoiceManager.buildDl
     *
     * Builds the list of all forms
     *
     * Must be called after forms have been set already.
     *
     * @see ChoiceManager.setForms
     * @see ChoiceManager.order
     */
    ChoiceManager.prototype.buildDl = function() {
        var i, len;
        var form;

        i = -1, len = this.forms.length;
        for ( ; ++i < len ; ) {
            form = this.forms[this.order[i]];
            appendDT(this.dl, form);
        }
    };

    ChoiceManager.prototype.append = function() {
        var div, opts;

        // Id must be unique.
        if (W.getElementById(this.id)) {
            throw new Error('ChoiceManager.append: id is not ' +
                            'unique: ' + this.id);
        }

        // MainText.
        if (this.mainText) {
            this.spanMainText = document.createElement('span');
            this.spanMainText.className = ChoiceManager.className + '-maintext';
            this.spanMainText.innerHTML = this.mainText;
            // Append mainText.
            this.bodyDiv.appendChild(this.spanMainText);
        }

        // Dl.
        this.dl = document.createElement('dl');
        this.buildDl();
        // Append Dl.
        this.bodyDiv.appendChild(this.dl);

        // Creates a free-text textarea, possibly with placeholder text.
        if (this.freeText) {
            this.textarea = document.createElement('textarea');
            if (this.id) this.textarea.id = this.id + '_text';
            if ('string' === typeof this.freeText) {
                this.textarea.placeholder = this.freeText;
            }
            this.textarea.className = ChoiceManager.className + '-freetext';
            // Append textarea.
            this.bodyDiv.appendChild(this.textarea);
        }

        if (this.backBtn || this.doneBtn) {
            div = W.append('div', this.bodyDiv);
            div.className = 'choicemanager-buttons';

            if (this.backBtn) {
                opts = this.backBtn;
                if ('string' === typeof opts) opts = { text: opts };
                else opts = J.mixin({ text: 'Back' }, opts);
                this.backBtn = node.widgets.append('BackButton', div, opts);
            }

            if (this.doneBtn) {
                opts = this.doneBtn;
                if ('string' === typeof opts) opts = { text: opts };
                opts = J.mixin({ text: 'Next' }, opts);
                this.doneBtn = node.widgets.append('DoneButton', div, opts);
            }
        }


        if (this.honeypot) this.addHoneypot(this.honeypot);
    };

    /**
     * ### ChoiceManager.listeners
     *
     * Implements Widget.listeners
     *
     * Adds two listeners two disable/enable the widget on events:
     * INPUT_DISABLE, INPUT_ENABLE
     *
     * @see Widget.listeners
     */
    ChoiceManager.prototype.listeners = function() {
        var that = this;
        node.on('INPUT_DISABLE', function() {
            that.disable();
        });
        node.on('INPUT_ENABLE', function() {
            that.enable();
        });
    };

    /**
     * ### ChoiceManager.disable
     *
     * Disables all forms
     */
    ChoiceManager.prototype.disable = function() {
        var i, len;
        if (this.disabled) return;
        i = -1, len = this.forms.length;
        for ( ; ++i < len ; ) {
            this.forms[i].disable();
        }
        this.disabled = true;
        this.emit('disabled');
    };

    /**
     * ### ChoiceManager.addForm
     *
     * Adds a new form at the bottom.
     */
    ChoiceManager.prototype.addForm = function(form, scrollIntoView, idx) {
        var name;

        if ('undefined' === typeof idx) idx = this.forms.length;
        if ('undefined' === typeof scrollIntoView) scrollIntoView = true;

        if (!node.widgets.isWidget(form)) {
            // TODO: smart checking form name. Maybe in Stager already?
            name = form.name || 'ChoiceTable';
            // Add defaults.
            J.mixout(form, this.formsOptions);

            // By default correctChoice means required.
            // However, it is possible to add required = false and correctChoice
            // truthy, for instance if there is a solution to display.
            if ((form.required !== false && form.requiredChoice !== false) &&
                (form.required || form.requiredChoice ||
                ('undefined' !== typeof form.correctChoice &&
                form.correctChoice !== false))) {

                // False is set manually, otherwise undefined.
                if (this.required === false) {
                    throw new Error('ChoiceManager.setForms: required is ' +
                                    'false, but form "' + form.id +
                                    '" has required truthy');
                }
                this.required = true;
            }

            // Display forms one by one.
            if (this.oneByOne && this.oneByOneCounter !== idx) {
                form.hidden = true;
            }

            if (form.conditional) {
                this.conditionals[form.id] = form.conditional;
            }

            if (this._bootstrap5 && 'undefined' === typeof form.bootstrap5) {
                form.bootstrap5 = true;
            }

            form = node.widgets.get(name, form);

        }

        if (form.id) {
            if (this.formsById[form.id]) {
                throw new Error('ChoiceManager.setForms: duplicated ' +
                                'form id: ' + form.id);
            }

        }
        else {
            form.id = form.className + '_' + idx;
        }
        this.forms[idx] = form;
        this.formsById[form.id] = form;

        if (this.dl) {

            // Add the last added form to the order array.
            this.order.push(this.order.length);

            appendDT(this.dl, form);
            W.adjustFrameHeight();
            if (!scrollIntoView) return;
            // Scroll into the slider.
            if ('function' === typeof form.bodyDiv.scrollIntoView) {
                form.bodyDiv.scrollIntoView({ behavior: 'smooth' });
            }
            else if (window.scrollTo) {
                // Scroll to bottom of page.
                window.scrollTo(0, document.body.scrollHeight);
            }
        }
    };

    /**
     * ### ChoiceManager.enable
     *
     * Enables all forms
     */
    ChoiceManager.prototype.enable = function() {
        var i, len;
        if (!this.disabled) return;
        i = -1, len = this.forms.length;
        for ( ; ++i < len ; ) {
            this.forms[i].enable();
        }
        this.disabled = false;
        this.emit('enabled')
    };

    /**
     * ### ChoiceManager.verifyChoice
     *
     * Compares the current choice/s with the correct one/s
     *
     * @param {boolean} markAttempt Optional. If TRUE, the value of
     *   current choice is added to the attempts array. Default
     *
     * @return {boolean|null} TRUE if current choice is correct,
     *   FALSE if it is not correct, or NULL if no correct choice
     *   was set
     *
     * @see ChoiceManager.attempts
     * @see ChoiceManager.setCorrectChoice
     */
    ChoiceManager.prototype.verifyChoice = function(markAttempt) {
        var i, len, obj, form;
        obj = {
            id: this.id,
            order: this.order,
            forms: {}
        };
        // Mark attempt by default.
        markAttempt = 'undefined' === typeof markAttempt ? true : markAttempt;
        i = -1, len = this.forms.length;
        for ( ; ++i < len ; ) {
            form = this.forms[i];
            obj.forms[form.id] = form.verifyChoice(markAttempt);
            if (!obj.form[form.id]) obj.fail = true;
        }
        return obj;
    };

    /**
     * ### ChoiceManager.setCurrentChoice
     *
     * Marks a choice as current in each form
     *
     * If the item allows it, multiple choices can be set as current.
     *
     * @param {number|string} The choice to mark as current
     */
    ChoiceManager.prototype.setCurrentChoice = function(choice) {
        var i, len;
        i = -1, len = this.forms[i].length;
        for ( ; ++i < len ; ) {
            this.forms[i].setCurrentChoice(choice);
        }
    };

    /**
     * ### ChoiceManager.unsetCurrentChoice
     *
     * Deletes the value for currentChoice in each form
     *
     * If `ChoiceManager.selectMultiple` is set the
     *
     * @param {number|string} Optional. The choice to delete
     *   when multiple selections are allowed
     */
    ChoiceManager.prototype.unsetCurrentChoice = function(choice) {
        var i, len;
        i = -1, len = this.forms[i].length;
        for ( ; ++i < len ; ) {
            this.forms[i].unsetCurrentChoice(choice);
        }
    };

    /**
     * ### ChoiceManager.highlight
     *
     * Highlights the choice table
     *
     * @param {string} The style for the dl's border.
     *   Default '1px solid red'
     *
     * @see ChoiceManager.highlighted
     */
    ChoiceManager.prototype.highlight = function(border) {
        if (border && 'string' !== typeof border) {
            throw new TypeError('ChoiceManager.highlight: border must be ' +
                                'string or undefined. Found: ' + border);
        }
        if (!this.dl || this.highlighted === true) return;
        this.dl.style.border = border || '3px solid red';
        this.highlighted = true;
        this.emit('highlighted');
    };

    /**
     * ### ChoiceManager.unhighlight
     *
     * Removes highlight from the choice dl
     *
     * @see ChoiceManager.highlighted
     */
    ChoiceManager.prototype.unhighlight = function() {
        if (!this.dl || this.highlighted !== true) return;
        this.dl.style.border = '';
        this.highlighted = false;
        this.emit('unhighlighted');
    };

    /**
     * ### ChoiceManager.reset
     *
     * Resets all forms
     *
     * @param {object} opts Optional. Reset options to pass each form
     */
    ChoiceManager.prototype.reset = function(opts) {
        var i, len;
        i = -1;
        len = this.forms.length;
        for ( ; ++i < len ; ) {
            this.forms[i].reset(opts);
        }
    };

    /**
     * ### ChoiceManager.getValues
     *
     * Returns the values for current selection and other paradata
     *
     * Paradata that is not set or recorded will be omitted
     *
     * @param {object} opts Optional. Configures the return value.
     *   Available optionts:
     *
     *   - markAttempt: If TRUE, getting the value counts as an attempt
     *      to find the correct answer. Default: TRUE.
     *   - highlight:   If TRUE, forms that do not have a correct value
     *      will be highlighted. Default: TRUE.
     *
     * @return {object} Object containing the choice and paradata
     *
     * @see ChoiceManager.verifyChoice
     */
    ChoiceManager.prototype.getValues = function(opts) {
        var obj, i, len, form, lastErrored, res, toCheck;
        obj = {
            order: this.order,
            forms: {},
            missValues: []
        };
        if ('undefined' !== typeof this.id) obj.id = this.id;
        opts = opts || {};
        if ('undefined' === typeof opts.markAttempt) opts.markAttempt = true;
        if ('undefined' === typeof opts.highlight) opts.highlight = true;
        if (opts.markAttempt) obj.isCorrect = true;

        len = this.forms.length;


        // TODO: we could save the results when #next() is called or
        // have an option to get the values of current form or a specific form.
        // The code below is a old and created before #next() was created.
        // Only one form displayed.
        // if (this.oneByOne) {
        //
        //     // Evaluate one-by-one and store partial results.
        //     if (this.oneByOneCounter < (len-1)) {
        //         form = this.forms[this.oneByOneCounter];
        //         res = form.getValues(opts);
        //         if (res) {
        //             this.oneByOneResults[form.id] = res;
        //             lastErrored = checkFormResult(res, form, opts);
        //
        //             if (!lastErrored) {
        //                 this.forms[this.oneByOneCounter].hide();
        //                 this.oneByOneCounter++;
        //                 this.forms[this.oneByOneCounter].show();
        //                 W.adjustFrameHeight();
        //                 // Prevent stepping.
        //                 obj.isCorrect = false;
        //             }
        //         }
        //     }
        //     // All one-by-one pages executed.
        //     else {
        //         // Copy all partial results in the obj returning the
        //         obj.forms = this.oneByOneResults;
        //     }
        //
        // }
        // All forms on the page.
        // else {
            i = -1;
            for ( ; ++i < len ; ) {
                form = this.forms[i];

                // Not one-by-one because there could be many hidden.
                // If it is hidden or disabled we do not do validation.

                if (this.oneByOne) toCheck = form._shown && form.required;
                else toCheck = !(form.isDisabled() || form.isHidden());

                if (toCheck) {
                    // ContentBox does not return a value.
                    res = form.getValues(opts);
                    if (!res) continue;
                    obj.forms[form.id] = res;

                    res = checkFormResult(res, form, opts, obj);
                    if (res) lastErrored = res;
                }
                else {
                    res = form.getValues({
                        markAttempt: false,
                        highlight: false
                    });
                    if (res) obj.forms[form.id] = res;
                }
            }
        // }

        if (lastErrored) {
            if (opts.highlight &&
                'function' === typeof lastErrored.bodyDiv.scrollIntoView) {

                lastErrored.bodyDiv.scrollIntoView({ behavior: 'smooth' });
            }
            obj._scrolledIntoView = true;
            obj.isCorrect = false;
            // Adjust frame heights because of error msgs.
            // TODO: error msgs should not change the height.
            W.adjustFrameHeight();
        }
        // if (obj.missValues.length) obj.isCorrect = false;
        if (this.textarea) obj.freetext = this.textarea.value;

        // Simplify everything, if requested.
        if (opts.simplify || this.simplify) {
            res = obj;
            obj = obj.forms;
            if (res.isCorrect === false) obj.isCorrect = false;
            if (res.freetext) obj.freetext = res.freetext;
        }

        if (this.honeypot) {
            obj.honeypotHit = 0;
            obj.honeypot = this.honeypot.map(function(h) {
                if (h.value) obj.honeypotHit++;
                return h.value || false;
            });
        }
        return obj;
    };

    /**
     * ### ChoiceManager.setValues
     *
     * Sets values for forms in manager as specified by the options
     *
     * @param {object} options Optional. Options specifying how to set
     *   the values. If no parameter is specified, random values will
     *   be set.
     */
    ChoiceManager.prototype.setValues = function(opts) {
        var i, len;
        if (!this.forms || !this.forms.length) {
            throw new Error('ChoiceManager.setValues: no forms found.');
        }
        opts = opts || {};
        i = -1, len = this.forms.length;
        for ( ; ++i < len ; ) {
            this.forms[i].setValues(opts);
        }

        // Make a random comment.
        if (this.textarea) this.textarea.value = J.randomString(100, '!Aa0');
    };

    /**
     * ### ChoiceManager.addHoneypot
     *
     * Adds a hidden <form> tag with nested <input> that bots should fill
     *
     * The inputs created are added under ChoiceManager.honeypot
     *
     * @param {object} opts Optional. Options to configure the honeypot.
     *  - id: id of the <form> tag
     *  - action: action attribute of the <form> tag
     *  - forms: array of forms to add to the <form> tag. Format:
     *      - id: id of input and "for" attribute of the label
     *      - label: text of the label
     *      - placeholder: placeholder for the input
     *      - type: type of input (default 'text')
     */
    ChoiceManager.prototype.addHoneypot = function(opts) {
        var h, forms, that;
        if (!this.isAppended()) {
            node.warn('ChoiceManager.addHoneypot: not appended yet');
            return;
        }
        if ('object' !== typeof opts) opts = {};
        h = W.add('form', this.panelDiv, {
            id: opts.id || (this.id + 'form'),
            action: opts.action || ('/' + this.id + 'receive')
        });

        h.style.opacity = 0;
        h.style.position = 'absolute';
        h.style.top = 0;
        h.style.left = 0;
        h.style.height = 0;
        h.style.width = 0;
        h.style['z-index'] = -1;

        if (!opts.forms) {
            forms = [
                { id: 'name', label: 'Your name',
                  placeholder: 'Enter your name' },
                { id: 'email', label: 'Your email',
                  placeholder: 'Type your email', type: 'email' }
            ];
        }
        else {
            forms = opts.forms;
        }

        // Change from options to array linking to honeypot inputs.
        this.honeypot = [];

        that = this;
        forms.forEach(function(f) {
            var hh;
            W.add('label', h, { 'for': f.id });
            hh = W.add('input', h, {
                id: f.id,
                type: f.type || 'text',
                placeholder: f.placeholder,
                required: true,
                autocomplete: 'off'
            });
            that.honeypot.push(hh);
        });
    };

    /**
     * ### ChoiceManager.next
     *
     * Sets values for forms in manager as specified by the options
     *
     * @return {boolean} FALSE, if there is not another visualization.
     */
    ChoiceManager.prototype.next = function() {
        var form, conditional, failsafe, that;
        if (!this.oneByOne) return false;
        if (!this.forms || !this.forms.length) {
            throw new Error('ChoiceManager.next: no forms found.');
        }
        form = this.forms[this.oneByOneCounter];
        if (!form) return false;

        if (form.next()) return true;
        if (this.oneByOneCounter >= (this.forms.length-1)) return false;

        form.hide();
        if (this.backBtn) this.backBtn.disable();
        if (this.doneBtn) this.doneBtn.disable();

        failsafe = 500;
        while (form && !conditional && this.oneByOneCounter < failsafe) {
            form = this.forms[++this.oneByOneCounter];
            if (!form) return false;
            conditional = checkConditional(this, form.id);
        }

        // TODO: make this property a reserved keyword.
        form._shown = true;

        if ('undefined' !== typeof $) {
            $(form.panelDiv).fadeIn();
            form.hidden = false; // for nodeGame.
        }
        else {
            form.show();
        }
        window.scrollTo(0,0);

        that = this;
        setTimeout(function() {
            if (node.game.isPaused()) return;
            if (that.backBtn) that.backBtn.enable();
            if (that.doneBtn) that.doneBtn.enable();
        }, 250);


        W.adjustFrameHeight();

        node.emit('WIDGET_NEXT', this);

        return true;
    };

    ChoiceManager.prototype.prev = function() {
        var form, conditional, failsafe;
        if (!this.oneByOne) return false;
        if (!this.forms || !this.forms.length) {
            throw new Error('ChoiceManager.prev: no forms found.');
        }
        form = this.forms[this.oneByOneCounter];
        if (!form) return false;
        if (form.prev()) return true;
        if (this.oneByOneCounter <= 0) return false;
        form.hide();

        failsafe = 500;
        while (form && !conditional && this.oneByOneCounter < failsafe) {
            form = this.forms[--this.oneByOneCounter];
            if (!form) return false;
            conditional = checkConditional(this, form.id);
        }

        if ('undefined' !== typeof $) {
            $(form.panelDiv).fadeIn();
            form.hidden = false; // for nodeGame.
        }
        else {
            form.show();
        }
        window.scrollTo(0,0);

        W.adjustFrameHeight();
        node.emit('WIDGET_PREV', this);

        return true;
    };

    // TODO: better to have .getForms({ hidden: false }); or similar
    ChoiceManager.prototype.getVisibleForms = function() {
        if (this.oneByOne) return [this.forms[this.oneByOneCounter]];
        return this.forms.map(function(f) { if (!f.isHidden()) return f; });
    };

    // ## Helper methods.

    function checkFormResult(res, form, opts, out) {
        var err;
        // Backward compatible (requiredChoice).
        if ((form.required || form.requiredChoice) &&
            (res.choice === null ||
            (form.selectMultiple && !res.choice.length))) {

            if (out) out.missValues.push(form.id);
            err = form;
        }
        if (opts.markAttempt && res.isCorrect === false) {
            // out.isCorrect = false;
            err = form;
        }

        return err;
    }

    function checkConditional(that, id) {
        var f, c, form;
        f = that.conditionals[id];
        if (f) {
            if ('function' === typeof f) {
                return f.call(that, that.formsById);
            }
            for (c in f) {
                if (f.hasOwnProperty(c)) {
                    form = that.formsById[c];
                    if (!form) continue;
                    // No multiple choice allowed.
                    if (J.isArray(f[c])) {
                        if (!J.inArray(form.currentChoice, f[c])) return false;
                    }
                    else if (form.currentChoice !== f[c]) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    function appendDT(dl, form) {
        var dt;
        dt = document.createElement('dt');
        dt.className = 'question';
        node.widgets.append(form, dt);
        dl.appendChild(dt);
    }

// In progress.
//     const createOnClick = (choice, question) => {
//     return function(value, removed, td) {
//         var w, hide;
//         w = node.widgets.lastAppended.formsById[question];
//         if (J.isArray(choice)) {
//             hide = !J.inArray(this.currentChoice, choice);
//         }
//         else {
//             hide = this.currentChoice !== choice;
//         }
//         if (hide) w.hide();
//         else w.show();
//         W.adjustFrameHeight();
//     };
// };
// onclick: createOnClick([0, 1], 'crypto_occupation')

})(node);

/**
 * # ChoiceTable
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Creates a configurable table where each cell is a selectable choice
 *
 * // TODO: register time for each current choice if selectMultiple is on?
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('ChoiceTable', ChoiceTable);

    // ## Meta-data

    ChoiceTable.version = '1.10.0';
    ChoiceTable.description = 'Creates a configurable table where ' +
        'each cell is a selectable choice.';

    ChoiceTable.title = 'Make your choice';
    ChoiceTable.className = 'choicetable';

    ChoiceTable.texts = {

        autoHint: function(w) {
            var res;
            if (!w.requiredChoice && !w.selectMultiple) return false;
            if (!w.selectMultiple) return '*';
            res = '(';
            if (!w.requiredChoice) {
                if ('number' === typeof w.selectMultiple) {
                    res += 'select up to ' + w.selectMultiple;
                }
                else {
                    res += 'multiple selection allowed';
                }
            }
            else {
                if ('number' === typeof w.selectMultiple) {
                    if (w.selectMultiple === w.requiredChoice) {
                        res += 'select ' + w.requiredChoice;
                    }
                    else {
                        res += 'select between ' + w.requiredChoice +
                        ' and ' + w.selectMultiple;
                    }
                }
                else {
                    res += 'select at least ' + w.requiredChoice;
                }
            }
            res += ')';
            if (w.requiredChoice) res += ' *';
            return res;
        },

        error: function(w, value) {
            if (value !== null &&
                ('number' === typeof w.correctChoice ||
                'string' === typeof w.correctChoice)) {

                return 'Not correct, try again.';
            }
            return 'Selection required.';
        },

        other: 'Other',

        customInput: 'Please specify.'

    };

    ChoiceTable.separator = '::';

    /**
     * ## ChoiceTable constructor
     *
     * Creates a new instance of ChoiceTable
     */
    function ChoiceTable() {
        var that;
        that = this;

        /**
         * ### ChoiceTable.table
         *
         * The HTML element triggering the listener function when clicked
         */
        this.table = null;

        /**
         * ### ChoiceTable.choicesSetSize
         *
         * How many choices can be on the same row/column
         */
        this.choicesSetSize = null;

        /**
         * ### ChoiceTable.tr
         *
         * Reference to TR elements of the table
         *
         * Note: if the orientation is vertical there will be multiple TR
         * otherwise just one.
         *
         * @see createTR
         */
        this.trs = [];

        /**
         * ### ChoiceTable.listener
         *
         * The main function listening on clicks
         *
         * @see ChoiceTable.onclick
         */
        this.listener = function(e) {
            var name, value, td, ci;
            var i, len, removed, other;

            e = e || window.event;
            td = e.target || e.srcElement;

            // See if it is a clickable choice.
            ci = that.choicesIds;
            if ('undefined' === typeof ci[td.id]) {
                // It might be a nested element, try the parent.
                td = td.parentNode;
                if (!td) return;
                if ('undefined' === typeof ci[td.id]) {
                    td = td.parentNode;
                    if (!td) return;
                    if ('undefined' === typeof ci[td.id]) {
                        td = td.parentNode;
                        if (!td || 'undefined' === typeof ci[td.id]) {
                            return;
                        }
                    }
                }
            }

            // Relative time.
            if ('string' === typeof that.timeFrom) {
                that.timeCurrentChoice = node.timer.getTimeSince(that.timeFrom);
            }
            // Absolute time.
            else {
                that.timeCurrentChoice = Date.now ?
                    Date.now() : new Date().getTime();
            }

            // Id of elements are in the form of name_value or name_item_value.
            value = td.id.split(that.separator);

            // Separator not found, not a clickable cell.
            if (value.length === 1) return;

            name = value[0];
            value = parseInt(value[1], 10);
            // value = value[1];

            // Choice disabled.
            // console.log('VALUE: ', value);
            if (that.disabledChoices[value]) return;

            // One more click.
            that.numberOfClicks++;

            removed = that.isChoiceCurrent(value);
            len = that.choices.length;

            if (that.customInput) {
                // Is "Other" currently selected?
                if (value === (len - 1) && !removed) {
                    that.customInput.show();
                }
                else {
                    that.customInput.hide();
                }
            }

            // Click on an already selected choice.
            if (removed) {
                that.unsetCurrentChoice(value);
                J.removeClass(td, 'selected');

                if (that.selectMultiple) {
                    // Remove selected TD (need to keep this clean for reset).
                    i = -1, len = that.selected.length;
                    for ( ; ++i < len ; ) {
                        if (that.selected[i].id === td.id) {
                            that.selected.splice(i, 1);
                            break;
                        }
                    }
                }
                else {
                    that.selected = null;
                }
            }
            // Click on a new choice.
            else {

                // Have we exhausted available choices?
                if ('number' === typeof that.selectMultiple &&
                    that.selected.length === that.selectMultiple) return;

                J.addClass(td, 'selected');

                if (that.oneTimeClick) {
                    setTimeout(function() {
                        J.removeClass(td, 'selected');
                    }, 60);
                }
                else {

                    that.setCurrentChoice(value);

                    if (that.selectMultiple) {
                        that.selected.push(td);
                    }
                    else {
                        // If only 1 selection allowed, remove old selection.
                        if (that.selected) {
                            J.removeClass(that.selected, 'selected');
                        }
                        that.selected = td;
                    }
                }
            }

            // Remove any warning/errors on click.
            if (that.isHighlighted()) that.unhighlight();

            // Call onclick, if any.
            if (that.onclick) {
                // TODO: Should we parseInt it anyway when we store
                // the current choice?
                value = parseInt(value, 10);
                that.onclick.call(that, value, removed, td);
            }

            if (that.doneOnClick) node.done();
        };

        /**
         * ## ChoiceTable.onclick
         *
         * The user-defined onclick listener
         *
         * Receives 3 input parameters: the value of the clicked choice,
         * whether it was a remove action, and the reference to the TD object.
         *
         * @see ChoiceTableGroup.listener
         */
        this.onclick = null;

        /**
         * ### ChoiceTable.mainText
         *
         * The main text introducing the choices
         *
         * @see ChoiceTable.spanMainText
         */
        this.mainText = null;

        /**
         * ### ChoiceTable.hint
         *
         * An additional text with information about how to select items
         *
         * If not specified, it may be auto-filled, e.g. '(pick 2)'.
         *
         * @see Feedback.texts.autoHint
         */
        this.hint = null;

        /**
         * ### ChoiceTable.spanMainText
         *
         * The span containing the main text
         */
        this.spanMainText = null;

        /**
         * ### ChoiceTable.choices
         *
         * The array available choices
         */
        this.choices = null;

        /**
         * ### ChoiceTable.choicesValues
         *
         * Map of choices' values to indexes in the choices array
         */
        this.choicesValues = {};

        /**
         * ### ChoiceTable.choicesIds
         *
         * Map of choices' cells ids to choices
         *
         * Used to determine what are the clickable choices.
         */
        this.choicesIds = {};

        /**
         * ### ChoiceTable.choicesCells
         *
         * The cells of the table associated with each choice
         */
        this.choicesCells = null;

        /**
         * ### ChoiceTable.left
         *
         * A non-clickable first cell of the row/column
         *
         * It will be placed to the left of the choices if orientation
         * is horizontal, or above the choices if orientation is vertical
         *
         * @see ChoiceTable.orientation
         */
        this.left = null;

        /**
         * ### ChoiceTable.leftCell
         *
         * The rendered left cell
         *
         * @see ChoiceTable.renderSpecial
         */
        this.leftCell = null;

        /**
         * ### ChoiceTable.right
         *
         * A non-clickable last cell of the row/column
         *
         * It will be placed to the right of the choices if orientation
         * is horizontal, or below the choices if orientation is vertical
         *
         * @see ChoiceTable.orientation
         */
        this.right = null;

        /**
         * ### ChoiceTable.rightCell
         *
         * The rendered right cell
         *
         * @see ChoiceTable.renderSpecial
         */
        this.rightCell = null;

        /**
         * ### ChoiceTable.errorBox
         *
         * An HTML element displayed when a validation error occurs
         */
        this.errorBox = null;

        /**
        * ### CustomInput.successBox
        *
        * An HTML element displayed when a validation error occurs
        */
        this.successBox = null;

        /**
         * ### ChoiceTable.timeCurrentChoice
         *
         * Time when the last choice was made
         */
        this.timeCurrentChoice = null;

        /**
         * ### ChoiceTable.timeFrom
         *
         * Time is measured from timestamp as saved by node.timer
         *
         * Default event is a new step is loaded (user can interact with
         * the screen). Set it to FALSE, to have absolute time.
         *
         * @see node.timer.getTimeSince
         */
        this.timeFrom = 'step';

        /**
         * ### ChoiceTable.order
         *
         * The current order of display of choices
         *
         * @see ChoiceTable.originalOrder
         */
        this.order = null;

        /**
         * ### ChoiceTable.correctChoice
         *
         * The correct choice/s
         *
         * The field is an array or number|string depending
         * on the value of ChoiceTable.selectMultiple
         *
         * @see ChoiceTable.selectMultiple
         */
        this.correctChoice = null;

        /**
         * ### ChoiceTable.requiredChoice
         *
         * The number of required choices. Default 0
         */
        this.requiredChoice = null;

        /**
         * ### ChoiceTable.attempts
         *
         * List of currentChoices at the moment of verifying correct answers
         */
        this.attempts = [];

        /**
         * ### ChoiceTable.numberOfClicks
         *
         * Total number of clicks on different choices
         */
        this.numberOfClicks = 0;

        /**
         * ### ChoiceTable.selected
         *
         * Currently selected TD elements
         *
         * @see ChoiceTable.currentChoice
         */
        this.selected = null;

        /**
         * ### ChoiceTable.currentChoice
         *
         * Choice/s associated with currently selected cell/s
         *
         * The field is an array or number|string depending
         * on the value of ChoiceTable.selectMultiple
         *
         * @see ChoiceTable.selectMultiple
         *
         * @see ChoiceTable.selected
         */
        this.currentChoice = null;

        /**
         * ### ChoiceTable.selectMultiple
         *
         * The number of maximum simulataneous selections (>1), or false
         *
         * Note: this option is incompatible with `oneTimeClick`.
         */
        this.selectMultiple = null;

        /**
        * ### ChoiceTable.oneTimeClick
        *
        * If TRUE, the selection is immediately removed after one click
        *
        * This is useful to create a buttons group which trigger some actions.
        *
        * Note: this option is incompatible with `selectMultiple`.
        */
        this.oneTimeClick = null;

        /**
         * ### ChoiceTable.shuffleChoices
         *
         * If TRUE, choices are randomly assigned to cells
         *
         * @see ChoiceTable.order
         */
        this.shuffleChoices = null;

        /**
         * ### ChoiceTable.renderer
         *
         * A callback that renders the content of each cell
         *
         * The callback must accept three parameters:
         *
         *   - a td HTML element,
         *   - a choice
         *   - the index of the choice element within the choices array
         *
         * and optionally return the _value_ for the choice (otherwise
         * the order in the choices array is used as value).
         */
        this.renderer = null;

        /**
         * ### ChoiceTable.orientation
         *
         * Orientation of display of choices: vertical ('V') or horizontal ('H')
         *
         * Default orientation is horizontal.
         */
        this.orientation = 'H';

        /**
         * ### ChoiceTable.group
         *
         * The name of the group where the table belongs, if any
         */
        this.group = null;

        /**
         * ### ChoiceTable.groupOrder
         *
         * The order of the choice table within the group
         */
        this.groupOrder = null;

        /**
         * ### ChoiceTable.freeText
         *
         * If truthy, a textarea for free-text comment will be added
         *
         * If 'string', the text will be added inside the textarea
         */
        this.freeText = null;

        /**
         * ### ChoiceTable.textarea
         *
         * Textarea for free-text comment
         */
        this.textarea = null;

        /**
         * ### ChoiceTable.separator
         *
         * Symbol used to separate tokens in the id attribute of every cell
         *
         * Default ChoiceTable.separator
         *
         * @see ChoiceTable.renderChoice
         */
        this.separator = ChoiceTable.separator;

        /**
         * ### ChoiceTable.tabbable
         *
         * If TRUE, the elements of the table can be accessed with TAB
         *
         * Clicking is simulated upon pressing space or enter.
         *
         * Default TRUE
         *
         * @see ChoiceTable.renderChoice
         */
        this.tabbable = null;

        /**
         * ### ChoiceTable.disabledChoices
         *
         * An object containing the list of disabled values
         */
        this.disabledChoices = {};


        /**
        * ### ChoiceTable.sameWidthCells
        *
        * If TRUE, cells have same width regardless of content
        */
        this.sameWidthCells = true;

        /**
        * ### ChoiceTable.other
        *
        * If TRUE, adds an "Other" choice as last choice
        *
        * Accepted values:
        * - true: adds "Other" choice as last choice.
        * - 'CustomInput':  adds "Other" choice AND a CustomInput widget below
        *   the choicetable (initially hidden).
        * - object: as previous, but it also allows for custom options for the
        *   custom input
        *
        * @see ChoiceTable.customInput
        */
        this.other = null;

        /**
        * ### ChoiceTable.customInput
        *
        * The customInput widget
        *
        * @see ChoiceTable.other
        */
        this.customInput = null;

        /**
        * ### ChoiceTable.doneOnClick
        *
        * If TRUE, node.done() will be invoked after the first click
        */
        this.doneOnClick = null;

        /**
        * ### ChoiceTable.solution
        *
        * Additional information to be displayed after a selection is confirmed
        *
        * If no answer is provided and the next method is triggered, the
        * solution is displayed only if solutionNoChoice is TRUE
        *
        * @see ChoiceTable.solutionNoChoice
        * @see ChoiceTable.next
        */
        this.solution = null;

        /**
        * ### ChoiceTable.solutionDisplayed
        *
        * TRUE, if the solution is currently displayed
        */
        this.solutionDisplayed = false;

        /**
        * ### ChoiceTable.solutionNoChoice
        *
        * TRUE, he solution is displayed upon trigger even with no choice
        */
        this.solutionNoChoice = false;

        /**
        * ### ChoiceTable.solutionDiv
        *
        * The <div> element containing the solution
        */
        this.solutionDiv = null;
    }

    // ## ChoiceTable methods

    /**
     * ### ChoiceTable.init
     *
     * Initializes the instance
     *
     * Available options are:
     *
     *   - left: the content of the left (or top) cell
     *   - right: the content of the right (or bottom) cell
     *   - className: the className of the table (string, array), or false
     *       to have none.
     *   - orientation: orientation of the table: vertical (v) or horizontal (h)
     *   - group: the name of the group (number or string), if any
     *   - groupOrder: the order of the table in the group, if any
     *   - listener: a function executed at every click. Context is
     *       `this` instance
     *   - onclick: a function executed after the listener function. Context is
     *       `this` instance
     *   - mainText: a text to be displayed above the table
     *   - hint: a text with extra info to be displayed after mainText
     *   - choices: the array of available choices. See
     *       `ChoiceTable.renderChoice` for info about the format
     *   - correctChoice: the array|number|string of correct choices. See
     *       `ChoiceTable.setCorrectChoice` for info about the format
     *   - selectMultiple: if TRUE multiple cells can be selected
     *   - shuffleChoices: if TRUE, choices are shuffled before being added
     *       to the table
     *   - renderer: a function that will render the choices. See
     *       ChoiceTable.renderer for info about the format
     *   - freeText: if TRUE, a textarea will be added under the table,
     *       if 'string', the text will be added inside the textarea
     *   - timeFrom: The timestamp as recorded by `node.timer.setTimestamp`
     *       or FALSE, to measure absolute time for current choice
     *   - tabbable: if TRUE, each cell can be reached with TAB and clicked
     *       with SPACE or ENTER. Default: TRUE.
     *   - disabledChoices: array of disabled choices (values).
     *
     * @param {object} opts Configuration options
     */
    ChoiceTable.prototype.init = function(opts) {
        var tmp, that;
        that = this;

        if (!this.id) {
            throw new TypeError('ChoiceTable.init: opts.id is missing');
        }

        // Option orientation, default 'H'.
        if ('undefined' === typeof opts.orientation) {
            tmp = 'H';
        }
        else if ('string' !== typeof opts.orientation) {
            throw new TypeError('ChoiceTable.init: opts.orientation must ' +
                                'be string, or undefined. Found: ' +
                                opts.orientation);
        }
        else {
            tmp = opts.orientation.toLowerCase().trim();
            if (tmp === 'horizontal' || tmp === 'h') {
                tmp = 'H';
            }
            else if (tmp === 'vertical' || tmp === 'v') {
                tmp = 'V';
            }
            else {
                throw new Error('ChoiceTable.init: opts.orientation is ' +
                                'invalid: ' + tmp);
            }
        }
        this.orientation = tmp;

        // Option shuffleChoices, default false.
        if ('undefined' === typeof opts.shuffleChoices) tmp = false;
        else tmp = !!opts.shuffleChoices;
        this.shuffleChoices = tmp;

        // Option selectMultiple, default false.
        tmp = opts.selectMultiple;
        if ('undefined' === typeof tmp) {
            tmp = false;
        }
        else if ('boolean' !== typeof tmp) {
            tmp = J.isInt(tmp, 1);
            if (!tmp) {
                throw new Error('ChoiceTable.init: selectMultiple must be ' +
                                'undefined or an integer > 1. Found: ' + tmp);
            }
        }
        this.selectMultiple = tmp;
        // Make an array for currentChoice and selected.
        if (tmp) {
            this.selected = [];
            this.currentChoice = [];
        }

        // Option requiredChoice, if any.
        if ('number' === typeof opts.requiredChoice) {
            if (!J.isInt(opts.requiredChoice, 0)) {
                throw new Error('ChoiceTable.init: if number, requiredChoice ' +
                                'must a positive integer. Found: ' +
                                opts.requiredChoice);
            }
            if ('number' === typeof this.selectMultiple &&
                opts.requiredChoice > this.selectMultiple) {

                throw new Error('ChoiceTable.init: requiredChoice cannot be ' +
                                'larger than selectMultiple. Found: ' +
                                opts.requiredChoice + ' > ' +
                                this.selectMultiple);
            }
            this.requiredChoice = opts.requiredChoice;
        }
        else if ('boolean' === typeof opts.requiredChoice) {
            this.requiredChoice = opts.requiredChoice ? 1 : null;
        }
        else if ('undefined' !== typeof opts.requiredChoice) {
            throw new TypeError('ChoiceTable.init: opts.requiredChoice ' +
                                'be number, boolean or undefined. Found: ' +
                                opts.requiredChoice);
        }

        if ('undefined' !== typeof opts.oneTimeClick) {
            this.oneTimeClick = !!opts.oneTimeClick;
        }

        // Set the group, if any.
        if ('string' === typeof opts.group ||
            'number' === typeof opts.group) {

            this.group = opts.group;
        }
        else if ('undefined' !== typeof opts.group) {
            throw new TypeError('ChoiceTable.init: opts.group must ' +
                                'be string, number or undefined. Found: ' +
                                opts.group);
        }

        // Set the groupOrder, if any.
        if ('number' === typeof opts.groupOrder) {
            this.groupOrder = opts.groupOrder;
        }
        else if ('undefined' !== typeof opts.groupOrder) {
            throw new TypeError('ChoiceTable.init: opts.groupOrder must ' +
                                'be number or undefined. Found: ' +
                                opts.groupOrder);
        }

        // Set the main onclick listener, if any.
        if ('function' === typeof opts.listener) {
            this.listener = function(e) {
                opts.listener.call(this, e);
            };
        }
        else if ('undefined' !== typeof opts.listener) {
            throw new TypeError('ChoiceTable.init: opts.listener must ' +
                                'be function or undefined. Found: ' +
                                opts.listener);
        }

        // Set an additional onclick, if any.
        if ('function' === typeof opts.onclick) {
            this.onclick = opts.onclick;
        }
        else if ('undefined' !== typeof opts.onclick) {
            throw new TypeError('ChoiceTable.init: opts.onclick must ' +
                                'be function or undefined. Found: ' +
                                opts.onclick);
        }

        // Set the mainText, if any.
        tmp = opts.mainText
        if ('function' === typeof tmp) {
            tmp = tmp.call(this);
            if ('string' !== typeof tmp) {
                throw new TypeError('ChoiceTable.init: opts.mainText cb ' +
                                    'must return a string. Found: ' +
                                    tmp);
            }
        }
        if ('string' === typeof tmp) {
            this.mainText = tmp;
        }
        else if ('undefined' !== typeof tmp) {
            throw new TypeError('ChoiceTable.init: opts.mainText must ' +
                                'be function, string or undefined. Found: ' +
                                tmp);
        }

        // Set the hint, if any.
        tmp = opts.hint;
        if ('function' === typeof tmp) {
            tmp = tmp.call(this);
            if ('string' !== typeof tmp && false !== tmp) {
                throw new TypeError('ChoiceTable.init: opts.hint cb must ' +
                                    'return string or false. Found: ' +
                                    tmp);
            }
        }
        if ('string' === typeof tmp || false === tmp) {
            this.hint = tmp;
            if (this.requiredChoice && tmp !== false) this.hint += ' *';
        }
        else if ('undefined' !== typeof tmp) {
            throw new TypeError('ChoiceTable.init: opts.hint must ' +
                                'be a string, false, or undefined. Found: ' +
                                tmp);
        }
        else {
            // Returns undefined if there are no constraints.
            this.hint = this.getText('autoHint');
        }

        // Set the timeFrom, if any.
        if (opts.timeFrom === false ||
            'string' === typeof opts.timeFrom) {

            this.timeFrom = opts.timeFrom;
        }
        else if ('undefined' !== typeof opts.timeFrom) {
            throw new TypeError('ChoiceTable.init: opts.timeFrom must ' +
                                'be string, false, or undefined. Found: ' +
                                opts.timeFrom);
        }

        // Set the separator, if any.
        if ('string' === typeof opts.separator) {
            this.separator = opts.separator;
        }
        else if ('undefined' !== typeof opts.separator) {
            throw new TypeError('ChoiceTable.init: opts.separator must ' +
                                'be string, or undefined. Found: ' +
                                opts.separator);
        }

        // Conflict might be generated by id or seperator.
        tmp = this.id + this.separator.substring(0, (this.separator.length -1));
        if (this.id.indexOf(this.separator) !== -1 ||
            tmp.indexOf(this.separator) !== -1) {

            throw new Error('ChoiceTable.init: separator cannot be ' +
                            'included in the id or in the concatenation ' +
                            '(id + separator). Please specify the right ' +
                            'separator option. Found: ' + this.separator);
        }

        // left.
        tmp = opts.left;
        if ('function' === typeof tmp) {
            tmp = tmp.call(this);
            if ('string' !== typeof tmp && 'undefined' !== typeof tmp) {
                throw new TypeError('ChoiceTable.init: opts.left cb must ' +
                                    'return string or undefined. Found: ' +
                                    tmp);
            }
        }
        if ('string' === typeof tmp || 'number' === typeof tmp) {
            this.left = '' + tmp;
        }
        else if (J.isNode(opts.left) ||
                 J.isElement(opts.left)) {

            this.left = opts.left;
        }
        else if ('undefined' !== typeof opts.left) {
            throw new TypeError('ChoiceTable.init: opts.left must be string, ' +
                                'number, function, an HTML Element or ' +
                                'undefined. Found: ' + tmp);
        }

        tmp = opts.right;
        if ('function' === typeof tmp) {
            tmp = tmp.call(this);
            if ('string' !== typeof tmp && 'undefined' !== typeof tmp) {
                throw new TypeError('ChoiceTable.init: opts.right cb must ' +
                                    'return string or undefined. Found: ' +
                                    tmp);
            }
        }
        if ('string' === typeof tmp || 'number' === typeof tmp) {
            this.right = '' + tmp;
        }
        else if (J.isNode(opts.right) || J.isElement(opts.right)) {
            this.right = opts.right;
        }
        else if ('undefined' !== typeof opts.right) {
            throw new TypeError('ChoiceTable.init: opts.right must ' +
                                'be string, number, an HTML Element or ' +
                                'undefined. Found: ' + opts.right);
        }


        // Set the className, if not use default.
        if ('undefined' === typeof opts.className) {
            this.className = ChoiceTable.className;
        }
        else if (opts.className === false) {
            this.className = false;
        }
        else if ('string' === typeof opts.className) {
            this.className =  ChoiceTable.className + ' ' + opts.className;
        }
        else if ( J.isArray(opts.className)) {
            this.className = [ChoiceTable.className].concat(opts.className);
        }
        else {
            throw new TypeError('ChoiceTable.init: opts.' +
                                'className must be string, array, ' +
                                'or undefined. Found: ' + opts.className);
        }

        if (opts.tabbable !== false) this.tabbable = true;

        // Set the renderer, if any.
        if ('function' === typeof opts.renderer) {
            this.renderer = opts.renderer;
        }
        else if ('undefined' !== typeof opts.renderer) {
            throw new TypeError('ChoiceTable.init: opts.renderer must ' +
                                'be function or undefined. Found: ' +
                                opts.renderer);
        }

        // After all configuration opts are evaluated, add choices.

        // Set table.
        if ('object' === typeof opts.table) {
            this.table = opts.table;
        }
        else if ('undefined' !== typeof opts.table &&
                 false !== opts.table) {

            throw new TypeError('ChoiceTable.init: opts.table ' +
                                'must be object, false or undefined. ' +
                                'Found: ' + opts.table);
        }

        this.table = opts.table;

        this.freeText = 'string' === typeof opts.freeText ?
            opts.freeText : !!opts.freeText;


        // Add the correct choices.
        tmp = opts.choicesSetSize;
        if ('function' === typeof tmp) {
            tmp = tmp.call(this);
        }
        if ('undefined' !== typeof tmp) {
            if (!J.isInt(tmp, 0)) {
                throw new Error('ChoiceTable.init: choicesSetSize must be ' +
                                'undefined or an integer > 0. Found: ' + tmp);
            }

            if (this.left || this.right) {
                throw new Error('ChoiceTable.init: choicesSetSize option ' +
                                'cannot be specified when either left or ' +
                                'right options are set.');
            }

            this.choicesSetSize = tmp;
        }

        // Add other.
        if ('undefined' !== typeof opts.other) {
            this.other = opts.other;
        }

        // Add the choices.
        tmp = opts.choices;
        if ('function' === typeof tmp) {
            tmp = tmp.call(this);
            if (!J.isArray(tmp) || !tmp.length) {
                throw new TypeError('ChoiceTable.init: opts.choices cb must ' +
                                    'return a non-empty array. Found: ' + tmp);
            }
        }
        if ('undefined' !== typeof tmp) {
            this.setChoices(tmp);
        }

        // Add the correct choices.
        tmp = opts.correctChoice;
        if ('undefined' !== typeof tmp) {
            if (this.requiredChoice) {
                throw new Error('ChoiceTable.init: cannot specify both ' +
                                'opts requiredChoice and correctChoice');
            }
            if ('function' === typeof tmp) {
                tmp = tmp.call(this);
                // No checks.
            }
            this.setCorrectChoice(opts.correctChoice);
        }


        // Add the correct choices.
        tmp = opts.disabledChoices;
        if ('undefined' !== typeof tmp) {
            if ('function' === typeof tmp) {
                tmp = tmp.call(this);
            }
            if (!J.isArray(opts.disabledChoices)) {
                throw new TypeError('ChoiceTable.init: disabledChoices ' +
                                    'must be undefined or array. Found: ' +
                                    tmp);
            }

            // TODO: check if values of disabled choices are correct?
            // Do we have the choices now, or can they be added later?
            if (tmp) {
                (function() {
                    for (var i = 0; i < tmp.length; i++) {
                        that.disableChoice(tmp[i]);
                    }
                })();
            }
        }

        if ('undefined' !== typeof opts.sameWidthCells) {
            this.sameWidthCells = !!opts.sameWidthCells;
        }

        if ('undefined' !== typeof opts.doneOnClick) {
            this.doneOnClick = !!opts.doneOnClick;
        }

        tmp = opts.solution;
        if ('undefined' !== typeof tmp) {
            if ('string' !== typeof tmp && 'function' !== typeof tmp) {
                throw new TypeError('ChoiceTable.init: solution must be ' +
                                    'string or undefined. Found: ' + tmp);
            }
            this.solution = tmp;
        }
    };

    /**
     * ### ChoiceTable.disableChoice
     *
     * Marks a choice as disabled (will not be clickable)
     *
     * @param {string|number} value The value of the choice to disable`
     */
    ChoiceTable.prototype.disableChoice = function(value) {
        this.disabledChoices[value] = true;
    };

    /**
     * ### ChoiceTable.enableChoice
     *
     * Enables a choice (will be clickable again if previously disabled)
     *
     * @param {string|number} value The value of the choice to disable`
     */
    ChoiceTable.prototype.enableChoice = function(value) {
        this.disabledChoices[value] = null;
    };

    /**
     * ### ChoiceTable.setChoices
     *
     * Sets the available choices and optionally builds the table
     *
     * If a table is defined, it will automatically append the choices
     * as TD cells. Otherwise, the choices will be built but not appended.
     *
     * @param {array} choices The array of choices
     *
     * @see ChoiceTable.table
     * @see ChoiceTable.shuffleChoices
     * @see ChoiceTable.order
     * @see ChoiceTable.buildChoices
     * @see ChoiceTable.buildTableAndChoices
     */
    ChoiceTable.prototype.setChoices = function(choices) {
        var len, idxOther;
        if (!J.isArray(choices)) {
            throw new TypeError('ChoiceTable.setChoices: choices ' +
                                'must be array');
        }
        if (!choices.length) {
            throw new Error('ChoiceTable.setChoices: choices array is empty');
        }
        // Check and drop previous "other" choices.
        idxOther = choices.indexOf(this.getText('other'));
        if (this.other && idxOther >= 0) choices.splice(idxOther, 1);
        this.choices = choices;
        len = choices.length;

        // Save the order in which the choices will be added.
        this.order = J.seq(0, len-1);
        if (this.shuffleChoices) this.order = J.shuffle(this.order);

        if (this.other) {
            this.choices[len] = this.getText('other');
            this.order[len] = len
        }

        // Build the table and choices at once (faster).
        if (this.table) this.buildTableAndChoices();
        // Or just build choices.
        else this.buildChoices();
    };

    /**
     * ### ChoiceTable.buildChoices
     *
     * Render every choice and stores cell in `choicesCells` array
     *
     * Left and right cells are also rendered, if specified.
     *
     * Follows a shuffled order, if set
     *
     * @see ChoiceTable.order
     * @see ChoiceTable.renderChoice
     * @see ChoiceTable.renderSpecial
     */
    ChoiceTable.prototype.buildChoices = function() {
        var i, len;
        i = -1, len = this.choices.length;
        // Pre-allocate the choicesCells array.
        this.choicesCells = new Array(len);
        for ( ; ++i < len ; ) {
            this.renderChoice(this.choices[this.order[i]], i);
        }
        if (this.left) this.renderSpecial('left', this.left);
        if (this.right) this.renderSpecial('right', this.right);
    };

    /**
     * ### ChoiceTable.buildTable
     *
     * Builds the table of clickable choices and enables it
     *
     * Must be called after choices have been set already.
     *
     * @see ChoiceTable.setChoices
     * @see ChoiceTable.order
     * @see ChoiceTable.renderChoice
     * @see ChoiceTable.orientation
     * @see ChoiceTable.choicesSetSize
     */
    ChoiceTable.prototype.buildTable = (function() {

        function makeSet(i, len, H, doSets) {
            var tr, counter;
            counter = 0;
            // Start adding tr/s and tds based on the orientation.
            if (H) {
                tr = createTR(this, 'main');
                // Add horizontal choices title.
                if (this.leftCell) tr.appendChild(this.leftCell);
            }
            // Main loop.
            for ( ; ++i < len ; ) {
                if (!H) {
                    tr = createTR(this, 'left');
                    // Add vertical choices title.
                    if (i === 0 && this.leftCell) {
                        tr.appendChild(this.leftCell);
                        tr = createTR(this, i);
                    }
                }
                // Clickable cell.
                tr.appendChild(this.choicesCells[i]);
                // Stop if we reached set size (still need to add the right).
                if (doSets && ++counter >= this.choicesSetSize) break;
            }
            if (this.rightCell) {
                if (!H) tr = createTR(this, 'right');
                tr.appendChild(this.rightCell);
            }

            // Start a new set, if necessary.
            if (i !== len) makeSet.call(this, i, len, H, doSets);
        }

        return function() {
            var len, H, doSets;

            if (!this.choicesCells) {
                throw new Error('ChoiceTable.buildTable: choices not set, ' +
                                'cannot build table. Id: ' + this.id);
            }

            H = this.orientation === 'H';
            len = this.choicesCells.length;
            doSets = 'number' === typeof this.choicesSetSize;

            // Recursively makes sets
            makeSet.call(this, -1, len, H, doSets);

            // Enable onclick listener.
            this.enable();
        };
    })();

    /**
     * ### ChoiceTable.buildTableAndChoices
     *
     * Builds the table of clickable choices
     *
     * @see ChoiceTable.choices
     * @see ChoiceTable.order
     * @see ChoiceTable.renderChoice
     * @see ChoiceTable.orientation
     */
    ChoiceTable.prototype.buildTableAndChoices = function() {
        var i, len, tr, td, H;

        len = this.choices.length;
        // Pre-allocate the choicesCells array.
        this.choicesCells = new Array(len);

        // Start adding tr/s and tds based on the orientation.
        i = -1, H = this.orientation === 'H';

        if (H) {
            tr = createTR(this, 'main');
            // Add horizontal choices left.
            if (this.left) {
                td = this.renderSpecial('left', this.left);
                tr.appendChild(td);
            }
        }
        // Main loop.
        for ( ; ++i < len ; ) {
            if (!H) {
                tr = createTR(this, 'left');
                // Add vertical choices left.
                if (i === 0 && this.left) {
                    td = this.renderSpecial('left', this.left);
                    tr.appendChild(td);
                    tr = createTR(this, i);
                }
            }
            // Clickable cell.
            td = this.renderChoice(this.choices[this.order[i]], i);
            tr.appendChild(td);
        }
        if (this.right) {
            if (!H) tr = createTR(this, 'right');
            td = this.renderSpecial('right', this.right);
            tr.appendChild(td);
        }

        // Enable onclick listener.
        this.enable();
    };

    /**
     * ### ChoiceTable.renderSpecial
     *
     * Renders a non-choice element into a cell of the table (e.g. left/right)
     *
     * @param {string} type The type of special cell ('left' or 'right').
     * @param {mixed} special The special element. It must be string or number,
     *   or array where the first element is the 'value' (incorporated in the
     *   `id` field) and the second the text to display as choice.
     *
     * @return {HTMLElement} td The newly created cell of the table
     *
     * @see ChoiceTable.left
     * @see ChoiceTable.right
     */
    ChoiceTable.prototype.renderSpecial = function(type, special) {
        var td, className;
        td = document.createElement('td');
        if ('string' === typeof special) td.innerHTML = special;
        // HTML element (checked before).
        else td.appendChild(special);
        if (type === 'left') {
            className = this.className ? this.className + '-left' : 'left';
            this.leftCell = td;
        }
        else if (type === 'right') {
            className = this.className ? this.className + '-right' : 'right';
            this.rightCell = td;
        }
        else {
            throw new Error('ChoiceTable.renderSpecial: unknown type: ' + type);
        }
        td.className = className;
        td.id = this.id + this.separator + 'special-cell-' + type;
        return td;
    };
    /* UPDATED TEXT
     * @param {mixed} choice The choice element. It must be string or
     *   number, HTML element, or an array. If array, the first
     *   element is the short value (string or number), and the second
     *   one the the full value (string, number or HTML element) to
     *   display. If a renderer function is defined there are no
     *   restriction on the format of choice
     * @param {number} idx The position of the choice within the choice array
     */

    /**
     * ### ChoiceTable.renderChoice
     *
     * Transforms a choice element into a cell of the table
     *
     * A reference to the cell is saved in `choicesCells`.
     *
     * @param {mixed} choice The choice element. It may be string, number,
     *   array where the first element is the 'value' and the second the
     *   text to display as choice, or an object with properties value and
     *   display. If a renderer function is defined there are no restriction
     *   on the format of choice.
     * @param {number} idx The position of the choice within the choice array
     *
     * @return {HTMLElement} td The newly created cell of the table
     *
     * @see ChoiceTable.renderer
     * @see ChoiceTable.separator
     * @see ChoiceTable.choicesCells
     */
    ChoiceTable.prototype.renderChoice = function(choice, idx) {
        var td, shortValue, value, width;
        td = document.createElement('td');
        if (this.tabbable) J.makeTabbable(td);

        // Forces equal width.
        if (this.sameWidthCells && this.orientation === 'H') {
            width = this.left ? 70 : 100;
            if (this.right) width = width - 30;
            width = width / (this.choicesSetSize || this.choices.length);
            td.style.width = width.toFixed(2) + '%';
        }

        // Use custom renderer.
        if (this.renderer) {
            value = this.renderer(td, choice, idx);
            if ('undefined' === typeof value) value = idx;
        }
        // Or use standard format.
        else {
            if (J.isArray(choice)) {
                shortValue = choice[0];
                choice = choice[1];
            }
            else if ('object' === typeof choice) {
                shortValue = choice.value;
                choice = choice.display;
            }

            value = this.shuffleChoices ? this.order[idx] : idx;

            if ('string' === typeof choice || 'number' === typeof choice) {
                td.innerHTML = choice;
            }
            else if (J.isElement(choice) || J.isNode(choice)) {
                td.appendChild(choice);
            }
            else if (node.widgets.isWidget(choice)) {
                node.widgets.append(choice, td);
            }
            else {
                throw new Error('ChoiceTable.renderChoice: invalid choice: ' +
                                choice);
            }
        }

        // Map a value to the index.
        if ('undefined' !== typeof this.choicesValues[value]) {
            throw new Error('ChoiceTable.renderChoice: value already ' +
                            'in use: ' + value);
        }

        // Add the id if not added already by the renderer function.
        if (!td.id || td.id === '') {
            td.id = this.id + this.separator + value;
        }

        // All fine, updates global variables.
        this.choicesValues[value] = idx;
        this.choicesCells[idx] = td;
        this.choicesIds[td.id] = td;

        return td;
    };

    /**
     * ### ChoiceTable.setCorrectChoice
     *
     * Set the correct choice/s
     *
     * Correct choice/s are always stored as 'strings', or not number
     * because then they are compared against the valued saved in
     * the `id` field of the cell
     *
     * @param {number|string|array} If `selectMultiple` is set, param must
     *   be an array, otherwise a string or a number. Each correct choice
     *   must have been already defined as choice (value)
     *
     * @see ChoiceTable.setChoices
     * @see checkCorrectChoiceParam
     */
    ChoiceTable.prototype.setCorrectChoice = function(choice) {
        var i, len;
        if (!this.selectMultiple) {
            choice = checkCorrectChoiceParam(this, choice);
        }
        else {
            if (J.isArray(choice) && choice.length) {
                i = -1, len = choice.length;
                for ( ; ++i < len ; ) {
                    choice[i] = checkCorrectChoiceParam(this, choice[i]);
                }
            }
            else {
                throw new TypeError('ChoiceTable.setCorrectChoice: choice ' +
                                    'must be non-empty array. Found: ' +
                                    choice);
            }
        }
        this.correctChoice = choice;
    };

    /**
     * ### ChoiceTable.append
     *
     * Implements Widget.append
     *
     * Checks that id is unique.
     *
     * Appends (all optional):
     *
     *   - mainText: a question or statement introducing the choices
     *   - table: the table containing the choices
     *   - freeText: a textarea for comments
     *
     * @see Widget.append
     */
    ChoiceTable.prototype.append = function() {
        var tmp;
        // Id must be unique.
        if (W.getElementById(this.id)) {
            throw new Error('ChoiceTable.append: id is not ' +
                            'unique: ' + this.id);
        }

        // MainText.
        if (this.mainText) {
            this.spanMainText = W.append('span', this.bodyDiv, {
                className: 'choicetable-maintext',
                innerHTML: this.mainText
            });
        }
        // Hint.
        if (this.hint) {
            W.append('span', this.spanMainText || this.bodyDiv, {
                className: 'choicetable-hint',
                innerHTML: this.hint
            });
        }

        // Create/set table.
        if (this.table !== false) {
            // Create table, if it was not passed as object before.
            if ('undefined' === typeof this.table) {
                this.table = document.createElement('table');
                this.buildTable();
            }
            // Set table id.
            this.table.id = this.id;
            // Class.
            tmp = this.className ? [ this.className ] : [];
            if (this.orientation !== 'H') tmp.push('choicetable-vertical');
            if (tmp.length) J.addClass(this.table, tmp);
            else this.table.className = '';
            // Append table.
            this.bodyDiv.appendChild(this.table);
        }

        this.errorBox = W.append('div', this.bodyDiv, { className: 'errbox' });

        this.setCustomInput(this.other, this.bodyDiv);

        if (this.solution) {
            this.solutionDiv = W.append('div', this.bodyDiv);
        }

        // Creates a free-text textarea, possibly with placeholder text.
        if (this.freeText) {
            this.textarea = document.createElement('textarea');
            if (this.id) this.textarea.id = this.id + '_text';
            if ('string' === typeof this.freeText) {
                this.textarea.placeholder = this.freeText;
            }
            tmp = this.className ? this.className + '-freetext' : 'freetext';
            this.textarea.className = tmp;
            // Append textarea.
            this.bodyDiv.appendChild(this.textarea);
        }
    };

    /**
     * ### ChoiceTable.setCustomInput
     *
     * Set Custom Input widget.
     *
     */
    ChoiceTable.prototype.setCustomInput = function(other, root) {
        var opts;
        if (other === null || 'boolean' === typeof other) return;
        opts = {
            id: 'other' + this.id,
            mainText: this.getText('customInput'),
            requiredChoice: this.requiredChoice
        }
        // other is the string 'CustomInput' or a conf object.
        if ('object' === typeof other) J.mixin(opts, other);
        // Force initially hidden.
        opts.hidden = true;
        this.customInput = node.widgets.append('CustomInput', root, opts);

    };

    /**
     * ### ChoiceTable.setError
     *
     * Set the error msg inside the errorBox and call highlight
     *
     * @param {string} The error msg (can contain HTML)
     *
     * @see ChoiceTable.highlight
     * @see ChoiceTable.errorBox
     */
    ChoiceTable.prototype.setError = function(err) {
        // TODO: the errorBox is added only if .append() is called.
        // However, ChoiceTableGroup use the table without calling .append().
        if (this.errorBox) this.errorBox.innerHTML = err || '';
        if (err) this.highlight();
        else this.unhighlight();
    };

    /**
     * ### ChoiceTable.listeners
     *
     * Implements Widget.listeners
     *
     * Adds two listeners two disable/enable the widget on events:
     * INPUT_DISABLE, INPUT_ENABLE
     *
     * @see Widget.listeners
     */
    ChoiceTable.prototype.listeners = function() {
        var that = this;
        node.on('INPUT_DISABLE', function() {
            that.disable();
        });
        node.on('INPUT_ENABLE', function() {
            that.enable();
        });
    };

    /**
     * ### ChoiceTable.disable
     *
     * Disables clicking on the table and removes CSS 'clicklable' class
     */
    ChoiceTable.prototype.disable = function() {
        if (this.disabled === true) return;
        this.disabled = true;
        if (this.table) {
            J.removeClass(this.table, 'clickable');
            this.table.removeEventListener('click', this.listener);
            // Remove listener to make cells clickable with the keyboard.
            if (this.tabbable) J.makeClickable(this.table, false);
        }
        if (this.customInput) this.customInput.disable();
        this.emit('disabled');
    };

    /**
     * ### ChoiceTable.enable
     *
     * Enables clicking on the table and adds CSS 'clicklable' class
     *
     * @return {function} cb The event listener function
     */
    ChoiceTable.prototype.enable = function() {
        if (this.disabled === false) return;
        if (!this.table) {
            throw new Error('ChoiceTable.enable: table not defined');
        }
        this.disabled = false;
        J.addClass(this.table, 'clickable');
        this.table.addEventListener('click', this.listener);
        // Add listener to make cells clickable with the keyboard.
        if (this.tabbable) J.makeClickable(this.table);
        if (this.customInput) this.customInput.enable();
        this.emit('enabled');
    };

    /**
     * ### ChoiceTable.verifyChoice
     *
     * Compares the current choice/s with the correct one/s
     *
     * Depending on current settings, there are two modes of verifying
     * choices:
     *
     *    - requiredChoice: there must be at least N choices selected
     *    - correctChoice:  the choices are compared against correct ones.
     *
     * @param {boolean} markAttempt Optional. If TRUE, the value of
     *   current choice is added to the attempts array. Default: TRUE
     *
     * @return {boolean|null} TRUE if current choice is correct,
     *   FALSE if it is not correct, or NULL if no correct choice
     *   was set
     *
     * @see ChoiceTable.attempts
     * @see ChoiceTable.setCorrectChoice
     */
     ChoiceTable.prototype.verifyChoice = function(markAttempt) {
        var i, len, j, lenJ, c, clone, found;
        var correctChoice, ci, ciCorrect;

        // Mark attempt by default.
        markAttempt = 'undefined' === typeof markAttempt ? true : markAttempt;
        if (markAttempt) this.attempts.push(this.currentChoice);

         // Custom input to check.
         ci = this.customInput && !this.customInput.isHidden();
         if (ci) {
             ciCorrect = this.customInput.getValues({
                 markAttempt: markAttempt
             }).isCorrect;
             if (ciCorrect === false) return false;
             // Set it to null so it is returned correctly, later below.
             if ('undefined' === typeof ciCorrect) ciCorrect = null;
         }

        // Check the number of choices.
        if (this.requiredChoice !== null) {
            if (!this.selectMultiple) return this.currentChoice !== null;
            else return this.currentChoice.length >= this.requiredChoice;
        }

        correctChoice = this.correctChoice;
        // If no correct choice is set return null or ciCorrect (true|null).
        if (null === correctChoice) return ci ? ciCorrect : null;

        // Only one choice allowed, ci is correct,
        // otherwise we would have returned already.
        if (!this.selectMultiple) return this.currentChoice === correctChoice;

        // Multiple selections allowed.

        // Make it an array (can be a string).
        if (!J.isArray(correctChoice)) correctChoice = [correctChoice];

        len = correctChoice.length;
        lenJ = this.currentChoice.length;
        // Quick check.
        if (len !== lenJ) return false;
        // Check every item.
        i = -1;
        clone = this.currentChoice.slice(0);
        for ( ; ++i < len ; ) {
            found = false;
            c = correctChoice[i];
            j = -1;
            for ( ; ++j < lenJ ; ) {
                if (clone[j] === c) {
                    found = true;
                    break;
                }
            }
            if (!found) return false;
        }
        return true;

    };

    /**
     * ### ChoiceTable.setCurrentChoice
     *
     * Marks a choice as current
     *
     * If `ChoiceTable.selectMultiple` is set multiple choices can be current.
     *
     * @param {number|string} The choice to mark as current
     *
     * @see ChoiceTable.currentChoice
     * @see ChoiceTable.selectMultiple
     */
    ChoiceTable.prototype.setCurrentChoice = function(choice) {
        if (!this.selectMultiple) this.currentChoice = choice;
        else this.currentChoice.push(choice);
    };

    /**
     * ### ChoiceTable.unsetCurrentChoice
     *
     * Deletes the value of currentChoice
     *
     * If `ChoiceTable.selectMultiple` is activated, then it is
     * possible to select the choice to unset.
     *
     * @param {number|string} Optional. The choice to delete from
     *   currentChoice when multiple selections are allowed
     *
     * @see ChoiceTable.currentChoice
     * @see ChoiceTable.selectMultiple
     */
    ChoiceTable.prototype.unsetCurrentChoice = function(choice) {
        var i, len;
        if (!this.selectMultiple || 'undefined' === typeof choice) {
            this.currentChoice = null;
        }
        else {
            if ('string' !== typeof choice && 'number' !== typeof choice) {
                throw new TypeError('ChoiceTable.unsetCurrentChoice: choice ' +
                                    'must be string, number or ' +
                                    'undefined. Found: ' + choice);
            }
            i = -1, len = this.currentChoice.length;
            for ( ; ++i < len ; ) {
                if (this.currentChoice[i] === choice) {
                    this.currentChoice.splice(i,1);
                    break;
                }
            }
        }
    };

    /**
     * ### ChoiceTable.isChoiceCurrent
     *
     * Returns TRUE if a choice is currently selected
     *
     * @param {number|string} The choice to check.
     *
     * @return {boolean} TRUE, if the choice is currently selected
     *
     * @see ChoiceTable.getChoiceAtPosition
     */
    ChoiceTable.prototype.isChoiceCurrent = function(choice) {
        var i, len;
        if ('string' === typeof choice) {
            choice = parseInt(choice, 10);
        }
        else if ('number' !== typeof choice) {
            throw new TypeError('ChoiceTable.isChoiceCurrent: choice ' +
                                'must be string or number. Found: ' + choice);
        }
        if (!this.selectMultiple) return this.currentChoice === choice;
        i = -1, len = this.currentChoice.length;
        for ( ; ++i < len ; ) {
            if (this.currentChoice[i] === choice) return true;
        }
        return false;
    };

    /**
     * ### ChoiceTable.getChoiceAtPosition
     *
     * Returns a choice displayed at a given position
     *
     * @param {string|number} i The numeric position of a choice in display
     *
     * @return {string|undefined} The value associated with the numeric
     *   position. If no value is found, returns undefined
     *
     * @see ChoiceTable.order
     * @see ChoiceTable.choices
     */
    ChoiceTable.prototype.getChoiceAtPosition = function(i) {
        if (!this.choices || !this.order) return;
        return this.choices[this.order[parseInt(i, 10)]];
    };

    /**
     * ### ChoiceTable.highlight
     *
     * Highlights the choice table
     *
     * @param {string|obj} opts Optional. If string is the 'border'
     *   option for backward compatibilityThe style for the table's border.
     *   Default '3px solid red'
     *
     * @see ChoiceTable.highlighted
     */
    ChoiceTable.prototype.highlight = function(opts) {
        var border, ci;
        opts = opts || {};
        // Backward compatible.
        if ('string' === typeof opts) opts = { border: opts };
        border = opts.border;
        if (border && 'string' !== typeof border) {
            throw new TypeError('ChoiceTable.highlight: border must be ' +
                                'string or undefined. Found: ' + border);
        }
        if (!this.table || this.highlighted) return;
        this.table.style.border = border || '3px solid red';
        ci = this.customInput;
        if (opts.customInput !== false && ci && !ci.isHidden()) ci.highlight();
        this.highlighted = true;
        this.emit('highlighted', border);
    };

    /**
     * ### ChoiceTable.unhighlight
     *
     * Removes highlight from the choice table
     *
     * @see ChoiceTable.highlighted
     */
    ChoiceTable.prototype.unhighlight = function(opts) {
        var ci;
        opts = opts || {};
        if (!this.table || this.highlighted !== true) return;
        this.table.style.border = '';
        ci = this.customInput;
        if (opts.customInput !== false && ci && !ci.isHidden()) {
            ci.unhighlight();
        }
        this.highlighted = false;
        this.setError();
        this.emit('unhighlighted');
    };

    /**
     * ### ChoiceTable.getValues
     *
     * Returns the values for current selection and other paradata
     *
     * Paradata that is not set or recorded will be omitted
     *
     * @param {object} opts Optional. Configures the return value.
     *   Available optionts:
     *
     *   - markAttempt: If TRUE, getting the value counts as an attempt
     *       to find the correct answer. Default: TRUE.
     *   - highlight: If TRUE, if current value is not the correct
     *       value, widget is highlighted. Default: TRUE.
     *   - reset: If TRUTHY and a correct choice is selected (or not
     *       specified), then it resets the state of the widgets before
     *       returning it. Default: FALSE.
     *   - addValue: If FALSE, it does not add .value property. Default: TRUE.
     *   - sortValue: If TRUE and multiple choices are allowed, the values
     *       in the `.value` property are sorted alphabetically. Note! The
     *       choices array is not sorted. Default: TRUE.
     *
     * @return {object} Object containing the choice and paradata
     *
     * @see ChoiceTable.verifyChoice
     * @see ChoiceTable.reset
     */
    ChoiceTable.prototype.getValues = function(opts) {
        var obj, resetOpts, i, len, ci, ciCorrect;
        var that;

        that = this;
        opts = opts || {};
        obj = {
            id: this.id,
            choice: opts.reset ?
                this.currentChoice: J.clone(this.currentChoice),
            time: this.timeCurrentChoice,
            nClicks: this.numberOfClicks
        };
        if ('undefined' === typeof opts.highlight) opts.highlight = true;
        if (opts.processChoice) {
            obj.choice = opts.processChoice.call(this, obj.choice);
        }
        if (this.shuffleChoices) obj.order = this.order;

        // Option getValue backward compatible.
        if (opts.addValue !== false && opts.getValue !== false) {
            if (!this.selectMultiple) {
                obj.value = getValueFromChoice(that,this.choices[obj.choice]);
            }
            else {
                len = obj.choice.length;
                obj.value = new Array(len);
                if (len === 1) {
                    obj.value[0] =
                        getValueFromChoice(that,this.choices[obj.choice[0]]);
                }
                else {
                    i = -1;
                    for ( ; ++i < len ; ) {
                        obj.value[i] =
                            getValueFromChoice(that,
                                               this.choices[obj.choice[i]]);
                    }
                    if (opts.sortValue !== false) obj.value.sort();
                }
            }
        }

        if (this.group === 0 || this.group) {
            obj.group = this.group;
        }
        if (this.groupOrder === 0 || this.groupOrder) {
            obj.groupOrder = this.groupOrder;
        }

        ci = this.customInput;
        if (this.required !== false &&
            (null !== this.correctChoice || null !== this.requiredChoice ||
            (ci && !ci.isHidden()))) {

            obj.isCorrect = this.verifyChoice(opts.markAttempt);
            obj.attempts = this.attempts;
            if (!obj.isCorrect && opts.highlight) this.highlight({
                // If errored, it is already highlighted
                customInput: false
            });
        }

        if (this.textarea) obj.freetext = this.textarea.value;

        if (obj.isCorrect === false) {
            // If there is an error on CI, we just highlight CI.
            // However, there could be an error also on the choice table,
            // e.g., not enough options selected. It will be catched
            // at next click.
            // TODO: change verifyChoice to say where the error is coming from.
            if (ci) {
                ciCorrect = ci.getValues({
                    markAttempt: false
                }).isCorrect;
            }
            if (ci && !ciCorrect && !ci.isHidden()) {
                this.unhighlight({ customInput: false });
            }
            else {
                this.setError(this.getText('error', obj.value));
            }
        }
        else if (opts.reset) {
             resetOpts = 'object' !== typeof opts.reset ? {} : opts.reset;
             this.reset(resetOpts);
        }
        return obj;
    };

    /**
     * ### ChoiceTable.setValues
     *
     * Sets values in the choice table as specified by the options
     *
     * @param {object} options Optional. Options specifying how to set
     *   the values. If no parameter is specified, random values will
     *   be set.
     *
     * @experimental
     */
    ChoiceTable.prototype.setValues = function(options) {
        var choice, correctChoice, tmp;
        var i, len, j, lenJ;

        if (!this.choices || !this.choices.length) {
            throw new Error('ChoiceTable.setValues: no choices found.');
        }
        options = options || {};

        // TODO: allow it to set it visually or just in the background.
        // Use options.visual.

        // TODO: allow it to set random or fixed values, or correct values
        // TODO: set freetext or not.

        if (!this.choicesCells || !this.choicesCells.length) {
            throw new Error('Choicetable.setValues: table was not ' +
                            'built yet.');
        }

        // Value this.correctChoice can be undefined, string or array.
        // If no correct choice is set, we simply ignore the correct param.
        if (options.correct && this.correctChoice !== null) {

            // Make it an array (can be a string).
            correctChoice = J.isArray(this.correctChoice) ?
                this.correctChoice : [this.correctChoice];

            i = -1, len = correctChoice.length;
            for ( ; ++i < len ; ) {
                choice = parseInt(correctChoice[i], 10);
                if (this.shuffleChoices) {
                    j = -1, lenJ = this.order.length;
                    for ( ; ++j < lenJ ; ) {
                        if (this.order[j] === choice) {
                            choice = j;
                            break;
                        }
                    }
                }

                this.choicesCells[choice].click();
            }
            return;
        }

        // Set values, random or pre-set.
        i = -1;
        if ('undefined' !== typeof options.values) {
            if (!J.isArray(options.values)) tmp = [ options.values ];
            len = tmp.length;
            // Can be true/false or a number > 1.
            if (this.selectMultiple) {
                tmp = 'number' === typeof this.selectMultiple ?
                    this.selectMultiple : this.choices.length;
                if (len > tmp) {
                    throw new Error('ChoiceTable.setValues: values array ' +
                                    'cannot be larger than max allowed set: ' +
                                    len +  ' > ' +  tmp);
                }
                tmp = options.values;
            }

            // Validate value.
            for ( ; ++i < len ; ) {
                choice = J.isInt(tmp[i], -1, (this.choices.length-1), 1, 1);
                if (false === choice) {
                    throw new Error('ChoiceTable.setValues: invalid ' +
                                    'choice value. Found: ' + tmp[i]);
                }
                this.choicesCells[choice].click();
            }
        }
        else {
            // How many random choices?
            len = 1;
            if (this.selectMultiple) {
                // Max random cells.
                len = 'number' === typeof this.selectMultiple ?
                    this.selectMultiple : this.choicesCells.length;
                // Min random cells.
                tmp = this.requiredChoice;
                len = J.randomInt('number' === typeof tmp ? (tmp-1) : 0, len);
            }

            for ( ; ++i < len ; ) {
                // This is the choice idx.
                choice = J.randomInt(-1, (this.choicesCells.length-1));

                // Do not click it again if it is already selected.
                // Else increment len and try again (until 300 failsafe).
                if (this.disabledChoices[choice] ||
                    this.isChoiceCurrent(choice)) {
                    // Failsafe.
                    if (len < 300) len++;
                }
                else {
                    // Resolve to cell idx (might differ if shuffled).
                    j =  this.choicesValues[choice];
                    this.choicesCells[j].click();
                }
            }
        }

        // Make a random comment.
        if (this.textarea) this.textarea.value = J.randomString(100, '!Aa0');
        if (this.custominput && !this.custominput.isHidden()) {
            this.custominput.setValues();
        }
    };

    /**
     * ### ChoiceTable.reset
     *
     * Resets current selection and collected paradata
     *
     * @param {object} options Optional. Available options:
     *    - shuffleChoices: If TRUE, choices are shuffled. Default: FALSE
     */
    ChoiceTable.prototype.reset = function(options) {
        var i, len;

        options = options || {};

        this.attempts = [];
        this.numberOfClicks = 0;
        this.timeCurrentChoice = null;

        if (this.selectMultiple) {
            i = -1, len = this.selected.length;
            for ( ; ++i < len ; ) {
                J.removeClass(this.selected[i], 'selected');
            }
            this.selected = [];
            this.currentChoice = [];

        }
        else {
            if (this.selected) {
                J.removeClass(this.selected, 'selected');
                this.selected = null;
                this.currentChoice = null;
            }
        }

        if (this.textarea) this.textarea.value = '';
        if (this.isHighlighted()) this.unhighlight();

        if (options.shuffleChoices) this.shuffle();
        if (this.customInput) this.customInput.reset();
    };

    /**
     * ### ChoiceTable.shuffle
     *
     * Shuffles the order of the choices
     */
    ChoiceTable.prototype.shuffle = function() {
        var order, H;
        var i, len, cell, choice;
        var choicesValues, choicesCells;
        var parentTR;

        H = this.orientation === 'H';
        len = this.order.length;
        if (this.other) {
            order = J.shuffle(this.order.slice(0,-1));
            order.push(this.order[len - 1]);
        }
        else {
            order = J.shuffle(this.order);
        }
        i = -1;
        choicesValues = {};
        choicesCells = new Array(len);

        for ( ; ++i < len ; ) {
            choice = order[i];
            cell = this.choicesCells[this.choicesValues[choice]];
            choicesCells[i] = cell;
            choicesValues[choice] = i;
            if (H) {
                this.trs[0].appendChild(cell);
            }
            else {
                parentTR = cell.parentElement || cell.parentNode;
                this.table.appendChild(parentTR);
            }
        }
        if (this.rightCell) {
            if (H) {
                this.trs[0].appendChild(this.rightCell);
            }
            else {
                parentTR = this.rightCell.parentElement ||
                    this.rightCell.parentNode;
                this.table.appendChild(parentTR);
            }
        }

        this.order = order;
        this.choicesCells = choicesCells;
        this.choicesValues = choicesValues;
    };

    /**
     * ### ChoiceManager.setValues
     *
     * Sets values for forms in manager as specified by the options
     *
     * @param {object} options Optional. Options specifying how to set
     *   the values. If no parameter is specified, random values will
     *   be set.
     */
    ChoiceTable.prototype.next = function() {
        var sol;
        sol = this.solution;
        // No solution or solution already displayed.
        if (!sol || this.solutionDisplayed) return false;
        // Solution, but no answer provided.
        if (sol) {
            if (!this.isChoiceDone() && !this.solutionNoChoice) return false;
            this.solutionDisplayed = true;
            if ('function' === typeof sol) {
                sol = this.solution(this.verifyChoice(false), this);
            }
            this.solutionDiv.innerHTML = sol;
        }
        this.disable();
        W.adjustFrameHeight();
        node.emit('WIDGET_NEXT', this);
        return true;
    };

    ChoiceTable.prototype.prev = function() {
        return false;
        if (!this.solutionDisplayed) return false;
        this.solutionDisplayed = false;
        this.solutionDiv.innerHTML = '';
        this.enable();
        W.adjustFrameHeight();
        node.emit('WIDGET_PREV', this);
        return true;
    };

    ChoiceTable.prototype.isChoiceDone = function(complete) {
        var cho, mul, len, ci;
        ci = this.customInput;
        cho = this.currentChoice;
        mul = this.selectMultiple;
        // Selected "Other, Specify"
        if (ci && this.isChoiceCurrent(this.choices.length-1)) return false;
        // Single choice.
        if ((!complete || !mul) && null !== cho) return true;
        // Multiple choices.
        if (J.isArray(cho)) len = cho.length;
        if (mul === true && len === this.choices.length) return true;
        if ('number' === typeof mul && len === mul) return true;
        // Not done.
        return false;
    };



    // ## Helper methods.

    /**
     * ### checkCorrectChoiceParam
     *
     * Checks the input parameters of method ChoiceTable.setCorrectChoice
     *
     * The function transforms numbers into string, because then the checking
     * is done with strings (they are serialized in the id property of tds).
     *
     * If `ChoiceTable.selectMultiple` is set, the function checks each
     * value of the array separately.
     *
     * @param {ChoiceTable} that This instance
     * @param {string|number} An already existing value of a choice
     *
     * @return {string} The checked choice
     */
    function checkCorrectChoiceParam(that, choice) {
        if ('string' === typeof choice) choice = parseInt(choice, 10);
        if ('number' !== typeof choice) {
            throw new TypeError('ChoiceTable.setCorrectChoice: each choice ' +
                                'must be number or string. Found: ' + choice);
        }
        if ('undefined' === typeof that.choicesValues[choice]) {

            throw new TypeError('ChoiceTable.setCorrectChoice: choice ' +
                                'not found: ' + choice);
        }
        return choice;
    }

    /**
     * ### createTR
     *
     * Creates and append a new TR element
     *
     * Adds the the `id` attribute formatted as:
     *   'tr' + separator + widget_id
     *
     * @param {ChoiceTable} that This instance
     *
     * @return {HTMLElement} Thew newly created TR element
     *
     * @see ChoiceTable.tr
     */
    function createTR(that) {
        var tr;
        tr = document.createElement('tr');
        tr.id = 'tr' + that.separator + that.id;
        that.table.appendChild(tr);
        // Store reference.
        that.trs.push(tr);
        return tr;
    }

    /**
     * ### getValueFromChoice
     *
     * Extract the value from a choice
     *
     * The value is either the text displayed or short value specified
     * by the choice.
     *
     * @param {mixed} choice
     * @param {boolean} display TRUE to return the display value instead
     *   one. Default: FALSE.
     *
     * @return {string|number|null} The value of the choice,
     *   or null if not found.
     *
     * @see ChoiceTable.getValues
     * @see ChoiceTable.renderChoice
     */
    function getValueFromChoice(that, choice, display) {
        if (choice === that.getText('other') && that.customInput) {
          return that.customInput.getValues().value;
        }
        if ('string' === typeof choice || 'number' === typeof choice) {
            return choice;
        }
        if (J.isArray(choice)) return choice[display ? 1 : 0];
        if ('object' === typeof choice) {
            return choice[ display ? 'display' : 'value' ];
        }
        if (J.isElement(choice) || J.isNode(choice)) return choice.innerHTML;
        return null;
    }

})(node);

/**
 * # ChoiceTableGroup
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Creates a table that groups together several choice tables widgets
 *
 * @see ChoiceTable
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('ChoiceTableGroup', ChoiceTableGroup);

    // ## Meta-data

    ChoiceTableGroup.version = '1.8.0';
    ChoiceTableGroup.description = 'Groups together and manages sets of ' +
        'ChoiceTable widgets.';

    ChoiceTableGroup.title = 'Make your choice';
    ChoiceTableGroup.className = 'choicetable choicetablegroup';

    ChoiceTableGroup.separator = '::';

    ChoiceTableGroup.texts = {

        autoHint: function(w) {
            if (w.requiredChoice) return '*';
            else return false;
        },

        error: 'Selection required.'
    };

    // ## Dependencies

    ChoiceTableGroup.dependencies = {
        ChoiceTable: {}
    };

    /**
     * ## ChoiceTableGroup constructor
     *
     * Creates a new instance of ChoiceTableGroup
     *
     * @param {object} options Optional. Configuration options.
     *   If a `table` option is specified, it sets it as the clickable
     *   table. All other options are passed to the init method.
     */
    function ChoiceTableGroup() {
        var that;
        that = this;

        /**
         * ### ChoiceTableGroup.dl
         *
         * The clickable table containing all the cells
         */
        this.table = null;

        /**
         * ### ChoiceTableGroup.trs
         *
         * Collection of all trs created
         *
         * Useful when shuffling items/choices
         *
         * @see ChoiceTableGroup.shuffle
         */
        this.trs = [];

        /**
         * ## ChoiceTableGroup.listener
         *
         * The main listener function
         *
         * @see ChoiceTableGroup.enable
         * @see ChoiceTableGroup.disable
         * @see ChoiceTableGroup.onclick
         */
        this.listener = function(e) {
            var name, value, item, td, oldSelected;
            var time, removed;

            // Relative time.
            if ('string' === typeof that.timeFrom) {
                time = node.timer.getTimeSince(that.timeFrom);
            }
            // Absolute time.
            else {
                time = Date.now ? Date.now() : new Date().getTime();
            }

            e = e || window.event;
            td = e.target || e.srcElement;

            // Not a clickable choice.
            if ('undefined' === typeof that.choicesById[td.id]) {
                // It might be a nested element, try the parent.
                td = td.parentNode;
                if (!td || 'undefined' === typeof that.choicesById[td.id]) {
                    return;
                }
            }
            // if (!that.choicesById[td.id]) return;

            // Id of elements are in the form of name_value or name_item_value.
            value = td.id.split(that.separator);

            // Separator not found, not a clickable cell.
            if (value.length === 1) return;

            name = value[0];
            value = value[1];

            item = that.itemsById[name];

            // Not a clickable cell.
            if (!item) return;

            item.timeCurrentChoice = time;

            // One more click.
            item.numberOfClicks++;

            // If only 1 selection allowed, remove selection from oldSelected.
            if (!item.selectMultiple) {
                oldSelected = item.selected;
                if (oldSelected) J.removeClass(oldSelected, 'selected');

                if (item.isChoiceCurrent(value)) {
                    item.unsetCurrentChoice(value);
                    removed = true;
                }
                else {
                    item.currentChoice = value;
                    J.addClass(td, 'selected');
                    item.selected = td;
                }
            }

            // Remove any warning/error from form on click.
            if (that.isHighlighted()) that.unhighlight();

            // Call onclick, if any.
            if (that.onclick) {
                // TODO: Should we parseInt it anyway when we store
                // the current choice?
                value = parseInt(value, 10);
                that.onclick.call(that, name, value, removed, td);
            }
        };

        /**
         * ## ChoiceTableGroup.onclick
         *
         * The user-defined onclick function
         *
         * Receives 4 input parameters: the name of the choice table clicked,
         * the value of the clicked choice, whether it was a remove action,
         * and the reference to the TD object.
         *
         * @see ChoiceTableGroup.listener
         */
        this.onclick = null;

        /**
         * ### ChoiceTableGroup.mainText
         *
         * The main text introducing the choices
         *
         * @see ChoiceTableGroup.spanMainText
         */
        this.mainText = null;

        /**
         * ### ChoiceTableGroup.spanMainText
         *
         * The span containing the main text
         */
        this.spanMainText = null;

        /**
         * ### ChoiceTableGroup.hint
         *
         * An additional text with information about how to select items
         *
         * If not specified, it may be auto-filled, e.g. '(pick 2)'.
         *
         * @see Feedback.texts.autoHint
         */
        this.hint = null;

        /**
         * ### ChoiceTableGroup.errorBox
         *
         * An HTML element displayed when a validation error occurs
         */
        this.errorBox = null;

        /**
         * ### ChoiceTableGroup.items
         *
         * The array of available items
         */
        this.items = null;

        /**
         * ### ChoiceTableGroup.itemsById
         *
         * Map of items ids to items
         */
        this.itemsById = {};

        /**
         * ### ChoiceTableGroup.itemsMap
         *
         * Maps items ids to the position in the items array
         */
        this.itemsMap = {};

        /**
         * ### ChoiceTableGroup.choices
         *
         * Array of default choices (if passed as global parameter)
         */
        this.choices = null;

        /**
         * ### ChoiceTableGroup.choicesById
         *
         * Map of items choices ids to corresponding cell
         *
         * Useful to detect clickable cells.
         */
        this.choicesById = {};

        /**
         * ### ChoiceTableGroup.itemsSettings
         *
         * The array of settings for each item
         */
        this.itemsSettings = null;

        /**
         * ### ChoiceTableGroup.order
         *
         * The current order of display of choices
         *
         * May differ from `originalOrder` if shuffled.
         *
         * @see ChoiceTableGroup.originalOrder
         */
        this.order = null;

        /**
         * ### ChoiceTableGroup.originalOrder
         *
         * The initial order of display of choices
         *
         * @see ChoiceTable.order
         */
        this.originalOrder = null;

        /**
         * ### ChoiceTableGroup.shuffleItems
         *
         * If TRUE, items are inserted in random order
         *
         * @see ChoiceTableGroup.order
         */
        this.shuffleItems = null;

        /**
         * ### ChoiceTableGroup.requiredChoice
         *
         * The number of required choices.
         */
        this.requiredChoice = null;

        /**
         * ### ChoiceTableGroup.orientation
         *
         * Orientation of display of items: vertical ('V') or horizontal ('H')
         *
         * Default orientation is horizontal.
         */
        this.orientation = 'H';

        /**
         * ### ChoiceTableGroup.group
         *
         * The name of the group where the table belongs, if any
         */
        this.group = null;

        /**
         * ### ChoiceTableGroup.groupOrder
         *
         * The order of the choice table within the group
         */
        this.groupOrder = null;

        /**
         * ### ChoiceTableGroup.freeText
         *
         * If truthy, a textarea for free-text comment will be added
         *
         * If 'string', the text will be added inside the the textarea
         */
        this.freeText = null;

        /**
         * ### ChoiceTableGroup.textarea
         *
         * Textarea for free-text comment
         */
        this.textarea = null;

        /**
        * ### ChoiceTableGroup.header
        *
        * Header to be displayed above the table
        *
        * @experimental
        */
        this.header = null;

        // Options passed to each individual item.

        /**
         * ### ChoiceTableGroup.timeFrom
         *
         * Time is measured from timestamp as saved by node.timer
         *
         * Default event is a new step is loaded (user can interact with
         * the screen). Set it to FALSE, to have absolute time.
         *
         * This option is passed to each individual item.
         *
         * @see mixinSettings
         *
         * @see node.timer.getTimeSince
         */
        this.timeFrom = 'step';

        /**
         * ### ChoiceTableGroup.selectMultiple
         *
         * If TRUE, it allows to select multiple cells
         *
         * This option is passed to each individual item.
         *
         * @see mixinSettings
         */
        this.selectMultiple = null;

        /**
         * ### ChoiceTableGroup.renderer
         *
         * A callback that renders the content of each cell
         *
         * The callback must accept three parameters:
         *
         *   - a td HTML element,
         *   - a choice
         *   - the index of the choice element within the choices array
         *
         * and optionally return the _value_ for the choice (otherwise
         * the order in the choices array is used as value).
         *
         * This option is passed to each individual item.
         *
         * @see mixinSettings
         */
        this.renderer = null;

        /**
         * ### ChoiceTableGroup.separator
         *
         * Symbol used to separate tokens in the id attribute of every cell
         *
         * Default ChoiceTableGroup.separator
         *
         * This option is passed to each individual item.
         *
         * @see mixinSettings
         */
        this.separator = ChoiceTableGroup.separator;

        /**
         * ### ChoiceTableGroup.shuffleChoices
         *
         * If TRUE, choices in items are shuffled
         *
         * This option is passed to each individual item.
         *
         * @see mixinSettings
         */
        this.shuffleChoices = null;

        /**
         * ### ChoiceTableGroup.tabbable
         *
         * If TRUE, the elements of each choicetable can be accessed with TAB
         *
         * Clicking is simulated upon pressing space or enter.
         *
         * Default TRUE
         *
         * @see ChoiceTable.tabbable
         */
        this.tabbable = null;
    }

    // ## ChoiceTableGroup methods

    /**
     * ### ChoiceTableGroup.init
     *
     * Initializes the instance
     *
     * Available options are:
     *
     *   - className: the className of the table (string, array), or false
     *       to have none.
     *   - orientation: orientation of the table: vertical (v) or horizontal (h)
     *   - group: the name of the group (number or string), if any
     *   - groupOrder: the order of the table in the group, if any
     *   - listener: a custom function executed at every click. Context is
     *       `this` instance.
     *   - onclick: a function executed after the listener function. Context is
     *       `this` instance
     *   - mainText: a text to be displayed above the table
     *   - shuffleItems: if TRUE, items are shuffled before being added
     *       to the table
     *   - freeText: if TRUE, a textarea will be added under the table,
     *       if 'string', the text will be added inside the the textarea
     *   - timeFrom: The timestamp as recorded by `node.timer.setTimestamp`
     *       or FALSE, to measure absolute time for current choice
     *   - tabbable: if TRUE, each cell can be reached with TAB and clicked
     *       with SPACE or ENTER. Default: TRUE.
     *
     * @param {object} opts Configuration options
     */
    ChoiceTableGroup.prototype.init = function(opts) {
        var tmp;

        // TODO: many options checking are replicated. Skip them all?
        // Have a method in ChoiceTable?

        if (!this.id) {
            throw new TypeError('ChoiceTableGroup.init: id ' +
                                'is missing.');
        }

        // Option orientation, default 'H'.
        if ('undefined' === typeof opts.orientation) {
            tmp = 'H';
        }
        else if ('string' !== typeof opts.orientation) {
            throw new TypeError('ChoiceTableGroup.init: orientation ' +
                                'must be string, or undefined. Found: ' +
                                opts.orientation);
        }
        else {
            tmp = opts.orientation.toLowerCase().trim();
            if (tmp === 'horizontal' || tmp === 'h') {
                tmp = 'H';
            }
            else if (tmp === 'vertical' || tmp === 'v') {
                tmp = 'V';
            }
            else {
                throw new Error('ChoiceTableGroup.init: orientation ' +
                                'is invalid: ' + tmp);
            }
        }
        this.orientation = tmp;

        // Option shuffleItems, default false.
        if ('undefined' === typeof opts.shuffleItems) tmp = false;
        else tmp = !!opts.shuffleItems;
        this.shuffleItems = tmp;

        // Option requiredChoice, if any.
        if ('number' === typeof opts.requiredChoice) {
            this.requiredChoice = opts.requiredChoice;
        }
        else if ('boolean' === typeof opts.requiredChoice) {
            this.requiredChoice = opts.requiredChoice ? 1 : 0;
        }
        else if ('undefined' !== typeof opts.requiredChoice) {
            throw new TypeError('ChoiceTableGroup.init: ' +
                                'opts.requiredChoice ' +
                                'be number or boolean or undefined. Found: ' +
                                opts.requiredChoice);
        }

        // Set the group, if any.
        if ('string' === typeof opts.group ||
            'number' === typeof opts.group) {

            this.group = opts.group;
        }
        else if ('undefined' !== typeof opts.group) {
            throw new TypeError('ChoiceTableGroup.init: group must ' +
                                'be string, number or undefined. Found: ' +
                                opts.group);
        }

        // Set the groupOrder, if any.
        if ('number' === typeof opts.groupOrder) {

            this.groupOrder = opts.groupOrder;
        }
        else if ('undefined' !== typeof opts.group) {
            throw new TypeError('ChoiceTableGroup.init: groupOrder ' +
                                'must be number or undefined. Found: ' +
                                opts.groupOrder);
        }

        // Set the main onclick listener, if any.
        if ('function' === typeof opts.listener) {
            this.listener = function(e) {
                opts.listener.call(this, e);
            };
        }
        else if ('undefined' !== typeof opts.listener) {
            throw new TypeError('ChoiceTableGroup.init: listener ' +
                                'must be function or undefined. Found: ' +
                                opts.listener);
        }

        // Set an additional onclick, if any.
        if ('function' === typeof opts.onclick) {
            this.onclick = opts.onclick;
        }
        else if ('undefined' !== typeof opts.onclick) {
            throw new TypeError('ChoiceTableGroup.init: onclick must ' +
                                'be function or undefined. Found: ' +
                                opts.onclick);
        }

        // Set the mainText, if any.
        if ('string' === typeof opts.mainText) {
            this.mainText = opts.mainText;
        }
        else if ('undefined' !== typeof opts.mainText) {
            throw new TypeError('ChoiceTableGroup.init: mainText ' +
                                'must be string or undefined. Found: ' +
                                opts.mainText);
        }

        // Set the hint, if any.
        if ('string' === typeof opts.hint || false === opts.hint) {
            this.hint = opts.hint;
        }
        else if ('undefined' !== typeof opts.hint) {
            throw new TypeError('ChoiceTableGroup.init: hint must ' +
                                'be a string, false, or undefined. Found: ' +
                                opts.hint);
        }
        else {
            // Returns undefined if there are no constraints.
            this.hint = this.getText('autoHint');
        }

        // Set the timeFrom, if any.
        if (opts.timeFrom === false ||
            'string' === typeof opts.timeFrom) {

            this.timeFrom = opts.timeFrom;
        }
        else if ('undefined' !== typeof opts.timeFrom) {
            throw new TypeError('ChoiceTableGroup.init: timeFrom ' +
                                'must be string, false, or undefined. Found: ' +
                                opts.timeFrom);
        }

        // Option shuffleChoices, default false.
        if ('undefined' !== typeof opts.shuffleChoices) {
            this.shuffleChoices = !!opts.shuffleChoices;
        }

        // Set the renderer, if any.
        if ('function' === typeof opts.renderer) {
            this.renderer = opts.renderer;
        }
        else if ('undefined' !== typeof opts.renderer) {
            throw new TypeError('ChoiceTableGroup.init: renderer ' +
                                'must be function or undefined. Found: ' +
                                opts.renderer);
        }

        // Set default choices, if any.
        if ('undefined' !== typeof opts.choices) {
            this.choices = opts.choices;
        }

        // Set the className, if not use default.
        if ('undefined' === typeof opts.className) {
            this.className = ChoiceTableGroup.className;
        }
        else if (opts.className === false ||
                 'string' === typeof opts.className ||
                 J.isArray(opts.className)) {

            this.className = opts.className;
        }
        else {
            throw new TypeError('ChoiceTableGroup.init: ' +
                                'className must be string, array, ' +
                                'or undefined. Found: ' + opts.className);
        }

        if (opts.tabbable !== false) this.tabbable = true;

        // Separator checked by ChoiceTable.
        if (opts.separator) this.separator = opts.separator;

        // After all configuration opts are evaluated, add items.

        if ('object' === typeof opts.table) {
            this.table = opts.table;
        }
        else if ('undefined' !== typeof opts.table &&
                 false !== opts.table) {

            throw new TypeError('ChoiceTableGroup.init: table ' +
                                'must be object, false or undefined. ' +
                                'Found: ' + opts.table);
        }

        this.table = opts.table;

        this.freeText = 'string' === typeof opts.freeText ?
            opts.freeText : !!opts.freeText;

        if (opts.header) {
            tmp = opts.header;
            // One td will colspan all choices.
            if ('string' === typeof tmp) {
                tmp = [ tmp ];
            }
            else if (!J.isArray(tmp) ||
                    (tmp.length !== 1 && tmp.length !== opts.choices.length)) {

                throw new Error('ChoiceTableGroup.init: header ' +
                                'must be string, array (size ' +
                                opts.choices.length +
                                '), or undefined. Found: ' + tmp);
            }

            this.header = tmp;
        }


        // Add the items.
        if ('undefined' !== typeof opts.items) this.setItems(opts.items);

    };

    /**
     * ### ChoiceTableGroup.setItems
     *
     * Sets the available items and optionally builds the table
     *
     * @param {array} items The array of items
     *
     * @see ChoiceTableGroup.table
     * @see ChoiceTableGroup.order
     * @see ChoiceTableGroup.shuffleItems
     * @see ChoiceTableGroup.buildTable
     */
    ChoiceTableGroup.prototype.setItems = function(items) {
        var len;
        if (!J.isArray(items)) {
            throw new TypeError('ChoiceTableGroup.setItems: ' +
                                'items must be array. Found: ' + items);
        }
        if (!items.length) {
            throw new Error('ChoiceTableGroup.setItems: ' +
                            'items is an empty array.');
        }

        len = items.length;
        this.itemsSettings = items;
        this.items = new Array(len);

        // Save the order in which the items will be added.
        this.order = J.seq(0, len-1);
        if (this.shuffleItems) this.order = J.shuffle(this.order);
        this.originalOrder = this.order;

        // Build the table and items at once (faster).
        if (this.table) this.buildTable();
    };

    /**
     * ### ChoiceTableGroup.buildTable
     *
     * Builds the table of clickable items and enables it
     *
     * Must be called after items have been set already.
     *
     * @see ChoiceTableGroup.setChoiceTables
     * @see ChoiceTableGroup.order
     */
    ChoiceTableGroup.prototype.buildTable = function() {
        var i, len, td, tr, H, ct;
        var j, lenJ, lenJOld, hasRight, cell;

        H = this.orientation === 'H';
        i = -1, len = this.itemsSettings.length;
        if (H) {

            if (this.header) {
                tr = W.add('tr', this.table);
                W.add('td', tr, {
                    className: 'header'
                });
                for ( ; ++i < this.header.length ; ) {
                    td = W.add('td', tr, {
                        innerHTML: this.header[i],
                        className: 'header'
                    });
                }
                // Only one element, header spans throughout.
                if (i === 1) td.setAttribute('colspan', this.choices.length);
                i = -1;
            }

            for ( ; ++i < len ; ) {
                // Get item.
                ct = getChoiceTable(this, i);

                // Add new TR.
                tr = createTR(this, ct.id);

                // Append choices for item.
                tr.appendChild(ct.leftCell);
                j = -1, lenJ = ct.choicesCells.length;
                // Make sure all items have same number of choices.
                if (i === 0) {
                    lenJOld = lenJ;
                }
                else if (lenJ !== lenJOld) {
                    throw new Error('ChoiceTableGroup.buildTable: item ' +
                                    'do not have same number of choices: ' +
                                    ct.id);
                }
                // TODO: might optimize. There are two loops (+1 inside ct).
                for ( ; ++j < lenJ ; ) {
                    cell = ct.choicesCells[j];
                    tr.appendChild(cell);
                    this.choicesById[cell.id] = cell;
                }
                if (ct.rightCell) tr.appendChild(ct.rightCell);
            }
        }
        else {

            // Add new TR.
            // TODO: rename, this is not the header as from options.
            tr = createTR(this, 'header');

            // Build all items first.
            for ( ; ++i < len ; ) {

                // Get item, append choices for item.
                ct = getChoiceTable(this, i);

                // Make sure all items have same number of choices.
                lenJ = ct.choicesCells.length;
                if (i === 0) {
                    lenJOld = lenJ;
                }
                else if (lenJ !== lenJOld) {
                    throw new Error('ChoiceTableGroup.buildTable: item ' +
                                    'do not have same number of choices: ' +
                                    ct.id);
                }

                if ('undefined' === typeof hasRight) {
                    hasRight = !!ct.rightCell;
                }
                else if ((!ct.rightCell && hasRight) ||
                         (ct.rightCell && !hasRight)) {

                    throw new Error('ChoiceTableGroup.buildTable: either all ' +
                                    'items or no item must have the right ' +
                                    'cell: ' + ct.id);

                }
                // Add left.
                tr.appendChild(ct.leftCell);
            }

            if (hasRight) lenJ++;

            j = -1;
            for ( ; ++j < lenJ ; ) {
                // Add new TR.
                tr = createTR(this, 'row' + (j+1));

                i = -1;
                // TODO: might optimize. There are two loops (+1 inside ct).
                for ( ; ++i < len ; ) {
                    if (hasRight && j === (lenJ-1)) {
                        tr.appendChild(this.items[i].rightCell);
                    }
                    else {
                        cell = this.items[i].choicesCells[j];
                        tr.appendChild(cell);
                        this.choicesById[cell.id] = cell;
                    }
                }
            }

        }

        // Enable onclick listener.
        this.enable(true);
    };

    /**
     * ### ChoiceTableGroup.append
     *
     * Implements Widget.append
     *
     * Checks that id is unique.
     *
     * Appends (all optional):
     *
     *   - mainText: a question or statement introducing the choices
     *   - table: the table containing the choices
     *   - freeText: a textarea for comments
     *
     * @see Widget.append
     */
    ChoiceTableGroup.prototype.append = function() {
        // Id must be unique.
        if (W.getElementById(this.id)) {
            throw new Error('ChoiceTableGroup.append: id ' +
                            'is not unique: ' + this.id);
        }

        // MainText.
        if (this.mainText) {
            this.spanMainText = W.append('span', this.bodyDiv, {
                className: 'choicetable-maintext',
                innerHTML: this.mainText
            });
        }
        // Hint.
        if (this.hint) {
            W.append('span', this.spanMainText || this.bodyDiv, {
                className: 'choicetable-hint',
                innerHTML: this.hint
            });
        }

        // Create/set table, if requested.
        if (this.table !== false) {
            if ('undefined' === typeof this.table) {
                this.table = document.createElement('table');
                if (this.items) this.buildTable();
            }
            // Set table id.
            this.table.id = this.id;
            if (this.className) J.addClass(this.table, this.className);
            else this.table.className = '';
            // Append table.
            this.bodyDiv.appendChild(this.table);
        }

        this.errorBox = W.append('div', this.bodyDiv, { className: 'errbox' });

        // Creates a free-text textarea, possibly with placeholder text.
        if (this.freeText) {
            this.textarea = document.createElement('textarea');
            if (this.id) this.textarea.id = this.id + '_text';
            this.textarea.className = ChoiceTableGroup.className + '-freetext';
            if ('string' === typeof this.freeText) {
                this.textarea.placeholder = this.freeText;
            }
            // Append textarea.
            this.bodyDiv.appendChild(this.textarea);
        }
    };

    /**
     * ### ChoiceTableGroup.listeners
     *
     * Implements Widget.listeners
     *
     * Adds two listeners two disable/enable the widget on events:
     * INPUT_DISABLE, INPUT_ENABLE
     *
     * Notice! Nested choice tables listeners are not executed.
     *
     * @see Widget.listeners
     * @see mixinSettings
     */
    ChoiceTableGroup.prototype.listeners = function() {
        var that = this;
        node.on('INPUT_DISABLE', function() {
            that.disable();
        });
        node.on('INPUT_ENABLE', function() {
            that.enable();
        });
    };

    /**
     * ### ChoiceTableGroup.disable
     *
     * Disables clicking on the table and removes CSS 'clicklable' class
     */
    ChoiceTableGroup.prototype.disable = function() {
        if (this.disabled === true || !this.table) return;
        this.disabled = true;
        J.removeClass(this.table, 'clickable');
        this.table.removeEventListener('click', this.listener);
        // Remove listener to make cells clickable with the keyboard.
        if (this.tabbable) J.makeClickable(this.table, false);
        this.emit('disabled');
    };

    /**
     * ### ChoiceTableGroup.enable
     *
     * Enables clicking on the table and adds CSS 'clicklable' class
     *
     * @return {function} cb The event listener function
     */
    ChoiceTableGroup.prototype.enable = function(force) {
        if (!this.table || (!force && !this.disabled)) return;
        this.disabled = false;
        J.addClass(this.table, 'clickable');
        this.table.addEventListener('click', this.listener);
        // Add listener to make cells clickable with the keyboard.
        if (this.tabbable) J.makeClickable(this.table);
        this.emit('enabled');
    };

    /**
     * ### ChoiceTableGroup.verifyChoice
     *
     * Compares the current choice/s with the correct one/s
     *
     * @param {boolean} markAttempt Optional. If TRUE, the value of
     *   current choice is added to the attempts array. Default
     *
     * @return {boolean|null} TRUE if current choice is correct,
     *   FALSE if it is not correct, or NULL if no correct choice
     *   was set
     *
     * @see ChoiceTableGroup.attempts
     * @see ChoiceTableGroup.setCorrectChoice
     */
    ChoiceTableGroup.prototype.verifyChoice = function(markAttempt) {
        var i, len, out;
        out = {};
        // Mark attempt by default.
        markAttempt = 'undefined' === typeof markAttempt ? true : markAttempt;
        i = -1, len = this.items.length;
        for ( ; ++i < len ; ) {
            out[this.items[i].id] = this.items[i].verifyChoice(markAttempt);
        }
        return out;
    };

    /**
     * ### ChoiceTable.setCurrentChoice
     *
     * Marks a choice as current in each item
     *
     * If the item allows it, multiple choices can be set as current.
     *
     * @param {number|string} The choice to mark as current
     *
     * @see ChoiceTable.currentChoice
     * @see ChoiceTable.selectMultiple
     */
    ChoiceTableGroup.prototype.setCurrentChoice = function(choice) {
        var i, len;
        i = -1, len = this.items[i].length;
        for ( ; ++i < len ; ) {
            this.items[i].setCurrentChoice(choice);
        }
    };

    /**
     * ### ChoiceTableGroup.unsetCurrentChoice
     *
     * Deletes the value for currentChoice from every item
     *
     * If `ChoiceTableGroup.selectMultiple` is set the
     *
     * @param {number|string} Optional. The choice to delete from currentChoice
     *   when multiple selections are allowed
     *
     * @see ChoiceTableGroup.currentChoice
     * @see ChoiceTableGroup.selectMultiple
     */
    ChoiceTableGroup.prototype.unsetCurrentChoice = function(choice) {
        var i, len;
        i = -1, len = this.items.length;
        for ( ; ++i < len ; ) {
            this.items[i].unsetCurrentChoice(choice);
        }
    };

    /**
     * ### ChoiceTableGroup.highlight
     *
     * Highlights the choice table
     *
     * @param {string} The style for the table's border.
     *   Default '1px solid red'
     *
     * @see ChoiceTableGroup.highlighted
     */
    ChoiceTableGroup.prototype.highlight = function(border) {
        if (border && 'string' !== typeof border) {
            throw new TypeError('ChoiceTableGroup.highlight: border must be ' +
                                'string or undefined. Found: ' + border);
        }
        if (!this.table || this.highlighted === true) return;
        this.table.style.border = border || '3px solid red';
        this.highlighted = true;
        this.emit('highlighted', border);
    };

    /**
     * ### ChoiceTableGroup.unhighlight
     *
     * Removes highlight from the choice table
     *
     * @see ChoiceTableGroup.highlighted
     */
    ChoiceTableGroup.prototype.unhighlight = function() {
        if (!this.table || this.highlighted !== true) return;
        this.table.style.border = '';
        this.highlighted = false;
        this.setError();
        this.emit('unhighlighted');
    };

    /**
     * ### ChoiceTableGroup.getValues
     *
     * Returns the values for current selection and other paradata
     *
     * Paradata that is not set or recorded will be omitted
     *
     * @param {object} opts Optional. Configures the return value.
     *   Available optionts:
     *
     *   - markAttempt: If TRUE, getting the value counts as an attempt
     *      to find the correct answer. Default: TRUE.
     *   - highlight:   If TRUE, if current value is not the correct
     *      value, widget will be highlighted. Default: TRUE.
     *   - reset:    If TRUTHY and no item raises an error,
     *       then it resets the state of all items before
     *       returning it. Default: FALSE.
     *
     * @return {object} Object containing the choice and paradata
     *
     * @see ChoiceTableGroup.verifyChoice
     * @see ChoiceTableGroup.reset
     */
    ChoiceTableGroup.prototype.getValues = function(opts) {
        var obj, i, len, tbl, toHighlight, toReset;
        obj = {
            id: this.id,
            order: this.order,
            items: {},
            isCorrect: true
        };
        opts = opts || {};
        if ('undefined' === typeof opts.highlight) opts.highlight = true;
        // Make sure reset is done only at the end.
        toReset = opts.reset;
        opts.reset = false;
        i = -1, len = this.items.length;
        for ( ; ++i < len ; ) {
            tbl = this.items[i];
            obj.items[tbl.id] = tbl.getValues(opts);
            if (obj.items[tbl.id].choice === null) {
                obj.missValues = true;
                if (tbl.requiredChoice) {
                    toHighlight = true;
                    obj.isCorrect = false;
                }
            }
            if (obj.items[tbl.id].isCorrect === false && opts.highlight) {
                toHighlight = true;
            }
        }
        if (opts.highlight && toHighlight) {
            this.setError(this.getText('error'));
        }
        else if (toReset) {
            this.reset(toReset);
        }
        opts.reset = toReset;
        if (this.textarea) obj.freetext = this.textarea.value;
        return obj;
    };


    /**
     * ### ChoiceTableGroup.setError
     *
     * Set the error msg inside the errorBox and call highlight
     *
     * @param {string} The error msg (can contain HTML)
     *
     * @see ChoiceTableGroup.highlight
     * @see ChoiceTableGroup.errorBox
     */
    ChoiceTableGroup.prototype.setError = function(err) {
        this.errorBox.innerHTML = err || '';
        if (err) this.highlight();
        else this.unhighlight();
    };


    /**
     * ### ChoiceTableGroup.setValues
     *
     * Sets values in the choice table group as specified by the options
     *
     * @param {object} options Optional. Options specifying how to set
     *   the values. If no parameter is specified, random values will
     *   be set.
     *
     * @see ChoiceTable.setValues
     *
     * @experimental
     */
    ChoiceTableGroup.prototype.setValues = function(opts) {
        var i, len;
        if (!this.items || !this.items.length) {
            throw new Error('ChoiceTableGroup.setValues: no items found.');
        }
        opts = opts || {};
        i = -1, len = this.items.length;
        for ( ; ++i < len ; ) {
            this.items[i].setValues(opts);
        }

        // Make a random comment.
        if (this.textarea) this.textarea.value = J.randomString(100, '!Aa0');
    };

    /**
     * ### ChoiceTableGroup.reset
     *
     * Resets all the ChoiceTable items and textarea
     *
     * @param {object} options Optional. Options specifying how to set
     *   to reset each item
     *
     * @see ChoiceTable.reset
     * @see ChoiceTableGroup.shuffle
     */
    ChoiceTableGroup.prototype.reset = function(opts) {
        var i, len;
        opts = opts || {};
        i = -1, len = this.items.length;
        for ( ; ++i < len ; ) {
            this.items[i].reset(opts);
        }
        // Delete textarea, if found.
        if (this.textarea) this.textarea.value = '';
        if (opts.shuffleItems) this.shuffle();
        if (this.isHighlighted()) this.unhighlight();
    };

    /**
     * ### ChoiceTableGroup.shuffle
     *
     * Shuffles the order of the displayed items
     *
     * Assigns the new order of items to `this.order`.
     *
     * @param {object} options Optional. Not used for now.
     *
     * TODO: shuffle choices in each item. (Note: can't use
     * item.shuffle, because the cells are taken out, so
     * there is no table and no tr in there)
     *
     * JSUS.shuffleElements
     */
    ChoiceTableGroup.prototype.shuffle = function(opts) {
        var order, i, len, j, lenJ, that, cb, newOrder;
        if (!this.items) return;
        len = this.items.length;
        if (!len) return;
        that = this;
        newOrder = new Array(len);
        // Updates the groupOrder property of each item,
        // and saves the order of items correctly.
        cb = function(el, newPos, oldPos) {
            var i;
            i = el.id.split(that.separator);
            i = that.orientation === 'H' ? i[2] : i[0];
            i = that.itemsMap[i];
            that.items[i].groupOrder = (newPos+1);
            newOrder[newPos] = i;
        };
        order = J.shuffle(this.order);
        if (this.orientation === 'H') {
            J.shuffleElements(this.table, order, cb);
        }
        else {
            // Here we maintain the columns manually. Each TR contains TD
            // belonging to different items, we make sure the order is the
            // same for all TR.
            len = this.trs.length;
            for ( i = -1 ; ++i < len ; ) {
                J.shuffleElements(this.trs[i], order, cb);
                // Call cb only on first iteration.
                cb = undefined;
            }
        }
        this.order = newOrder;
    };



    // ## Helper methods.

    /**
     * ### mixinSettings
     *
     * Mix-ins global settings with local settings for specific choice tables
     *
     * @param {ChoiceTableGroup} that This instance
     * @param {object|string} s The current settings for the item
     *   (choice table), or just its id, to mixin all settings.
     * @param {number} i The ordinal position of the table in the group
     *
     * @return {object} s The mixed-in settings
     */
    function mixinSettings(that, s, i) {
        if ('string' === typeof s) {
            s = { id: s };
        }
        else if (J.isArray(s)) {
            s = { id: s[0], left: s[1] };
        }
        else if ('object' !== typeof s) {
            throw new TypeError('ChoiceTableGroup.buildTable: item must be ' +
                                'string or object. Found: ' + s);
        }
        s.group = that.id;
        s.groupOrder = i+1;
        s.orientation = that.orientation;
        s.title = false;
        s.listeners = false;
        s.separator = that.separator;

        if ('undefined' === typeof s.choices && that.choices) {
            s.choices = that.choices;
        }

        if (!s.renderer && that.renderer) s.renderer = that.renderer;

        if ('undefined' === typeof s.requiredChoice && that.requiredChoice) {
            s.requiredChoice = that.requiredChoice;
        }

        if ('undefined' === typeof s.selectMultiple &&
            null !== that.selectMultiple) {

            s.selectMultiple = that.selectMultiple;
        }

        if ('undefined' === typeof s.shuffleChoices && that.shuffleChoices) {
            s.shuffleChoices = that.shuffleChoices;
        }

        if ('undefined' === typeof s.timeFrom) s.timeFrom = that.timeFrom;

        if ('undefined' === typeof s.left) s.left = s.id;

        // No reference is stored in node.widgets.
        s.storeRef = false;

        return s;
    }

    /**
     * ### getChoiceTable
     *
     * Creates a instance i-th of choice table with relative settings
     *
     * Stores a reference of each table in `itemsById`
     *
     * @param {ChoiceTableGroup} that This instance
     * @param {number} i The ordinal position of the table in the group
     *
     * @return {object} ct The requested choice table
     *
     * @see ChoiceTableGroup.itemsSettings
     * @see ChoiceTableGroup.itemsById
     * @see mixinSettings
     */
    function getChoiceTable(that, i) {
        var ct, s, idx;
        idx = that.order[i];
        s = mixinSettings(that, that.itemsSettings[idx], i);
        ct = node.widgets.get('ChoiceTable', s);
        if (that.itemsById[ct.id]) {
            throw new Error('ChoiceTableGroup.buildTable: an item ' +
                            'with the same id already exists: ' + ct.id);
        }
        if (!ct.leftCell) {
            throw new Error('ChoiceTableGroup.buildTable: item ' +
                            'is missing a left cell: ' + s.id);
        }
        that.itemsById[ct.id] = ct;
        that.items[idx] = ct;
        that.itemsMap[ct.id] = idx;
        return ct;
    }

    /**
     * ### createTR
     *
     * Creates and append a new TR element
     *
     * If required by current configuration, the `id` attribute is
     * added to the TR in the form of: 'tr' + separator + widget_id
     *
     * @param {ChoiceTable} that This instance
     *
     * @return {HTMLElement} Thew newly created TR element
     */
    function createTR(that, trid) {
        var tr, sep;
        tr = document.createElement('tr');
        that.table.appendChild(tr);
        // Set id.
        sep = that.separator;
        tr.id = that.id + sep + 'tr' + sep + trid;
        // Store reference.
        that.trs.push(tr);
        return tr;
    }

})(node);

/**
 * # Consent
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Displays a consent form with buttons to accept/reject it
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('Consent', Consent);

    // ## Meta-data

    Consent.version = '0.4.0';
    Consent.description = 'Displays a configurable consent form.';

    Consent.title = false;
    Consent.panel = false;
    Consent.className = 'consent';

    Consent.texts = {

        areYouSure: 'You did not consent and are about to leave the ' +
                    'study. Are you sure?',

        printText:
        '<br/><p>If you need a copy of this consent form, you may ' +
        'print a copy of this page for your records.</p>',

        printBtn: 'Print this page',

        consentTerms: 'Do you understand and consent to these terms?',

        agree: 'Yes, I agree',

        notAgree: 'No, I do not agree',

        showHideConsent: function(w, s) {
            return (s === 'hide' ? 'Hide' : 'Show') + ' Consent Form';
        }

    };

    /**
     * ## Consent constructor
     *
     * Creates a new instance of Consent
     *
     * @param {object} options Optional. Configuration options
     * which is forwarded to Consent.init.
     *
     * @see Consent.init
     */
    function Consent() {

        /**
         * ## Consent.consent
         *
         * The object containing the variables to substitute
         *
         * Default: node.game.settings.CONSENT
         */
        this.consent = null;

        /**
         * ## Consent.showPrint
         *
         * If TRUE, the print button is shown
         *
         * Default: TRUE
         */
        this.showPrint = null;
    }

    // ## Consent methods.

    /**
     * ### Consent.init
     *
     * Initializes the widget
     *
     * @param {object} opts Optional. Configuration options.
     */
    Consent.prototype.init = function(opts) {
        opts = opts || {};

        this.consent = opts.consent || node.game.settings.CONSENT;

        if (this.consent && 'object' !== typeof this.consent) {
            throw new TypeError('Consent: consent must be object or ' +
                                'undefined. Found: ' + this.consent);
        }

        this.showPrint = opts.showPrint === false ? false : true;
    };

    Consent.prototype.enable = function() {
        var a, na;
        if (this.notAgreed) return;
        a = W.gid('agree');
        if (a) a.disabled = false;
        na = W.gid('notAgree');
        if (na) na.disabled = false;
    };

    Consent.prototype.disable = function() {
        var a, na;
        if (this.notAgreed) return;
        a = W.gid('agree');
        if (a) a.disabled = true;
        na = W.gid('notAgree');
        if (na) na.disabled = true;
    };

    Consent.prototype.append = function() {
        var consent, html, btn1, btn2, st1, st2;
        // Hide not agreed div.
        W.hide('notAgreed');

        consent = W.gid('consent');
        if (!consent) {
            throw new Error('Consent.append: the page does not contain an ' +
                            'element with id "consent"');
        }
        html = '';

        // Print.
        if (this.showPrint) {
            html = this.getText('printText');
            html += '<input class="btn" type="button" value="' +
            this.getText('printBtn') +
            '" onclick="window.print()" /><br/><br/>';
        }

        // Header for buttons.
        html += '<strong>' + this.getText('consentTerms') + '</strong><br/>';

        // Buttons.
        html += '<div style="margin-top: 30px; text-align: center;">';

        if (document.querySelector('html').dir === 'rtl') {
            btn1 = 'agree';
            btn2 = 'notAgree';
            st1 = 'info';
            st2 = 'danger';
        }
        else {
            btn1 = 'notAgree';
            btn2 = 'agree';
            st1 = 'danger';
            st2 = 'info';
        }

        html += '<button class="btn btn-lg btn-' + st1 +
              '" style="margin: 0px 30px" id="' + btn1 + '">' +
              this.getText(btn1) + '</button>';

        html += '<button class="btn btn-lg btn-' + st2 + '" id="' +
                 btn2 + '">' + this.getText(btn2) + '</button></div>';

        consent.innerHTML += html;
        setTimeout(function() { W.adjustFrameHeight(); });
    };

    Consent.prototype.listeners = function() {
        var that = this;
        var consent = this.consent;
        node.on('FRAME_LOADED', function() {
            var a, na, p, id;

            // Replace all texts.
            if (consent) {
                for (p in consent) {
                    if (consent.hasOwnProperty(p)) {
                        // Making lower-case and replacing underscore
                        // s with dashes.
                        id = p.toLowerCase();
                        id = id.replace(new RegExp("_", 'g'), "-");
                        W.setInnerHTML(id, consent[p]);
                    }
                }
            }

            // Add listeners on buttons.
            a = W.gid('agree');
            na = W.gid('notAgree');

            if (!a) throw new Error('Consent: agree button not found');
            if (!na) throw new Error('Consent: notAgree button not found');


            a.onclick = function() { node.done({ consent: true }); };
            na.onclick = function() {
                var showIt, confirmed;

                confirmed = confirm(that.getText('areYouSure'));
                if (!confirmed) return;

                node.emit('CONSENT_REJECTING');

                that.notAgreed = true;
                node.set({
                    consent: false,
                    // Need to send these two because it's not a DONE msg.
                    time: node.timer.getTimeSince('step'),
                    timeup: false
                });
                a.disabled = true;
                na.disabled = true;
                a.onclick = null;
                na.onclick = null;

                node.socket.disconnect();
                W.hide('consent');
                W.show('notAgreed');

                // If a show-consent button is found enable it.
                showIt = W.gid('show-consent');
                if (showIt) {
                    showIt.onclick = function() {
                        var div, s;
                        div = W.toggle('consent');
                        s = div.style.display === '' ? 'hide' : 'show';
                        this.innerHTML = that.getText('showHideConsent', s);
                    };
                }
                node.emit('CONSENT_REJECTED');
            };
       });
    };

})(node);

/**
 * # ContentBox
 * Copyright(c) 2019 Stefano Balietti
 * MIT Licensed
 *
 * Displays some content.
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('ContentBox', ContentBox);

    // ## Meta-data

    ContentBox.version = '0.2.0';
    ContentBox.description = 'Simply displays some content';

    ContentBox.title = false;
    ContentBox.panel = false;
    ContentBox.className = 'contentbox';

    // ## Dependencies

    ContentBox.dependencies = {};

    /**
     * ## ContentBox constructor
     *
     */
    function ContentBox() {

        // ### ContentBox.mainText
        // The main text above the content.
        this.mainText = null;

        // ### ContentBox.content
        // Some content to be displayed.
        this.content = null;

        // ### ContentBox.hint
        // A hint text.
        this.hint = null;
    }

    // ## ContentBox methods
    ContentBox.prototype.init = function(opts) {
        // Set the mainText, if any.
        if ('string' === typeof opts.mainText) {
            this.mainText = opts.mainText;
        }
        else if ('undefined' !== typeof opts.mainText) {
            throw new TypeError('ContentBox.init: mainText must ' +
                                'be string or undefined. Found: ' +
                                opts.mainText);
        }
        // Set the content, if any.
        if ('string' === typeof opts.content) {
            this.content = opts.content;
        }
        else if ('undefined' !== typeof opts.content) {
            throw new TypeError('ContentBox.init: content must ' +
                                'be string or undefined. Found: ' +
                                opts.content);
        }
        // Set the content, if any.
        if ('string' === typeof opts.hint) {
            this.hint = opts.hint;
        }
        else if ('undefined' !== typeof opts.hint) {
            throw new TypeError('ContentBox.init: hint must ' +
                                'be string or undefined. Found: ' +
                                opts.hint);
        }
    };

    ContentBox.prototype.append = function() {
        // MainText.
        if (this.mainText) {
            W.append('span', this.bodyDiv, {
                className: 'contentbox-maintext',
                innerHTML: this.mainText
            });
        }
        // Content.
        if (this.content) {
            W.append('div', this.bodyDiv, {
                className: 'contentbox-content',
                innerHTML: this.content
            });
        }
        // Hint.
        if (this.hint) {
            W.append('span', this.bodyDiv, {
                className: 'contentbox-hint',
                innerHTML: this.hint
            });
        }
    };

})(node);

/**
 * # Controls
 * Copyright(c) 2017 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Creates and manipulates a set of forms
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    // TODO: handle different events, beside onchange

    node.widgets.register('Controls', Controls);

    // ## Meta-data

    Controls.version = '0.5.1';
    Controls.description = 'Wraps a collection of user-inputs controls.';

    Controls.title = 'Controls';
    Controls.className = 'controls';

    /**
     * ## Controls constructor
     *
     * `Control` wraps a collection of user-input controls
     *
     * @param {object} options Optional. Configuration options
     * which is stored and forwarded to Controls.init.
     *
     *  The  options object can have the following attributes:
     *   - Any option that can be passed to `W.List` constructor.
     *   - `change`: Event to fire when contents change.
     *   - `features`: Collection of collection attributes for individual
     *                 controls.
     *   - `submit`: Description of the submit button.
     *               If submit.id is defined, the button will get that id and
     *               the text on the button will be the text in submit.name.
     *               If submit is a string, it will be the text on the button.
     *   - `attributes`: Attributes of the submit button.
     *
     * @see Controls.init
     */
    function Controls(options) {
        this.options = options;

        /**
         * ### Controls.listRoot
         *
         * The list which holds the controls
         */
        this.listRoot = null;

        /**
         * ### Controls.submit
         *
         * The submit button
         */
        this.submit = null;

        /**
         * ### Controls.changeEvent
         *
         * The event to be fired when the list changes
         */
        this.changeEvent = 'Controls_change';

        /**
         * ### Controls.hasChanged
         *
         * Flag to indicate whether the list has changed
         */
        this.hasChanged = false;
    }

    Controls.prototype.add = function(root, id, attributes) {
        // TODO: replace W.addTextInput 
        //return W.addTextInput(root, id, attributes);
    };

    Controls.prototype.getItem = function(id, attributes) {
        // TODO: replace W.addTextInput
        //return W.getTextInput(id, attributes);
    };

    // ## Controls methods

    /**
     * ### Controls.init
     *
     * Initializes the widget
     *
     * @param {object} options Optional. Configuration options.
     *
     * The  options object can have the following attributes:
     *   - Any option that can be passed to `W.List` constructor.
     *   - `change`: Event to fire when contents change.
     *   - `features`: Collection of collection attributes for individual
     *                 controls.
     *
     * @see nodegame-window/List
     */
    Controls.prototype.init = function(options) {
        this.hasChanged = false; // TODO: should this be inherited?
        if ('undefined' !== typeof options.change) {
            if (!options.change) {
                this.changeEvent = false;
            }
            else {
                this.changeEvent = options.change;
            }
        }
        this.list = new W.List(options);
        this.listRoot = this.list.getRoot();

        if (options.features) {
            this.features = options.features;
            this.populate();
        }
    };

    /**
     * ### Controls.append
     *
     * Appends the widget to `this.bodyDiv`
     *
     * @see Controls.init
     */
    Controls.prototype.append = function() {
        var that = this;
        var idButton = 'submit_Controls';


        this.list.parse();
        this.bodyDiv.appendChild(this.listRoot);

        if (this.options.submit) {
            if (this.options.submit.id) {
                idButton = this.options.submit.id;
                this.option.submit = this.option.submit.name;
            }
            this.submit = W.add('button', this.bodyDiv,
                                J.merge(this.options.attributes, {
                                    id: idButton,
                                    innerHTML: this.options.submit
                                }));

            this.submit.onclick = function() {
                if (that.options.change) {
                    node.emit(that.options.change);
                }
            };
        }
    };

    Controls.prototype.parse = function() {
        return this.list.parse();
    };

    /**
     * ### Controls.populate
     *
     * Adds features to the list.
     *
     * @see Controls.init
     */
    Controls.prototype.populate = function() {
        var key, id, attributes, container, elem;
        var that = this;

        for (key in this.features) {
            if (this.features.hasOwnProperty(key)) {
                // Prepare the attributes vector.
                attributes = this.features[key];
                id = key;
                if (attributes.id) {
                    id = attributes.id;
                    delete attributes.id;
                }

                container = document.createElement('div');
                // Add a different element according
                // to the subclass instantiated.
                elem = this.add(container, id, attributes);

                // Fire the onChange event, if one defined
                if (this.changeEvent) {
                    elem.onchange = function() {
                        node.emit(that.changeEvent);
                    };
                }

                if (attributes.label) {                    
                    W.add('label', container, {
                        'for': elem.id,
                        innerHTML: attributes.label
                    });
                }

                // Element added to the list.
                this.list.addDT(container);
            }
        }
    };

    Controls.prototype.listeners = function() {
        var that = this;
        // TODO: should this be inherited?
        node.on(this.changeEvent, function() {
            that.hasChanged = true;
        });

    };

    Controls.prototype.refresh = function() {
        var key, el;
        for (key in this.features) {
            if (this.features.hasOwnProperty(key)) {
                el = W.getElementById(key);
                if (el) {
                    // node.log('KEY: ' + key, 'DEBUG');
                    // node.log('VALUE: ' + el.value, 'DEBUG');
                    el.value = this.features[key].value;
                    // TODO: set all the other attributes
                    // TODO: remove/add elements
                }

            }
        }

        return true;
    };

    Controls.prototype.getValues = function() {
        var out, el, key;
        out = {};
        for (key in this.features) {
            if (this.features.hasOwnProperty(key)) {
                el = W.getElementById(key);
                if (el) out[key] = Number(el.value);
            }
        }
        return out;
    };

    Controls.prototype.highlight = function(code) {
        return W.highlight(this.listRoot, code);
    };

    // ## Sub-classes

    /**
     * ### Slider
     */


    SliderControls.prototype.__proto__ = Controls.prototype;
    SliderControls.prototype.constructor = SliderControls;

    SliderControls.version = '0.2.2';
    SliderControls.description = 'Collection of Sliders.';

    SliderControls.title = 'Slider Controls';
    SliderControls.className = 'slidercontrols';

    SliderControls.dependencies = {
        Controls: {}
    };

    // Need to be after the prototype is inherited.
    node.widgets.register('SliderControls', SliderControls);

    function SliderControls(options) {
        Controls.call(this, options);
    }

    SliderControls.prototype.add = function(root, id, attributes) {
        attributes = attributes || {};
        attributes.id = id;
        attributes.type = 'range';
        return W.add('input', root, attributes);
    };

    SliderControls.prototype.getItem = function(id, attributes) {
        attributes = attributes || {};
        attributes.id = id;
        return W.get('input', attributes);
    };

    /**
     * ### jQuerySlider
     */


    jQuerySliderControls.prototype.__proto__ = Controls.prototype;
    jQuerySliderControls.prototype.constructor = jQuerySliderControls;

    jQuerySliderControls.version = '0.14';
    jQuerySliderControls.description = 'Collection of jQuery Sliders.';

    jQuerySliderControls.title = 'jQuery Slider Controls';
    jQuerySliderControls.className = 'jqueryslidercontrols';

    jQuerySliderControls.dependencies = {
        jQuery: {},
        Controls: {}
    };

    node.widgets.register('jQuerySliderControls', jQuerySliderControls);

    function jQuerySliderControls(options) {
        Controls.call(this, options);
    }

    jQuerySliderControls.prototype.add = function(root, id, attributes) {
        var slider = jQuery('<div/>', {
            id: id
        }).slider();

        var s = slider.appendTo(root);
        return s[0];
    };

    jQuerySliderControls.prototype.getItem = function(id, attributes) {
        var slider = jQuery('<div/>', {
            id: id
        }).slider();

        return slider;
    };

    /**
     * ### RadioControls
     */

    RadioControls.prototype.__proto__ = Controls.prototype;
    RadioControls.prototype.constructor = RadioControls;

    RadioControls.version = '0.1.2';
    RadioControls.description = 'Collection of Radio Controls.';

    RadioControls.title = 'Radio Controls';
    RadioControls.className = 'radiocontrols';

    RadioControls.dependencies = {
        Controls: {}
    };

    node.widgets.register('RadioControls', RadioControls);

    function RadioControls(options) {
        Controls.call(this,options);
        this.groupName = ('undefined' !== typeof options.name) ? options.name :
            W.generateUniqueId();
        this.radioElem = null;
    }

    // overriding populate also. There is an error with the Label
    RadioControls.prototype.populate = function() {
        var key, id, attributes, elem, that;
        that = this;

        if (!this.radioElem) {
            this.radioElem = document.createElement('radio');
            this.radioElem.group = this.name || "radioGroup";
            this.radioElem.group = this.className || "radioGroup";
            this.bodyDiv.appendChild(this.radioElem);
        }

        for (key in this.features) {
            if (this.features.hasOwnProperty(key)) {
                // Prepare the attributes vector.
                attributes = this.features[key];
                id = key;
                if (attributes.id) {
                    id = attributes.id;
                    delete attributes.id;
                }

                // Add a different element according
                // to the subclass instantiated.
                elem = this.add(this.radioElem, id, attributes);

                // Fire the onChange event, if one defined
                if (this.changeEvent) {
                    elem.onchange = function() {
                        node.emit(that.changeEvent);
                    };
                }

                // Element added to the list.
                this.list.addDT(elem);
            }
        }
    };

    RadioControls.prototype.add = function(root, id, attributes) {
        var elem;
        if ('undefined' === typeof attributes.name) {
            attributes.name = this.groupName;
        }
        attributes.id = id;
        attributes.type = 'radio';
        elem = W.add('input', root, attributes);
        // Adding the text for the radio button
        elem.appendChild(document.createTextNode(attributes.label));
        return elem;
    };

    RadioControls.prototype.getItem = function(id, attributes) {
        attributes = attributes || {};
        // add the group name if not specified
        // TODO: is this a javascript bug?
        if ('undefined' === typeof attributes.name) {
            attributes.name = this.groupName;
        }
        attributes.id = id;
        attributes.type = 'radio';
        return W.get('input', attributes);
    };

    // Override getAllValues for Radio Controls
    RadioControls.prototype.getValues = function() {
        var key, el;
        for (key in this.features) {
            if (this.features.hasOwnProperty(key)) {
                el = W.getElementById(key);
                if (el.checked) return el.value;                
            }
        }
        return false;
    };

})(node);

/**
 * # CustomInput
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Creates a configurable input form with validation
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('CustomInput', CustomInput);

    // ## Meta-data

    CustomInput.version = '0.12.0';
    CustomInput.description = 'Creates a configurable input form';

    CustomInput.title = false;
    CustomInput.panel = false;
    CustomInput.className = 'custominput';

    CustomInput.types = {
        text: true,
        number: true,
        'float': true,
        'int': true,
        date: true,
        list: true,
        us_city_state_zip: true,
        us_state: true,
        us_zip: true
    };

    var sepNames = {
        ',': 'comma',
        ' ': 'space',
        '.': 'dot'
    };

    var usStates = {
        Alabama: 'AL',
        Alaska: 'AK',
        Arizona: 'AZ',
        Arkansas: 'AR',
        California: 'CA',
        Colorado: 'CO',
        Connecticut: 'CT',
        Delaware: 'DE',
        Florida: 'FL',
        Georgia: 'GA',
        Hawaii: 'HI',
        Idaho: 'ID',
        Illinois: 'IL',
        Indiana: 'IN',
        Iowa: 'IA',
        Kansas: 'KS',
        Kentucky: 'KY',
        Louisiana: 'LA',
        Maine: 'ME',
        Maryland: 'MD',
        Massachusetts: 'MA',
        Michigan: 'MI',
        Minnesota: 'MN',
        Mississippi: 'MS',
        Missouri: 'MO',
        Montana: 'MT',
        Nebraska: 'NE',
        Nevada: 'NV',
        'New Hampshire': 'NH',
        'New Jersey': 'NJ',
        'New Mexico': 'NM',
        'New York': 'NY',
        'North Carolina': 'NC',
        'North Dakota': 'ND',
        Ohio: 'OH',
        Oklahoma: 'OK',
        Oregon: 'OR',
        Pennsylvania: 'PA',
        'Rhode Island': 'RI',
        'South Carolina': 'SC',
        'South Dakota': 'SD',
        Tennessee: 'TN',
        Texas: 'TX',
        Utah: 'UT',
        Vermont: 'VT',
        Virginia: 'VA',
        Washington: 'WA',
        'West Virginia': 'WV',
        Wisconsin: 'WI',
        Wyoming: 'WY',
    };

    var usTerr = {
        'American Samoa': 'AS',
        'District of Columbia': 'DC',
        'Federated States of Micronesia': 'FM',
        Guam: 'GU',
        'Marshall Islands': 'MH',
        'Northern Mariana Islands': 'MP',
        Palau: 'PW',
        'Puerto Rico': 'PR',
        'Virgin Islands': 'VI'
    };

    // To be filled if requested.
    var usTerrByAbbr;
    var usStatesByAbbr;
    var usStatesTerr;
    var usStatesTerrByAbbr;
    // Lower case keys.
    var usStatesLow;
    var usTerrLow;
    var usTerrByAbbrLow;
    var usStatesByAbbrLow;
    var usStatesTerrLow;
    var usStatesTerrByAbbrLow;

    CustomInput.texts = {
        listErr: 'Check that there are no empty items; do not end with ' +
            'the separator',
        listSizeErr: function(w, param) {
            if (w.params.fixedSize) {
                return w.params.minItems + ' items required';
            }
            if (param === 'min') {
                return 'Too few items. Min: ' + w.params.minItems;
            }
            return 'Too many items. Max: ' + w.params.maxItems;

        },
        usStateAbbrErr: 'Not a valid state abbreviation (must be 2 characters)',
        usStateErr: 'Not a valid state (full name required)',
        usZipErr: 'Not a valid ZIP code (must be 5 digits)',
        autoHint: function(w) {
            var res, sep;
            if (w.type === 'list') {
                sep = sepNames[w.params.listSep] || w.params.listSep;
                res = '(if more than one, separate with ' + sep + ')';
            }
            else if (w.type === 'us_state') {
                res = w.params.abbr ? '(Use 2-letter abbreviation)' :
                    '(Type the full name of the state)';
            }
            else if (w.type === 'us_zip') {
                res = '(Use 5-digit ZIP code)';
            }
            else if (w.type === 'us_city_state_zip') {
                sep = w.params.listSep;
                res = '(Format: Town' + sep + ' State' + sep + ' ZIP code)';
            }
            else if (w.type === 'date') {
                if (w.params.minDate && w.params.maxDate) {
                    res = '(Must be between ' + w.params.minDate.str + ' and ' +
                        w.params.maxDate.str + ')';
                }
                else if (w.params.minDate) {
                    res = '(Must be after ' + w.params.minDate.str + ')';
                }
                else if (w.params.maxDate) {
                    res = '(Must be before ' + w.params.maxDate.str + ')';
                }
                else {
                    res = '(Format: ' + w.params.format + ')';
                }
            }
            else if (w.type === 'number' || w.type === 'int' ||
                     w.type === 'float') {

                if (w.params.min && w.params.max) {
                    res = '(Must be between ' + w.params.min + ' and ' +
                        w.params.max + ')';
                }
                else if (w.params.min) {
                    res = '(Must be after ' + w.params.min + ')';
                }
                else if (w.params.max) {
                    res = '(Must be before ' + w.params.max + ')';
                }
            }
            return w.required ? ((res || '') + ' *') : (res || false);
        },
        numericErr: function(w) {
            var str, p;
            p = w.params;
            // Weird, but valid, case.
            if (p.exactly) return 'Must enter ' + p.lower;
            // Others.
            str = 'Must be ';
            if (w.type === 'float') str += 'a floating point number';
            else if (w.type === 'int') str += 'an integer';
            if (p.between) {
                str += ' ' + (p.leq ? '&ge; ' : '<' ) + p.lower;
                str += ' and ';
                str += (p.ueq ? '&le; ' : '> ') + p.upper;
            }
            else if ('undefined' !== typeof p.lower) {
                str += ' ' + (p.leq ? '&ge; ' : '< ') + p.lower;
            }
            // It can be also a non-numeric error, e.g. a string here.
            else if ('undefined' !== typeof p.upper) {
                str += ' ' + (p.ueq ? '&le; ' : '> ') + p.upper;
            }
            return str;
        },
        textErr: function(w, param) {
            var str, p;
            if (param === 'num') return 'Cannot contain numbers';
            p = w.params;
            str = 'Must be ';
            if (p.exactly) {
                str += 'exactly ' + (p.lower + 1);
            }
            else if (p.between) {
                str += 'between ' + p.lower + ' and ' + p.upper;
            }
            else if ('undefined' !== typeof p.lower) {
                str += ' more than ' + (p.lower -1);
            }
            else if ('undefined' !== typeof p.upper) {
                str += ' less than ' + (p.upper + 1);
            }
            str += ' characters long';
            if (p.between) str += ' (extremes included)';
            str += '. Current length: ' + param;
            return str;
        },
        dateErr: function(w, param) {
            if (param === 'invalid') return 'Date is invalid';
            if (param === 'min') {
                return 'Date must be after ' + w.params.minDate.str;
            }
            if (param === 'max') {
                return 'Date must be before ' + w.params.maxDate.str;
            }
            return 'Must follow format ' + w.params.format;
        },
        emptyErr: 'Cannot be empty'
    };

    // ## Dependencies

    CustomInput.dependencies = {
        JSUS: {}
    };

    /**
     * ## CustomInput constructor
     *
     * Creates a new instance of CustomInput
     */
    function CustomInput() {

        /**
         * ### CustomInput.input
         *
         * The HTML input element
         */
        this.input = null;

        /**
         * ### CustomInput.placeholder
         *
         * The placeholder text for the input form
         *
         * Some types preset it automatically
         */
        this.placeholder = null;

        /**
         * ### CustomInput.inputWidth
         *
         * The width of the input form as string (css attribute)
         *
         * Some types preset it automatically
         */
        this.inputWidth = null;

        /**
         * ### CustomInput.type
         *
         * The type of input
         */
        this.type = null;

        /**
         * ### CustomInput.preprocess
         *
         * The function that preprocess the input before validation
         *
         * The function receives the input form and must modify it directly
         */
        this.preprocess = null;

        /**
         * ### CustomInput.validation
         *
         * The validation function for the input
         *
         * The function returns an object like:
         *
         * ```javascript
         *  {
         *    value: 'validvalue',
         *    err:   'This error occurred' // If invalid.
         *  }
         * ```
         */
        this.validation = null;

        /**
         * ### CustomInput.userValidation
         *
         * An additional validation executed after the main validation function
         *
         * Executes only if validation does not fail, takes as input the return
         * value from the validation function which can be modified accordingly.
         *
         * ```javascript
         *  {
         *    value: 'validvalue',
         *    err:   'This error occurred' // If invalid.
         *  }
         * ```
         */
        this.userValidation = null;

        /**
         * ### CustomInput.validationSpeed
         *
         * How often (in milliseconds) the validation function is called
         *
         * Default: 500
         */
        this.validationSpeed = 500;

        /**
         * ### CustomInput.postprocess
         *
         * The function that postprocess the input after validation
         *
         * The function returns the postprocessed value
         */
        this.postprocess = null;

        /**
         * ### CustomInput.oninput
         *
         * A function that is executed after any input
         *
         * It is executed after validation and receives a result object
         * and a reference to this widget.
         */
        this.oninput = null;

        /**
         * ### CustomInput.params
         *
         * Object containing extra validation params
         *
         * This object is populated by the init function
         */
        this.params = {};

        /**
         * ### CustomInput.errorBox
         *
         * An HTML element displayed when a validation error occurs
         */
        this.errorBox = null;

        /**
         * ### CustomInput.mainText
         *
         * A text preceeding the custom input
         */
        this.mainText = null;

        /**
         * ### CustomInput.hint
         *
         * An additional text with information about the input
         *
         * If not specified, it may be auto-filled, e.g. '*'.
         *
         * @see CustomInput.texts.autoHint
         */
        this.hint = null;

        /**
         * ### CustomInput.requiredChoice
         *
         * If TRUE, the input form cannot be left empty
         *
         * Default: TRUE
         *
         * @deprecated Use CustomInput.required
         */
        this.requiredChoice = null;

        /**
         * ### CustomInput.required
         *
         * If TRUE, the input form cannot be left empty
         *
         * Default: TRUE
         */
        this.required = null;

        /**
         * ### CustomInput.timeBegin
         *
         * When the first character was inserted
         */
        this.timeBegin = null;

        /**
         * ### CustomInput.timeEnd
         *
         * When the last character was inserted
         */
        this.timeEnd = null;

        /**
         * ### CustomInput.checkbox
         *
         * A checkbox element for an additional action
         */
        this.checkbox = null;

        /**
         * ### CustomInput.checkboxText
         *
         * The text next to the checkbox
         */
        this.checkboxText = null;

        /**
         * ### CustomInput.checkboxCb
         *
         * The callback executed when the checkbox is clicked
         */
        this.checkboxCb = null;

        /**
         * ### CustomInput.orientation
         *
         * The orientation of main text relative to the input box
         *
         * Options:
         *   - 'V': main text above input box
         *   - 'H': main text next to input box
         *
         * Default: 'V'
         */
        this.orientation = null;
    }

    // ## CustomInput methods

    /**
     * ### CustomInput.init
     *
     * Initializes the instance
     *
     * @param {object} opts Configuration options
     */
    CustomInput.prototype.init = function(opts) {
        var tmp, val, that, e, isText, setValues;
        that = this;
        e = 'CustomInput.init: ';


        // Option orientation, default 'H'.
        if ('undefined' === typeof opts.orientation) {
            tmp = 'V';
        }
        else if ('string' !== typeof opts.orientation) {
            throw new TypeError('CustomInput.init: orientation must ' +
                                'be string, or undefined. Found: ' +
                                opts.orientation);
        }
        else {
            tmp = opts.orientation.toLowerCase().trim();
            if (tmp === 'h') tmp = 'H';
            else if (tmp === 'v') tmp = 'V';
            else {
                throw new Error('CustomInput.init: unknown orientation: ' +
                                tmp);
            }
        }
        this.orientation = tmp;

        // Backward compatible checks.
        // Option required will be used in the future.
        if ('undefined' !== typeof opts.required) {
            this.required = this.requiredChoice = !!opts.required;
        }
        if ('undefined' !== typeof opts.requiredChoice) {
            if (!!this.required !== !!opts.requiredChoice) {
                throw new TypeError('CustomInput.init: required and ' +
                                    'requiredChoice are incompatible. Option ' +
                                    'requiredChoice will be deprecated.');
            }
            this.required = this.requiredChoice = !!opts.requiredChoice;
        }
        if ('undefined' === typeof this.required) {
            this.required = this.requiredChoice = false;
        }

        if (opts.userValidation) {
            if ('function' !== typeof opts.userValidation) {
                throw new TypeError('CustomInput.init: userValidation must ' +
                                    'be function or undefined. Found: ' +
                                    opts.userValidation);
            }
            this.userValidation = opts.userValidation;
        }

        if (opts.type) {
            if (!CustomInput.types[opts.type]) {
                throw new Error(e + 'type not supported: ' + opts.type);
            }
            this.type = opts.type;
        }
        else {
            this.type = 'text';
        }

        if (opts.validation) {
            if ('function' !== typeof opts.validation) {
                throw new TypeError(e + 'validation must be function ' +
                                    'or undefined. Found: ' +
                                    opts.validation);
            }
            val = opts.validation;
        }
        // Add default validations based on type.

        if (this.type === 'number' || this.type === 'float' ||
            this.type === 'int' || this.type === 'text') {

            isText = this.type === 'text';

            // Greater than.
            if ('undefined' !== typeof opts.min) {
                tmp = J.isNumber(opts.min);
                if (false === tmp) {
                    throw new TypeError(e + 'min must be number or ' +
                                        'undefined. Found: ' + opts.min);
                }
                this.params.lower = opts.min;
                this.params.leq = true;
            }
            // Less than.
            if ('undefined' !== typeof opts.max) {
                tmp = J.isNumber(opts.max);
                if (false === tmp) {
                    throw new TypeError(e + 'max must be number or ' +
                                        'undefined. Found: ' + opts.max);
                }
                this.params.upper = opts.max;
                this.params.ueq = true;
            }

            if (opts.strictlyGreater) this.params.leq = false;
            if (opts.strictlyLess) this.params.ueq = false;

            // Checks on both min and max.
            if ('undefined' !== typeof this.params.lower &&
                'undefined' !== typeof this.params.upper) {

                if (this.params.lower > this.params.upper) {
                    throw new TypeError(e + 'min cannot be greater ' +
                                        'than max. Found: ' +
                                        opts.min + '> ' + opts.max);
                }
                // Exact length.
                if (this.params.lower === this.params.upper) {
                    if (!this.params.leq || !this.params.ueq) {

                        throw new TypeError(e + 'min cannot be equal to ' +
                                            'max when strictlyGreater or ' +
                                            'strictlyLess are set. ' +
                                            'Found: ' + opts.min);
                    }
                    if (this.type === 'int' || this.type === 'text') {
                        if (J.isFloat(this.params.lower)) {


                            throw new TypeError(e + 'min cannot be a ' +
                                                'floating point number ' +
                                                'and equal to ' +
                                                'max, when type ' +
                                                'is not "float". Found: ' +
                                                opts.min);
                        }
                    }
                    // Store this to create better error strings.
                    this.params.exactly = true;
                }
                else {
                    // Store this to create better error strings.
                    this.params.between = true;
                }
            }

            // Checks for text only.
            if (isText) {

                this.params.noNumbers = opts.noNumbers;

                if ('undefined' !== typeof this.params.lower) {
                    if (this.params.lower < 0) {
                        throw new TypeError(e + 'min cannot be negative ' +
                                            'when type is "text". Found: ' +
                                            this.params.lower);
                    }
                    if (!this.params.leq) this.params.lower++;
                }
                if ('undefined' !== typeof this.params.upper) {
                    if (this.params.upper < 0) {
                        throw new TypeError(e + 'max cannot be negative ' +
                                            'when type is "text". Found: ' +
                                            this.params.upper);
                    }
                    if (!this.params.ueq) this.params.upper--;
                }

                if (!val) {
                    val = function(value) {
                        var len, p, out, err;
                        p = that.params;
                        len = value.length;
                        out = { value: value };
                        if (p.noNumbers && /\d/.test(value)) {
                            err = that.getText('textErr', 'num');
                        }
                        else {
                            if (p.exactly) {
                                err = len !== p.lower;
                            }
                            else {
                                if (('undefined' !== typeof p.lower &&
                                len < p.lower) ||
                                ('undefined' !== typeof p.upper &&
                                len > p.upper)) {

                                    err = true;
                                }
                            }
                            if (err) err = that.getText('textErr', len);
                        }
                        if (err) out.err = err;
                        return out;
                    };
                }

                setValues = function() {
                    var a, b;
                    a = 'undefined' !== typeof that.params.lower ?
                        (that.params.lower + 1) : 5;
                    b = 'undefined' !== typeof that.params.upper ?
                        that.params.upper : (a + 5);
                    return J.randomString(J.randomInt(a, b));
                };
            }
            else {
                if (!val) {
                    val = (function() {
                        var cb;
                        if (that.type === 'float') cb = J.isFloat;
                        else if (that.type === 'int') cb = J.isInt;
                        else cb = J.isNumber;
                        return function(value) {
                            var res, p;
                            p = that.params;
                            res = cb(value, p.lower, p.upper, p.leq, p.ueq);
                            if (res !== false) return { value: res };
                            return {
                                value: value,
                                err: that.getText('numericErr')
                            };
                        };
                    })();
                }

                setValues = function() {
                    var p, a, b;
                    p = that.params;
                    if (that.type === 'float') return J.random();
                    a = 0;
                    if ('undefined' !== typeof p.lower) {
                        a = p.leq ? (p.lower - 1) : p.lower;
                    }
                    if ('undefined' !== typeof p.upper) {
                        b = p.ueq ? p.upper : (p.upper - 1);
                    }
                    else {
                        b = 100 + a;
                    }
                    return J.randomInt(a, b);
                };
            }

            // Preset inputWidth.
            if (this.params.upper) {
                if (this.params.upper < 10) this.inputWidth = '100px';
                else if (this.params.upper < 20) this.inputWidth = '200px';
            }

        }
        else if (this.type === 'date') {
            if ('undefined' !== typeof opts.format) {
                // TODO: use regex.
                if (opts.format !== 'mm-dd-yy' &&
                    opts.format !== 'dd-mm-yy' &&
                    opts.format !== 'mm-dd-yyyy' &&
                    opts.format !== 'dd-mm-yyyy' &&
                    opts.format !== 'mm.dd.yy' &&
                    opts.format !== 'dd.mm.yy' &&
                    opts.format !== 'mm.dd.yyyy' &&
                    opts.format !== 'dd.mm.yyyy' &&
                    opts.format !== 'mm/dd/yy' &&
                    opts.format !== 'dd/mm/yy' &&
                    opts.format !== 'mm/dd/yyyy' &&
                    opts.format !== 'dd/mm/yyyy') {

                    throw new Error(e + 'date format is invalid. Found: ' +
                                    opts.format);
                }
                this.params.format = opts.format;
            }
            else {
                this.params.format = 'mm/dd/yyyy';
            }

            this.params.sep = this.params.format.charAt(2);
            tmp = this.params.format.split(this.params.sep);
            this.params.yearDigits = tmp[2].length;
            this.params.dayPos = tmp[0].charAt(0) === 'd' ? 0 : 1;
            this.params.monthPos =  this.params.dayPos ? 0 : 1;
            this.params.dateLen = tmp[2].length + 6;
            if (opts.minDate) {
                tmp = getParsedDate(opts.minDate, this.params);
                if (!tmp) {
                    throw new Error(e + 'minDate must be a Date object. ' +
                                    'Found: ' + opts.minDate);
                }
                this.params.minDate = tmp;
            }
            if (opts.maxDate) {
                tmp = getParsedDate(opts.maxDate, this.params);
                if (!tmp) {
                    throw new Error(e + 'maxDate must be a Date object. ' +
                                    'Found: ' + opts.maxDate);
                }
                if (this.params.minDate &&
                    this.params.minDate.obj > tmp.obj) {

                    throw new Error(e + 'maxDate cannot be prior to ' +
                                    'minDate. Found: ' + tmp.str +
                                    ' < ' + this.params.minDate.str);
                }
                this.params.maxDate = tmp;
            }

            // Preset inputWidth.
            if (this.params.yearDigits === 2) this.inputWidth = '100px';
            else this.inputWidth = '150px';

            // Preset placeholder.
            this.placeholder = this.params.format;

            if (!val) {
                val = function(value) {
                    var p, tokens, tmp, res, dayNum, l1, l2;
                    p = that.params;

                    // Is the format valid.

                    tokens = value.split(p.sep);
                    if (tokens.length !== 3) {
                        return { err: that.getText('dateErr') };
                    }

                    // Year.
                    if (tokens[2].length !== p.yearDigits) {
                        return { err: that.getText('dateErr') };
                    }

                    // Now we check if the date is valid.

                    res = {};
                    if (p.yearDigits === 2) {
                        l1 = -1;
                        l2 = 100;
                    }
                    else {
                        l1 = -1;
                        l2 = 10000;
                    }
                    tmp = J.isInt(tokens[2], l1, l2);
                    if (tmp !== false) res.year = tmp;
                    else res.err = true;

                    // Month.
                    tmp = J.isInt(tokens[p.monthPos], 1, 12, 1, 1);
                    if (!tmp) res.err = true;
                    else res.month = tmp;
                    // 31 or 30 days?
                    if (tmp === 1 || tmp === 3 || tmp === 5 || tmp === 7 ||
                        tmp === 8 || tmp === 10 || tmp === 12) {

                        dayNum = 31;
                    }
                    else if (tmp !== 2) {
                        dayNum = 30;
                    }
                    else {
                        // Is it leap year?
                        dayNum = (res.year % 4 === 0 && res.year % 100 !== 0) ||
                        res.year % 400 === 0 ? 29 : 28;
                    }
                    res.month = tmp;
                    // Day.
                    tmp = J.isInt(tokens[p.dayPos], 1, dayNum, 1, 1);
                    if (!tmp) res.err = true;
                    else res.day = tmp;

                    if (res.err) {
                        res.err = that.getText('dateErr', 'invalid');
                    }
                    else if (p.minDate || p.maxDate) {
                        tmp = new Date(value);
                        if (p.minDate.obj && p.minDate.obj > tmp) {
                            res.err = that.getText('dateErr', 'min');
                        }
                        else if (p.maxDate.obj && p.maxDate.obj < tmp) {
                            res.err = that.getText('dateErr', 'max');
                        }
                    }
                    if (!res.err) {
                        res.value = value;
                        res = { value: res };
                    }
                    return res;
                };
            }

            setValues = function() {
                var p, minD, maxD, d, day, month, year;
                p = that.params;
                minD = p.minDate ? p.minDate.obj : new Date('01/01/1900');
                maxD = p.maxDate ? p.maxDate.obj : undefined;
                d = J.randomDate(minD, maxD);
                day = d.getDate();
                month = (d.getMonth() + 1);
                year = d.getFullYear();
                if (p.yearDigits === 2) year = ('' + year).substr(2);
                if (p.monthPos === 0) d = month + p.sep + day;
                else d = day + p.sep + month;
                d += p.sep + year;
                return d;
            };
        }
        else if (this.type === 'us_state') {
            if (opts.abbreviation) {
                this.params.abbr = true;
                this.inputWidth = '100px';
            }
            else {
                this.inputWidth = '200px';
            }
            if (opts.territories !== false) {
                this.terr = true;
                if (this.params.abbr) {
                    tmp = getUsStatesList('usStatesTerrByAbbrLow');
                }
                else {
                    tmp = getUsStatesList('usStatesTerrLow');
                }
            }
            else {
                if (this.params.abbr) {
                    tmp = getUsStatesList('usStatesByAbbrLow');
                }
                else {
                    tmp = getUsStatesList('usStatesLow');
                }
            }
            this.params.usStateVal = tmp;

            if (!val) {
                val = function(value) {
                    var res;
                    res = { value: value };
                    if (!that.params.usStateVal[value.toLowerCase()]) {
                        res.err = that.getText('usStateErr');
                    }
                    return res;
                };
            }

            setValues = function() {
                return J.randomKey(that.params.usStateVal);
            };

        }
        else if (this.type === 'us_zip') {
            if (val) {
                val = function(value) {
                    var res;
                    res = { value: value };
                    if (!isValidUSZip(value)) {
                        res.err = that.getText('usZipErr');
                    }
                    return res;
                };
            }

            setValues = function() {
                return Math.floor(Math.random()*90000) + 10000;
            };
        }

        // Lists.

        else if (this.type === 'list' ||
                 this.type === 'us_city_state_zip') {

            if (opts.listSeparator) {
                if ('string' !== typeof opts.listSeparator) {
                    throw new TypeError(e + 'listSeparator must be ' +
                                        'string or undefined. Found: ' +
                                        opts.listSeperator);
                }
                this.params.listSep = opts.listSeparator;
            }
            else {
                this.params.listSep = ',';
            }

            if (this.type === 'us_city_state_zip') {

                getUsStatesList('usStatesTerrByAbbr');
                this.params.minItems = this.params.maxItems = 3;
                this.params.fixedSize = true;
                this.params.itemValidation = function(item, idx) {
                    if (idx === 2) {
                        if (!usStatesTerrByAbbr[item.toUpperCase()]) {
                            return { err: that.getText('usStateAbbrErr') };
                        }
                    }
                    else if (idx === 3) {
                        if (!isValidUSZip(item)) {
                            return { err: that.getText('usZipErr') };
                        }
                    }
                };

                this.placeholder = 'Town' + this.params.listSep +
                    ' State' + this.params.listSep + ' ZIP';
            }
            else {
                if ('undefined' !== typeof opts.minItems) {
                    tmp = J.isInt(opts.minItems, 0);
                    if (tmp === false) {
                        throw new TypeError(e + 'minItems must be ' +
                                            'a positive integer. Found: ' +
                                            opts.minItems);
                    }
                    this.params.minItems = tmp;
                }
                else if (this.required) {
                    this.params.minItems = 1;
                }
                if ('undefined' !== typeof opts.maxItems) {
                    tmp = J.isInt(opts.maxItems, 0);
                    if (tmp === false) {
                        throw new TypeError(e + 'maxItems must be ' +
                                            'a positive integer. Found: ' +
                                            opts.maxItems);
                    }
                    if (this.params.minItems &&
                        this.params.minItems > tmp) {

                        throw new TypeError(e + 'maxItems must be larger ' +
                                            'than minItems. Found: ' +
                                            tmp + ' < ' +
                                            this.params.minItems);
                    }
                    this.params.maxItems = tmp;
                }
            }

            if (!val) {
                val = function(value) {
                    var i, len, v, iVal, err;
                    value = value.split(that.params.listSep);
                    len = value.length;
                    if (!len) return value;
                    iVal = that.params.itemValidation;
                    i = 0;
                    v = value[0].trim();
                    if (!v) return { err: that.getText('listErr') };
                    if (iVal) {
                        err = iVal(v, 1);
                        if (err) return err;
                    }
                    value[i++] = v;
                    if (len > 1) {
                        v = value[1].trim();
                        if (!v) return { err: that.getText('listErr') };
                        if (iVal) {
                            err = iVal(v, (i+1));
                            if (err) return err;
                        }
                        value[i++] = v;
                    }
                    if (len > 2) {
                        v = value[2].trim();
                        if (!v) return { err: that.getText('listErr') };
                        if (iVal) {
                            err = iVal(v, (i+1));
                            if (err) return err;
                        }
                        value[i++] = v;
                    }
                    if (len > 3) {
                        for ( ; i < len ; ) {
                            v = value[i].trim();
                            if (!v) return { err: that.getText('listErr') };
                            if (iVal) {
                                err = iVal(v, (i+1));
                                if (err) return err;
                            }
                            value[i++] = v;
                        }
                    }
                    // Need to do it here, because some elements might be empty.
                    if (that.params.minItems && i < that.params.minItems) {
                        return { err: that.getText('listSizeErr', 'min') };
                    }
                    if (that.params.maxItems && i > that.params.maxItems) {
                        return { err: that.getText('listSizeErr', 'max') };
                    }
                    return { value: value };
                };
            }

            if (this.type === 'us_city_state_zip') {
                setValues = function() {
                    var sep;
                    sep = that.params.listSep + ' ';
                    return J.randomString(8) + sep +
                        J.randomKey(usStatesTerrByAbbr) + sep +
                        (Math.floor(Math.random()*90000) + 10000);
                };
            }
            else {
                setValues = function(opts) {
                    var p, minItems, nItems, i, str, sample;
                    p = that.params;
                    minItems = p.minItems || 0;
                    if (opts.availableValues) {
                        nItems = J.randomInt(minItems,
                                             opts.availableValues.length);
                        nItems--;
                        sample = J.sample(0, (nItems-1));
                    }
                    else {
                        nItems = J.randomInt(minItems,
                                             p.maxItems || (minItems + 5));
                        nItems--;
                    }
                    str = '';
                    for (i = 0; i < nItems; i++) {
                        if (i !== 0) str += p.listSep + ' ';
                        if (sample) str += opts.availableValues[sample[i]];
                        else str += J.randomString(J.randomInt(3,10));
                    }
                    return str;
                };
            }

            // US_Town,State, Zip Code

            // TODO: add other types, e.g., email.
        }

        // Variable tmp contains a validation function, either from
        // defaults, or from user option.

        this.validation = function(value) {
            var res;
            res = { value: value };
            if (value.trim() === '') {
                if (that.required) res.err = that.getText('emptyErr');
            }
            else if (val) {
                res = val.call(this, value);
            }
            if (that.userValidation) that.userValidation.call(this, res);
            return res;
        };

        this._setValues = setValues;

        // Preprocess

        if (opts.preprocess) {
            if ('function' !== typeof opts.preprocess) {
                throw new TypeError(e + 'preprocess must be function or ' +
                                    'undefined. Found: ' + opts.preprocess);
            }
            this.preprocess = opts.preprocess;
        }
        else if (opts.preprocess !== false) {

            if (this.type === 'date') {
                this.preprocess = function(input) {
                    var sep, len;
                    len = input.value.length;
                    sep = that.params.sep;
                    if (len === 2) {
                        if (input.selectionStart === 2) {
                            if (input.value.charAt(1) !== sep) {
                                input.value += sep;
                            }
                        }
                    }
                    else if (len === 5) {
                        if (input.selectionStart === 5) {
                            if (input.value.charAt(4) !== sep &&
                                (input.value.split(sep).length - 1) === 1) {

                                input.value += sep;
                            }
                        }
                    }
                    else if (len > this.params.dateLen) {
                        input.value =
                            input.value.substring(0, this.params.dateLen);
                    }
                };
            }
            else if (this.type === 'list' ||
                     this.type === 'us_city_state_zip') {

                // Add a space after separator, if separator is not space.
                if (this.params.listSep.trim() !== '') {
                    this.preprocess = function(input) {
                        var sep, len;
                        len = input.value.length;
                        sep = that.params.listSep;
                        if (len > 1 &&
                            len === input.selectionStart &&
                            input.value.charAt(len-1) === sep &&
                            input.value.charAt(len-2) !== sep) {

                            input.value += ' ';
                        }
                    };
                }
            }
        }

        // Postprocess.

        if (opts.postprocess) {
            if ('function' !== typeof opts.postprocess) {
                throw new TypeError(e + 'postprocess must be function or ' +
                                    'undefined. Found: ' + opts.postprocess);
            }
            this.postprocess = opts.postprocess;
        }
        else {
            // Add postprocess as needed.
        }

        // Oninput.

        if (opts.oninput) {
            if ('function' !== typeof opts.oninput) {
                throw new TypeError(e + 'oninput must be function or ' +
                                    'undefined. Found: ' + opts.oninput);
            }
            this.oninput = opts.oninput;
        }

        // Validation Speed
        if ('undefined' !== typeof opts.validationSpeed) {
            tmp = J.isInt(opts.valiadtionSpeed, 0, undefined, true);
            if (tmp === false) {
                throw new TypeError(e + 'validationSpeed must a non-negative ' +
                                    'number or undefined. Found: ' +
                                    opts.validationSpeed);
            }
            this.validationSpeed = tmp;
        }

        // MainText, Hint, and other visuals.

        if (opts.mainText) {
            if ('string' !== typeof opts.mainText) {
                throw new TypeError(e + 'mainText must be string or ' +
                                    'undefined. Found: ' + opts.mainText);
            }
            this.mainText = opts.mainText;
        }
        if ('undefined' !== typeof opts.hint) {
            if (false !== opts.hint && 'string' !== typeof opts.hint) {
                throw new TypeError(e + 'hint must be a string, false, or ' +
                                    'undefined. Found: ' + opts.hint);
            }
            this.hint = opts.hint;
            if (this.required) this.hint += ' *';
        }
        else {
            this.hint = this.getText('autoHint');
        }
        if (opts.placeholder) {
            if ('string' !== typeof opts.placeholder) {
                throw new TypeError(e + 'placeholder must be string or ' +
                                    'undefined. Found: ' + opts.placeholder);
            }
            this.placeholder = opts.placeholder;
        }
        if (opts.width) {
            if ('string' !== typeof opts.width) {
                throw new TypeError(e + 'width must be string or ' +
                                    'undefined. Found: ' + opts.width);
            }
            this.inputWidth = opts.width;
        }

        if (opts.checkboxText) {
            if ('string' !== typeof opts.checkboxText) {
                throw new TypeError(e + 'checkboxText must be string or ' +
                                    'undefined. Found: ' + opts.checkboxText);
            }
            this.checkboxText = opts.checkboxText;
        }

        if (opts.checkboxCb) {
            if (!this.checkboxText) {
                throw new TypeError(e + 'checkboxCb cannot be defined ' +
                                    'if checkboxText is not defined');
            }
            if ('function' !== typeof opts.checkboxCb) {
                throw new TypeError(e + 'checkboxCb must be function or ' +
                                    'undefined. Found: ' + opts.checkboxCb);
            }
            this.checkboxCb = opts.checkboxCb;
        }
    };


    /**
     * ### CustomInput.append
     *
     * Implements Widget.append
     *
     * @see Widget.append
     */
    CustomInput.prototype.append = function() {
        var that, timeout;
        that = this;

        // MainText.
        if (this.mainText) {
            this.spanMainText = W.append('span', this.bodyDiv, {
                className: 'custominput-maintext',
                innerHTML: this.mainText
            });
        }
        // Hint.
        if (this.hint) {
            W.append('span', this.spanMainText || this.bodyDiv, {
                className: 'custominput-hint',
                innerHTML: this.hint
            });
        }

        this.input = W.append('input', this.bodyDiv);
        if (this.placeholder) this.input.placeholder = this.placeholder;
        if (this.inputWidth) this.input.style.width = this.inputWidth;

        this.errorBox = W.append('div', this.bodyDiv, { className: 'errbox' });

        this.input.oninput = function() {
            if (!that.timeBegin) {
                that.timeEnd = that.timeBegin = node.timer.getTimeSince('step');
            }
            else {
                that.timeEnd = node.timer.getTimeSince('step');
            }
            if (timeout) clearTimeout(timeout);
            if (that.isHighlighted()) that.unhighlight();
            if (that.preprocess) that.preprocess(that.input);
            timeout = setTimeout(function() {
                var res;
                if (that.validation) {
                    res = that.validation(that.input.value);
                    if (res.err) that.setError(res.err);
                }
                // In case something else needs to be updated.
                if (that.oninput) that.oninput(res, that);
            }, that.validationSpeed);
        };
        this.input.onclick = function() {
            if (that.isHighlighted()) that.unhighlight();
        };


        // Checkbox.
        if (this.checkboxText) {
            this.checkbox = W.append('input', this.bodyDiv, {
                type: 'checkbox',
                className: 'custominput-checkbox'
            });
            W.append('span', this.bodyDiv, {
                className: 'custominput-checkbox-text',
                innerHTML: this.checkboxText
            });

            if (this.checkboxCb) {
                J.addEvent(this.checkbox, 'change', function() {
                    that.checkboxCb(that.checkbox.checked, that);
                });
            }
        }
    };

    /**
     * ### CustomInput.setError
     *
     * Set the error msg inside the errorBox and call highlight
     *
     * @param {string} The error msg (can contain HTML)
     *
     * @see CustomInput.highlight
     * @see CustomInput.errorBox
     */
    CustomInput.prototype.setError = function(err) {
        this.errorBox.innerHTML = err;
        this.highlight();
    };

    /**
     * ### CustomInput.highlight
     *
     * Highlights the input
     *
     * @param {string} The style for the table's border.
     *   Default '3px solid red'
     *
     * @see CustomInput.highlighted
     */
    CustomInput.prototype.highlight = function(border) {
        if (border && 'string' !== typeof border) {
            throw new TypeError('CustomInput.highlight: border must be ' +
                                'string or undefined. Found: ' + border);
        }
        if (!this.input || this.highlighted) return;
        this.input.style.border = border || '3px solid red';
        this.highlighted = true;
        this.emit('highlighted', border);
    };

    /**
     * ### CustomInput.unhighlight
     *
     * Removes highlight from the input
     *
     * @see CustomInput.highlighted
     */
    CustomInput.prototype.unhighlight = function() {
        if (!this.input || this.highlighted !== true) return;
        this.input.style.border = '';
        this.highlighted = false;
        this.errorBox.innerHTML = '';
        this.emit('unhighlighted');
    };

    /**
     * ### CustomInput.disable
     *
     * Disables the widget
     *
     * @see CustomInput.disabled
     */
    CustomInput.prototype.disable = function(opts) {
        if (this.disabled) return;
        if (!this.isAppended()) return;
        this.disabled = true;
        this.input.disabled = true;
        if (this.checkbox && (!opts || opts.checkbox !== false)) {
            this.checkbox.disable = true;
        }
        this.emit('disabled');
    };

    /**
     * ### CustomInput.enable
     *
     * Enables the widget
     *
     * @see CustomInput.disabled
     */
    CustomInput.prototype.enable = function(opts) {
        if (this.disabled !== true) return;
        if (!this.isAppended()) return;
        this.disabled = false;
        this.input.disabled = false;
        if (this.checkbox && (!opts || opts.checkbox !== false)) {
            this.checkbox.disable = false;
        }
        this.emit('enabled');
    };

    /**
     * ### CustomInput.reset
     *
     * Resets the widget
     */
    CustomInput.prototype.reset = function() {
        if (this.input) this.input.value = '';
        if (this.isHighlighted()) this.unhighlight();
        this.timeBegin = this.timeEnd = null;
    };

    /**
     * ### CustomInput.getValues
     *
     * Returns the value currently in the input
     *
     * The postprocess function is called if specified
     *
     * @param {object} opts Optional. Configures the return value.
     *   Available options:
     *
     *   - markAttempt: If TRUE, getting the value counts as an attempt
     *       to find the correct answer. Default: TRUE.
     *   - highlight:   If TRUE, if current value is not the correct
     *       value, widget will be highlighted. Default: TRUE.
     *   - reset:       If TRUTHY and a correct choice is selected (or not
     *       specified), then it resets the state of the widgets before
     *       returning it. Default: FALSE.
     *
     * @return {mixed} The value in the input
     *
     * @see CustomInput.reset
     */
    CustomInput.prototype.getValues = function(opts) {
        var res, valid;
        opts = opts || {};
        res = this.input.value;
        if (opts.valuesOnly) return res;
        if ('undefined' === typeof opts.markAttempt) opts.markAttempt = true;
        if ('undefined' === typeof opts.highlight) opts.highlight = true;
        res = this.validation ? this.validation(res) : { value: res };
        valid = !res.err;
        res.timeBegin = this.timeBegin;
        res.timeEnd = this.timeEnd;
        if (this.postprocess) res.value = this.postprocess(res.value, valid);
        if (!valid) {
            if (opts.highlight) this.setError(res.err);
            if (opts.markAttempt) res.isCorrect = false;
        }
        else {
            if (opts.markAttempt) res.isCorrect = true;
            if (opts.reset) this.reset();
        }
        if (this.checkbox) res.checked = this.checkbox.checked;
        res.id = this.id;
        return res;
    };

    /**
     * ### CustomInput.setValues
     *
     * Set the value of the input form
     *
     * @param {object} opts An object containing values or info about how
     *   how to set values.
     *
     * @experimental
     */
    CustomInput.prototype.setValues = function(opts) {
        var value, tmp;
        opts = opts || {};
        if ('undefined' !== typeof opts.value) {
            value = opts.value;
        }
        // Alias.
        else if ('undefined' !== typeof opts.values) {
            value = opts.values;
        }
        else if (opts.availableValues) {
            tmp = opts.availableValues;
            if (!J.isArray(tmp) || !tmp.length) {
                throw new TypeError('CustomInput.setValues: availableValues ' +
                                    'must be a non-empty array or undefined. ' +
                                    'Found: ' + tmp);
            }
            if (this.type === 'list') {
                if (tmp.length < this.params.minItems) {
                    throw new Error('CustomInput.setValues: availableValues ' +
                                    'must be a non-empty array or undefined. ' +
                                    'Found: ' + tmp);
                }
                value = this._setValues(opts);
            }
            else {
                value = tmp[J.randomInt(0, tmp.length) -1];
            }
        }
        else {
            value = this._setValues(opts);
        }
        this.input.value = value;
        if (this.preprocess) this.preprocess(this.input);
    };

    // ## Helper functions.

    // ### getParsedDate
    //
    // Tries to parse a date object, catches exceptions
    //
    // @param {string|Date} d The date object
    // @param {object} p The configuration object for date format
    //
    // @return {object|boolean} An object with the parsed date or false
    //   if an error occurred
    //
    function getParsedDate(d, p) {
        var res, day;
        if ('string' === typeof d) {
            d = d === 'today' ? new Date() : new Date(d);
            // If invalid  date it return NaN.
            day = d.getDate();
            if (!day) return false;
        }
        try {
            res = {
                day: day || d.getDate(),
                month: d.getMonth() + 1,
                year: d.getFullYear(),
                obj: d
            };
        }
        catch(e) {
            return false;
        }
        res.str = (p.dayPos ? res.day + p.sep + res.month :
                   res.month + p.sep + res.day) + p.sep;
        res.str += p.yearDigits === 2 ? res.year.substring(3,4) : res.year;
        return res;
    }



    // ### getUsStatesList
    //
    // Sets the value of a global variable and returns it.
    //
    // @param {string} s A string specifying the type of list
    //
    // @return {object} The requested list
    //
    function getUsStatesList(s) {
        switch(s) {

        case 'usStatesTerrByAbbrLow':
            if (!usStatesTerrByAbbrLow) {
                getUsStatesList('usStatesTerrLow');
                usStatesTerrByAbbrLow = J.reverseObj(usStatesTerr, toLK);
            }
            return usStatesTerrByAbbrLow;
        case 'usStatesTerrByAbbr':
            if (!usStatesTerrByAbbr) {
                getUsStatesList('usStatesTerr');
                usStatesTerrByAbbr = J.reverseObj(usStatesTerr);
            }
            return usStatesTerrByAbbr;

        case 'usTerrByAbbrLow':
            if (!usTerrByAbbrLow) usTerrByAbbrLow = J.reverseObj(usTerr, toLK);
            return usTerrByAbbrLow;
        case 'usTerrByAbbr':
            if (!usTerrByAbbr) usTerrByAbbr = J.reverseObj(usTerr);
            return usTerrByAbbr;

        case 'usStatesByAbbrLow':
            if (!usStatesByAbbrLow) {
                usStatesByAbbrLow = J.reverseObj(usStates, toLK);
            }
            return usStatesByAbbrLow;
        case 'usStatesByAbbr':
            if (!usStatesByAbbr) usStatesByAbbr = J.reverseObj(usStates);
            return usStatesByAbbr;

        case 'usStatesTerrLow':
            if (!usStatesTerrLow) {
                if (!usStatesLow) usStatesLow = objToLK(usStates);
                if (!usTerrLow) usTerrLow = objToLK(usTerr);
                usStatesTerrLow = J.merge(usStatesLow, usTerrLow);
            }
            return usStatesTerrLow;
        case 'usStatesTerr':
            if (!usStatesTerr) usStatesTerr = J.merge(usStates, usTerr);
            return usStatesTerr;

        case 'usStatesLow':
            if (!usStatesLow) usStatesLow = objToLK(usStates);
            return usStatesLow;
        case 'usStates':
            return usStates;

        case 'usTerrLow':
            if (!usTerrLow) usTerrLow = objToLK(usTerr);
            return usTerrLow;
        case 'usTerr':
            return usTerr;

        default:
            throw new Error('getUsStatesList: unknown request: ' + s);
        }
    }

    // Helper function for getUsStatesList
    // @see OBJ.reverseObj
    function toLK(key, value) {
        return [ key.toLowerCase(), value ];
    }
    // Helper function for getUsStatesList
    function objToLK(obj) {
        var p, objLow;
        objLow = {};
        for (p in obj) {
            if (obj.hasOwnProperty(p)) {
                objLow[p.toLowerCase()] = obj[p];
            }
        }
        return objLow;
    }

    // ### isValidUSZip
    //
    // Trivial validation of a US ZIP code
    //
    // @param {string} z
    //
    // @return {boolean} TRUE if valid
    //
    function isValidUSZip(z) {
        return z.length === 5 && J.isInt(z, 0);
    }

})(node);

/**
 * # CustomInputGroup
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Creates a table that groups together several custom input widgets
 *
 * @see CustomInput
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('CustomInputGroup', CustomInputGroup);

    // ## Meta-data

    CustomInputGroup.version = '0.3.0';
    CustomInputGroup.description = 'Groups together and manages sets of ' +
        'CustomInput widgets.';

    CustomInputGroup.title = false;
    CustomInputGroup.className = 'custominput custominputgroup';

    CustomInputGroup.separator = '::';

    CustomInputGroup.texts.autoHint = function(w) {
        if (w.requiredChoice) return '*';
        else return false;
    };
    CustomInputGroup.texts.inputErr = 'One or more errors detected.';

    // ## Dependencies

    CustomInputGroup.dependencies = {
        JSUS: {}
    };

    /**
     * ## CustomInputGroup constructor
     *
     * Creates a new instance of CustomInputGroup
     *
     * @param {object} options Optional. Configuration options.
     *   If a `table` option is specified, it sets it as main
     *   table. All other options are passed to the init method.
     */
    function CustomInputGroup() {

        /**
         * ### CustomInputGroup.dl
         *
         * The table containing all the custom inputs
         */
        this.table = null;

        /**
         * ### CustomInputGroup.trs
         *
         * Collection of all trs created
         *
         * Useful when shuffling items/choices
         *
         * @see CustomInputGroup.shuffle
         */
        this.trs = [];

        /**
         * ### CustomInputGroup.mainText
         *
         * The main text introducing the choices
         *
         * @see CustomInputGroup.spanMainText
         */
        this.mainText = null;

        /**
         * ### CustomInputGroup.spanMainText
         *
         * The span containing the main text
         */
        this.spanMainText = null;

        /**
         * ### CustomInputGroup.hint
         *
         * An additional text with information about how to select items
         *
         * If not specified, it may be auto-filled, e.g. '(pick 2)'.
         *
         * @see Feedback.texts.autoHint
         */
        this.hint = null;

        /**
         * ### CustomInputGroup.items
         *
         * The array of available items
         */
        this.items = null;

        /**
         * ### CustomInputGroup.itemsById
         *
         * Map of items ids to items
         */
        this.itemsById = {};

        /**
         * ### CustomInputGroup.itemsMap
         *
         * Maps items ids to the position in the items array
         */
        this.itemsMap = {};

        /**
         * ### CustomInputGroup.choices
         *
         * Array of default choices (if passed as global parameter)
         */
        this.choices = null;

        /**
         * ### CustomInputGroup.choicesById
         *
         * Map of items choices ids to corresponding cell
         *
         * Useful to detect clickable cells.
         */
        this.choicesById = {};

        /**
         * ### CustomInputGroup.itemsSettings
         *
         * The array of settings for each item
         */
        this.itemsSettings = null;

        /**
         * ### CustomInputGroup.order
         *
         * The current order of display of choices
         *
         * May differ from `originalOrder` if shuffled.
         *
         * @see CustomInputGroup.originalOrder
         */
        this.order = null;

        /**
         * ### CustomInputGroup.originalOrder
         *
         * The initial order of display of choices
         *
         * @see CustomInput.order
         */
        this.originalOrder = null;

        /**
         * ### CustomInputGroup.shuffleItems
         *
         * If TRUE, items are inserted in random order
         *
         * @see CustomInputGroup.order
         */
        this.shuffleItems = null;

        /**
         * ### CustomInputGroup.requiredChoice
         *
         * The number of required choices.
         */
        this.requiredChoice = null;

        /**
         * ### ChoiceManager.required
         *
         * TRUE if widget should be checked upon node.done.
         *
         * TODO: Harmonize required and requiredChoice
         */
        this.required = null;

        /**
         * ### CustomInputGroup.orientation
         *
         * Orientation of display of items: vertical ('V') or horizontal ('H')
         *
         * Default orientation is vertical.
         */
        this.orientation = 'V';

        /**
         * ### CustomInputGroup.group
         *
         * The name of the group where the table belongs, if any
         */
        this.group = null;

        /**
         * ### CustomInputGroup.groupOrder
         *
         * The order of the choice table within the group
         */
        this.groupOrder = null;

        /**
         * ### CustomInputGroup.freeText
         *
         * If truthy, a textarea for free-text comment will be added
         *
         * If 'string', the text will be added inside the the textarea
         */
        this.freeText = null;

        /**
         * ### CustomInputGroup.textarea
         *
         * Textarea for free-text comment
         */
        this.textarea = null;

        // Options passed to each individual item.

        /**
         * ### CustomInputGroup.timeFrom
         *
         * Time is measured from timestamp as saved by node.timer
         *
         * Default event is a new step is loaded (user can interact with
         * the screen). Set it to FALSE, to have absolute time.
         *
         * This option is passed to each individual item.
         *
         * @see mixinSettings
         *
         * @see node.timer.getTimeSince
         */
        this.timeFrom = 'step';

        /**
         * ### CustomInputGroup.separator
         *
         * Symbol used to separate tokens in the id attribute of every cell
         *
         * Default CustomInputGroup.separator
         *
         * This option is passed to each individual item.
         *
         * @see mixinSettings
         */
        this.separator = CustomInputGroup.separator;

        /**
         * ### CustomInputGroup.shuffleChoices
         *
         * If TRUE, choices in items are shuffled
         *
         * This option is passed to each individual item.
         *
         * @see mixinSettings
         */
        this.shuffleChoices = null;

        /**
         * ### CustomInputGroup.sharedOptions
         *
         * An object containing options to be added to every custom input
         *
         * Options are added only if forms are specified as object literals,
         * and can be overriden by each individual form.
         */
        this.sharedOptions = {};

        /**
         * ### CustomInputGroup.summaryInput
         *
         * A summary custom input added last which can be updated in real time
         *
         * @see CustomInputGroup.summaryInputCb
         */
        this.summaryInput = null;

        /**
         * ### CustomInputGroup.errorBox
         *
         * An HTML element displayed when a validation error occurs
         */
        this.errorBox = null;

        /**
         * ### CustomInputGroup.validation
         *
         * The callback validating all the inputs at once
         *
         * The callback is executed by getValues.
         *
         * Input paramers:
         *
         * - res: the validation result of all inputs
         * - values: object literal containing the current value of each input
         * - widget: a reference to this widget
         *
         * Return value:
         *
         * - res: the result object as it is on success, or with with an err
         *        property containing the error message on failure. Any change
         *        to the result object is carried over.
         *
         * @see CustomInputGroup.oninput
         */
        this.validation = null;

        /**
         * ### CustomInputGroup._validation
         *
         * Reference to the user defined validation function
         *
         * @api private
         */
        this._validation = null;

        /**
         * ### CustomInputGroup.oninput
         *
         * Callback called when any input has changed
         *
         * Input paramers:
         *
         * - res: the validation result of the single input
         * - input: the custom input that fired oninput
         * - widget: a reference to this widget
         */
        this.oninput = null;

        /**
         * ### CustomInputGroup._oninput
         *
         * Reference to the user defined oninput function
         *
         * @api private
         */
        this._oninput = null;
    }

    // ## CustomInputGroup methods

    /**
     * ### CustomInputGroup.init
     *
     * Initializes the instance
     *
     * Available options are:
     *
     *   - className: the className of the table (string, array), or false
     *       to have none.
     *   - orientation: orientation of the table: vertical (v) or horizontal (h)
     *   - group: the name of the group (number or string), if any
     *   - groupOrder: the order of the table in the group, if any
     *   - onclick: a custom onclick listener function. Context is
     *       `this` instance
     *   - mainText: a text to be displayed above the table
     *   - shuffleItems: if TRUE, items are shuffled before being added
     *       to the table
     *   - freeText: if TRUE, a textarea will be added under the table,
     *       if 'string', the text will be added inside the the textarea
     *   - timeFrom: The timestamp as recorded by `node.timer.setTimestamp`
     *       or FALSE, to measure absolute time for current choice
     *   - sharedOptions: Options shared across all inputs
     *   - summary: An object containing the options to instantiate a custom
     *       input summary field.
     *   - validation: A validation callback for all inputs.
     *   - oninput: A callback called when any input is changed
     *
     * @param {object} opts Configuration options
     */
    CustomInputGroup.prototype.init = function(opts) {
        var tmp, that;
        that = this;

        // TODO: many options checking are replicated. Skip them all?
        // Have a method in CustomInput?

        if (!this.id) {
            throw new TypeError('CustomInputGroup.init: id ' +
                                'is missing.');
        }

        // Option orientation, default 'H'.
        if ('undefined' === typeof opts.orientation) {
            tmp = 'V';
        }
        else if ('string' !== typeof opts.orientation) {
            throw new TypeError('CustomInputGroup.init: orientation ' +
                                'must be string, or undefined. Found: ' +
                                opts.orientation);
        }
        else {
            tmp = opts.orientation.toLowerCase().trim();
            if (tmp === 'horizontal' || tmp === 'h') {
                tmp = 'H';
            }
            else if (tmp === 'vertical' || tmp === 'v') {
                tmp = 'V';
            }
            else {
                throw new Error('CustomInputGroup.init: orientation ' +
                                'is invalid: ' + tmp);
            }
        }
        this.orientation = tmp;

        // Option shuffleItems, default false.
        if ('undefined' === typeof opts.shuffleItems) tmp = false;
        else tmp = !!opts.shuffleItems;
        this.shuffleItems = tmp;

        // Option requiredChoice, if any.
        if ('number' === typeof opts.requiredChoice) {
            this.requiredChoice = opts.requiredChoice;
        }
        else if ('boolean' === typeof opts.requiredChoice) {
            this.requiredChoice = opts.requiredChoice ? 1 : 0;
        }
        else if ('undefined' !== typeof opts.requiredChoice) {
            throw new TypeError('CustomInputGroup.init: ' +
                                'requiredChoice ' +
                                'be number or boolean or undefined. Found: ' +
                                opts.requiredChoice);
        }

        if ('undefined' !== typeof opts.required) {
            this.required = !!opts.required;
        }

        // Set the group, if any.
        if ('string' === typeof opts.group ||
            'number' === typeof opts.group) {

            this.group = opts.group;
        }
        else if ('undefined' !== typeof opts.group) {
            throw new TypeError('CustomInputGroup.init: group must ' +
                                'be string, number or undefined. Found: ' +
                                opts.group);
        }

        // Set the groupOrder, if any.
        if ('number' === typeof opts.groupOrder) {

            this.groupOrder = opts.groupOrder;
        }
        else if ('undefined' !== typeof opts.group) {
            throw new TypeError('CustomInputGroup.init: groupOrder ' +
                                'must be number or undefined. Found: ' +
                                opts.groupOrder);
        }

        // Set the validation function.
        if ('function' === typeof opts.validation) {
            this._validation = opts.validation;

            this.validation = function(res, values) {
                if (!values) values = that.getValues({ valuesOnly: true });
                return that._validation(res || {}, values, that)
            };
        }
        else if ('undefined' !== typeof opts.validation) {
            throw new TypeError('CustomInputGroup.init: validation must ' +
                                'be function or undefined. Found: ' +
                                opts.validation);
        }

        // Set the validation function.
        if ('function' === typeof opts.oninput) {
            this._oninput = opts.oninput;

            this.oninput = function(res, input) {
                that._oninput(res, input, that);
            };
        }
        else if ('undefined' !== typeof opts.oninput) {
            throw new TypeError('CustomInputGroup.init: oninput must ' +
                                'be function or undefined. Found: ' +
                                opts.oninput);
        }

        // Set the mainText, if any.
        if ('string' === typeof opts.mainText) {
            this.mainText = opts.mainText;
        }
        else if ('undefined' !== typeof opts.mainText) {
            throw new TypeError('CustomInputGroup.init: mainText ' +
                                'must be string or undefined. Found: ' +
                                opts.mainText);
        }

        // Set the hint, if any.
        if ('string' === typeof opts.hint) {
            this.hint = opts.hint;
            if (this.requiredChoice) this.hint += ' *';
        }
        else if ('undefined' !== typeof opts.hint) {
            throw new TypeError('CustomInputGroup.init: hint must ' +
                                'be a string, or undefined. Found: ' +
                                opts.hint);
        }
        else {
            // Returns undefined if there are no constraints.
            this.hint = this.getText('autoHint');
        }

        // Set the timeFrom, if any.
        if (opts.timeFrom === false ||
            'string' === typeof opts.timeFrom) {

            this.timeFrom = opts.timeFrom;
        }
        else if ('undefined' !== typeof opts.timeFrom) {
            throw new TypeError('CustomInputGroup.init: timeFrom ' +
                                'must be string, false, or undefined. Found: ' +
                                opts.timeFrom);
        }

        // Option shuffleChoices, default false.
        if ('undefined' !== typeof opts.shuffleChoices) {
            this.shuffleChoices = !!opts.shuffleChoices;
        }

        // Set the className, if not use default.
        if ('undefined' === typeof opts.className) {
            this.className = CustomInputGroup.className;
        }
        else if (opts.className === false ||
                 'string' === typeof opts.className ||
                 J.isArray(opts.className)) {

            this.className = opts.className;
        }
        else {
            throw new TypeError('CustomInputGroup.init: ' +
                                'className must be string, array, ' +
                                'or undefined. Found: ' + opts.className);
        }

        // sharedOptions.
        if ('undefined' !== typeof opts.sharedOptions) {
            if ('object' !== typeof opts.sharedOptions) {
                throw new TypeError('CustomInputGroup.init: sharedOptions' +
                                    ' must be object or undefined. Found: ' +
                                    opts.sharedOptions);
            }
            if (opts.sharedOptions.hasOwnProperty('name')) {
                throw new Error('CustomInputGroup.init: sharedOptions ' +
                                'cannot contain property name. Found: ' +
                                opts.sharedOptions);
            }
            this.sharedOptions = J.mixin(this.sharedOptions,
                                        opts.sharedOptions);
        }

        if ('undefined' !== typeof opts.summary) {
            if ('string' === typeof opts.summary) {
                opts.summary = { mainText: opts.summary }
            }
            else if ('object' !== typeof opts.summary) {
                throw new TypeError('CustomInputGroup.init: summary' +
                                    ' must be object or undefined. Found: ' +
                                    opts.summary);
            }

            this.summaryInput = opts.summary;
        }

        // After all configuration options are evaluated, add items.

        if ('object' === typeof opts.table) {
            this.table = opts.table;
        }
        else if ('undefined' !== typeof opts.table &&
                 false !== opts.table) {

            throw new TypeError('CustomInputGroup.init: table ' +
                                'must be object, false or undefined. ' +
                                'Found: ' + opts.table);
        }

        // TODO: check this.
        this.table = opts.table;

        this.freeText = 'string' === typeof opts.freeText ?
            opts.freeText : !!opts.freeText;

        // Add the items.
        if ('undefined' !== typeof opts.items) this.setItems(opts.items);

    };

    /**
     * ### CustomInputGroup.setItems
     *
     * Sets the available items and optionally builds the table
     *
     * @param {array} items The array of items
     *
     * @see CustomInputGroup.table
     * @see CustomInputGroup.order
     * @see CustomInputGroup.shuffleItems
     * @see CustomInputGroup.buildTable
     */
    CustomInputGroup.prototype.setItems = function(items) {
        var len;
        if (!J.isArray(items)) {
            throw new TypeError('CustomInputGroup.setItems: ' +
                                'items must be array. Found: ' + items);
        }
        if (!items.length) {
            throw new Error('CustomInputGroup.setItems: ' +
                            'items is an empty array.');
        }

        len = items.length;
        this.itemsSettings = items;
        this.items = new Array(len);

        // Save the order in which the items will be added.
        this.order = J.seq(0, len-1);
        if (this.shuffleItems) this.order = J.shuffle(this.order);
        this.originalOrder = this.order;

        // Build the table and items at once (faster).
        if (this.table) this.buildTable();
    };

    /**
     * ### CustomInputGroup.buildTable
     *
     * Builds the table of clickable items and enables it
     *
     * Must be called after items have been set already.
     *
     * @see CustomInputGroup.setCustomInputs
     */
    CustomInputGroup.prototype.buildTable = function() {
        var i, len, tr, H;

        H = this.orientation === 'H';
        i = -1, len = this.itemsSettings.length;

        if (H) tr = createTR(this, 'row1');
        for ( ; ++i < len ; ) {
            // Add new TR.
            if (!H) tr = createTR(this, 'row' + (i+1));
            addCustomInput(this, tr, i);
        }
        if (this.summaryInput) {
            if (!H) tr = createTR(this, 'row' + (i+1));
            addSummaryInput(this, tr, i);
        }


        var that = this;
        this.table.onclick = function() {
            // Remove any warning/error from form on click.
            if (that.isHighlighted()) that.unhighlight();
        };

        this.enable(true);
    };

    /**
     * ### CustomInputGroup.append
     *
     * Implements Widget.append
     *
     * Checks that id is unique.
     *
     * Appends (all optional):
     *
     *   - mainText: a question or statement introducing the choices
     *   - table: the table containing the choices
     *   - freeText: a textarea for comments
     *
     * @see Widget.append
     */
    CustomInputGroup.prototype.append = function() {
        // Id must be unique.
        if (W.getElementById(this.id)) {
            throw new Error('CustomInputGroup.append: id ' +
                            'is not unique: ' + this.id);
        }

        // MainText.
        if (this.mainText) {
            this.spanMainText = W.append('span', this.bodyDiv, {
                className: 'custominputgroup-maintext',
                innerHTML: this.mainText
            });
        }
        // Hint.
        if (this.hint) {
            W.append('span', this.spanMainText || this.bodyDiv, {
                className: 'custominputgroup-hint',
                innerHTML: this.hint
            });
        }

        // Create/set table, if requested.
        if (this.table !== false) {
            if ('undefined' === typeof this.table) {
                this.table = document.createElement('table');
                if (this.items) this.buildTable();
            }
            // Set table id.
            this.table.id = this.id;
            if (this.className) J.addClass(this.table, this.className);
            else this.table.className = '';
            // Append table.
            this.bodyDiv.appendChild(this.table);
        }

        this.errorBox = W.append('div', this.bodyDiv, { className: 'errbox' });

        // Creates a free-text textarea, possibly with placeholder text.
        if (this.freeText) {
            this.textarea = document.createElement('textarea');
            this.textarea.id = this.id + '_text';
            this.textarea.className = CustomInputGroup.className + '-freetext';
            if ('string' === typeof this.freeText) {
                this.textarea.placeholder = this.freeText;
            }
            // Append textarea.
            this.bodyDiv.appendChild(this.textarea);
        }
    };

    /**
     * ### CustomInputGroup.listeners
     *
     * Implements Widget.listeners
     *
     * Adds two listeners two disable/enable the widget on events:
     * INPUT_DISABLE, INPUT_ENABLE
     *
     * Notice! Nested choice tables listeners are not executed.
     *
     * @see Widget.listeners
     * @see mixinSettings
     */
    CustomInputGroup.prototype.listeners = function() {
        var that = this;
        node.on('INPUT_DISABLE', function() {
            that.disable();
        });
        node.on('INPUT_ENABLE', function() {
            that.enable();
        });
    };

    /**
     * ### CustomInputGroup.disable
     *
     * Disables clicking on the table and removes CSS 'clicklable' class
     */
    CustomInputGroup.prototype.disable = function() {
        if (this.disabled === true || !this.table) return;
        this.disabled = true;
        this.emit('disabled');
    };

    /**
     * ### CustomInputGroup.enable
     *
     * Enables clicking on the table and adds CSS 'clicklable' class
     *
     * @return {function} cb The event listener function
     */
    CustomInputGroup.prototype.enable = function(force) {
        if (!this.table || (!force && !this.disabled)) return;
        this.disabled = false;
        this.emit('enabled');
    };

    /**
     * ### CustomInputGroup.highlight
     *
     * Highlights the choice table
     *
     * @param {string} The style for the table's border.
     *   Default '1px solid red'
     *
     * @see CustomInputGroup.highlighted
     */
    CustomInputGroup.prototype.highlight = function(border) {
        if (border && 'string' !== typeof border) {
            throw new TypeError('CustomInputGroup.highlight: border must be ' +
                                'string or undefined. Found: ' + border);
        }
        if (!this.table || this.highlighted === true) return;
        this.table.style.border = border || '3px solid red';
        this.highlighted = true;
        this.emit('highlighted', border);
    };

    /**
     * ### CustomInputGroup.unhighlight
     *
     * Removes highlight from the choice table
     *
     * @see CustomInputGroup.highlighted
     */
    CustomInputGroup.prototype.unhighlight = function() {
        if (!this.table || this.highlighted !== true) return;
        this.table.style.border = '';
        this.highlighted = false;
        this.errorBox.innerHTML = '';
        this.emit('unhighlighted');
    };

    /**
     * ### CustomInputGroup.getValues
     *
     * Returns the values for current selection and other paradata
     *
     * Paradata that is not set or recorded will be omitted
     *
     * @param {object} opts Optional. Configures the return value.
     *   Available optionts:
     *
     *   - valuesOnly: just returns the current values, no other checkings.
     *   - markAttempt: If TRUE, getting the value counts as an attempt
     *      to find the correct answer. Default: TRUE.
     *   - highlight:   If TRUE, if current value is not the correct
     *      value, widget will be highlighted. Default: TRUE.
     *   - reset:    If TRUTHY and no item raises an error,
     *       then it resets the state of all items before
     *       returning it. Default: FALSE.
     *
     * @return {object} Object containing the choice and paradata
     *
     * @see CustomInputGroup.verifyChoice
     * @see CustomInputGroup.reset
     */
    CustomInputGroup.prototype.getValues = function(opts) {
        var res, i, len, input, toReset, values;

        opts = opts || {};
        i = -1, len = this.items.length;
        if (opts.valuesOnly) {
            res = {};
            for ( ; ++i < len ; ) {
                res[this.items[i].id] =
                    this.items[i].getValues({ valuesOnly: true });
            }
            return res;
        }
        res = {
            id: this.id,
            order: this.order,
            items: {},
            isCorrect: true
        };
        if ('undefined' === typeof opts.highlight) opts.highlight = true;
        // TODO: do we need markAttempt?
        // if ('undefined' === typeof opts.markAttempt) opts.markAttempt = true;

        // Make sure reset is done only at the end.
        toReset = opts.reset;
        opts.reset = false;

        if (this.validation) values = {};
        for ( ; ++i < len ; ) {
            input = this.items[i];
            res.items[input.id] = input.getValues(opts);
            // TODO is null or empty?
            if (res.items[input.id].value === "") {
                res.missValues = true;
                // TODO: check do we need to check for correctChoice?
                if (input.requiredChoice || input.required ||
                    input.correctChoice) {

                    res.err = true;
                    res.isCorrect = false;
                }
            }
            if (res.items[input.id].isCorrect === false && opts.highlight) {
                res.err = true;
            }
            if (values) values[input.id] = res.items[input.id].value;
        }
        if (!res.err && values) {
            // res.err = this.getText('inputErr');
            this.validation(res, values);
            if (opts.highlight && res.err) this.setError(res.err);
            if (res.err) res.isCorrect = false;
        }
        else if (toReset) this.reset(toReset);
        if (!res.isCorrect && opts.highlight) this.highlight();

        // Restore opts.reset.
        opts.reset = toReset;

        if (this.textarea) res.freetext = this.textarea.value;
        return res;
    };

    /**
     * ### CustomInputGroup.setValues
     *
     * Sets values in the choice table group as specified by the options
     *
     * @param {object} options Optional. Options specifying how to set
     *   the values. If no parameter is specified, random values will
     *   be set.
     *
     * @see CustomInput.setValues
     *
     * @experimental
     */
    CustomInputGroup.prototype.setValues = function(opts) {
        var i, len;
        if (!this.items || !this.items.length) {
            throw new Error('CustomInputGroup.setValues: no items found.');
        }
        opts = opts || {};
        i = -1, len = this.items.length;
        for ( ; ++i < len ; ) {
            this.items[i].setValues(opts);
        }

        // Make a random comment.
        if (this.textarea) this.textarea.value = J.randomString(100, '!Aa0');
    };

    /**
     * ### CustomInputGroup.reset
     *
     * Resets all the CustomInput items and textarea
     *
     * @param {object} options Optional. Options specifying how to set
     *   to reset each item
     *
     * @see CustomInput.reset
     * @see CustomInputGroup.shuffle
     */
    CustomInputGroup.prototype.reset = function(opts) {
        var i, len;
        opts = opts || {};
        i = -1, len = this.items.length;
        for ( ; ++i < len ; ) {
            this.items[i].reset(opts);
        }
        // Delete textarea, if found.
        if (this.textarea) this.textarea.value = '';
        if (opts.shuffleItems) this.shuffle();
        if (this.isHighlighted()) this.unhighlight();
    };

    /**
     * ### CustomInputGroup.shuffle
     *
     * Shuffles the order of the displayed items
     *
     * Assigns the new order of items to `this.order`.
     *
     * @param {object} options Optional. Not used for now.
     *
     * TODO: shuffle choices in each item. (Note: can't use
     * item.shuffle, because the cells are taken out, so
     * there is no table and no tr in there)
     *
     * JSUS.shuffleElements
     */
    CustomInputGroup.prototype.shuffle = function(opts) {
        var order, i, len, that, cb, newOrder;
        if (!this.items) return;
        len = this.items.length;
        if (!len) return;
        that = this;
        newOrder = new Array(len);
        // Updates the groupOrder property of each item,
        // and saves the order of items correctly.
        cb = function(el, newPos, oldPos) {
            var i;
            i = el.id.split(that.separator);
            i = that.orientation === 'H' ? i[2] : i[0];
            i = that.itemsMap[i];
            that.items[i].groupOrder = (newPos+1);
            newOrder[newPos] = i;
        };
        order = J.shuffle(this.order);
        if (this.orientation === 'H') {
            J.shuffleElements(this.table, order, cb);
        }
        else {
            // Here we maintain the columns manually. Each TR contains TD
            // belonging to different items, we make sure the order is the
            // same for all TR.
            len = this.trs.length;
            for ( i = -1 ; ++i < len ; ) {
                J.shuffleElements(this.trs[i], order, cb);
                // Call cb only on first iteration.
                cb = undefined;
            }
        }
        this.order = newOrder;
    };

    /**
     * ### CustomInputGroup.setError
     *
     * Set the error msg inside the errorBox and call highlight
     *
     * @param {string} The error msg (can contain HTML)
     *
     * @see CustomInput.highlight
     * @see CustomInput.errorBox
     */
    CustomInputGroup.prototype.setError = function(err) {
        this.errorBox.innerHTML = err;
        this.highlight();
    };
    // ## Helper methods.

    /**
     * ### mixinSettings
     *
     * Mix-ins global settings with local settings for specific choice tables
     *
     * @param {CustomInputGroup} that This instance
     * @param {object|string} s The current settings for the item
     *   (choice table), or just its id, to mixin all settings.
     * @param {number} i The ordinal position of the table in the group
     *
     * @return {object} s The mixed-in settings
     */
    function mixinSettings(that, s, i) {
        if ('string' === typeof s) {
            s = { id: s };
        }
        else if ('object' !== typeof s) {
            throw new TypeError('CustomInputGroup.buildTable: item must be ' +
                                'string or object. Found: ' + s);
        }
        s.group = that.id;
        s.groupOrder = i+1;
        s.orientation = that.orientation;
        s.title = false;

        if (that.oninput) s.oninput = that.oninput;

        if ('undefined' === typeof s.requiredChoice && that.requiredChoice) {
            s.requiredChoice = that.requiredChoice;
        }

        if ('undefined' === typeof s.timeFrom) s.timeFrom = that.timeFrom;

        s = J.mixout(s, that.sharedOptions);

        // No reference is stored in node.widgets.
        s.storeRef = false;

        return s;
    }

    /**
     * ### addCustomInput
     *
     * Creates a instance i-th of choice table with relative settings
     *
     * Stores a reference of each input in `itemsById`
     *
     * @param {CustomInputGroup} that This instance
     * @param {HTMLElement} tr A TR element where the custom input is appended
     * @param {number} i The ordinal position of the table in the group
     *
     * @return {object} ct The requested choice table
     *
     * @see CustomInputGroup.itemsSettings
     * @see CustomInputGroup.itemsById
     * @see mixinSettings
     */
    function addCustomInput(that, tr, i) {
        var ci, s, td, idx;
        idx = that.order[i];
        s = mixinSettings(that, that.itemsSettings[idx], i);
        td = document.createElement('td');
        tr.appendChild(td);
        ci = node.widgets.append('CustomInput', td, s);
        if (that.itemsById[ci.id]) {
            throw new Error('CustomInputGroup.buildTable: an input ' +
                            'with the same id already exists: ' + ci.id);
        }
        that.itemsById[ci.id] = ci;
        that.items[idx] = ci;
        that.itemsMap[ci.id] = idx;

        if (s.required || s.requiredChoice || s.correctChoice) {
            // False is set manually, otherwise undefined.
            if (that.required === false) {
                throw new Error('CustomInputGroup.buildTable: required is ' +
                                'false, but item "' + s.id +
                                '" has required truthy');
            }
            that.required = true;
        }

        return ci;
    }

    /**
     * ### addSummaryInput
     *
     * Creates the last summary input
     *
     * Stores a reference in `summaryInput`
     *
     * @param {CustomInputGroup} that This instance
     * @param {HTMLElement} tr A TR element where the custom input is appended
     * @param {number} i The ordinal position of the table in the group
     *
     * @return {object} ct The requested choice table
     *
     * @see CustomInputGroup.itemsSettings
     * @see CustomInputGroup.itemsById
     * @see mixinSettings
     */
    function addSummaryInput(that, tr, i) {
        var ci, s, td;
        s = J.mixout({
            id: that.id + '_summary',
            storeRef: false,
            title: false,
            panel: false,
            className: 'custominputgroup-summary',
            disabled: true
        }, that.sharedOptions);
        s = J.mixin(s, that.summaryInput);
        td = document.createElement('td');
        tr.appendChild(td);
        ci = node.widgets.append('CustomInput', td, s);
        that.summaryInput = ci;
        return ci;
    }

    /**
     * ### createTR
     *
     * Creates and append a new TR element
     *
     * If required by current configuration, the `id` attribute is
     * added to the TR in the form of: 'tr' + separator + widget_id
     *
     * @param {CustomInput} that This instance
     *
     * @return {HTMLElement} Thew newly created TR element
     */
    function createTR(that, trid) {
        var tr, sep;
        tr = document.createElement('tr');
        that.table.appendChild(tr);
        // Set id.
        sep = that.separator;
        tr.id = that.id + sep + 'tr' + sep + trid;
        // Store reference.
        that.trs.push(tr);
        return tr;
    }

})(node);

/**
 * # D3
 * Copyright(c) 2015 Stefano Balietti
 * MIT Licensed
 *
 * Integrates nodeGame with the D3 library to plot a real-time chart
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('D3', D3);
    node.widgets.register('D3ts', D3ts);

    D3.prototype.__proto__ = node.Widget.prototype;
    D3.prototype.constructor = D3;

    // ## Defaults

    D3.defaults = {};
    D3.defaults.id = 'D3';
    D3.defaults.fieldset = {
        legend: 'D3 plot'
    };


    // ## Meta-data

    D3.version = '0.1';
    D3.description = 'Real time plots for nodeGame with d3.js';

    // ## Dependencies

    D3.dependencies = {
        d3: {},
        JSUS: {}
    };

    function D3 (options) {
        this.id = options.id || D3.id;
        this.event = options.event || 'D3';
        this.svg = null;

        var that = this;
        node.on(this.event, function(value) {
            that.tick.call(that, value);
        });
    }

    D3.prototype.append = function(root) {
        this.root = root;
        this.svg = d3.select(root).append("svg");
        return root;
    };

    D3.prototype.tick = function() {};

    // # D3ts


    // ## Meta-data

    D3ts.id = 'D3ts';
    D3ts.version = '0.1';
    D3ts.description = 'Time series plot for nodeGame with d3.js';

    // ## Dependencies
    D3ts.dependencies = {
        D3: {},
        JSUS: {}
    };

    D3ts.prototype.__proto__ = D3.prototype;
    D3ts.prototype.constructor = D3ts;

    D3ts.defaults = {};

    D3ts.defaults.width = 400;
    D3ts.defaults.height = 200;

    D3ts.defaults.margin = {
        top: 10,
        right: 10,
        bottom: 20,
        left: 40
    };

    D3ts.defaults.domain = {
        x: [0, 10],
        y: [0, 1]
    };

    D3ts.defaults.range = {
        x: [0, D3ts.defaults.width],
        y: [D3ts.defaults.height, 0]
    };

    function D3ts(options) {
        var o, x, y;
        D3.call(this, options);

        this.options = o = J.merge(D3ts.defaults, options);
        this.n = o.n;
        this.data = [0];

        this.margin = o.margin;

        this.width = o.width - this.margin.left - this.margin.right;
        this.height = o.height - this.margin.top - this.margin.bottom;

        // Identity function.
        this.x = x = d3.scale.linear()
            .domain(o.domain.x)
            .range(o.range.x);

        this.y = y = d3.scale.linear()
            .domain(o.domain.y)
            .range(o.range.y);

        // line generator
        this.line = d3.svg.line()
            .x(function(d, i) { return x(i); })
            .y(function(d, i) { return y(d); });
    }

    D3ts.prototype.init = function(options) {
        //D3.init.call(this, options);

        console.log('init!');
        var x = this.x,
        y = this.y,
        height = this.height,
        width = this.width,
        margin = this.margin;


        // Create the SVG and place it in the middle
        this.svg.attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top +
                  ")");


        // Line does not go out the axis
        this.svg.append("defs").append("clipPath")
            .attr("id", "clip")
            .append("rect")
            .attr("width", width)
            .attr("height", height);

        // X axis
        this.svg.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.svg.axis().scale(x).orient("bottom"));

        // Y axis
        this.svg.append("g")
            .attr("class", "y axis")
            .call(d3.svg.axis().scale(y).orient("left"));

        this.path = this.svg.append("g")
            .attr("clip-path", "url(#clip)")
            .append("path")
            .data([this.data])
            .attr("class", "line")
            .attr("d", this.line);
    };

    D3ts.prototype.tick = function(value) {
        this.alreadyInit = this.alreadyInit || false;
        if (!this.alreadyInit) {
            this.init();
            this.alreadyInit = true;
        }

        var x = this.x;

        console.log('tick!');

        // push a new data point onto the back
        this.data.push(value);

        // redraw the line, and slide it to the left
        this.path
            .attr("d", this.line)
            .attr("transform", null);

        // pop the old data point off the front
        if (this.data.length > this.n) {

            this.path
                .transition()
                .duration(500)
                .ease("linear")
                .attr("transform", "translate(" + x(-1) + ")");

            this.data.shift();

        }
    };

})(node);

/**
 * # DebugInfo
 * Copyright(c) 2019 Stefano Balietti
 * MIT Licensed
 *
 * Display information about the state of a player
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    var Table = W.Table;

    node.widgets.register('DebugInfo', DebugInfo);

    // ## Meta-data

    DebugInfo.version = '0.6.2';
    DebugInfo.description = 'Display basic info a client\'s status.';

    DebugInfo.title = 'Debug Info';
    DebugInfo.className = 'debuginfo';

    // ## Dependencies

    DebugInfo.dependencies = {
        Table: {}
    };

    /**
     * ## DebugInfo constructor
     *
     * `DebugInfo` displays information about the state of a player
     */
    function DebugInfo() {

        /**
         * ### DebugInfo.table
         *
         * The `Table` which holds the information
         *
         * @See nodegame-window/Table
         */
        this.table = null;

        /**
         * ### DebugInfo.interval
         *
         * The interval checking node properties
         */
        this.interval = null;

        /**
         * ### DebugInfo.intervalTime
         *
         * The frequency of update of the interval. Default: 1000
         */
        this.intervalTime = 1000;
    }

    // ## DebugInfo methods

    /**
     * ### DebugInfo.init
     *
     * Appends widget to `this.bodyDiv` and calls `this.updateAll`
     *
     * @see DebugInfo.updateAll
     */
    DebugInfo.prototype.init = function(options) {
        var that;
        if ('number' === typeof options.intervalTime) {
            this.intervalTime = options.intervalTime;
        }

        that = this;
        this.on('destroyed', function() {
            clearInterval(that.interval);
            that.interval = null;
            node.silly('DebugInfo destroyed.');
        });
    };

    /**
     * ### DebugInfo.append
     *
     * Appends widget to `this.bodyDiv` and calls `this.updateAll`
     *
     * @see DebugInfo.updateAll
     */
    DebugInfo.prototype.append = function() {
        var that;

        this.table = new Table();
        this.bodyDiv.appendChild(this.table.table);

        this.updateAll();
        that = this;
        this.interval = setInterval(function() {
            that.updateAll();
        }, this.intervalTime);
    };

    /**
     * ### DebugInfo.updateAll
     *
     * Updates information in `this.table`
     */
    DebugInfo.prototype.updateAll = function() {
        var stage, stageNo, stageId, playerId;
        var stageLevel, stateLevel, winLevel;
        var errMsg, connected, treatment;
        var tmp, miss;

        if (!this.bodyDiv) {
            node.err('DebugInfo.updateAll: bodyDiv not found.');
            return;
        }

        miss = '-';

        stageId = miss;
        stageNo = miss;

        stage = node.game.getCurrentGameStage();
        if (stage) {
            tmp = node.game.plot.getStep(stage);
            stageId = tmp ? tmp.id : '-';
            stageNo = stage.toString();
        }

        stageLevel = J.getKeyByValue(node.constants.stageLevels,
                                     node.game.getStageLevel());

        stateLevel = J.getKeyByValue(node.constants.stateLevels,
                                     node.game.getStateLevel());

        winLevel = J.getKeyByValue(node.constants.windowLevels,
                                   W.getStateLevel());


        playerId = node.player ? node.player.id : miss;

        errMsg = node.errorManager.lastErr || miss;

        treatment = node.game.settings && node.game.settings.treatmentName ?
            node.game.settings.treatmentName : miss;

        connected = node.socket.connected ? 'yes' : 'no';

        this.table.clear(true);
        this.table.addRow(['Treatment: ', treatment]);
        this.table.addRow(['Connected: ', connected]);
        this.table.addRow(['Player Id: ', playerId]);
        this.table.addRow(['Stage  No: ', stageNo]);
        this.table.addRow(['Stage  Id: ', stageId]);
        this.table.addRow(['Stage Lvl: ', stageLevel]);
        this.table.addRow(['State Lvl: ', stateLevel]);
        this.table.addRow(['Players  : ', node.game.pl.size()]);
        this.table.addRow(['Win   Lvl: ', winLevel]);
        this.table.addRow(['Win Loads: ', W.areLoading]);
        this.table.addRow(['Last  Err: ', errMsg]);

        this.table.parse();

    };

})(node);

/**
 * # DebugWall
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Creates a wall where all incoming and outgoing messages are printed
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('DebugWall', DebugWall);

    // ## Meta-data

    DebugWall.version = '1.1.0';
    DebugWall.description = 'Intercepts incoming and outgoing messages, and ' +
        'logs and prints them numbered and timestamped. Warning! Modifies ' +
        'core functions, therefore its usage in production is ' +
        'not recommended.';

    DebugWall.title = 'Debug Wall';
    DebugWall.className = 'debugwall';

    // ## Dependencies

    DebugWall.dependencies = {
        JSUS: {}
    };

    /**
     * ## DebugWall constructor
     *
     * Creates a new DebugWall oject
     */
    function DebugWall() {

        /**
         * ### DebugWall.buttonsDiv
         *
         * Div contains controls for the display info inside the wall.
         */
        this.buttonsDiv = null;

        /**
         * ### DebugWall.hidden
         *
         * Keep tracks of what is hidden in the wall
         */
        this.hiddenTypes = {};

        /**
         * ### DebugWall.counterIn
         *
         * Counts number of incoming message printed on wall
         */
        this.counterIn = 0;

        /**
         * ### DebugWall.counterOut
         *
         * Counts number of outgoing message printed on wall
         */
        this.counterOut = 0;

        /**
         * ### DebugWall.counterLog
         *
         * Counts number of log entries printed on wall
         */
        this.counterLog = 0;

        /**
         * ### DebugWall.wall
         *
         * The table element in which to write
         */
        this.wall = null;

        /**
         * ### DebugWall.wallDiv
         *
         * The div element containing the wall (for scrolling)
         */
        this.wallDiv = null;

        /**
         * ### DebugWall.origMsgInCb
         *
         * The original function that receives incoming msgs
         */
        this.origMsgInCb = null;

        /**
         * ### DebugWall.origMsgOutCb
         *
         * The original function that sends msgs
         */
        this.origMsgOutCb = null;

        /**
         * ### DebugWall.origLogCb
         *
         * The original log callback
         */
        this.origLogCb = null;
    }

    // ## DebugWall methods

    /**
     * ### DebugWall.init
     *
     * Initializes the instance
     *
     * @param {object} opts Optional. Configuration options
     *
     *  - msgIn: If FALSE, incoming messages are ignored.
     *  - msgOut: If FALSE, outgoing  messages are ignored.
     *  - log: If FALSE, log  messages are ignored.
     *  - hiddenTypes: An object containing what is currently hidden
     *     in the wall.
     */
    DebugWall.prototype.init = function(opts) {
        var that;
        that = this;
        if (opts.msgIn !== false) {
            this.origMsgInCb = node.socket.onMessage;
            node.socket.onMessage = function(msg) {
                that.write('in', that.makeTextIn(msg));
                that.origMsgInCb.call(node.socket, msg);
            };
        }
        if (opts.msgOut !== false) {
            this.origMsgOutCb = node.socket.send;
            node.socket.send = function(msg) {
                that.write('out', that.makeTextOut(msg));
                that.origMsgOutCb.call(node.socket, msg);
            };
        }
        if (opts.log !== false) {
            this.origLogCb = node.log;
            node.log = function(txt, level, prefix) {
                that.write(level || 'info',
                           that.makeTextLog(txt, level, prefix));
                that.origLogCb.call(node, txt, level, prefix);
            };
        }

        if (opts.hiddenTypes) {
            if ('object' !== typeof opts.hiddenTypes) {
                throw new TypeError('DebugWall.init: hiddenTypes must be ' +
                                    'object. Found: ' + opts.hiddenTypes);
            }
            this.hiddenTypes = opts.hiddenTypes;
        }

        this.on('destroyed', function() {
            if (that.origLogCb) node.log = that.origLogCb;
            if (that.origMsgOutCb) node.socket.send = that.origMsgOutCb;
            if (that.origMsgInCb) node.socket.onMessage = that.origMsgInCb;
        });

    };

    DebugWall.prototype.append = function() {
        var displayIn, displayOut, displayLog, that;
        var btnGroup, cb;

        this.buttonsDiv = W.add('div', this.bodyDiv, {
            className: 'wallbuttonsdiv'
        });

        btnGroup = W.add('div', this.buttonsDiv, {
            className: 'btn-group',
            role: 'group',
            'aria-label': 'Toggle visibility of messages on wall'
        });

        // Incoming.
        W.add('input', btnGroup, {
            id: 'debug-wall-incoming',
            // name: 'debug-wall-check',
            className: 'btn-check',
            autocomplete: "off",
            checked: true,
            type: 'checkbox'
        });
        displayIn = W.add('label', btnGroup, {
            className: "btn btn-outline-primary",
            'for': "debug-wall-incoming",
            innerHTML: 'Incoming'
        });
        // Outgoing.
        W.add('input', btnGroup, {
            id: 'debug-wall-outgoing',
            className: 'btn-check',
            // name: 'debug-wall-check',
            autocomplete: "off",
            checked: true,
            type: 'checkbox'
        });
        displayOut = W.add('label', btnGroup, {
            className: "btn btn-outline-primary",
            'for': "debug-wall-outgoing",
            innerHTML: 'Outgoing'
        });
        // Log.
        W.add('input', btnGroup, {
            id: 'debug-wall-log',
            className: 'btn-check',
            // name: 'debug-wall-check',
            autocomplete: "off",
            checked: true,
            type: 'checkbox'
        });
        displayLog = W.add('label', btnGroup, {
            className: "btn btn-outline-primary",
            'for': "debug-wall-log",
            innerHTML: 'Log'
        });

        that = this;

        W.add('button', this.buttonsDiv, {
            className: "btn btn-outline-danger me-2",
            innerHTML: 'Clear'
        })
        .onclick = function() { that.clear(); };

        this.buttonsDiv.appendChild(btnGroup);

        cb = function(type) {
            var items, i, vis, className;
            className = 'wall_' + type;
            items = that.wall.getElementsByClassName(className);
            if (!items || !items.length) return;
            vis = items[0].style.display === '' ? 'none' : '';
            for (i = 0; i < items.length; i++) {
                items[i].style.display = vis;
            }
            that.hiddenTypes[type] = !!vis;
        };

        displayIn.onclick = function() { cb('in'); };
        displayOut.onclick = function() { cb('out'); };
        displayLog.onclick = function() { cb('log'); };

        this.wallDiv = W.add('div', this.bodyDiv, { className: 'walldiv' });
        this.wall = W.add('table', this.wallDiv);
    };

    /**
     * ### DebugWall.write
     *
     * Writes argument as first entry of this.wall if document is fully loaded
     *
     * @param {string} type 'in', 'out', or 'log' (different levels)
     * @param {string} text The text to write
     */
    DebugWall.prototype.shouldHide = function(type) {
        return this.hiddenTypes[type];
    };

    /**
     * ### DebugWall.write
     *
     * Writes argument as first entry of this.wall if document is fully loaded
     *
     * @param {string} type 'in', 'out', or 'log' (different levels)
     * @param {string} text The text to write
     */
    DebugWall.prototype.clear = function() {
        this.wall.innerHTML = '';
    };

    /**
     * ### DebugWall.write
     *
     * Writes argument as first entry of this.wall if document is fully loaded
     *
     * @param {string} type 'in', 'out', or 'log' (different levels)
     * @param {string} text The text to write
     */
    DebugWall.prototype.write = function(type, text) {
        var spanContainer, spanDots, spanExtra, counter, className;
        var limit;
        var TR, TDtext;
        if (this.isAppended()) {

            counter = type === 'in' ? ++this.counterIn :
                (type === 'out' ? ++this.counterOut : ++this.counterLog);

            limit = 200;
            className = 'wall_' + type;
            TR = W.add('tr', this.wall, { className: className });
            if (type !== 'in' && type !== 'out') TR.className += ' wall_log';

            if (this.shouldHide(type, text)) TR.style.display = 'none';

            W.add('td', TR, { innerHTML: counter });
            W.add('td', TR, { innerHTML: type });
            W.add('td', TR, { innerHTML: J.getTimeM()});
            TDtext = W.add('td', TR);

            if (text.length > limit) {
                spanContainer = W.add('span', TDtext, {
                    className: className + '_click' ,
                    innerHTML: text.substr(0, limit)
                });
                spanExtra = W.add('span', spanContainer, {
                    className: className + '_extra',
                    innerHTML: text.substr(limit, text.length),
                    id: 'wall_' + type + '_' + counter,
                    style: { display: 'none' }

                });
                spanDots = W.add('span', spanContainer, {
                    className: className + '_dots',
                    innerHTML: ' ...',
                    id: 'wall_' + type + '_' + counter
                });

                spanContainer.onclick = function() {
                    if (spanDots.style.display === 'none') {
                        spanDots.style.display = '';
                        spanExtra.style.display = 'none';
                    }
                    else {
                        spanDots.style.display = 'none';
                        spanExtra.style.display = '';
                    }
                };
            }
            else {
                spanContainer = W.add('span', TDtext, {
                    innerHTML: text
                });
            }
            this.wallDiv.scrollTop = this.wallDiv.scrollHeight;
        }
        else {
            node.warn('Wall not appended, cannot write.');
        }
    };

    DebugWall.prototype.makeTextIn = function(msg) {
        var text, d;
        d = new Date(msg.created);
        text = d.getHours() + ':' + d.getMinutes() + ':' + d.getSeconds() +
            ':' + d.getMilliseconds();
        text += ' | ' + msg.to + ' | ' + msg.target +
            ' | ' + msg.action + ' | ' + msg.text + ' | ' + msg.data;
        return text;
    };


    DebugWall.prototype.makeTextOut = function(msg) {
        var text;
        text = msg.from + ' | ' + msg.target + ' | ' + msg.action + ' | ' +
            msg.text + ' | ' + msg.data;
        return text;
    };

    DebugWall.prototype.makeTextLog = function(text) {
        return text;
    };

})(node);

/**
 * # DisconnectBox
 * Copyright(c) 2019 Stefano Balietti
 * MIT Licensed
 *
 * Shows a disconnect button
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('DisconnectBox', DisconnectBox);

    // ## Meta-data

    DisconnectBox.version = '0.4.0';
    DisconnectBox.description = 'Monitors and handles disconnections';

    DisconnectBox.title = false;
    DisconnectBox.panel = false;
    DisconnectBox.className = 'disconnectbox';

    DisconnectBox.texts = {
        leave: 'Leave Task',
        left: 'You Left',
        disconnected: 'Disconnected!',
        connected: 'Connected'
    };

    // ## Dependencies

    DisconnectBox.dependencies = {};

    /**
     * ## DisconnectBox constructor
     *
     */
    function DisconnectBox() {

        // ### DisconnectBox.showStatus
        // If TRUE, it shows current connection status. Default: TRUE
        this.showStatus = null;

        // ### DisconnectBox.showDiscBtn
        // If TRUE, it shows the disconnect button. Default: FALSE
        this.showDiscBtn = null;

        // ### DisconnectBox.statusSpan
        // The SPAN containing the status
        this.statusSpan = null;

        // ### DisconnectBox.disconnectBtn
        // The button for disconnection
        this.disconnectBtn = null;

        // ### DisconnectBox.disconnectBtn
        // TRUE, user pressed the disconnect button
        this.userDiscFlag = null;

        // ### DisconnectBox.ee
        // The event emitter with whom the events are registered
        this.ee = null;

        // ### DisconnectBox.disconnectCb
        // Callback executed when a disconnection is detected
        this.disconnectCb = null;

        // ### DisconnectBox.disconnectCb
        // Callback executed when a connection is detected
        this.connectCb = null;
    }

    // ## DisconnectBox methods
    DisconnectBox.prototype.init = function(opts) {

        if (opts.connectCb) {
            if ('function' !== typeof opts.connectCb) {
                throw new TypeError('DisconnectBox.init: connectCb must be ' +
                                    'function or undefined. Found: ' +
                                    opts.connectCb);
            }
            this.connectCb = opts.connectCb;
        }
        if (opts.disconnectCb) {
            if ('function' !== typeof opts.disconnectCb) {
                throw new TypeError('DisconnectBox.init: disconnectCb must ' +
                                    'be function or undefined. Found: ' +
                                    opts.disconnectCb);
            }
            this.disconnectCb = opts.disconnectCb;
        }

        this.showDiscBtn = !!opts.showDiscBtn;
        this.showStatus = !!opts.showStatus;
    };

    DisconnectBox.prototype.append = function() {
        var that, con;
        that = this;
        con = node.socket.isConnected();
        if (this.showStatus) {
            this.statusSpan = W.add('span', this.bodyDiv);
            this.updateStatus(con ? 'connected' : 'disconnected');
        }
        if (this.showDiscBtn) {
            this.disconnectBtn = W.add('button', this.bodyDiv, {
                innerHTML: this.getText(con ? 'leave' : 'left'),
                className: 'btn',
                style: { 'margin-left': '10px' }
            });
            if (!con) this.disconnectBtn.disabled = true;
            this.disconnectBtn.onclick = function() {
                that.disconnectBtn.disabled = true;
                that.userDiscFlag = true;
                node.socket.disconnect();
            };
        }

    };

    DisconnectBox.prototype.updateStatus = function(status) {
        if (!this.statusSpan) {
            node.warn('DisconnectBox.updateStatus: display disabled.');
            return;
        }
        this.statusSpan.innerHTML = this.getText(status);
        this.statusSpan.className = status === 'disconnected' ?
            'text-danger' : '';
    };

    DisconnectBox.prototype.listeners = function() {
        var that;
        that = this;

        this.ee = node.getCurrentEventEmitter();
        this.ee.on('SOCKET_DISCONNECT', function() {
            if (that.statusSpan) that.updateStatus('disconnected');
            if (that.disconnectBtn) {
                that.disconnectBtn.disabled = true;
                that.disconnectBtn.innerHTML = that.getText('left');
            }
            if (that.disconnectCb) that.disconnectCb(that.userDiscFlag);
        });

        this.ee.on('SOCKET_CONNECT', function() {
            if (that.statusSpan) that.updateStatus('connected');
            if (that.disconnectBtn) {
                that.disconnectBtn.disabled = false;
                that.disconnectBtn.innerHTML = that.getText('leave');
            }
            if (that.connectCb) that.disconnectCb();
            // Reset pressedDisc.
            that.userDiscFlag = false;
        });
    };


})(node);

/**
 * # DoneButton
 * Copyright(c) 2020 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Creates a button that if pressed emits node.done()
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('DoneButton', DoneButton);

    // ## Meta-data

    DoneButton.version = '1.1.0';
    DoneButton.description = 'Creates a button that if ' +
        'pressed emits node.done().';

    DoneButton.title = false;
    DoneButton.panel = false;
    DoneButton.className = 'donebutton';
    DoneButton.texts.done = 'Done';

    /**
     * ## DoneButton constructor
     *
     * Creates a new instance of DoneButton
     *
     * @param {object} options Optional. Configuration options.
     *   If a `button` option is specified, it sets it as the clickable
     *   button. All other options are passed to the init method.
     *
     * @see DoneButton.init
     */
    function DoneButton(options) {
        var that;
        that = this;

        /**
         * ### DoneButton.button
         *
         * The HTML element triggering node.done() when pressed
         */
        if ('object' === typeof options.button) {
            this.button = options.button;
        }
        else if ('undefined' === typeof options.button) {
            this.button = document.createElement('input');
            this.button.type = 'button';
        }
        else {
            throw new TypeError('DoneButton constructor: options.button must ' +
                                'be object or undefined. Found: ' +
                                options.button);
        }

        this.button.onclick = function() {
            if (that.onclick && false === that.onclick()) return;
            if (node.game.isWidgetStep()) {
                // Widget has a next visualization in the same step.
                if (node.widgets.last.next() !== false) return;
            }
            if (node.done()) that.disable();
        };

        /**
         * ### DoneButton.onclick
         *
         * A callback executed after the button is clicked
         *
         * If it return FALSE, node.done() is not called.
         */
        this.onclick = null;

        /**
         * ### DoneButton.disableOnDisconnect
         *
         * If TRUE, the button is automatically disableb upon disconnection
         */
        this.disableOnDisconnect = null;

        /**
         * ### DoneButton.delayOnPlaying
         *
         * The number of milliseconds to wait to enable at a new step
         *
         * A small delay prevents accidental double clicking between steps.
         */
        this.delayOnPlaying = 800;
    }

    // ## DoneButton methods

    /**
     * ### DoneButton.init
     *
     * Initializes the instance
     *
     * Available options are:
     *
     * - id: id of the HTML button, or false to have none. Default:
     *     DoneButton.className
     * - className: the className of the button (string, array), or false
     *     to have none. Default bootstrap classes: 'btn btn-lg btn-primary'
     * - text: the text on the button. Default: DoneButton.text
     * - onclick: a callback executed when the button is clicked. Default: null
     * - disableOnDisconnect: TRUE to disable upon disconnection. Default: TRUE
     * - delayOnPlaying: number of milliseconds to wait to enable after
     *     the `PLAYING` event is fired (e.g., a new step begins). Default: 800
     *
     * @param {object} opts Optional. Configuration options
     */
    DoneButton.prototype.init = function(opts) {
        var tmp;
        opts = opts || {};

        //Button
        if ('undefined' === typeof opts.id) {
            tmp = DoneButton.className;
        }
        else if ('string' === typeof opts.id) {
            tmp = opts.id;
        }
        else if (false === opts.id) {
            tmp = false;
        }
        else {
            throw new TypeError('DoneButton.init: id must ' +
                                'be string, false, or undefined. Found: ' +
                                opts.id);
        }
        if (tmp) this.button.id = tmp;

        // Button className.
        if ('undefined' === typeof opts.className) {
            tmp  = 'btn btn-lg btn-primary';
        }
        else if (opts.className === false) {
            tmp = '';
        }
        else if ('string' === typeof opts.className) {
            tmp = opts.className;
        }
        else if (J.isArray(opts.className)) {
            tmp = opts.className.join(' ');
        }
        else  {
            throw new TypeError('DoneButton.init: className must ' +
                                'be string, array, or undefined. Found: ' +
                                opts.className);
        }
        this.button.className = tmp;

        // Button text.
        this.button.value = 'string' === typeof opts.text ?
            opts.text : this.getText('done');

        this.disableOnDisconnect =
            'undefined' === typeof opts.disableOnDisconnect ?
            true : !! opts.disableOnDisconnect;

        tmp = opts.delayOnPlaying;
        if ('number' === typeof tmp) {
            this.delayOnPlaying = tmp;
        }
        else if ('undefined' !== typeof tmp) {
            throw new TypeError('DoneButton.init: delayOnPlaying must ' +
                                'be number or undefined. Found: ' + tmp);
        }

        setOnClick(this, opts.onclick);
    };

    DoneButton.prototype.append = function() {
        // If added in init, it must stay disabled until the step property
        // of first step is evaluated.
        if (!node.game.isReady()) {
            this.disabled = true;
            this.button.disabled = true;
        }
        this.bodyDiv.appendChild(this.button);
    };

    DoneButton.prototype.listeners = function() {
        var that, disabled;
        that = this;

        // This is normally executed after the PLAYING listener of
        // GameWindow where lockUnlockedInputs takes place.
        // In case of a timeup, the donebutton will be locked and
        // then unlocked by GameWindow, but otherwise it must be
        // done here.
        node.on('PLAYING', function() {
            var prop, step, delay;

            step = node.game.getCurrentGameStage();
            prop = node.game.plot.getProperty(step, 'donebutton');
            if (prop === false || (prop && prop.enableOnPlaying === false)) {
                // It might be disabled already, but we do it again.
                that.disable();
            }
            else {
                if (prop && prop.hasOwnProperty &&
                    prop.hasOwnProperty('delayOnPlaying')) {
                        delay = prop.delayOnPlaying;
                }
                else {
                    delay = that.delayOnPlaying;
                }
                if (delay) {
                    setTimeout(function () {
                        // If not disabled because of a disconnection,
                        // enable it.
                        if (!disabled) that.enable();
                    }, delay);
                }
                else {
                    // It might be enabled already, but we do it again.
                    that.enable();
                }
            }
            if ('string' === typeof prop) that.button.value = prop;
            else if (prop && prop.text) that.button.value = prop.text;

            if (prop) setOnClick(this, prop.onclick, true);
        });

        if (this.disableOnDisconnect) {
            node.on('SOCKET_DISCONNECT', function() {
                if (!that.isDisabled()) {
                    that.disable();
                    disabled = true;
                }
            });

            node.on('SOCKET_CONNECT', function() {
                if (disabled) {
                    if (that.isDisabled()) that.enable();
                    disabled = false;
                }
            });
        }
    };

    /**
     * ### DoneButton.updateText
     *
     * Updates the text on the button, possibly for a given duration only
     *
     * @param {string} text The new text
     * @param {number} duration Optional. The number of milliseconds the new
     *   text is displayed. If undefined, the new text stays indefinitely.
     */
    DoneButton.prototype.updateText = function(text, duration) {
        var oldText, that;
        if (duration) {
            that = this;
            oldText = this.button.value;
            node.timer.setTimeout(function() {
                that.button.value = oldText;
            }, duration);
        }
        this.button.value = text;
    };

    /**
     * ### DoneButton.disable
     *
     * Disables the done button
     */
    DoneButton.prototype.disable = function(opts) {
        if (this.disabled) return;
        this.disabled = true;
        this.button.disabled = true;
        this.emit('disabled', opts);
    };

    /**
     * ### DoneButton.enable
     *
     * Enables the done button
     */
    DoneButton.prototype.enable = function(opts) {
        if (!this.disabled) return;
        this.disabled = false;
        this.button.disabled = false;
        this.emit('enabled', opts);
    };


    // ## Helper functions.

    // Checks and sets the onclick function.
    function setOnClick(that, onclick, step) {
        var str;
        if ('undefined' !== typeof onclick) {
            if ('function' !== typeof onclick && onclick !== null) {
                str = 'DoneButton.init';
                if (step) str += ' (step property)';
                throw new TypeError(str + ': onclick must be function, null,' +
                                    ' or undefined. Found: ' + onclick);
            }
            that.onclick = onclick;
        }
    }

})(node);

(function(node) {

    node.widgets.register('Dropdown', Dropdown);

    // Meta-data.

    Dropdown.version = '0.4.0';
    Dropdown.description = 'Creates a configurable dropdown menu.';

    Dropdown.texts = {

        // Texts here (more info on this later).
        error: function (w, value) {
            if (value !== null && w.fixedChoice &&
                w.choices.indexOf(value) < 0) {
                return 'No custom values allowed.'
            }
            if (value !== null && w.correctChoice !== null) {
                return 'Not correct, try again.';
            }
            if (value !== null && w.verifyChoice().err) {
                return w.verifyChoice().err;
            }

            return 'Answer required.';
        }
    };

    // Title is displayed in the header.
    Dropdown.title = false;
    // Classname is added to the widgets.
    Dropdown.className = 'dropdown';

    // Constructor taking a configuration parameter.
    // The options object is always existing.
    function Dropdown() {
        var that;
        that = this;

        // You can define widget properties here,
        // but they should get assigned a value in init.

        this.id = null;

        /**
         * ### Dropdown.mainText
         *
         * Main text above the dropdown
         */
        this.mainText = null;

        /**
         * ### Dropdown.hint
         *
         * An additional text with information in lighter font
         */
        this.hint = null;

        /**
         * ### Dropdown.labelText
         *
         * A label text for the input
         */
        this.labelText = null;

        /**
         * ### Dropdown.placeholder
         *
         * A placeholder text for the input
         */
        this.placeholder = null;

        /**
         * ### Dropdown.choices
         *
         * The array available choices
         */
        this.choices = null;

        /**
         * ### Dropdown.tag
         *
         * The HTML tag: "datalist" or "select"
         */
        this.tag = null;

        /**
         * ### Dropdown.menu
         *
         * Holder of the selected value (input or select)
         */
        this.menu = null;

        /**
         * ### Dropdown.datalist
         *
         * Holder of the options for the datalist element
         */
        this.datalist = null;

        /**
         * ### Dropdown.listener
         *
         * The main listener
         *
         * @see Dropdown.onchange
         */
        this.listener = function (e) {
            var menu, timeout;

            e = e || window.event;
            menu = e.target || e.srcElement;

            that.currentChoice = menu.value;
            if (that.currentChoice.length === 0) that.currentChoice = null;

            // Relative time.
            if ('string' === typeof that.timeFrom) {
                that.timeCurrentChoice = node.timer.getTimeSince(that.timeFrom);
            }
            // Absolute time.
            else {
                that.timeCurrentChoice = Date.now ?
                    Date.now() : new Date().getTime();
            }

            // One more change.
            that.numberOfChanges++;

            // Remove any warning/errors on change.
            if (that.isHighlighted()) that.unhighlight();

            if (timeout) clearTimeout(timeout);

            timeout = setTimeout(function () {
                that.verifyChoice();
                if (that.verifyChoice().err) {
                    that.setError(that.verifyChoice().err)
                }

            }, that.validationSpeed);

            // Call onchange, if any.
            if (that.onchange) {
                that.onchange(that.currentChoice, menu, that);
            }

        };

        /*
         * ### Dropdown.onchange
         *
         * User defined onchange function
         */
        this.onchange = null;

        /**
         * ### Dropdown.timeCurrentChoice
         *
         * Time when the last choice was made
         */
        this.timeCurrentChoice = null;

        /**
         * ### Dropdown.timeFrom
         *
         * Time is measured from timestamp as saved by node.timer
         *
         * Default event is a new step is loaded (user can interact with
         * the screen). Set it to FALSE, to have absolute time.
         *
         * @see node.timer.getTimeSince
         */
        this.timeFrom = 'step';

        /**
         * ### Dropdown.numberOfChanges
         *
         * Total number of changes between different choices
         */
        this.numberOfChanges = 0;

        /**
         * ### Dropdown.currentChoice
         *
         * Choice associated with currently selected cell/s
         *
         * The field is a  number.
         */
        this.currentChoice = null;

        /**
         * ###  Dropdown.shuffleChoices
         *
         * If TRUE, choices are shuffled.
         */
        this.shuffleChoices = null;

        /**
         * ### Dropdown.order
         *
         * The current order of display of choices
         *
         */
        this.order = null;

        /**
         * ### Dropdown.errorBox
         *
         * An HTML element displayed when a validation error occurs
         */
        this.errorBox = null;

        /**
         * ### Dropdown.correctChoice
         *
         * The correct choice/s
         *
         * The field is an array or number|string.
         *
         */
        this.correctChoice = null;

        /**
         * ### Dropdown.requiredChoice
         *
         * If True, a choice is required.
         */
        this.requiredChoice = null;

        /**
         * ### Dropdown.fixedChoice
         *
         * If True, custom values in menu do not validated.
         */
        this.fixedChoice = null;

        /**
        * ### Dropdown.inputWidth
        *
        * The width of the input form as string (css attribute)
        *
        * Some types preset it automatically
        */
        this.inputWidth = null;

        /**
          * ### CustomInput.userValidation
          *
          * An additional validation executed after the main validation function
          *
          * The function returns an object like:
          *
          * ```javascript
          *  {
          *    value: 'validvalue',
          *    err:   'This error occurred' // If invalid.
          *  }
          * ```
          */
        this.validation = null;

        /**
         * ### Dropdown.validationSpeed
         *
         * How often (in milliseconds) the validation function is called
         *
         * Default: 500
         */
        this.validationSpeed = 500;

    }


    Dropdown.prototype.init = function (opts) {
        // Init widget variables, but do not create
        // HTML elements, they should be created in append.

        var tmp;

        if (!this.id) {
            throw new TypeError('Dropdown.init: id is missing');
        }

        if ('string' === typeof opts.mainText) {
            this.mainText = opts.mainText;
        }
        else if ('undefined' !== typeof opts.mainText) {
            throw new TypeError('Dropdown.init: mainText must ' +
                'be string or undefined. Found: ' +
                opts.mainText);
        }

        // Set the labelText, if any.
        if ('string' === typeof opts.labelText) {
            this.labelText = opts.labelText;
        }
        else if ('undefined' !== typeof opts.labelText) {
            throw new TypeError('Dropdown.init: labelText must ' +
                'be string or undefined. Found: ' +
                opts.labelText);
        }

        // Set the placeholder text, if any.
        if ('string' === typeof opts.placeholder) {
            this.placeholder = opts.placeholder;
        }
        else if ('undefined' !== typeof opts.placeholder) {
            throw new TypeError('Dropdown.init: placeholder must ' +
                'be string or undefined. Found: ' +
                opts.placeholder);
        }

        // Add the choices.
        if ('undefined' !== typeof opts.choices) {
            this.choices = opts.choices;
        }

        // Option requiredChoice, if any.
        if ('boolean' === typeof opts.requiredChoice) {
            this.requiredChoice = opts.requiredChoice;
        }
        else if ('undefined' !== typeof opts.requiredChoice) {
            throw new TypeError('Dropdown.init: requiredChoice ' +
                'be boolean or undefined. Found: ' +
                opts.requiredChoice);
        }

        // Add the correct choices.
        if ('undefined' !== typeof opts.correctChoice) {
            if (this.requiredChoice) {
                throw new Error('Dropdown.init: cannot specify both ' +
                    'opts requiredChoice and correctChoice');
            }
            if (J.isArray(opts.correctChoice) &&
                opts.correctChoice.length > opts.choices.length) {
                throw new Error('Dropdown.init: correctChoice ' +
                    'length cannot exceed opts.choices length');
            }
            else {
                this.correctChoice = opts.correctChoice;
            }

        }

        // Option fixedChoice, if any.
        if ('boolean' === typeof opts.fixedChoice) {
            this.fixedChoice = opts.fixedChoice;
        }
        else if ('undefined' !== typeof opts.fixedChoice) {
            throw new TypeError('Dropdown.init: fixedChoice ' +
                'be boolean or undefined. Found: ' +
                opts.fixedChoice);
        }

        if ("undefined" === typeof opts.tag) {
            this.tag = "datalist";
        }
        else if ("datalist" === opts.tag || "select" === opts.tag) {
            this.tag = opts.tag;
        }
        else {
            throw new TypeError('Dropdown.init: tag must ' +
                'be "datalist", "select" or undefined. Found: ' + opts.tag);
        }

        // Set the main onchange listener, if any.
        if ('function' === typeof opts.listener) {
            this.listener = function (e) {
                opts.listener.call(this, e);
            };
        }
        else if ('undefined' !== typeof opts.listener) {
            throw new TypeError('Dropdown.init: listener must ' +
                'be function or undefined. Found: ' +
                opts.listener);
        }

        // Set an additional onchange, if any.
        if ('function' === typeof opts.onchange) {
            this.onchange = opts.onchange;
        }
        else if ('undefined' !== typeof opts.onchange) {
            throw new TypeError('Dropdownn.init: onchange must ' +
                'be function or undefined. Found: ' +
                opts.onchange);
        }

        // Set an additional validation, if any.
        if ('function' === typeof opts.validation) {
            this.validation = opts.validation;
        }
        else if ('undefined' !== typeof opts.validation) {
            throw new TypeError('Dropdownn.init: validation must ' +
                'be function or undefined. Found: ' +
                opts.validation);
        }


        // Option shuffleChoices, default false.
        if ('undefined' === typeof opts.shuffleChoices) tmp = false;
        else tmp = !!opts.shuffleChoices;
        this.shuffleChoices = tmp;

        if (opts.width) {
            if ('string' !== typeof opts.width) {
                throw new TypeError('Dropdownn.init:width must be string or ' +
                    'undefined. Found: ' + opts.width);
            }
            this.inputWidth = opts.width;
        }

        // Validation Speed
        if ('undefined' !== typeof opts.validationSpeed) {

            tmp = J.isInt(opts.valiadtionSpeed, 0, undefined, true);
            if (tmp === false) {
                throw new TypeError('Dropdownn.init: validationSpeed must ' +
                    ' a non-negative number or undefined. Found: ' +
                    opts.validationSpeed);
            }
            this.validationSpeed = tmp;
        }

        // Hint (must be done after requiredChoice)
        tmp = opts.hint;
        if ('function' === typeof tmp) {
            tmp = tmp.call(this);
            if ('string' !== typeof tmp && false !== tmp) {
                throw new TypeError('Dropdown.init: hint cb must ' +
                                    'return string or false. Found: ' +
                                    tmp);
            }
        }
        if ('string' === typeof tmp || false === tmp) {
            this.hint = tmp;
        }
        else if ('undefined' !== typeof tmp) {
            throw new TypeError('Dropdown.init: hint must ' +
                                'be a string, false, or undefined. Found: ' +
                                tmp);
        }
        if (this.requiredChoice && tmp !== false) {
            this.hint = tmp ? this.hint + ' *' : ' *';
        }

    }

    // Implements the Widget.append method.
    Dropdown.prototype.append = function () {
        if (W.gid(this.id)) {
            throw new Error('Dropdown.append: id is not unique: ' + this.id);
        }
        var mt;

        if (this.mainText) {
            mt = W.append('span', this.bodyDiv, {
                className: 'dropdown-maintext',
                innerHTML: this.mainText
            });
        }

        // Hint.
        if (this.hint) {
            W.append('span', mt || this.bodyDiv, {
                className: 'dropdown-hint',
                innerHTML: this.hint
            });
        }

        if (this.labelText) {
            W.append('label', this.bodyDiv, {
                innerHTML: this.labelText
            });
        }

        this.setChoices(this.choices, true);

        this.errorBox = W.append('div', this.bodyDiv, {
            className: 'errbox'
        });
    };


    Dropdown.prototype.setChoices = function (choices, append) {
        var isDatalist, order;
        var select;
        var i, len, value, name;

        // TODO validate choices.
        this.choices = choices;

        if (!append) return;

        isDatalist = this.tag === 'datalist';

        // Create the structure from scratch or just clear all options.
        if (this.menu) {
            select = isDatalist ? this.datalist : this.menu;
            select.innerHTML = '';
        }
        else {
            if (isDatalist) {

                this.menu = W.add('input', this.bodyDiv, {
                    id: this.id,
                    autocomplete: 'off'
                });

                this.datalist = select = W.add('datalist', this.bodyDiv, {
                    id: this.id + "_datalist"
                });

                this.menu.setAttribute('list', this.datalist.id);
            }
            else {

                select = W.get('select');
                select.id = this.id;

                this.bodyDiv.appendChild(select);
                this.menu = select;
            }
        }

        // Set width.
        if (this.inputWidth) this.menu.style.width = this.inputWidth;

        // Adding placeholder.
        if (this.placeholder) {
            if (isDatalist) {
                this.menu.placeholder = this.placeholder;
            }
            else {

                W.add('option', this.menu, {
                    value: '',
                    innerHTML: this.placeholder,
                    // Makes the placeholder unselectable after first click.
                    disabled: '',
                    selected: '',
                    hidden: ''
                });
            }
        }

        // Adding all options.
        len = choices.length;
        order = J.seq(0, len - 1);
        if (this.shuffleChoices) order = J.shuffle(order);
        for (i = 0; i < len; i++) {

            // Determining value and name of choice.
            value = name = choices[order[i]];
            if ('object' === typeof value) {
                if ('undefined' !== typeof value.value) {
                    name = value.name;
                    value = value.value;
                }
                else if (J.isArray(value)) {
                    name = value[1];
                    value = value[0];
                }
            }

            // select is a datalist element if tag is "datalist".
            W.add('option', select, {
                value: value,
                innerHTML: name
            });
        }

        this.enable();
    };

    /**
     * ### Dropdown.verifyChoice
     *
     * Compares the current choice/s with the correct one/s
     *
     * Depending on current settings, there are three modes of verifying
     * choices:
     *
     *    - requiredChoice: either true or false.
     *    - correctChoice:  the choices are compared against correct ones.
     *    - fixedChoice: compares the choice with given choices.
     *
     * @return {boolean|null} TRUE if current choice is correct,
     *   FALSE if it is not correct, or NULL if no correct choice
     *   was set
     *
     */
    Dropdown.prototype.verifyChoice = function () {

        var that = this;
        var correct = this.correctChoice;
        var current = this.currentChoice;
        var correctOptions;
        var res = { value: '' };


        if (this.tag === "select" && this.numberOfChanges === 0) {
            current = this.currentChoice = this.menu.value || null;
        }

        if (this.requiredChoice) {
            res.value = current !== null && current !== this.placeholder;
        }

        // If no correct choice is set return null.
        if ('undefined' === typeof correct) res.value = null;
        if ('string' === typeof correct) {
            res.value = current === correct;
        }
        if ('number' === typeof correct) {
            res.value = current === this.choices[correct];
        }
        if (J.isArray(correct)) {
            correctOptions = correct.map(function (x) {
                return that.choices[x];
            });
            res.value = correctOptions.indexOf(current) >= 0;
        }

        if (this.fixedChoice) {
            if (this.choices.indexOf(current) < 0) res.value = false;
        }

        if (this.validation) this.validation(this.currentChoice, res);

        return res;
    };

    /**
     * ### Dropdown.setError
     *
     * Set the error msg inside the errorBox
     *
     * @param {string} The error msg (can contain HTML)
     *
     * @see Dropdown.errorBox
     */
    Dropdown.prototype.setError = function (err) {
        // TODO: the errorBox is added only if .append() is called.
        // However, DropdownGroup use the table without calling .append().
        if (this.errorBox) this.errorBox.innerHTML = err || '';
        if (err) this.highlight();
        else this.unhighlight();
    };

    /**
     * ### Dropdown.highlight
     *
     * Highlights the input
     *
     * @param {string} The style for the table's border.
     *   Default '3px solid red'
     *
     * @see Dropdown.highlighted
     */
    Dropdown.prototype.highlight = function (border) {
        if (border && 'string' !== typeof border) {
            throw new TypeError('Dropdown.highlight: border must be ' +
                'string or undefined. Found: ' + border);
        }
        if (this.highlighted) return;
        this.menu.style.border = border || '3px solid red';
        this.highlighted = true;
        this.emit('highlighted', border);
    };

    /**
     * ### Dropdown.unhighlight
     *
     * Removes highlight
     *
     * @see Dropdown.highlighted
     */
    Dropdown.prototype.unhighlight = function () {
        if (this.highlighted !== true) return;
        this.menu.style.border = '';
        this.highlighted = false;
        this.setError();
        this.emit('unhighlighted');
    };

    /**
     * ### Dropdown.selectChoice
     *
     * Select a given choice in the datalist or select tag.
     *
     * @param {string|number} choice. Its value depends on the tag.
     *
     *   - "datalist": a string, if number it is resolved to the name of
     *     the choice at idx === choice.
     *   - "select": a number, if string it is resolved to the idx of
     *     the choice name === choice. Value -1 will unselect all choices.
     *
     * @return {string|number} idx The resolved name or index
     */
    Dropdown.prototype.selectChoice = function (choice) {
        // idx is a number if tag is select and a string if tag is datalist.
        var idx;

        if (!this.choices || !this.choices.length) return;
        if ('undefined' === typeof choice) return;

        idx = choice;

        if (this.tag === 'select') {
            if ('string' === typeof choice) {
                idx = getIdxOfChoice(this, choice);
                if (idx === -1) {
                    node.warn('Dropdown.selectChoice: choice not found: ' +
                               choice);
                    return;
                }
            }
            else if (null === choice || false === choice) {
                idx = 0;
            }
            else if ('number' === typeof choice) {
                // 1-based. 0 is for deselecting everything.
                idx++;
            }
            else {
                throw new TypeError('Dropdown.selectChoice: invalid choice: ' +
                                    choice);
            }

            // Set the choice.
            this.menu.selectedIndex = idx;
        }
        else {

            if ('number' === typeof choice) {
                idx = getChoiceOfIdx(this, choice);
                if ('undefined' === typeof idx) {
                    node.warn('Dropdown.selectChoice: choice not found: ' +
                               choice);
                    return;
                }
            }
            else if ('string' !== typeof choice) {
                throw new TypeError('Dropdown.selectChoice: invalid choice: ' +
                                    choice);
            }

            this.menu.value = idx;
        }

        // Simulate event.
        this.listener({ target: this.menu });

        return idx;
    };

    /**
     * ### Dropdown.setValues
     *
     * Set the values on the dropdown menu
     *
     * @param {object} opts Optional. Configuration options.
     *
     * @see Dropdown.verifyChoice
     */
    Dropdown.prototype.setValues = function(opts) {
        var choice, correctChoice;
        var i, len, j, lenJ;

        if (!this.choices || !this.choices.length) {
            throw new Error('Dropdown.setValues: no choices found.');
        }
        if ('undefined' === typeof opts) opts = {};

        // TODO: this code is duplicated from ChoiceTable.
        if (opts.correct && this.correctChoice !== null) {

            // Make it an array (can be a string).
            correctChoice = J.isArray(this.correctChoice) ?
                this.correctChoice : [this.correctChoice];

            i = -1, len = correctChoice.length;
            for ( ; ++i < len ; ) {
                choice = parseInt(correctChoice[i], 10);
                if (this.shuffleChoices) {
                    j = -1, lenJ = this.order.length;
                    for ( ; ++j < lenJ ; ) {
                        if (this.order[j] === choice) {
                            choice = j;
                            break;
                        }
                    }
                }

                this.selectChoice(choice);
            }
            return;
        }

        // Set values, random or pre-set.
        if ('number' === typeof opts || 'string' === typeof opts) {
            opts = { values: opts };
        }
        else if (opts && 'undefined' === typeof opts.values) {
            // Select has index 0 for deselecting
            opts = { values: J.randomInt(this.choices.length) -1 };
            // TODO: merge other options if they are used by selectChoice.
        }

        // If other options are used (rather than values) change TODO above.
        this.selectChoice(opts.values);

    };

    /**
     * ### Dropdown.getValues
     *
     * Returns the values for current selection and other paradata
     *
     * Paradata that is not set or recorded will be omitted
     *
     * @return {object} Object containing the choice and paradata
     *
     * @see Dropdown.verifyChoice
     */
    Dropdown.prototype.getValues = function (opts) {
        var obj;
        opts = opts || {};
        var verif = this.verifyChoice().value;

        obj = {
            id: this.id,
            choice: this.fixedChoice ?
                this.choices.indexOf(this.currentChoice) : this.currentChoice,
            time: this.timeCurrentChoice,
            nChanges: this.numberOfChanges
        };
        if ('undefined' === typeof opts.highlight) opts.highlight = true;
        if (this.shuffleChoices) obj.order = this.order;

        // Option getValue backward compatible.
        if (opts.addValue !== false && opts.getValue !== false) {
            obj.value = this.currentChoice;
        }

        if (null !== this.correctChoice || null !== this.requiredChoice ||
            null !== this.fixedChoice) {
            obj.isCorrect = verif;
            if (!obj.isCorrect && opts.highlight) this.highlight();
        }
        if (obj.isCorrect === false) {
            this.setError(this.getText('error', obj.value));
        }
        return obj;
    };

    /**
     * ### Dropdown.listeners
     *
     * Implements Widget.listeners
     *
     * Adds two listeners two disable/enable the widget on events:
     * INPUT_DISABLE, INPUT_ENABLE
     *
     * @see Widget.listeners
     */
    Dropdown.prototype.listeners = function () {
        var that = this;
        node.on('INPUT_DISABLE', function () {
            that.disable();
        });
        node.on('INPUT_ENABLE', function () {
            that.enable();
        });
    };

    /**
     * ### Dropdown.disable
     *
     * Disables the dropdown menu
     */
    Dropdown.prototype.disable = function () {
        if (this.disabled === true) return;
        this.disabled = true;
        if (this.menu) this.menu.removeEventListener('change', this.listener);
        this.emit('disabled');
    };

    /**
     * ### Dropdown.enable
     *
     * Enables the dropdown menu
     */
    Dropdown.prototype.enable = function () {
        if (this.disabled === false) return;
        if (!this.menu) {
            throw new Error('Dropdown.enable: dropdown menu not found.');
        }
        this.disabled = false;
        this.menu.addEventListener('change', this.listener);
        this.emit('enabled');
    };

    // ## Helper methods.


    function getChoiceOfIdx(that, idx) {
        return extractChoice(that.choices[idx]);

    }

    function extractChoice(c) {
        if ('object' === typeof c) {
            if ('undefined' !== typeof c.name) c = c.name;
            else c = c[1];
        }
        return c;
    }

    function getIdxOfChoice(that, choice) {
        var i, len, c;
        len = that.choices.length;
        for (i = 0; i < len; i++) {
            c = that.choices[i];
            // c can be string, object, or array.
            if ('object' === typeof c) {
                if ('undefined' !== typeof c.name) c = c.name;
                else c = c[1];
            }
            if (c === choice) return i;
        }
        return -1;
    }


})(node);

/**
 * # EmailForm
 * Copyright(c) 2021 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Displays a form to input email
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('EmailForm', EmailForm);

    // ## Meta-data

    EmailForm.version = '0.13.1';
    EmailForm.description = 'Displays a configurable email form.';

    EmailForm.title = false;
    EmailForm.className = 'emailform';

    EmailForm.texts = {
        label: 'Enter your email:',
        errString: 'Not a valid email address, ' +
                   'please correct it and submit it again.',
        sent: 'Sent!'
    };

    /**
     * ## EmailForm constructor
     *
     * @param {object} options configuration option
     */
    function EmailForm(opts) {

        /**
         * ### EmailForm.onsubmit
         *
         * Options passed to `getValues` when the submit button is pressed
         *
         * @see EmailForm.getValues
         */
        if (!opts.onsubmit) {
            this.onsubmit = {
                emailOnly: true,
                send: true,
                updateUI: true
            };
        }
        else if ('object' === typeof opts.onsubmit) {
            this.onsubmit = opts.onsubmit;
        }
        else {
            throw new TypeError('EmailForm constructor: opts.onsubmit ' +
                                'must be object or undefined. Found: ' +
                                opts.onsubmit);
        }

        /**
         * ### EmailForm._email
         *
         * Internal storage of the value of the email
         *
         * This value is used when the form has not been created yet
         *
         * @see EmailForm.createForm
         */
        this._email = opts.email || null;

        /**
         * ### EmailForm.attempts
         *
         * Invalid emails tried
         */
        this.attempts = [];

        /**
         * ### EmailForm.timeInput
         *
         * Time when the email was inserted (first character, last attempt)
         */
        this.timeInput = null;

        /**
         * ### EmailForm.formElement
         *
         * The email's HTML form
         */
        this.formElement = null;

        /**
         * ### EmailForm.inputElement
         *
         * The email's HTML input form
         */
        this.inputElement = null;

        /**
         * ### EmailForm.buttonElement
         *
         * The email's HTML submit button
         */
        this.buttonElement = null;

        /**
         * ### EmailForm.setMsg
         *
         * If TRUE, a set message is sent instead of a data msg
         *
         * Default: FALSE
         */
        this.setMsg = !!opts.setMsg || false;

        /**
         * ### EmailForm.showSubmitBtn
         *
         * If TRUE, a set message is sent instead of a data msg
         *
         * Default: FALSE
         */
        this.showSubmitBtn = 'undefined' === typeof opts.showSubmitBtn ?
            true : !!opts.showSubmitBtn;
    }

    // ## EmailForm methods

    EmailForm.prototype.createForm = function() {
        var that;
        var formElement, labelElement, inputElement, buttonElement;

        that = this;

        formElement = document.createElement('form');
        formElement.className = 'emailform-form';

        labelElement = document.createElement('label');
        labelElement.innerHTML = this.getText('label');

        inputElement = document.createElement('input');
        inputElement.setAttribute('type', 'text');
        inputElement.setAttribute('placeholder', 'Email');
        inputElement.className = 'emailform-input form-control';

        formElement.appendChild(labelElement);
        formElement.appendChild(inputElement);

        // Store references.
        this.formElement = formElement;
        this.inputElement = inputElement;

        if (this.showSubmitBtn) {
            buttonElement = document.createElement('input');
            buttonElement.setAttribute('type', 'submit');
            buttonElement.setAttribute('value', 'Submit email');
            buttonElement.className = 'btn btn-lg btn-primary ' +
            'emailform-submit';
            formElement.appendChild(buttonElement);

            // Add listeners on input form.
            J.addEvent(formElement, 'submit', function(event) {
                event.preventDefault();
                that.getValues(that.onsubmit);
            }, true);
            J.addEvent(formElement, 'input', function() {
                if (!that.timeInput) that.timeInput = J.now();
                if (that.isHighlighted()) that.unhighlight();
            }, true);

            // Store reference.
            this.buttonElement = buttonElement;
        }

        // If a value was previously set, insert it in the form.
        if (this._email) this.formElement.value = this._email;
        this._email = null;

        return formElement;
    };

    /**
     * ### EmailForm.verifyInput
     *
     * Verify current email, updates interface, and optionally marks attempt
     *
     * @param {boolean} markAttempt Optional. If TRUE, the current email
     *    is added to the attempts array. Default: TRUE
     * @param {boolean} updateUI Optional. If TRUE, the interface is updated.
     *    Default: FALSE
     *
     * @return {boolean} TRUE, if the email is valid
     *
     * @see EmailForm.getValues
     * @see getEmail
     */
    EmailForm.prototype.verifyInput = function(markAttempt, updateUI) {
        var email, res;
        email = getEmail.call(this);
        res = J.isEmail(email);
        if (res && updateUI) {
            if (this.inputElement) this.inputElement.disabled = true;
            if (this.buttonElement) {
                this.buttonElement.disabled = true;
                this.buttonElement.value = this.getText('sent');
            }
        }
        else {
            if (updateUI && this.buttonElement) {
                this.buttonElement.value = this.getText('errString');
            }
            if ('undefined' === typeof markAttempt || markAttempt) {
                this.attempts.push(email);
            }
        }
        return res;
    };

    /**
     * ### EmailForm.append
     *
     * Appends widget to this.bodyDiv
     */
    EmailForm.prototype.append = function() {
        this.createForm();
        this.bodyDiv.appendChild(this.formElement);
    };

    /**
     * ### EmailForm.setValues
     *
     * Set the value of the email input form
     */
    EmailForm.prototype.setValues = function(options) {
        var email;
        options = options || {};
        if (!options.email) email = J.randomEmail();
        else email = options.email;

        if (!this.inputElement) this._email = email;
        else this.inputElement.value = email;

        this.timeInput = J.now();
    };

    /**
     * ### EmailForm.getValues
     *
     * Returns the email and paradata
     *
     * @param {object} opts Optional. Configures the return value.
     *   Available optionts:
     *
     *   - emailOnly:   If TRUE, returns just the email (default: FALSE),
     *   - verify:      If TRUE, check if the email is valid (default: TRUE),
     *   - reset:       If TRUTHY and the email is valid, then it resets
     *       the email value before returning (default: FALSE),
     *   - markAttempt: If TRUE, getting the value counts as an attempt
     *       (default: TRUE),
     *   - updateUI:    If TRUE, the UI (form, input, button) is updated.
     *                  Default: FALSE.
     *   - highlight:   If TRUE, if email is not the valid, widget is
     *                  is highlighted. Default: (updateUI || FALSE).
     *   - send:        If TRUE, and the email is valid, then it sends
     *                  a data or set msg. Default: FALSE.
     *   - sendAnyway:  If TRUE, it sends a data or set msg regardless of
     *                  the validity of the email. Default: FALSE.
     *   - say:         same as send, but deprecated.
     *   - sayAnyway:   same as sendAnyway, but deprecated
     *
     * @return {string|object} The email, and optional paradata
     *
     * @see EmailForm.sendValues
     * @see EmailForm.verifyInput
     * @see getEmail
     */
    EmailForm.prototype.getValues = function(opts) {
        var email, res;
        opts = opts || {};

        if ('undefined' !== typeof opts.say) {
            console.log('***EmailForm.getValues: option say is deprecated, ' +
                        ' use send.***');
            opts.send = opts.say;
        }
        if ('undefined' !== typeof opts.sayAnyway) {
            console.log('***EmailForm.getValues: option sayAnyway is ' +
                        'deprecated, use sendAnyway.***');
            opts.sendAnyway = opts.sayAnyway;
        }

        if ('undefined' === typeof opts.markAttempt) opts.markAttempt = true;
        if ('undefined' === typeof opts.highlight) opts.highlight = true;

        email = getEmail.call(this);

        if (opts.verify !== false) {
            res = this.verifyInput(opts.markAttempt, opts.updateUI);
        }

        // Only value.
        if (!opts.emailOnly) {
            email = {
                time: this.timeInput,
                email: email,
                attempts: this.attempts,
            };
            if (opts.markAttempt) email.isCorrect = res;
        }

        if (res === false) {
            if (opts.updateUI || opts.highlight) this.highlight();
            this.timeInput = null;
        }

        // Send the message.
        if ((opts.send && res) || opts.sendAnyway) {
            this.sendValues({ values: email });
        }

        if (opts.reset) this.reset();

        return email;
    };

    /**
     * ### EmailForm.sendValues
     *
     * Sends a DATA message with label 'email' with current email and paradata
     *
     * @param {object} opts Optional. Options to pass to the `getValues`
     *    method. Additional options:
     *
     *    - values: actual values to send, instead of the return
     *        value of `getValues`
     *    - to: recipient of the message. Default: 'SERVER'
     *
     * @return {string|object} The email, and optional paradata
     *
     * @see EmailForm.getValues
     */
    EmailForm.prototype.sendValues = function(opts) {
        var values;
        opts = opts || { emailOnly: true };
        values = opts.values || this.getValues(opts);
        if (this.setMsg) {
            if ('string' === typeof values) values = { email: values };
            node.set(values, opts.to || 'SERVER');
        }
        else {
            node.say('email', opts.to || 'SERVER', values);
        }
        return values;
    };

    /**
     * ### EmailForm.highlight
     *
     * Highlights the email form
     *
     * @param {string} The style for the form border. Default: '1px solid red'
     *
     * @see EmailForm.highlighted
     */
    EmailForm.prototype.highlight = function(border) {
        if (border && 'string' !== typeof border) {
            throw new TypeError('EmailForm.highlight: border must be ' +
                                'string or undefined. Found: ' + border);
        }
        if (!this.inputElement || this.highlighted === true) return;
        this.inputElement.style.border = border || '3px solid red';
        this.highlighted = true;
        this.emit('highlighted', border);
    };

    /**
     * ### EmailForm.unhighlight
     *
     * Removes highlight from the form
     *
     * @see EmailForm.highlighted
     */
    EmailForm.prototype.unhighlight = function() {
        if (!this.inputElement || this.highlighted !== true) return;
        this.inputElement.style.border = '';
        this.highlighted = false;
        this.emit('unhighlighted');
    };

    /**
     * ### EmailForm.reset
     *
     * Resets email and collected paradata
     */
    EmailForm.prototype.reset = function() {
        this.attempts = [];
        this.timeInput = null;
        this._email = null;

        if (this.inputElement) this.inputElement.value = '';
        if (this.isHighlighted()) this.unhighlight();
    };

    // ## Helper methods.

    /**
     * ### getEmail
     *
     * Returns the value of the email in form or in `_email`
     *
     * Must be invoked with right context
     *
     * @return {string|null} The value of the email, if any
     */
    function getEmail() {
        return this.inputElement ? this.inputElement.value : this._email;
    }

})(node);

/**
 * # EndScreen
 * Copyright(c) 2021 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Creates an interface to display final earnings, exit code, etc.
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    // Register the widget in the widgets collection.
    node.widgets.register('EndScreen', EndScreen);

    // ## Add Meta-data

    EndScreen.version = '0.8.0';
    EndScreen.description = 'Game end screen. With end game message, ' +
                            'email form, and exit code.';

    EndScreen.title = false;
    EndScreen.className = 'endscreen';

    EndScreen.texts = {
        headerMessage: 'Thank you for participating!',
        message: 'You have now completed this task and your data has ' +
                 'been saved. Please go back to the Amazon Mechanical Turk ' +
                 'web site and submit the HIT.',
        totalWin: 'Your total win:',
        exitCode: 'Your exit code:',
        errTotalWin: 'Error: invalid total win.',
        errExitCode: 'Error: invalid exit code.',
        copyButton: 'Copy',
        exitCopyMsg: 'Exit code copied to clipboard.',
        exitCopyError: 'Failed to copy exit code. Please copy it manually.'
    };

    // ## Dependencies

    // Checked when the widget is created.
    EndScreen.dependencies = {
        Feedback: {},
        EmailForm: {}
    };

    /**
     * ## EndScreen constructor
     *
     * Creates a new instance of EndScreen
     *
     * @param {object} options Configuration options
     *
     * @see EndScreen.init
     */
    function EndScreen(options) {

        /**
         * ### EndScreen.showEmailForm
         *
         * If true, the email form is shown
         *
         * Default: true
         */
        this.showEmailForm = true;

        /**
         * ### EndScreen.showFeedbackForm
         *
         * If true, the feedback form is shown
         *
         * Default: true
         */
        this.showFeedbackForm = true;

        /**
         * ### EndScreen.showTotalWin
         *
         * If true, the total win is shown
         *
         * Default: true
         */
         this.showTotalWin = true;

        /**
         * ### EndScreen.showExitCode
         *
         * If true, the exit code is shown
         *
         * Default: true
         */
        this.showExitCode = true;

        /**
         * ### EndScreen.totalWinCurrency
         *
         * The currency displayed after totalWin
         *
         * Default: 'USD'
         *
         * // TODO: deprecate and rename to currency.
         */
         this.totalWinCurrency = 'USD';

        /**
         * ### EndScreen.totalWinCb
         *
         * If defined, the return value is displayed inside the totalWin box
         *
         * Accepts two parameters: a data object (as sent from server), and
         * the reference to the EndScreen.
         */
        this.totalWinCb = null;

        /**
         * ### EndScreen.emailForm
         *
         * EmailForm widget element
         *
         * @see EmailForm
         */
        this.emailForm = null;

        /**
         * ### EndScreen.feedback
         *
         * Feedback widget element
         *
         * @see Feedback
         */
        this.feedback = null;

        /**
         * ### EndScreen.endScreenElement
         *
         * Endscreen HTML element
         *
         * Default: an HTML element,
         * null initially, element added on append()
         */
        this.endScreenHTML = null;

        /**
         * ### EndScreen.askServer
         *
         * If TRUE, after being appended it sends a 'WIN' message to server
         *
         * Default: FALSE
         */
        this.askServer = options.askServer || false;
    }

    EndScreen.prototype.init = function(options) {

        if (options.email === false) {
            this.showEmailForm = false;
        }
        else if ('boolean' === typeof options.showEmailForm) {
            this.showEmailForm = options.showEmailForm;
        }
        else if ('undefined' !== typeof options.showEmailForm) {
            throw new TypeError('EndScreen.init: ' +
                                'options.showEmailForm ' +
                                'must be boolean or undefined. ' +
                                'Found: ' + options.showEmailForm);
        }

        if (options.feedback === false) {
            this.showFeedbackForm = false;
        }
        else if ('boolean' === typeof options.showFeedbackForm) {
            this.showFeedbackForm = options.showFeedbackForm;
        }
        else if ('undefined' !== typeof options.showFeedbackForm) {
            throw new TypeError('EndScreen.init: ' +
                                'options.showFeedbackForm ' +
                                'must be boolean or undefined. ' +
                                'Found: ' + options.showFeedbackForm);
        }

        if (options.totalWin === false) {
            this.showTotalWin = false;
        }
        else if ('boolean' === typeof options.showTotalWin) {
            this.showTotalWin = options.showTotalWin;
        }
        else if ('undefined' !== typeof options.showTotalWin) {
            throw new TypeError('EndScreen.init: ' +
                                'options.showTotalWin ' +
                                'must be boolean or undefined. ' +
                                'Found: ' + options.showTotalWin);
        }

        if (options.exitCode === false) {
            options.showExitCode !== false
        }
        else if ('boolean' === typeof options.showExitCode) {
            this.showExitCode = options.showExitCode;
        }
        else if ('undefined' !== typeof options.showExitCode) {
            throw new TypeError('EndScreen.init: ' +
                                'options.showExitCode ' +
                                'must be boolean or undefined. ' +
                                'Found: ' + options.showExitCode);
        }

        if ('string' === typeof options.totalWinCurrency &&
                 options.totalWinCurrency.trim() !== '') {

            this.totalWinCurrency = options.totalWinCurrency;
        }
        else if ('undefined' !== typeof options.totalWinCurrency) {
            throw new TypeError('EndScreen.init: ' +
                                'options.totalWinCurrency must be undefined ' +
                                'or a non-empty string. Found: ' +
                                options.totalWinCurrency);
        }

        if (options.totalWinCb) {
            if ('function' === typeof options.totalWinCb) {
                this.totalWinCb = options.totalWinCb;
            }
            else {
                throw new TypeError('EndScreen.init: ' +
                                    'options.totalWinCb ' +
                                    'must be function or undefined. ' +
                                    'Found: ' + options.totalWinCb);
            }
        }

        if (this.showEmailForm && !this.emailForm) {
            // TODO: nested properties are overwitten fully. Update.
            this.emailForm = node.widgets.get('EmailForm', J.mixin({
                onsubmit: {
                    send: true,
                    emailOnly: true,
                    updateUI: true
                },
                storeRef: false,
                texts: {
                    label: 'If you would like to be contacted for future ' +
                        'studies, please enter your email (optional):',
                    errString: 'Please enter a valid email and retry'
                },
                setMsg: true // Sends a set message for logic's db.
            }, options.email));
        }

        if (this.showFeedbackForm) {
            this.feedback = node.widgets.get('Feedback', J.mixin(
                { storeRef: false, minChars: 50, setMsg: true },
                options.feedback));
        }
    };

    // Implements the Widget.append method.
    EndScreen.prototype.append = function() {
        this.endScreenHTML = this.makeEndScreen();
        this.bodyDiv.appendChild(this.endScreenHTML);
        if (this.askServer) setTimeout(function() { node.say('WIN'); });
    };

    /**
     * ### EndScreen.makeEndScreen
     *
     * Builds up the end screen (HTML + nested widgets)
     */
    EndScreen.prototype.makeEndScreen = function() {
        var endScreenElement;
        var headerElement, messageElement;
        var totalWinElement, totalWinParaElement, totalWinInputElement;
        var exitCodeElement, exitCodeParaElement, exitCodeInputElement;
        var exitCodeBtn, exitCodeGroup;
        var basePay;
        var that = this;

        endScreenElement = document.createElement('div');
        endScreenElement.className = 'endscreen';

        headerElement = document.createElement('h1');
        headerElement.innerHTML = this.getText('headerMessage');
        endScreenElement.appendChild(headerElement);

        messageElement = document.createElement('p');
        messageElement.innerHTML = this.getText('message');
        endScreenElement.appendChild(messageElement);

        if (this.showTotalWin) {
            totalWinElement = document.createElement('div');

            totalWinParaElement = document.createElement('p');
            totalWinParaElement.innerHTML = '<strong>' +
                this.getText('totalWin') +
                '</strong>';

            totalWinInputElement = document.createElement('input');
            totalWinInputElement.className = 'endscreen-total form-control';
            totalWinInputElement.setAttribute('disabled', 'true');

            totalWinParaElement.appendChild(totalWinInputElement);
            totalWinElement.appendChild(totalWinParaElement);

            endScreenElement.appendChild(totalWinElement);
            this.totalWinInputElement = totalWinInputElement;
        }

        if (this.showExitCode) {
            exitCodeElement = document.createElement('div');
            exitCodeElement.className = 'input-group';

            exitCodeParaElement = document.createElement('span');
            exitCodeParaElement.innerHTML = '<strong>' +
                this.getText('exitCode') + '</strong>';

            exitCodeInputElement = document.createElement('input');
            exitCodeInputElement.id = 'exit_code';
            exitCodeInputElement.className = 'endscreen-exit-code ' +
                                             'form-control';
            exitCodeInputElement.setAttribute('disabled', 'true');

            exitCodeGroup = document.createElement('span');
            exitCodeGroup.className = 'input-group-btn';

            exitCodeBtn = document.createElement('button');
            exitCodeBtn.className = 'btn btn-default endscreen-copy-btn';
            exitCodeBtn.innerHTML = this.getText('copyButton');
            exitCodeBtn.type = 'button';
            exitCodeBtn.onclick = function() {
                that.copy(exitCodeInputElement.value);
            };

            exitCodeGroup.appendChild(exitCodeBtn);
            endScreenElement.appendChild(exitCodeParaElement);
            exitCodeElement.appendChild(exitCodeGroup);
            exitCodeElement.appendChild(exitCodeInputElement);

            endScreenElement.appendChild(exitCodeElement);
            this.exitCodeInputElement = exitCodeInputElement;
        }

        basePay = node.game.settings.BASE_PAY;
        if ('undefined' !== typeof basePay) {
            this.updateDisplay({
                basePay: basePay, total: basePay, exitCode: ''
            });
        }

        if (this.showEmailForm) {
            node.widgets.append(this.emailForm, endScreenElement, {
                title: false,
                panel: false
            });
        }

        if (this.showFeedbackForm) {
            node.widgets.append(this.feedback, endScreenElement, {
                title: false,
                panel: false
            });
        }

        return endScreenElement;
    };

    // Implements the Widget.listeners method.
    EndScreen.prototype.listeners = function() {
        var that;
        that = this;
        node.on.data('WIN', function(message) {
            that.updateDisplay(message.data);
        });
    };

    EndScreen.prototype.copy = function(text) {
        var inp = document.createElement('input');
        try {
            document.body.appendChild(inp);
            inp.value = text;
            inp.select();
            document.execCommand('copy', false);
            inp.remove();
            alert(this.getText('exitCopyMsg'));
        }
        catch (err) {
            alert(this.getText('exitCopyError'));
        }
    };

    /**
     * ### EndScreen.updateDisplay
     *
     * Updates the display
     *
     * @param {object} data An object containing the info to update. Format:
     *    - total: The total won.
     *    - exit: An exit code.
     */
    EndScreen.prototype.updateDisplay = function(data) {
        var preWin, totalWin, totalRaw, exitCode;
        var totalHTML, exitCodeHTML, ex, err;

        if (this.totalWinCb) {
            totalWin = this.totalWinCb(data, this);
        }
        else {
            if ('undefined' === typeof data.total &&
                'undefined' === typeof data.totalRaw) {

                throw new Error('EndScreen.updateDisplay: data.total and ' +
                                'data.totalRaw cannot be both undefined.');
            }

            if ('undefined' !== typeof data.total) {
                totalWin = J.isNumber(data.total);
                if (totalWin === false) {
                    node.err('EndScreen.updateDisplay: invalid data.total: ' +
                             data.total);
                    totalWin = this.getText('errTotalWin');
                    err = true;
                }
            }

            preWin = '';

            if ('undefined' !== typeof data.basePay) {
                preWin = data.basePay;
            }

            if ('undefined' !== typeof data.bonus &&
                data.showBonus !== false) {

                if (preWin !== '') preWin += ' + ';
                preWin += data.bonus;
            }

            if (data.partials) {
                if (!J.isArray(data.partials)) {
                    node.err('EndScreen error, invalid partials win: ' +
                             data.partials);
                }
                else {
                    // If there is a basePay we already have a preWin.
                    if (preWin !== '') preWin += ' + ';
                    preWin += data.partials.join(' + ');
                }
            }

            if ('undefined' !== typeof data.totalRaw) {
                if (preWin) preWin += ' = ';
                else preWin = '';
                preWin += data.totalRaw;

                // Get Exchange Rate.
                ex = 'undefined' !== typeof data.exchangeRate ?
                    data.exchangeRate : node.game.settings.EXCHANGE_RATE;

                // If we have an exchange rate, check if we have a totalRaw.
                if ('undefined' !== typeof ex) preWin += '*' + ex;

                // Need to compute total manually.
                if ('undefined' === typeof totalWin) {
                    totalRaw = J.isNumber(data.totalRaw, 0);
                    totalWin = parseFloat(ex*totalRaw).toFixed(2);
                    totalWin = J.isNumber(totalWin, 0);
                    if (totalWin === false) {
                        node.err('EndScreen.updateDisplay: invalid : ' +
                                 'totalWin calculation from totalRaw.');
                        totalWin = this.getText('errTotalWin');
                        err = true;
                    }
                }
            }

            if (!err) {
                if (totalWin !== preWin & preWin !== '') {
                    totalWin = preWin + ' = ' + totalWin;
                }
                totalWin += ' ' + this.totalWinCurrency;
            }
        }

        exitCode = data.exit;
        if ('string' !== typeof exitCode) {
            node.err('EndScreen error, invalid exit code: ' + exitCode);
            exitCode = this.getText('errExitCode');
        }

        totalHTML = this.totalWinInputElement;
        exitCodeHTML = this.exitCodeInputElement;

        if (totalHTML && this.showTotalWin) {
            totalHTML.value = totalWin;
        }

        if (exitCodeHTML && this.showExitCode) {
            exitCodeHTML.value = exitCode;
        }
    };

})(node);

/**
 * # Feedback
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Sends a feedback message to the server
 *
 * www.nodegame.org
 *
 * TODO: rename css class feedback-char-count
 * TODO: words and chars count without contraints, just show.
 * TODO: shows all constraints in gray before the textarea.
 */
(function(node) {

    "use strict";

    node.widgets.register('Feedback', Feedback);

    // ## Meta-data

    Feedback.version = '1.6.0';
    Feedback.description = 'Displays a configurable feedback form';

    Feedback.title = 'Feedback';
    Feedback.className = 'feedback';

    Feedback.texts = {
        autoHint: function(w) {
            var res, res2;
            if (w.minChars && w.maxChars) {
                res = 'between ' + w.minChars + ' and ' + w.maxChars +
                    ' characters';
            }
            else if (w.minChars) {
                res = 'at least ' + w.minChars + ' character';
                if (w.minChars > 1) res += 's';
            }
            else if (w.maxChars) {
                res = 'at most ' +  w.maxChars + ' character';
                if (w.maxChars > 1) res += 's';
            }
            if (w.minWords && w.maxWords) {
                res2 = 'beetween ' + w.minWords + ' and ' + w.maxWords +
                    ' words';
            }
            else if (w.minWords) {
                res2 = 'at least ' + w.minWords + ' word';
                if (w.minWords > 1) res2 += 's';
            }
            else if (w.maxWords) {
                res2 = 'at most ' +  w.maxWords + ' word';
                if (w.maxWords > 1) res2 += 's';
            }
            if (res) {
                res = '(' + res;
                if (res2) res +=  ', and ' + res2;
                return res + ')';
            }
            else if (res2) {
                return '(' + res2 + ')';
            }
            return false;
        },
        submit: 'Submit feedback',
        label: 'Any feedback? Let us know here:',
        sent: 'Sent!',
        counter: function(w, param) {
            var res;
            res = param.chars ? ' character' : ' word';
            if (param.len !== 1) res += 's';
            if (param.needed) res += ' needed';
            else if (param.over) res += ' over';
            else if (!param.justcount) res += ' remaining';
            return res;
        }
    };

    // Colors for missing, excess or ok.
    var colNeeded, colOver, colRemain;
    colNeeded = '#a32020'; // #f2dede';
    colOver = '#a32020'; // #f2dede';
    colRemain = '#78b360'; // '#dff0d8';

    /**
     * ## Feedback constructor
     *
     * `Feedback` sends a feedback message to the server
     *
     * @param {object} options Optional. Configuration options
     */
    function Feedback(options) {
        var tmp;

        if ('undefined' !== typeof options.maxLength) {
            console.log('***Feedback constructor: maxLength is deprecated, ' +
                        'use maxChars instead***');
            options.maxChars = options.maxLength;
        }
        if ('undefined' !== typeof options.minLength) {
            console.log('***Feedback constructor: minLength is deprecated, ' +
                        'use minChars instead***');
            options.minChars = options.minLength;
        }

        /**
         * ### Feedback.mainText
         *
         * The main text introducing the choices
         *
         * @see Feedback.spanMainText
         */
        this.mainText = null;

        /**
         * ### Feedback.hint
         *
         * An additional text with information about how to select items
         *
         * If not specified, it may be auto-filled, e.g. '(pick 2)'.
         *
         * @see Feedback.texts.autoHint
         */
        this.hint = null;

        /**
         * ### Feedback.spanMainText
         *
         * The span containing the main text
         */
        this.spanMainText = null;

        /**
         * ### Feedback.maxChars
         *
         * The maximum character length for feedback to be submitted
         *
         * Default: 0
         */
        if ('undefined' === typeof options.maxChars) {
            this.maxChars = 0;
        }
        else {
            tmp = J.isInt(options.maxChars, 0);
            if (tmp !== false) {
                this.maxChars = tmp;
            }
            else {
                throw new TypeError('Feedback constructor: maxChars ' +
                                    'must be an integer >= 0 or undefined. ' +
                                    'Found: ' + options.maxChars);
            }
        }

        /**
         * ### Feedback.minChars
         *
         * The minimum character length for feedback to be submitted
         *
         * If minChars = 0, then there is no minimum length checked.
         *
         * Default: 0
         */
        if ('undefined' === typeof options.minChars) {
            this.minChars = 0;
        }
        else {
            tmp = J.isInt(options.minChars, 0, undefined, true);
            if (tmp !== false) {
                if (this.maxChars && tmp > this.maxChars) {
                    throw new TypeError('Feedback constructor: minChars ' +
                                        'cannot be greater than maxChars. ' +
                                        'Found: ' + tmp + ' > ' +
                                        this.maxChars);
                }
                this.minChars = tmp;
            }
            else {
                throw new TypeError('Feedback constructor: minChars ' +
                                    'must be an integer >= 0 or undefined. ' +
                                    'Found: ' + options.minChars);
            }
        }

        /**
         * ### Feedback.maxWords
         *
         * The maximum number of words for feedback to be submitted
         *
         * Set to 0 for no checks.
         *
         * Default: 0
         */
        if ('undefined' === typeof options.maxWords) {
            this.maxWords = 0;
        }
        else {
            tmp = J.isInt(options.maxWords, 0, undefined, true);
            if (tmp !== false) {
                this.maxWords = options.maxWords;
            }
            else {
                throw new TypeError('Feedback constructor: maxWords ' +
                                    'must be an integer >= 0 or undefined. ' +
                                    'Found: ' + options.maxWords);
            }
        }

        /**
         * ### Feedback.minWords
         *
         * The minimum number of words for feedback to be submitted
         *
         * If minWords = 0, then there is no minimum checked.
         *
         * Default: 0
         */
        if ('undefined' === typeof options.minWords) {
            this.minWords = 0;
        }
        else {
            tmp = J.isInt(options.minWords, 0, undefined, true);
            if (tmp  !== false) {
                this.minWords = options.minWords;

                // Checking if words and characters limit are compatible.
                if (this.maxChars) {
                    tmp = (this.maxChars+1)/2;
                    if (this.minWords > tmp) {

                        throw new TypeError('Feedback constructor: minWords ' +
                                            'cannot be larger than ' +
                                            '(maxChars+1)/2. Found: ' +
                                            this.minWords + ' > ' + tmp);
                    }
                }
            }
            else {
                throw new TypeError('Feedback constructor: minWords ' +
                                    'must be an integer >= 0 or undefined. ' +
                                    'Found: ' + options.minWords);
            }
        }

        // Extra checks.
        if (this.maxWords) {
            if (this.maxChars && this.maxChars < this.maxWords) {
                throw new TypeError('Feedback constructor: maxChars ' +
                                    'cannot be smaller than maxWords. ' +
                                    'Found: ' + this.maxChars + ' > ' +
                                    this.maxWords);
            }
            if (this.minChars > this.maxWords) {
                throw new TypeError('Feedback constructor: minChars ' +
                                    'cannot be greater than maxWords. ' +
                                    'Found: ' + this.minChars + ' > ' +
                                    this.maxWords);
            }
        }

        if (this.minWords || this.minChars || this.maxWords ||
            this.maxChars) {

            this.required = true;
        }

        /**
         * ### Feedback.rows
         *
         * The number of initial rows of the texarea
         *
         * Default: 3
         */
        if ('undefined' === typeof options.rows) {
            this.rows = 3;
        }
        else if (J.isInt(options.rows, 0) !== false) {
            this.rows = options.rows;
        }
        else {
            throw new TypeError('Feedback constructor: rows ' +
                                'must be an integer > 0 or undefined. ' +
                                'Found: ' + options.rows);
        }

        /**
         * ### Feedback.maxAttemptLength
         *
         * The maximum character length for an attempt to submit feedback
         *
         * Attempts are stored in the attempts array. You can store attempts
         * longer than valid feedbacks.
         *
         * Set to 0 for no limit.
         *
         * Default: 0
         */
        if ('undefined' === typeof options.maxAttemptLength) {
            this.maxAttemptLength = 0;
        }
        else {
            tmp = J.isNumber(options.maxAttemptLength, 0);
            if (tmp !== false) {
                this.maxAttemptLength = tmp;
            }
            else {
                throw new TypeError('Feedback constructor: ' +
                                'options.maxAttemptLength must be a number ' +
                                '> 0 or undefined. Found: ' +
                                options.maxAttemptLength);
            }
        }

        /**
         * ### Feedback.showSubmit
         *
         * If TRUE, the submit button is shown
         *
         * Default: true
         *
         * @see Feedback.submitButton
         */
        this.showSubmit = 'undefined' === typeof options.showSubmit ?
            true : !!options.showSubmit;

        /**
         * ### Feedback.onsubmit
         *
         * Options passed to `getValues` when the submit button is pressed
         *
         * @see Feedback.getValues
         */
        if (!options.onsubmit) {
            this.onsubmit = { feedbackOnly: true, send: true, updateUI: true };
        }
        else if ('object' === typeof options.onsubmit) {
            this.onsubmit = options.onsubmit;
        }
        else {
            throw new TypeError('Feedback constructor: onsubmit ' +
                                'must be string or object. Found: ' +
                                options.onsubmit);
        }

        /**
         * ### Feedback._feedback
         *
         * Internal storage of the value of the feedback
         *
         * This value is used when the form has not been created yet
         */
        this._feedback = options.feedback || null;

        /**
         * ### Feedback.attempts
         *
         * Invalid feedbacks tried
         */
        this.attempts = [];

        /**
         * ### Feedback.timeInputBegin
         *
         * Time when feedback was inserted (first character, last attempt)
         */
        this.timeInputBegin = null;

        /**
         * ### Feedback.feedbackForm
         *
         * The HTML form element containing the textarea
         */
        this.feedbackForm = null;

        /**
         * ### Feedback.textareaElement
         *
         * The HTML textarea element containing the feedback
         */
        this.textareaElement = null;

        /**
         * ### Feedback.charCounter
         *
         * The HTML span element containing the characters count
         */
        this.charCounter = null;

        /**
         * ### Feedback.wordCounter
         *
         * The HTML span element containing the words count
         */
        this.wordCounter = null;

        /**
         * ### Feedback.submitButton
         *
         * The HTML submit button
         */
        this.submitButton = null;

        /**
         * ### Feedback.setMsg
         *
         * If TRUE, a set message is sent instead of a data msg
         *
         * Default: FALSE
         */
        this.setMsg = !!options.setMsg || false;

    }

    // ## Feedback methods

    // TODO: move all initialization here from constructor.
    Feedback.prototype.init = function(options) {
        // Set the mainText, if any.
        if ('string' === typeof options.mainText) {
            this.mainText = options.mainText;
        }
        else if ('undefined' === typeof options.mainText) {
            this.mainText = this.getText('label');
        }
        else {
            throw new TypeError('Feedback.init: options.mainText must ' +
                                'be string or undefined. Found: ' +
                                options.mainText);
        }

        // Set the hint, if any.
        if ('string' === typeof options.hint || false === options.hint) {
            this.hint = options.hint;
        }
        else if ('undefined' !== typeof options.hint) {
            throw new TypeError('Feedback.init: options.hint must ' +
                                'be a string, false, or undefined. Found: ' +
                                options.hint);
        }
        else {
            // Returns undefined if there are no constraints.
            this.hint = this.getText('autoHint');
        }
    };

    /**
     * ### Feedback.verifyFeedback
     *
     * Verify feedback and optionally marks attempt and updates interface
     *
     * @param {boolean} markAttempt Optional. If TRUE, the current feedback
     *    is added to the attempts array (if too long, may be truncateed).
     *    Default: TRUE
     * @param {boolean} updateUI Optional. If TRUE, the interface is updated.
     *    Default: FALSE
     *
     * @return {boolean} TRUE, if the feedback is valid
     *
     * @see Feedback.getValues
     * @see Feedback.maxAttemptLength
     * @see getFeedback
     */
    Feedback.prototype.verifyFeedback = function(markAttempt, updateUI) {
        var feedback, length,  res;
        var submitButton, charCounter, wordCounter, tmp;
        var updateCharCount, updateCharColor, updateWordCount, updateWordColor;

        feedback = getFeedback.call(this);
        length = feedback ? feedback.length : 0;

        submitButton = this.submitButton;
        charCounter = this.charCounter;
        wordCounter = this.wordCounter;

        res = true;

        if (length < this.minChars) {
            res = false;
            tmp = this.minChars - length;
            updateCharCount = tmp + this.getText('counter', {
                chars: true,
                needed: true,
                len: tmp
            });
            updateCharColor = colNeeded;
        }
        else if (this.maxChars && length > this.maxChars) {
            res = false;
            tmp = length - this.maxChars;
            updateCharCount = tmp + this.getText('counter', {
                chars: true,
                over: true,
                len: tmp
            });
            updateCharColor = colOver;
        }
        else {
            tmp = this.maxChars ? this.maxChars - length : length;
            updateCharCount = tmp + this.getText('counter', {
                chars: true,
                len: tmp,
                justcount: !this.maxChars
            });
            updateCharColor = colRemain;
        }

        if (wordCounter) {
            // kudos: https://css-tricks.com/build-word-counter-app/
            // word count using \w metacharacter -
            // replacing this with .* to match anything between word
            // boundaries since it was not taking 'a' as a word.
            // this is a masterstroke - to count words with any number
            // of hyphens as one word
            // [-?(\w+)?]+ looks for hyphen and a word (we make
            // both optional with ?). + at the end makes it a repeated pattern
            // \b is word boundary metacharacter
            tmp = feedback ? feedback.match(/\b[-?(\w+)?]+\b/gi) : 0;
            length = tmp ? tmp.length : 0;
            if (length < this.minWords) {
                res = false;
                tmp = tmp = this.minWords - length;
                updateWordCount = tmp + this.getText('counter', {
                    needed: true,
                    len: tmp
                });
                updateWordColor = colNeeded;
            }
            else if (this.maxWords && length > this.maxWords) {
                res = false;
                tmp = length - this.maxWords;
                updateWordCount = tmp + this.getText('counter', {
                    over: true,
                    len: tmp
                });
                updateWordColor = colOver;
            }
            else {
                tmp = this.maxWords ? this.maxWords - length : length;
                updateWordCount = tmp + this.getText('counter', {
                    len: tmp,
                    justcount: !this.maxWords
                });
                updateWordColor = colRemain;
            }
        }

        if (updateUI) {
            if (submitButton) submitButton.disabled = !res;
            if (charCounter) {
                charCounter.style.backgroundColor = updateCharColor;
                charCounter.innerHTML = updateCharCount;
            }
            if (wordCounter) {
                wordCounter.style.backgroundColor = updateWordColor;
                wordCounter.innerHTML = updateWordCount;
            }
        }

        if (!res && ('undefined' === typeof markAttempt || markAttempt)) {
            if (this.maxAttemptLength && length > this.maxAttemptLength) {
                feedback = feedback.substr(0, this.maxAttemptLength);
            }
            this.attempts.push(feedback);
        }
        return res;
    };

    /**
     * ### Feedback.append
     *
     * Appends widget to this.bodyDiv
     */
    Feedback.prototype.append = function() {
        var that;
        that = this;

        // this.feedbackForm = W.get('div', { className: 'feedback' });

        this.feedbackForm = W.append('form', this.bodyDiv, {
            className: 'feedback-form'
        });

        // MainText.
        if (this.mainText) {
            this.spanMainText = W.append('span', this.feedbackForm, {
                className: 'feedback-maintext',
                innerHTML: this.mainText
            });
        }
        // Hint.
        if (this.hint) {
            W.append('span', this.spanMainText || this.feedbackForm, {
                className: 'feedback-hint',
                innerHTML: this.hint
            });
        }

        this.textareaElement = W.append('textarea', this.feedbackForm, {
            className: 'form-control feedback-textarea',
            type: 'text',
            rows: this.rows
        });

        if (this.showSubmit) {
            this.submitButton = W.append('input', this.feedbackForm, {
                className: 'btn btn-lg btn-primary',
                type: 'submit',
                value: this.getText('submit')
            });

            // Add listeners.
            J.addEvent(this.feedbackForm, 'submit', function(event) {
                event.preventDefault();
                that.getValues(that.onsubmit);
            });
        }

        this.showCounters();

        J.addEvent(this.feedbackForm, 'input', function() {
            if (that.isHighlighted()) that.unhighlight();
            that.verifyFeedback(false, true);
        });
        J.addEvent(this.feedbackForm, 'click', function() {
            if (that.isHighlighted()) that.unhighlight();
        });

        // Check it once at the beginning to initialize counter.
        this.verifyFeedback(false, true);
    };

    /**
     * ### Feedback.setValues
     *
     * Set the value of the feedback
     *
     * @param {object} options Conf options. Values:
     *
     *   - feedback: a string containing the desired feedback.
     *               If not set, a random string will be set.
     *   - verify: if TRUE, the method verifyFeedback is called
     *             afterwards, updating the UI. Default: TRUE
     *   - markAttempt: if TRUE, the verify attempt is added. Default: TRUE
     */
    Feedback.prototype.setValues = function(options) {
        var feedback, maxChars, minChars, nWords, i;
        options = options || {};
        if (!options.feedback) {
            minChars = this.minChars || 0;
            if (this.maxChars) maxChars = this.maxChars;
            else if (this.maxWords) maxChars = this.maxWords * 4;
            else if (minChars) maxChars = minChars + 80;
            else maxChars = 80;

            feedback = J.randomString(J.randomInt(minChars, maxChars), 'aA_1');
            if (this.minWords) {
                nWords = this.minWords - feedback.split(' ').length;
                if (nWords > 0) {
                    for (i = 0; i < nWords ; i++) {
                        feedback += ' ' + i;
                    }
                }
            }
        }
        else {
            feedback = options.feedback;
        }

        if (!this.textareaElement) this._feedback = feedback;
        else this.textareaElement.value = feedback;

        this.timeInputBegin = J.now();

        if (options.verify !== false) {
            this.verifyFeedback(options.markAttempt, true);
        }
    };

    /**
     * ### Feedback.getValues
     *
     * Returns the feedback and paradata
     *
     * @param {object} opts Optional. Configures the return value.
     *   Available optionts:
     *
     *   - feedbackOnly:If TRUE, returns just the feedback (default: FALSE),
     *   - keepBreaks:  If TRUE, returns a value where all line breaks are
     *                  substituted with HTML <br /> tags (default: FALSE)
     *   - verify:      If TRUE, check if the feedback is valid (default: TRUE),
     *   - reset:       If TRUTHY and the feedback is valid, then it resets
     *       the feedback value before returning (default: FALSE),
     *   - markAttempt: If TRUE, getting the value counts as an attempt
     *       (default: TRUE),
     *   - updateUI:    If TRUE, the UI (form, input, button) is updated.
     *                  Default: FALSE.
     *   - highlight:   If TRUE, if feedback is not the valid, widget is
     *                  is highlighted. Default: (updateUI || FALSE).
     *   - send:        If TRUE, and the email is valid, then it sends
     *                  a data or set msg. Default: FALSE.
     *   - sendAnyway:  If TRUE, it sends a data or set msg regardless of
     *                  the validity of the email. Default: FALSE.
     *   - say:         same as send, but deprecated.
     *   - sayAnyway:   same as sendAnyway, but deprecated
     *
     * @return {string|object} The feedback, and optional paradata
     *
     * @see Feedback.sendValues
     * @see Feedback.verifyFeedback
     * @see getFeedback
     */
    Feedback.prototype.getValues = function(opts) {
        var feedback, res;

        opts = opts || {};

        if ('undefined' !== typeof opts.say) {
            console.log('***EmailForm.getValues: option say is deprecated, ' +
                        ' use send.***');
            opts.send = opts.say;
        }
        if ('undefined' !== typeof opts.sayAnyway) {
            console.log('***EmailForm.getValues: option sayAnyway is ' +
                        'deprecated, use sendAnyway.***');
            opts.sendAnyway = opts.sayAnyway;
        }

        if ('undefined' === typeof opts.markAttempt) opts.markAttempt = true;
        if ('undefined' === typeof opts.highlight) opts.highlight = true;

        feedback = getFeedback.call(this);

        if (opts.keepBreaks) feedback = feedback.replace(/\n\r?/g, '<br />');

        if (opts.verify !== false) res = this.verifyFeedback(opts.markAttempt,
                                                             opts.updateUI);

        if (res === false &&
            (opts.updateUI || opts.highlight)) this.highlight();

        // Only value.
        if (!opts.feedbackOnly) {
            feedback = {
                timeBegin: this.timeInputBegin,
                feedback: feedback,
                attempts: this.attempts,
                valid: res
            };
            if (opts.markAttempt) feedback.isCorrect = res;
        }

        // Send the message.
        if (feedback !== '' && ((opts.send && res) || opts.sendAnyway)) {
            this.sendValues({ values: feedback });
            if (opts.updateUI) {
                this.submitButton.setAttribute('value', this.getText('sent'));
                this.submitButton.disabled = true;
                this.textareaElement.disabled = true;
            }
        }

        if (opts.reset) this.reset();

        return feedback;
    };

    /**
     * ### Feedback.sendValues
     *
     * Sends a DATA message with label 'feedback' with feedback and paradata
     *
     * @param {object} opts Optional. Options to pass to the `getValues`
     *    method. Additional options:
     *
     *    - values: actual values to send, instead of the return
     *        value of `getValues`
     *    - to: recipient of the message. Default: 'SERVER'
     *
     * @return {string|object} The feedback, and optional paradata
     *
     * @see Feedback.getValues
     */
    Feedback.prototype.sendValues = function(opts) {
        var values;
        opts = opts || { feedbackOnly: true };
        values = opts.values || this.getValues(opts);
        if (this.setMsg) {
            if ('string' === typeof values) values = { feedback: values };
            node.set(values, opts.to || 'SERVER');
        }
        else {
            node.say('feedback', opts.to || 'SERVER', values);
        }
        return values;
    };

    /**
     * ### Feedback.highlight
     *
     * Highlights the feedback form
     *
     * @param {string} The style for the form border. Default: '1px solid red'
     *
     * @see Feedback.highlighted
     */
    Feedback.prototype.highlight = function(border) {
        if (border && 'string' !== typeof border) {
            throw new TypeError('Feedback.highlight: border must be ' +
                                'string or undefined. Found: ' + border);
        }
        if (!this.isAppended() || this.highlighted === true) return;
        this.textareaElement.style.border = border || '3px solid red';
        this.highlighted = true;
        this.emit('highlighted', border);
    };

    /**
     * ### Feedback.unhighlight
     *
     * Removes highlight from the form
     *
     * @see Feedback.highlighted
     */
    Feedback.prototype.unhighlight = function() {
        if (!this.isAppended() || this.highlighted !== true) return;
        this.textareaElement.style.border = '';
        this.highlighted = false;
        this.emit('unhighlighted');
    };

    /**
     * ### Feedback.reset
     *
     * Resets feedback and collected paradata
     */
    Feedback.prototype.reset = function() {
        this.attempts = [];
        this.timeInputBegin = null;
        this._feedback = null;

        if (this.textareaElement) this.textareaElement.value = '';
        if (this.isHighlighted()) this.unhighlight();
    };

    /**
     * ### Feedback.disable
     *
     * Disables texarea and submit button (if present)
     */
    Feedback.prototype.disable = function() {
        // TODO: This gets off when WaitScreen locks all inputs.
        // if (this.disabled === true) return;
        if (!this.textareaElement || this.textareaElement.disabled) return;
        this.disabled = true;
        if (this.submitElement) this.submitElement.disabled = true;
        this.textareaElement.disabled = true;
        this.emit('disabled');
    };

    /**
     * ### Feedback.enable
     *
     * Enables texarea and submit button (if present)
     *
     */
    Feedback.prototype.enable = function() {
        // TODO: This gets off when WaitScreen locks all inputs.
        // if (this.disabled === false || !this.textareaElement) return;
        if (!this.textareaElement || !this.textareaElement.disabled) return;
        this.disabled = false;
        if (this.submitElement) this.submitElement.disabled = false;
        this.textareaElement.disabled = false;
        this.emit('enabled');
    };

    /**
     * ### Feedback.showCounters
     *
     * Shows the character counter
     *
     * If not existing before, it creates it.
     *
     * @see Feedback.charCounter
     */
    Feedback.prototype.showCounters = function() {
        if (!this.charCounter) {
            if (this.minChars || this.maxChars) {
                this.charCounter = W.append('span', this.feedbackForm, {
                    className: 'feedback-char-count badge',
                    innerHTML: this.maxChars
                });
            }
        }
        else {
            this.charCounter.style.display = '';
        }
        if (!this.wordCounter) {
            if (this.minWords || this.maxWords) {
                this.wordCounter = W.append('span', this.feedbackForm, {
                    className: 'feedback-char-count badge',
                    innerHTML: this.maxWords
                });
                if (this.charCounter) {
                    this.wordCounter.style['margin-left'] = '10px';
                }
            }
        }
        else {
            this.wordCounter.style.display = '';
        }
    };

    /**
     * ### Feedback.hideCounters
     *
     * Hides the character counter
     */
    Feedback.prototype.hideCounters = function() {
        if (this.charCounter) this.charCounter.style.display = 'none';
        if (this.wordCounter) this.wordCounter.style.display = 'none';
    };

    // ## Helper functions.

    /**
     * ### getFeedback
     *
     * Returns the value of the feedback textarea or in `_feedback`
     *
     * Must be invoked with right context
     *
     * @return {string|null} The value of the feedback, if any
     */
    function getFeedback() {
        var out;
        out = this.textareaElement ?
            this.textareaElement.value : this._feedback;
        return out ? out.trim() : out;
    }

})(node);

/**
 * # Goto
 * Copyright(c) 2022 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Creates a simple interface to go to a step in the sequence.
 *
 * www.nodegame.org
 */
 (function(node) {

    "use strict";

    node.widgets.register('Goto', Goto);

    // ## Meta-data

    Goto.version = '0.0.2';
    Goto.description = 'Creates a simple interface to move across ' +
                       'steps in the sequence.';

    Goto.title = false;
    Goto.panel = false;
    Goto.className = 'goto';

    /**
     * ## Goto constructor
     *
     * Creates a new instance of Goto
     *
     * @param {object} options Optional. Configuration options.
     *
     * @see Goto.init
     */
    function Goto() {
        /**
         * ### Goto.dropdown
         *
         * A callback executed after the button is clicked
         *
         * If it return FALSE, node.done() is not called.
         */
        this.dropdown;
    }

    Goto.prototype.append = function() {
        this.dropdown = node.widgets.append('Dropdown', this.bodyDiv, {
            tag: 'select',
            choices: getSequence(),
            id: 'ng_goto',
            placeholder: 'Go to Step',
            width: '15rem',
            onchange: function(choice, datalist, that) {
                node.game.gotoStep(choice);
            }
        });
    };

    /**
     * ### Goto.disable
     *
     * Disables the widget
     */
    Goto.prototype.disable = function(opts) {
        if (this.disabled) return;
        this.disabled = true;
        this.dropdown.enable();
        this.emit('disabled', opts);
    };

    /**
     * ### Goto.enable
     *
     * Enables the widget
     */
    Goto.prototype.enable = function(opts) {
        if (!this.disabled) return;
        this.disabled = false;
        this.dropdown.disable();
        this.emit('enabled', opts);
    };


    // ## Helper functions.

    function getSequence(seq) {
        var i, j, out, value, vvalue, name, ss;
        out = [];
        seq = seq || node.game.plot.stager.sequence;
        for ( i = 0 ; i < seq.length ; i++) {
            value = (i+1);
            name = seq[i].id;
            for ( j = 0 ; j < seq[i].steps.length ; j++) {
                ss = seq[i].steps.length === 1;
                vvalue = ss ? value : value + '.' + (j+1);
                out.push({
                    value: vvalue,
                    name: vvalue + ' ' +
                         (ss ? name : name + '.' + seq[i].steps[j])
                });
            }
        }
        return out;
    }

})(node);

/**
 * # GroupMalleability
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Displays an interface to measure users' perception of group malleability.
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('GroupMalleability', GroupMalleability);

    // ## Meta-data

    GroupMalleability.version = '0.1.0';
    GroupMalleability.description = 'Displays an interface to measure ' +
        'perception for group malleability.';

    GroupMalleability.title = 'Group Malleability';
    GroupMalleability.className = 'group-malleability';


    var items = [
        'As hard as it is to admit, it is impossible to change the ' +
            'central characteristics of nationalities and groups.',
        'Groups that are characterized by extreme and violent traits ' +
            'will never change as these traits are inherently ingrained ' +
            'in their nature.',
        'Groups can sometimes change their outward behavior, but can ' +
            'never change who they really are.',
        'Every nationality or group has a fixed set of beliefs and ' +
            'values that cannot be changed.',
        'Social and political processes can lead to changes in a ' +
            'group\'s values and morality.'
    ];

    var choices = [ 1,2,3,4,5,6,7 ];

    var header = [
        'Strongly Oppose',
        'Somewhat Oppose',
        'Slightly Oppose',
        'Neutral',
        'Slightly Favor',
        'Somewhat Favor',
        'Strongly Favor'
    ];

    GroupMalleability.texts = {

        mainText:
            'Show how much you favor or oppose each idea below by ' +
            'selecting a number from 1 to 7 on the scale below. <em>You ' +
            'can work quickly, your first feeling is generally best.</em>'
    };

    // ## Dependencies

    GroupMalleability.dependencies = {};

    /**
     * ## GroupMalleability constructor
     *
     * Creates a new instance of GroupMalleability
     *
     * @param {object} options Optional. Configuration options
     * which is forwarded to GroupMalleability.init.
     *
     * @see GroupMalleability.init
     */
    function GroupMalleability() {

        /**
         * ## GroupMalleability.ct
         *
         * The ChoiceTableGroup widget containing the items
         */
        this.ctg = null;

        /**
         * ## GroupMalleability.choices
         *
         * The numerical scale used
         */
        this.choices = choices;

        /**
         * ## GroupMalleability.header
         *
         * The categorical scale used
         */
        this.header = header;

        /**
         * ### GroupMalleability.mainText
         *
         * A text preceeding the GroupMalleability scale
         */
        this.mainText = null;
    }

    // ## GroupMalleability methods.

    /**
     * ### GroupMalleability.init
     *
     * Initializes the widget
     *
     * @param {object} opts Optional. Configuration options.
     */
    GroupMalleability.prototype.init = function(opts) {
        opts = opts || {};

        if (opts.choices) {
            if (!J.isArray(opts.choices) || opts.choices.length < 2) {
                throw new Error('GroupMalleability.init: choices must be an ' +
                                'array of length > 1 or undefined. Found: ' +
                                opts.choices);
            }
            this.choices = opts.choices;
        }

        if (opts.header) {
            if (!J.isArray(opts.header) ||
                opts.header.length !== this.choices.length) {

                throw new Error('GroupMalleability.init: header must be an ' +
                                'array of length equal to the number of ' +
                                'choices or undefined. Found: ' + opts.header);
            }
            this.header = opts.header;
        }

        if (opts.mainText) {
            if ('string' !== typeof opts.mainText && opts.mainText !== false) {
                throw new Error('GroupMalleability.init: mainText must be ' +
                                'string, false, or undefined. Found: ' +
                                opts.mainText);
            }
            this.mainText = opts.mainText;
        }
        else if (opts.mainText !== false) {
             this.mainText = this.getText('mainText');
        }
    };

    GroupMalleability.prototype.append = function() {
        this.ctg = node.widgets.add('ChoiceTableGroup', this.panelDiv, {
            id: this.id || 'groupmalleability_choicetable',
            items: items.map(function(item, i) {
                return [('GM_' + (i+1)), item ];
            }),
            choices: this.choices,
            mainText: this.mainText,
            title: false,
            panel: false,
            requiredChoice: this.required,
            header: this.header
        });
    };

    GroupMalleability.prototype.getValues = function(opts) {
        opts = opts || {};
        return this.ctg.getValues(opts);
    };

    GroupMalleability.prototype.setValues = function(opts) {
        opts = opts || {};
        return this.ctg.setValues(opts);
    };

    GroupMalleability.prototype.enable = function(opts) {
        return this.ctg.enable(opts);
    };

    GroupMalleability.prototype.disable = function(opts) {
        return this.ctg.disable(opts);
    };

    GroupMalleability.prototype.highlight = function(opts) {
        return this.ctg.highlight(opts);
    };

    GroupMalleability.prototype.unhighlight = function(opts) {
        return this.ctg.unhighlight(opts);
    };

})(node);

/**
 * # LanguageSelector
 * Copyright(c) 2017 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Manages and displays information about languages available and selected
 *
 * @TODO: bubble event in case of buttons (now there are many listeners).
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('LanguageSelector', LanguageSelector);

    // ## Meta-data

    LanguageSelector.version = '0.6.2';
    LanguageSelector.description = 'Display information about the current ' +
        'language and allows to change language.';
    LanguageSelector.title = 'Language';
    LanguageSelector.className = 'languageselector';

    LanguageSelector.texts.loading = 'Loading language information...';

    // ## Dependencies

    LanguageSelector.dependencies = {
        JSUS: {}
    };

    /**
     * ## LanguageSelector constructor
     *
     * Manages the setting and display of the language used
     *
     * @param {object} options Optional. Configuration options
     *
     * @see Player.lang
     */
    function LanguageSelector(options) {
        var that = this;

        this.options = options;

        /**
         * ### LanguageSelector.availableLanguages
         *
         * Object containing an object per availble language.
         *
         * The language object contains at least the following properties:
         *
         * - `name`: Name of the language in English.
         * - `nativeName`: Native name of the language
         * - `shortName`: An abbreviation for the language, also determines the
         *    path to the context files for this language.
         *
         * The key for each language object is its `shortName`.
         *
         * @see Player.lang
         */
        this.availableLanguages = {
            en: {
                name: 'English',
                nativeName: 'English',
                shortName: 'en'
            }
        };

        /**
         * ### LanguageSelector.currentLanguageIndex
         *
         * A reference to the currently used language
         *
         * @see LanguageSelector.availableLanguages
         */
        this.currentLanguage = null;

        /**
         * ### LanguageSelector.buttonListLength
         *
         * Specifies maximum number of radio buttons used in selection tool
         */
        this.buttonListLength = null;

        /**
         * ### LanguageSelector.displayForm
         *
         * The form in which the widget displays the language information
         */
        this.displayForm = null;

        /**
         * ### LanguageSelector.optionsLabel
         *
         * Array containing the labels for the language selection optionsDisplay
         */
        this.optionsLabel = {};

        /**
         * ### LanguageSelector.optionsDisplay
         *
         * Array containing the optionsDisplay for the language selection
         */
        this.optionsDisplay = {};

        /**
         * ### LanguageSelector.loadingDiv
         *
         * Div displaying information on whether the languages have been loaded
         */
        this.loadingDiv = null;

        /**
         * ### LanguageSelector.languagesLoaded
         *
         * Flag indicating whether languages have been loaded from server
         */
        this.languagesLoaded = false;

        /**
         * ## LanguageSelector.usingButtons
         *
         * Flag indicating if the interface should have buttons
         *
         * Default: TRUE.
         */
        this.usingButtons = true;

        /**
         * ## LanguageSelector.updatePlayer
         *
         * Specifies when updating the player
         *
         * Available options:
         *
         *   - false: alias for 'never',
         *   - 'never': never notifies,
         *   - 'onselect': each time a selection is made,
         *   - 'ondone': when current step is done.
         *
         * Default: 'ondone'
         */
        this.updatePlayer = 'ondone';

        /**
         * ## LanguageSelector.setUriPrefix
         *
         * If TRUE, the Window URI prefix is updated when the player is updated
         *
         * Default: TRUE.
         *
         * @see GameWindow.setUriPrefix
         */
        this.setUriPrefix = true;

        /**
         * ## LanguageSelector.notifyServer
         *
         * If TRUE, a message is sent to the server when the player is updated
         *
         * Default: TRUE.
         */
        this.notifyServer = true;

        /**
         * ### LanguageSelector.onLangCallback
         *
         * Function to be called when languages have been loaded
         *
         * Initializes form displaying the information as well
         * as the optionsDisplay and their labels.
         * Initializes language to English.
         * Forwards to `LanguageSelector.onLangCallbackExtension` at the very
         * end.
         *
         * @param {object} msg GameMsg
         *
         * @see LanguageSelector.setLanguage
         */
        this.onLangCallback = function(msg) {
            var language;

            // Clear display.
            while (that.displayForm.firstChild) {
                that.displayForm.removeChild(that.displayForm.firstChild);
            }

            // Initialize widget.
            that.availableLanguages = msg.data;
            if (that.usingButtons) {

                // Creates labeled buttons.
                for (language in msg.data) {
                    if (msg.data.hasOwnProperty(language)) {
                        that.optionsLabel[language] = W.get('label', {
                            id: language + 'Label',
                            'for': language + 'RadioButton'
                        });

                        that.optionsDisplay[language] = W.get('input', {
                            id: language + 'RadioButton',
                            type: 'radio',
                            name: 'languageButton',
                            value: msg.data[language].name
                        });

                        that.optionsDisplay[language].onclick =
                            makeSetLanguageOnClick(language);

                        that.optionsLabel[language].appendChild(
                            that.optionsDisplay[language]);
                        that.optionsLabel[language].appendChild(
                            document.createTextNode(
                                msg.data[language].nativeName));
                        W.add('br', that.displayForm);
                        that.optionsLabel[language].className =
                            'unselectedButtonLabel';
                        that.displayForm.appendChild(
                            that.optionsLabel[language]);
                    }
                }
            }
            else {

                that.displaySelection = W.get('select', 'selectLanguage');
                for (language in msg.data) {
                    that.optionsLabel[language] =
                        document.createTextNode(msg.data[language].nativeName);
                    that.optionsDisplay[language] = W.get('option', {
                        id: language + 'Option',
                        value: language
                    });
                    that.optionsDisplay[language].appendChild(
                        that.optionsLabel[language]);
                    that.displaySelection.appendChild(
                        that.optionsDisplay[language]);

                }
                that.displayForm.appendChild(that.displaySelection);
                that.displayForm.onchange = function() {
                    that.setLanguage(that.displaySelection.value,
                                     that.updatePlayer === 'onselect');
                };
            }

            that.loadingDiv.style.display = 'none';
            that.languagesLoaded = true;

            // Initialize with current value inside player object,
            // or default to English. Does not update the player object yet.
            that.setLanguage(node.player.lang.shortName || 'en', false);

            // Extension point.
            if (that.onLangCallbackExtension) {
                that.onLangCallbackExtension(msg);
                that.onLangCallbackExtension = null;
            }

            function makeSetLanguageOnClick(langStr) {
                return function() {
                    that.setLanguage(langStr, that.updatePlayer === 'onselect');
                };
            }
        };

        /**
         * ### LanguageSelector.onLangCallbackExtension
         *
         * Extension point to `LanguageSelector.onLangCallback`
         *
         * @see LanguageSelector.onLangCallback
         */
        this.onLangCallbackExtension = null;
    }

    // ## LanguageSelector methods

    /**
     * ### LanguageSelector.init
     *
     * Initializes the widget
     *
     * @param {object} options Optional. Configuration options
     *
     * @see LanguageSelector.onLangCallback
     */
    LanguageSelector.prototype.init = function(options) {
        J.mixout(options, this.options);
        this.options = options;

        if ('undefined' !== typeof this.options.usingButtons) {
            this.usingButtons = !!this.options.usingButtons;
        }

        if ('undefined' !== typeof this.options.notifyServer) {
            if (false === this.options.notifyServer) {
                this.options.notifyServer = 'never';
            }
            else if ('string' === typeof this.options.notifyServer) {
                if ('never' === this.options.notifyServer ||
                    'onselect' === this.options.notifyServer ||
                    'ondone' === this.options.notifyServer) {

                    this.notifyServer = this.options.notifyServer;
                }
                else {
                    throw new Error('LanguageSelector.init: invalid value ' +
                                    'for notifyServer: "' +
                                    this.options.notifyServer + '". Valid ' +
                                    'values: "never","onselect", "ondone".');
                }
            }
            else {
                throw new Error('LanguageSelector.init: options.notifyServer ' +
                                'must be ' +
                                this.options.notifyServer);
            }
        }

        if ('undefined' !== typeof this.options.setUriPrefix) {
            this.setUriPrefix = !!this.options.setUriPrefix;
        }

        // Register listener.
        // TODO: should it be moved into the listeners method?
        // TODO: calling init twice will add it twice.
        node.on.lang(this.onLangCallback);

        // Display initialization.
        this.displayForm = W.get('form', 'radioButtonForm');
        this.loadingDiv = W.add('div', this.displayForm);
        this.loadingDiv.innerHTML = this.getText('loading');

        this.loadLanguages();
    };

    LanguageSelector.prototype.append = function() {
        this.bodyDiv.appendChild(this.displayForm);
    };

    /**
     * ### LanguageSelector.setLanguage
     *
     * Sets language within the widget and globally and updates the display
     *
     * @param {string} langName shortName of language to be set
     * @param {boolean} updatePlayer If FALSE, the language is set only
     *   inside the widget, and no changes are made to the player object.
     *   Default: TRUE
     *
     * @see NodeGameClient.setLanguage
     */
    LanguageSelector.prototype.setLanguage = function(langName, updatePlayer) {

        if (this.usingButtons) {

            // Uncheck current language button and change className of label.
            if (this.currentLanguage !== null &&
                this.currentLanguage !== this.availableLanguages[langName] ) {

                this.optionsDisplay[this.currentLanguage].checked =
                    'unchecked';
                this.optionsLabel[this.currentLanguage].className =
                    'unselectedButtonLabel';
            }
        }

        // Set current language index.
        this.currentLanguage = langName;

        if (this.usingButtons) {
            // Check language button and change className of label.
            this.optionsDisplay[this.currentLanguage].checked = 'checked';
            this.optionsLabel[this.currentLanguage].className =
                'selectedButtonLabel';
        }
        else {
            this.displaySelection.value = this.currentLanguage;
        }

        // Update node.player.
        if (updatePlayer !== false) {
            node.setLanguage(this.availableLanguages[this.currentLanguage],
                             this.setUriPrefix, this.notifyServer);
        }
    };

    /**
     * ### LanguageSelector.updateAvailableLanguages
     *
     * Updates available languages asynchronously
     *
     * @param {object} options Optional. Configuration options
     */
    LanguageSelector.prototype.updateAvalaibleLanguages = function(options) {
        if (options && options.callback) {
            this.onLangCallbackExtension = options.callback;
        }
        node.socket.send(node.msg.create({
            target: "LANG",
            to: "SERVER",
            action: "get"
        }));
    };

    /**
     * ### LanguageSelector.loadLanguages
     *
     * Loads languages once from server
     *
     * @param {object} options Optional. Configuration options
     *
     * @see LanguageSelector.updateAvalaibleLanguages
     */
    LanguageSelector.prototype.loadLanguages = function(options) {
        if (!this.languagesLoaded) this.updateAvalaibleLanguages(options);
        else if (options && options.callback) options.callback();
    };

    /**
     * ### LanguageSelector.listeners
     *
     * Implements Widget.listeners
     */
    LanguageSelector.prototype.listeners = function() {
        var that;
        that = this;
        node.events.step.on('REALLY_DONE', function() {
            if (that.updatePlayer === 'ondone') {
                node.setLanguage(that.availableLanguages[that.currentLanguage],
                                 that.setUriPrefix, that.notifyServer);
            }
        });
    };

})(node);

/**
 * # MoneyTalks
 * Copyright(c) 2020 Stefano Balietti
 * MIT Licensed
 *
 * Displays a box for formatting earnings ("money") in currency
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('MoneyTalks', MoneyTalks);

    // ## Meta-data

    MoneyTalks.version = '0.5.0';
    MoneyTalks.description = 'Displays the earnings of a player.';

    MoneyTalks.title = 'Earnings';
    MoneyTalks.className = 'moneytalks';

    // ## Dependencies

    MoneyTalks.dependencies = {
        JSUS: {}
    };

    /**
     * ## MoneyTalks constructor
     *
     * `MoneyTalks` displays the earnings ("money") of players
     *
     * @see MoneyTalks.init
     */
    function MoneyTalks() {

        /**
         * ### MoneyTalks.spanCurrency
         *
         * The SPAN which holds information on the currency
         */
        this.spanCurrency = null;

        /**
         * ### MoneyTalks.spanMoney
         *
         * The SPAN which holds information about the money earned so far
         */
        this.spanMoney = null;

        /**
         * ### MoneyTalks.currency
         *
         * String describing the currency
         */
        this.currency = 'ECU';

        /**
         * ### MoneyTalks.money
         *
         * Currently earned money
         */
        this.money = 0;

        /**
         * ### MoneyTalks.precicison
         *
         * Precision of floating point number to display
         */
        this.precision = 2;

        /**
         * ### MoneyTalks.showCurrency
         *
         * If TRUE, the currency is displayed after the money
         */
        this.showCurrency = true;

        /**
         * ### MoneyTalks.currencyClassname
         *
         * Class name to be attached to the currency span
         */
        this.classnameCurrency = 'moneytalkscurrency';

        /**
         * ### MoneyTalks.currencyClassname
         *
         * Class name to be attached to the money span
         */
        this.classnameMoney = 'moneytalksmoney';
    }

    // ## MoneyTalks methods

    /**
     * ### MoneyTalks.init
     *
     * Initializes the widget
     *
     * @param {object} options Optional. Configuration options.
     *
     * The  options object can have the following attributes:
     *
     *   - `currency`: The name of currency.
     *   - `money`: Initial amount of money earned.
     *   - `precision`: How mamy floating point digits to use.
     *   - `currencyClassName`: Class name to be set for this.spanCurrency.
     *   - `moneyClassName`: Class name to be set for this.spanMoney.
     *   - `showCurrency`: Flag whether the name of currency is to be displayed.
     */
    MoneyTalks.prototype.init = function(options) {
        options = options || {};
        if ('string' === typeof options.currency) {
            this.currency = options.currency;
        }
        if ('undefined' !== typeof options.showCurrency) {
            this.showCurrency = !!options.showCurrency;
        }
        if ('number' === typeof options.money) {
            this.money = options.money;
        }
        if ('number' === typeof options.precision) {
            this.precision = options.precision;
        }
        if ('string' === typeof options.MoneyClassName) {
            this.classnameMoney = options.MoneyClassName;
        }
        if ('string' === typeof options.currencyClassName) {
            this.classnameCurrency = options.currencyClassName;
        }
    };

    MoneyTalks.prototype.append = function() {
        if (!this.spanMoney) {
            this.spanMoney = document.createElement('span');
        }
        if (!this.spanCurrency) {
            this.spanCurrency = document.createElement('span');
        }
        if (!this.showCurrency) this.spanCurrency.style.display = 'none';

        this.spanMoney.className = this.classnameMoney;
        this.spanCurrency.className = this.classnameCurrency;

        this.spanCurrency.innerHTML = this.currency;
        this.spanMoney.innerHTML = this.money;

        this.bodyDiv.appendChild(this.spanMoney);
        this.bodyDiv.appendChild(this.spanCurrency);
    };

    MoneyTalks.prototype.listeners = function() {
        var that = this;
        node.on('MONEYTALKS', function(amount, clear) {
            that.update(amount, clear);
        });
    };

    /**
     * ### MoneyTalks.update
     *
     * Updates the display and the count of available "money"
     *
     * @param {string|number} amount Amount to add to current value of money
     * @param {boolean} clear Optional. If TRUE, money will be set to 0
     *    before adding the new amount
     *
     * @return {number} The current value after the update
     *
     * @see MoneyTalks.money
     * @see MonetyTalks.spanMoney
     */
    MoneyTalks.prototype.update = function(amount, clear) {
        var parsedAmount;
        parsedAmount = J.isNumber(amount);
        if (parsedAmount === false) {
            node.err('MoneyTalks.update: invalid amount: ' + amount);
            return;
        }
        if (clear) this.money = 0;
        this.money += parsedAmount;
        this.spanMoney.innerHTML = this.money.toFixed(this.precision);
        return this.money;
    };

    /**
     * ### MoneyTalks.getValues
     *
     * Returns the current value of "money"
     *
     * @see MoneyTalks.money
     */
    MoneyTalks.prototype.getValues = function() {
        return this.money;
    };

})(node);

/**
 * # MoodGauge
 * Copyright(c) 2019 Stefano Balietti
 * MIT Licensed
 *
 * Displays an interface to query users about mood, emotions and well-being
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('MoodGauge', MoodGauge);

    // ## Meta-data

    MoodGauge.version = '0.4.0';
    MoodGauge.description = 'Displays an interface to measure mood ' +
        'and emotions.';

    MoodGauge.title = 'Mood Gauge';
    MoodGauge.className = 'moodgauge';

    MoodGauge.texts.mainText = 'Thinking about yourself and how you normally' +
                ' feel, to what extent do you generally feel: ';

    // ## Dependencies
    MoodGauge.dependencies = {
        JSUS: {}
    };

    /**
     * ## MoodGauge constructor
     *
     * Creates a new instance of MoodGauge
     *
     * @param {object} options Optional. Configuration options
     * which is forwarded to MoodGauge.init.
     *
     * @see MoodGauge.init
     */
    function MoodGauge(options) {

        /**
         * ### MoodGauge.methods
         *
         * List of available methods
         *
         * Maps names to functions.
         *
         * Each function is called with `this` instance as context,
         * and accepts the `options` parameters passed to constructor.
         * Each method must return widget-like gauge object
         * implementing functions: append, enable, disable, getValues
         *
         * or an error will be thrown
         */
        this.methods = {};

        /**
         * ## MoodGauge.method
         *
         * The method used to measure mood
         *
         * Available methods: 'I-PANAS-SF'
         *
         * Default method is: 'I-PANAS-SF'
         *
         * References:
         *
         * 'I-PANAS-SF', Thompson E.R. (2007) "Development
         * and Validation of an Internationally Reliable Short-Form of
         * the Positive and Negative Affect Schedule (PANAS)"
         */
        this.method = 'I-PANAS-SF';

        /**
         * ### MoodGauge.mainText
         *
         * A text preceeding the SVO gauger
         */
        this.mainText = null;

        /**
         * ## SVOGauge.gauge
         *
         * The object measuring mood
         *
         * @see SVOGauge.method
         */
        this.gauge = null;

        this.addMethod('I-PANAS-SF', I_PANAS_SF);
    }

    // ## MoodGauge methods.

    /**
     * ### MoodGauge.init
     *
     * Initializes the widget
     *
     * @param {object} opts Optional. Configuration options.
     */
    MoodGauge.prototype.init = function(opts) {
        var gauge;
        if ('undefined' !== typeof opts.method) {
            if ('string' !== typeof opts.method) {
                throw new TypeError('MoodGauge.init: method must be string ' +
                                    'or undefined: ' + opts.method);
            }
            if (!this.methods[opts.method]) {
                throw new Error('MoodGauge.init: method is invalid: ' +
                                opts.method);
            }
            this.method = opts.method;
        }
        if (opts.mainText) {
            if ('string' !== typeof opts.mainText) {
                throw new TypeError('MoodGauge.init: mainText must be string ' +
                                    'or undefined. Found: ' + opts.mainText);
            }
            this.mainText = opts.mainText;
        }
        // Call method.
        gauge = this.methods[this.method].call(this, opts);
        // Check properties.
        checkGauge(this.method, gauge);
        // Approved.
        this.gauge = gauge;

        this.on('enabled', function() {
            gauge.enable();
        });

        this.on('disabled', function() {
            gauge.disable();
        });

        this.on('highlighted', function() {
            gauge.highlight();
        });

        this.on('unhighlighted', function() {
            gauge.unhighlight();
        });
    };

    MoodGauge.prototype.append = function() {
        node.widgets.append(this.gauge, this.bodyDiv, { panel: false });
    };

    /**
     * ## MoodGauge.addMethod
     *
     * Adds a new method to measure mood
     *
     * @param {string} name The name of the method
     * @param {function} cb The callback implementing it
     */
    MoodGauge.prototype.addMethod = function(name, cb) {
        if ('string' !== typeof name) {
            throw new Error('MoodGauge.addMethod: name must be string: ' +
                            name);
        }
        if ('function' !== typeof cb) {
            throw new Error('MoodGauge.addMethod: cb must be function: ' +
                            cb);
        }
        if (this.methods[name]) {
            throw new Error('MoodGauge.addMethod: name already existing: ' +
                            name);
        }
        this.methods[name] = cb;
    };

    MoodGauge.prototype.getValues = function(opts) {
        return this.gauge.getValues(opts);
    };

    MoodGauge.prototype.setValues = function(opts) {
        return this.gauge.setValues(opts);
    };

    // ## Helper functions.

    /**
     * ### checkGauge
     *
     * Checks if a gauge is properly constructed, throws an error otherwise
     *
     * @param {string} method The name of the method creating it
     * @param {object} gauge The object to check
     *
     * @see ModdGauge.init
     */
    function checkGauge(method, gauge) {
        if (!gauge) {
            throw new Error('MoodGauge.init: method ' + method +
                            'did not create element gauge.');
        }
        if ('function' !== typeof gauge.getValues) {
            throw new Error('MoodGauge.init: method ' + method +
                            ': gauge missing function getValues.');
        }
        if ('function' !== typeof gauge.enable) {
            throw new Error('MoodGauge.init: method ' + method +
                            ': gauge missing function enable.');
        }
        if ('function' !== typeof gauge.disable) {
            throw new Error('MoodGauge.init: method ' + method +
                            ': gauge missing function disable.');
        }
        if ('function' !== typeof gauge.append) {
            throw new Error('MoodGauge.init: method ' + method +
                            ': gauge missing function append.');
        }
    }

    // ## Available methods.

    // ### I_PANAS_SF
    function I_PANAS_SF(options) {
        var items, emotions, choices, left, right;
        var gauge, i, len;

        choices = options.choices ||
            [ '1', '2', '3', '4', '5' ];

        emotions = options.emotions || [
            'Upset',
            'Hostile',
            'Alert',
            'Ashamed',
            'Inspired',
            'Nervous',
            'Determined',
            'Attentive',
            'Afraid',
            'Active'
        ];

        left = options.left || 'never';

        right = options.right || 'always';

        len = emotions.length;

        items = new Array(len);

        i = -1;
        for ( ; ++i < len ; ) {
            items[i] = {
                id: emotions[i],
                left: '<span class="emotion">' + emotions[i] + ':</span> never',
                right: right,
                choices: choices
            };
        }

        gauge = node.widgets.get('ChoiceTableGroup', {
            id: options.id || 'ipnassf',
            items: items,
            mainText: this.mainText || this.getText('mainText'),
            title: false,
            requiredChoice: true,
            storeRef: false
        });

        return gauge;
    }

})(node);

/**
 * # Requirements
 * Copyright(c) 2019 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Checks a list of requirements and displays the results
 *
 * TODO: see if we need to reset the state between two
 * consecutive calls to checkRequirements (results array).
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('Requirements', Requirements);

    // ## Meta-data

    Requirements.version = '0.7.2';
    Requirements.description = 'Checks a set of requirements and display the ' +
        'results';

    Requirements.title = 'Requirements';
    Requirements.className = 'requirements';

    Requirements.texts.errStr = 'One or more function is taking too long. ' +
                                'This is likely to be due to a compatibility' +
                                ' issue with your browser or to bad network' +
                                ' connectivity.';
    Requirements.texts.testPassed = 'All tests passed.';

    // ## Dependencies

    Requirements.dependencies = {
        JSUS: {},
        List: {}
    };

    /**
     * ## Requirements constructor
     *
     * Instantiates a new Requirements object
     *
     * @param {object} options
     */
    function Requirements(options) {

        /**
         * ### Requirements.callbacks
         *
         * Array of all test callbacks
         */
        this.requirements = [];

        /**
         * ### Requirements.stillChecking
         *
         * Number of tests still pending
         */
        this.stillChecking = 0;

        /**
         * ### Requirements.withTimeout
         *
         * If TRUE, a maximum timeout to the execution of ALL tests is set
         */
        this.withTimeout = options.withTimeout || true;

        /**
         * ### Requirements.timeoutTime
         *
         * The time in milliseconds for the timeout to expire
         */
        this.timeoutTime = options.timeoutTime || 10000;

        /**
         * ### Requirements.timeoutId
         *
         * The id of the timeout, if created
         */
        this.timeoutId = null;

        /**
         * ### Requirements.summary
         *
         * Span summarizing the status of the tests
         */
        this.summary = null;

        /**
         * ### Requirements.summaryUpdate
         *
         * Span counting how many tests have been completed
         */
        this.summaryUpdate = null;

        /**
         * ### Requirements.summaryResults
         *
         * Span displaying the results of the tests
         */
        this.summaryResults = null;

        /**
         * ### Requirements.dots
         *
         * Looping dots to give the user the feeling of code execution
         */
        this.dots = null;

        /**
         * ### Requirements.hasFailed
         *
         * TRUE if at least one test has failed
         */
        this.hasFailed = false;

        /**
         * ### Requirements.results
         *
         * The outcomes of all tests
         */
        this.results = [];

        /**
         * ### Requirements.completed
         *
         * Maps all tests that have been completed already to avoid duplication
         */
        this.completed = {};

        /**
         * ### Requirements.sayResult
         *
         * If true, the final result of the tests will be sent to the server
         */
        this.sayResults = options.sayResults || false;

        /**
         * ### Requirements.sayResultLabel
         *
         * The label of the SAY message that will be sent to the server
         */
        this.sayResultsLabel = options.sayResultLabel || 'requirements';

        /**
         * ### Requirements.addToResults
         *
         *  Callback to add properties to result object sent to server
         */
        this.addToResults = options.addToResults || null;

        /**
         * ### Requirements.onComplete
         *
         * Callback to be executed at the end of all tests
         */
        this.onComplete = null;

        /**
         * ### Requirements.onSuccess
         *
         * Callback to be executed at the end of all tests
         */
        this.onSuccess = null;

        /**
         * ### Requirements.onFailure
         *
         * Callback to be executed at the end of all tests
         */
        this.onFailure = null;

        /**
         * ### Requirements.callbacksExecuted
         *
         * TRUE, the callbacks have been executed
         */
        this.callbacksExecuted = false;

        /**
         * ### Requirements.list
         *
         * `List` to render the results
         *
         * @see nodegame-server/List
         */
        // TODO: simplify render syntax.
        this.list = new W.List({
            render: {
                pipeline: renderResult,
                returnAt: 'first'
            }
        });

        function renderResult(o) {
            var imgPath, img, span, text;
            imgPath = '/images/' + (o.content.success ?
                                    'success-icon.png' : 'delete-icon.png');
            img = document.createElement('img');
            img.src = imgPath;

            // Might be the full exception object.
            if ('object' === typeof o.content.text) {
                o.content.text = extractErrorMsg(o.content.text);
            }

            text = document.createTextNode(o.content.text);
            span = document.createElement('span');
            span.className = 'requirement';
            span.appendChild(img);

            span.appendChild(text);
            return span;
        }
    }

    // ## Requirements methods

    /**
     * ### Requirements.init
     *
     * Setups the requirements widget
     *
     * Available options:
     *
     *   - requirements: array of callback functions or objects formatted as
     *      { cb: function [, params: object] [, name: string] };
     *   - onComplete: function executed with either failure or success
     *   - onFailure: function executed when at least one test fails
     *   - onSuccess: function executed when all tests succeed
     *   - maxWaitTime: max waiting time to execute all tests (in milliseconds)
     *
     * @param {object} conf Configuration object.
     */
    Requirements.prototype.init = function(conf) {
        if ('object' !== typeof conf) {
            throw new TypeError('Requirements.init: conf must be object. ' +
                                'Found: ' + conf);
        }
        if (conf.requirements) {
            if (!J.isArray(conf.requirements)) {
                throw new TypeError('Requirements.init: conf.requirements ' +
                                    'must be array or undefined. Found: ' +
                                    conf.requirements);
            }
            this.requirements = conf.requirements;
        }
        if ('undefined' !== typeof conf.onComplete) {
            if (null !== conf.onComplete &&
                'function' !== typeof conf.onComplete) {

                throw new TypeError('Requirements.init: conf.onComplete must ' +
                                    'be function, null or undefined. Found: ' +
                                    conf.onComplete);
            }
            this.onComplete = conf.onComplete;
        }
        if ('undefined' !== typeof conf.onSuccess) {
            if (null !== conf.onSuccess &&
                'function' !== typeof conf.onSuccess) {

                throw new TypeError('Requirements.init: conf.onSuccess must ' +
                                    'be function, null or undefined. Found: ' +
                                    conf.onSuccess);
            }
            this.onSuccess = conf.onSuccess;
        }
        if ('undefined' !== typeof conf.onFailure) {
            if (null !== conf.onFailure &&
                'function' !== typeof conf.onFailure) {

                throw new TypeError('Requirements.init: conf.onFailure must ' +
                                    'be function, null or undefined. Found: ' +
                                    conf.onFailure);
            }
            this.onFailure = conf.onFailure;
        }
        if (conf.maxExecTime) {
            if (null !== conf.maxExecTime &&
                'number' !== typeof conf.maxExecTime) {

                throw new TypeError('Requirements.init: conf.onMaxExecTime ' +
                                    'must be number, null or undefined. ' +
                                    'Found: ' + conf.maxExecTime);
            }
            this.withTimeout = !!conf.maxExecTime;
            this.timeoutTime = conf.maxExecTime;
        }
    };

    /**
     * ### Requirements.addRequirements
     *
     * Adds any number of requirements to the requirements array
     *
     * Callbacks can be asynchronous or synchronous.
     *
     * An asynchronous callback must call the `results` function
     * passed as input parameter to communicate the outcome of the test.
     *
     * A synchronous callback must return the value immediately.
     *
     * In both cases the return is an array, where every item is an
     * error message. Empty array means test passed.
     *
     * @see this.requirements
     */
    Requirements.prototype.addRequirements = function() {
        var i, len;
        i = -1, len = arguments.length;
        for ( ; ++i < len ; ) {
            if ('function' !== typeof arguments[i] &&
                'object' !== typeof arguments[i] ) {

                throw new TypeError('Requirements.addRequirements: ' +
                                    'requirements must be function or ' +
                                    'object. Found: ' + arguments[i]);
            }
            this.requirements.push(arguments[i]);
        }
    };

    /**
     * ### Requirements.checkRequirements
     *
     * Asynchronously or synchronously checks all registered callbacks
     *
     * Can add a timeout for the max execution time of the callbacks, if the
     * corresponding option is set.
     *
     * Results are displayed conditionally
     *
     * @param {boolean} display If TRUE, results are displayed
     *
     * @return {array} The array containing the errors
     *
     * @see this.withTimeout
     * @see this.requirements
     */
    Requirements.prototype.checkRequirements = function(display) {
        var i, len;
        var errors, cbName, errMsg;
        if (!this.requirements.length) {
            throw new Error('Requirements.checkRequirements: no requirements ' +
                            'to check.');
        }

        this.updateStillChecking(this.requirements.length, true);

        errors = [];
        i = -1, len = this.requirements.length;
        for ( ; ++i < len ; ) {
            // Get Test Name.
            if (this.requirements[i] && this.requirements[i].name) {
                cbName = this.requirements[i].name;
            }
            else {
                cbName = i + 1;
            }
            try {
                resultCb(this, cbName, i);
            }
            catch(e) {
                this.hasFailed = true;
                errMsg = extractErrorMsg(e);
                this.updateStillChecking(-1);
                errors.push('An error occurred in requirement n.' +
                            cbName + ': ' + errMsg);
            }
        }

        if (this.withTimeout) this.addTimeout();

        if ('undefined' === typeof display ? true : false) {
            this.displayResults(errors);
        }

        if (this.isCheckingFinished()) this.checkingFinished();

        return errors;
    };

    /**
     * ### Requirements.addTimeout
     *
     * Starts a timeout for the max execution time of the requirements
     *
     * Upon time out results are checked, and eventually displayed.
     *
     * @see this.stillCheckings
     * @see this.withTimeout
     * @see this.requirements
     */
    Requirements.prototype.addTimeout = function() {
        var that = this;

        this.timeoutId = setTimeout(function() {
            if (that.stillChecking > 0) {
                that.displayResults([that.getText('errStr')]);
            }
            that.timeoutId = null;
            that.hasFailed = true;
            that.checkingFinished();
        }, this.timeoutTime);
    };

    /**
     * ### Requirements.clearTimeout
     *
     * Clears the timeout for the max execution time of the requirements
     *
     * @see this.timeoutId
     * @see this.stillCheckings
     * @see this.requirements
     */
    Requirements.prototype.clearTimeout = function() {
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
    };

    /**
     * ### Requirements.updateStillChecking
     *
     * Updates the number of requirements still running on the display
     *
     * @param {number} update The number of requirements still running, or an
     *   increment as compared to the current value
     * @param {boolean} absolute TRUE, if `update` is to be interpreted as an
     *   absolute value
     *
     * @see this.summaryUpdate
     * @see this.stillCheckings
     * @see this.requirements
     */
    Requirements.prototype.updateStillChecking = function(update, absolute) {
        var total, remaining;

        this.stillChecking = absolute ? update : this.stillChecking + update;

        total = this.requirements.length;
        remaining = total - this.stillChecking;
        this.summaryUpdate.innerHTML = ' (' +  remaining + ' / ' + total + ')';
    };

    /**
     * ### Requirements.isCheckingFinished
     *
     * Returns TRUE if all requirements have returned
     *
     * @see this.stillCheckings
     * @see this.requirements
     */
    Requirements.prototype.isCheckingFinished = function() {
        return this.stillChecking <= 0;
    };

    /**
     * ### Requirements.checkingFinished
     *
     * Clears up timer and dots, and executes final callbacks accordingly
     *
     * First, executes the `onComplete` callback in any case. Then if no
     * errors have been raised executes the `onSuccess` callback, otherwise
     * the `onFailure` callback.
     *
     * @param {boolean} force If TRUE, the function is executed again,
     *   regardless of whether it was already executed. Default: FALSE
     *
     * @see this.onComplete
     * @see this.onSuccess
     * @see this.onFailure
     * @see this.stillCheckings
     * @see this.requirements
     */
    Requirements.prototype.checkingFinished = function(force) {
        var results;

        // Sometimes, if all requirements are almost synchronous, it
        // can happen that this function is called twice (from resultCb
        // and at the end of all requirements checkings.
        if (this.callbacksExecuted && !force) return;
        this.callbacksExecuted = true;

        if (this.timeoutId) clearTimeout(this.timeoutId);

        this.dots.stop();

        if (this.sayResults) {
            results = {
                success: !this.hasFailed,
                results: this.results
            };

            if (this.addToResults) {
                J.mixin(results, this.addToResults());
            }
            node.say(this.sayResultsLabel, 'SERVER', results);
        }

        if (this.onComplete) this.onComplete();

        if (this.hasFailed) {
            if (this.onFailure) this.onFailure();
        }
        else if (this.onSuccess) {
            this.onSuccess();
        }
    };

    /**
     * ### Requirements.displayResults
     *
     * Displays the results of the requirements on the screen
     *
     * Creates a new item in the list of results for every error found
     * in the results array.
     *
     * If no error was raised, the results array should be empty.
     *
     * @param {array} results The array containing the return values of all
     *   the requirements
     *
     * @see this.onComplete
     * @see this.onSuccess
     * @see this.onFailure
     * @see this.stillCheckings
     * @see this.requirements
     */
    Requirements.prototype.displayResults = function(results) {
        var i, len;

        if (!this.list) {
            throw new Error('Requirements.displayResults: list not found. ' +
                            'Have you called .append() first?');
        }

        if (!J.isArray(results)) {
            throw new TypeError('Requirements.displayResults: results must ' +
                                'be array. Found: ' + results);
        }

        // No errors.
        if (!this.hasFailed && this.stillChecking <= 0) {
            // All tests passed.
            this.list.addDT({
                success: true,
                text: this.getText('testPassed')
            });
        }
        else {
            // Add the errors.
            i = -1, len = results.length;
            for ( ; ++i < len ; ) {
                this.list.addDT({
                    success: false,
                    text: results[i]
                });
            }
        }
        // Parse deletes previously existing nodes in the list.
        this.list.parse();
    };

    Requirements.prototype.append = function() {

        this.summary = document.createElement('span');
        this.summary.appendChild(
            document.createTextNode('Evaluating requirements'));

        this.summaryUpdate = document.createElement('span');
        this.summary.appendChild(this.summaryUpdate);

        this.dots = W.getLoadingDots();
        this.summary.appendChild(this.dots.span);

        this.summaryResults = document.createElement('div');
        this.summary.appendChild(document.createElement('br'));
        this.summary.appendChild(this.summaryResults);


        this.bodyDiv.appendChild(this.summary);
        this.bodyDiv.appendChild(this.list.getRoot());
    };

    Requirements.prototype.listeners = function() {
        var that;
        that = this;
        node.registerSetup('requirements', function(conf) {
            if (!conf) return;
            if ('object' !== typeof conf) {
                node.warn('requirements widget: invalid setup object: ' + conf);
                return;
            }
            // Configure all requirements.
            that.init(conf);
            // Start a checking immediately if requested.
            if (conf.doChecking !== false) that.checkRequirements();

            return conf;
        });

        this.on('destroyed', function() {
            node.deregisterSetup('requirements');
        });
    };

    // ## Helper methods.

    function resultCb(that, name, i) {
        var req, update, res;

        update = function(success, errors, data) {
            if (that.completed[name]) {
                throw new Error('Requirements.checkRequirements: test ' +
                                'already completed: ' + name);
            }
            that.completed[name] = true;
            that.updateStillChecking(-1);
            if (!success) that.hasFailed = true;

            if ('string' === typeof errors) errors = [ errors ];

            if (errors) {
                if (!J.isArray(errors)) {
                    throw new Error('Requirements.checkRequirements: ' +
                                    'errors must be array or undefined. ' +
                                    'Found: ' + errors);
                }
                that.displayResults(errors);
            }

            that.results.push({
                name: name,
                success: success,
                errors: errors,
                data: data
            });

            if (that.isCheckingFinished()) that.checkingFinished();
        };

        req = that.requirements[i];
        if ('function' === typeof req) {
            res = req(update);
        }
        else if ('object' === typeof req) {
            res = req.cb(update, req.params || {});
        }
        else {
            throw new TypeError('Requirements.checkRequirements: invalid ' +
                                'requirement: ' + name + '.');
        }
        // Synchronous checking.
        if (res) update(res.success, res.errors, res.data);
    }

    function extractErrorMsg(e) {
        var errMsg;
        if (e.msg) {
            errMsg = e.msg;
        }
        else if (e.message) {
            errMsg = e.message;
        }
        else if (e.description) {
            errMsg = errMsg.description;
        }
        else {
            errMsg = e.toString();
        }
        return errMsg;
    }

})(node);

/**
 * # RiskGauge
 * Copyright(c) 2020 Stefano Balietti
 * MIT Licensed
 *
 * Displays an interface to measure risk preferences with different methods
 *
 * Available methods: Holt_Laury (default), and Bomb.
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('RiskGauge', RiskGauge);

    // ## Meta-data

    RiskGauge.version = '0.8.0';
    RiskGauge.description = 'Displays an interface to ' +
        'measure risk preferences with different methods.';

    RiskGauge.title = 'Risk Gauge';
    RiskGauge.className = 'riskgauge';

    RiskGauge.texts =  {

        // Holt Laury.

        holt_laury_mainText:
            'Below you find a series of hypothetical lotteries, each ' +
            'contains two lotteries with different probabalities of winning. ' +
            'In each row, select the lottery you would rather take part in.',

        // Bomb.

        // probBomb is passed as input param because it may be hidden.
        bomb_mainText: function(widget, probBomb) {
            var str;
            str = '<p style="margin-bottom: 0.3em">';
            str +=  'Below there are ' + widget.totBoxes + ' black boxes. ';
            str += 'Every box contains a prize of ' +
                    widget.boxValue + ' ' + widget.currency + ', but ';
            if (probBomb === 1) {
                str += 'one random box contains a <em>bomb</em>.';
            }
            else {
                if (widget.revealProbBomb) {
                    str += 'with probability ' + probBomb +
                    ' one random box contains a <em>bomb</em>.';
                }
                else {
                    str += 'one random box might contain a <em>bomb</em>.';
                }
            }
            str += ' You must decide how many boxes you want to open.';
            str += '</p>';
            if (widget.withPrize) {
                str += '<p style="margin-bottom: 0.3em">';
                str += 'You will receive a reward equal to the ' +
                       'sum of all the prizes in every opened ' +
                       'box. However, if you open the box ' +
                       'with the bomb, you get nothing.</p>'
            }
            str += '<p style="margin-bottom: 0.5em">';
            str += '<strong>How many boxes do you want to open ';
            str += 'between 1 and ' + widget.maxBoxes + '?</strong></p>';
            return str;
        },

        bomb_sliderHint:
            'Move the slider to choose the number of boxes to open, ' +
            'then click "Open Boxes"',

        bomb_boxValue: 'Prize per box: ',

        bomb_numBoxes: 'Number of boxes: ',

        bomb_totalWin: 'Total reward: ',

        bomb_openButton: 'Open Boxes',

        bomb_warn: 'Open at least one box.',

        bomb_won: 'You won! You did not open the box with the bomb.',

        bomb_lost: 'You lost! You opened the box with the bomb.'
    };

    // Backward compatibility.
    RiskGauge.texts.mainText = RiskGauge.texts.holt_laury_mainText;


    /**
     * ## RiskGauge constructor
     *
     * Creates a new instance of RiskGauge
     *
     * @see RiskGauge.init
     */
    function RiskGauge() {

        /**
         * ### RiskGauge.methods
         *
         * List of available methods
         *
         * Maps names to functions.
         *
         * Each function is called with `this` instance as context,
         * and accepts the `options` parameters passed to constructor.
         * Each method must return widget-like gauge object
         * implementing functions: append, enable, disable, getValues
         * or an error will be thrown.
         */
        this.methods = {};

        /**
         * ## RiskGauge.method
         *
         * The method used to measure mood
         *
         * Available methods: 'Holt_Laury', 'Bomb'
         *
         * Default method is: 'Holt_Laury'
         *
         * References:
         *
         * Holt, C. A., & Laury, S. K. (2002).
         * Risk aversion and incentive effects.
         * American economic review, 92(5), 1644-1655.
         */
        this.method = 'Holt_Laury';

        /**
         * ### RiskGauge.mainText
         *
         * A text preceeding the SVO gauger
         */
        this.mainText = null;

        /**
         * ## SVOGauge.gauge
         *
         * The object measuring mood
         *
         * @see SVOGauge.method
         */
        this.gauge = null;

        this.addMethod('Holt_Laury', holtLaury);
        this.addMethod('Bomb', bomb);
    }

    // ## RiskGauge methods.

    /**
     * ### RiskGauge.init
     *
     * Initializes the widget
     *
     * @param {object} opts Optional. Configuration options.
     */
    RiskGauge.prototype.init = function(opts) {
        var gauge, that;
        if ('undefined' !== typeof opts.method) {
            if ('string' !== typeof opts.method) {
                throw new TypeError('RiskGauge.init: method must be string ' +
                                    'or undefined: ' + opts.method);
            }
            if (!this.methods[opts.method]) {
                throw new Error('RiskGauge.init: method is invalid: ' +
                                opts.method);
            }
            this.method = opts.method;
        }
        if (opts.mainText) {
            if ('string' !== typeof opts.mainText) {
                throw new TypeError('RiskGauge.init: mainText must be string ' +
                                    'or undefined. Found: ' + opts.mainText);
            }
            this.mainText = opts.mainText;
        }
        // Call method.
        gauge = this.methods[this.method].call(this, opts);

        // Add defaults.
        that = this;
        gauge.isHidden = function() { return that.isHidden(); };
        gauge.isCollapsed = function() { return that.isCollapsed(); };

        // Check properties.
        if (!node.widgets.isWidget(gauge)) {
            throw new Error('RiskGauge.init: method ' + this.method +
                            ' created invalid gauge: missing default widget ' +
                            'methods.')
        }

        // Approved.
        this.gauge = gauge;

        this.on('enabled', function() {
            if (gauge.enable) gauge.enable();
        });

        this.on('disabled', function() {
            if (gauge.disable) gauge.disable();
        });

        this.on('highlighted', function() {
            if (gauge.highlight) gauge.highlight();
        });

        this.on('unhighlighted', function() {
            if (gauge.unhighlight) gauge.unhighlight();
        });
    };

    RiskGauge.prototype.append = function() {
        node.widgets.append(this.gauge, this.bodyDiv, { panel: false });
    };

    /**
     * ## RiskGauge.addMethod
     *
     * Adds a new method to measure mood
     *
     * @param {string} name The name of the method
     * @param {function} cb The callback implementing it
     */
    RiskGauge.prototype.addMethod = function(name, cb) {
        if ('string' !== typeof name) {
            throw new TypeError('RiskGauge.addMethod: name must be string: ' +
                            name);
        }
        if ('function' !== typeof cb) {
            throw new TypeError('RiskGauge.addMethod: cb must be function: ' +
                            cb);
        }
        if (this.methods[name]) {
            throw new Error('RiskGauge.addMethod: name already existing: ' +
                            name);
        }
        this.methods[name] = cb;
    };

    RiskGauge.prototype.getValues = function(opts) {
        return this.gauge.getValues(opts);
    };

    RiskGauge.prototype.setValues = function(opts) {
        return this.gauge.setValues(opts);
    };

    // ## Methods.

    // ### Holt and Laury

    function makeProbString(p1, v1, p2, v2, opts) {
        var of, cur, sep, out;
        opts = opts || {};
        of = (opts.of || ' chance to win ');
        cur = opts.currency || '$';
        sep = opts.sep || '<span class="sep">and</span>';
        out = p1 + of;
        // Place currency sign before or after.
        out += opts.currencyAfter ? v1 + cur : cur + v1;
        out += sep + p2 + of;
        return out + (opts.currencyAfter ? v2 + cur : cur + v2);
    }

    function holtLaury(options) {
        var items, gauge, i, len, j;
        var tmp, v1, v2, v3, v4, p1, p2;

        tmp = options.values || [ 2, 1.6, 3.85, 0.1 ];

        if (options.scale) {
            tmp = tmp.map(function(i) { return i * options.scale; });
        }
        // Make it two decimals.
        v1 = tmp[0].toFixed(2);
        v2 = tmp[1].toFixed(2);
        v3 = tmp[2].toFixed(2);
        v4 = tmp[3].toFixed(2);

        len = 10;
        items = new Array(len);
        for (i = 0; i < len ; i++) {
            j = i + 1;
            p1 = j + '/' + len;
            p2 = (len - j) + '/' + len;
            items[i] = {
                id: 'hl_' + j,
                left: j + '. ',
                choices: [
                    makeProbString(p1, v1, p2, v2, options),
                    makeProbString(p1, v3, p2, v4, options),
                ]
            };
        }

        gauge = node.widgets.get('ChoiceTableGroup', {
            id: options.id || 'holt_laury',
            items: items,
            mainText: this.mainText || this.getText('holt_laury_mainText'),
            title: false,
            requiredChoice: true,
            storeRef: false
        });

        return gauge;
    }


    // ### Bomb Risk

    function bomb(opts) {
        var that;
        that = this;

        // Private variables.

        // Probability that there is a bomb. Default 1.
        var probBomb;

        // The index of the box with the bomb (0 to totBoxes), or -1 if no bomb.
        var bombBox;

        // Div containing info about how many boxes to open, etc.
        var infoDiv;

        // Paragraph containing the outcome of opening the box or a warning.
        var bombResult;

        // The Slider widget to select how many boxes to open.
        var slider;

        // The open box button.
        var button;

        // Flag that participant did not found the bomb.
        var isWinner;

        // Holds the final number of boxes opened after clicking the button.
        var finalValue;

        // Init private variables.

        // The height of every box in px (default: 30px in css).
        if (opts.boxHeight) {
            if ('string' !== typeof opts.boxHeight) {
                throw new Error('Bomb.init: boxHeight must be string ' +
                                'or undefined. Found: ' + opts.boxHeight);
            }
            W.cssRule('div.riskgauge .bomb-box { height: ' +
                      opts.boxHeight + '}');
        }

        if ('undefined' !== typeof opts.probBomb) {
            if (false === J.isNumber(opts.probBomb, 0, 1, true, true)) {
                throw new Error('Bomb.init: probBomb must be a number ' +
                'between 0 and 1 or undefined. Found: ' +
                opts.probBomb);
            }
            probBomb = opts.probBomb;
        }
        else {
            probBomb = 1;
        }

        // Variable bombBox is init after totBoxes is validated.

        // Public variables.

        // Store locally because they are overwritten. TODO: check if needed.
        this._highlight = this.highlight;
        this._unhighlight = this.unhighlight;

        // The value of each box. Default 0.01.
        if ('undefined' !== typeof opts.boxValue) {
            this.boxValue = J.isNumber(opts.boxValue, 0);
            if (!this.boxValue) {
                throw new TypeError('Bomb.init: boxValue must be an ' +
                                    'a number > 0 or undefined. Found: ' +
                                    opts.boxValue);
            }
        }
        else {
            this.boxValue = 0.01;
        }

        // The currency of the prize. Default: USD.
        this.currency = opts.currency || 'USD';

        // Flag TRUE if the probability that a bomb exists is revealed.
        this.revealProbBomb = 'undefined' === typeof opts.revealProbBomb ?
                              true : !!opts.revealProbBomb;

        // Max number of boxes to open (default 99 if probBomb = 1, else 100).
        if ('undefined' !== typeof opts.totBoxes) {
            if (!J.isInt(opts.totBoxes, 0, 10000, false, true)) {
                throw new TypeError('Bomb.init: maxBoxes must be an ' +
                'integer > 0 and <= 10000 or undefined. Found: ' +
                opts.totBoxes);
            }
            this.totBoxes = opts.totBoxes;
        }
        else {
            this.totBoxes = 100;
        }

        // Max num of boxes to open.
        // Default totBoxes -1 if probBomb = 1, else this.totBoxes.
        if ('undefined' !== typeof opts.maxBoxes) {
            if (!J.isInt(opts.maxBoxes, 0, this.totBoxes)) {
                throw new TypeError('Bomb.init: maxBoxes must be a positive' +
                                    ' integer <= ' + this.totBoxes +
                                    ' or undefined. Found: ' + opts.maxBoxes);
            }
            this.maxBoxes = opts.maxBoxes;
        }
        else {
            this.maxBoxes = probBomb === 1 ? this.totBoxes - 1 : this.totBoxes;
        }

        // Number of boxes in each row.
        if ('undefined' !== typeof opts.boxesInRow) {
            if (!J.isInt(opts.boxesInRow, 0)) {
                throw new TypeError('Bomb.init: boxesInRow must be a positive' +
                                    ' integer or undefined. Found: ' +
                                    opts.boxesInRow);
            }
            this.boxesInRow = opts.boxesInRow > this.totBoxes ?
                                  this.totBoxes : opts.boxesInRow;
        }
        else {
            this.boxesInRow = this.totBoxes < 10 ? this.totBoxes : 10;
        }

        // If TRUE, there is an actual prize for the participant. Default: TRUE.
        this.withPrize = 'undefined' === typeof opts.withPrize ?
                         true : !!opts.withPrize;

        this.onopen = null;
        if (opts.onopen) {
            if ('function' !== typeof opts.onopen) {
                throw new TypeError('Bomb: onopen must be function or ' +
                                    'undefined. Found: ' + opts.onopen);
            }
            this.onopen = opts.onopen;
        }

        // Bomb box.
        // Pick bomb box id, if probability permits it, else set to -1.
        // Resulting id is between 1 and totBoxes.
        bombBox = Math.random() >= probBomb ?
                  -1 : Math.ceil(Math.random() * this.totBoxes);

        // Return widget-like object.
        return {

            setValues: function(opts) {
                slider.setValues(opts);
            },

            getValues: function(opts) {
                var out, values, nb, ic;
                opts = opts || {};
                values = slider.getValues();
                // We use finalValue, because values.value might be manipulated.
                if ('undefined' !== typeof finalValue) {
                    nb = finalValue;
                    ic = true
                }
                else {
                    // TODO: slider.getValues returns non-integers. Check.
                    nb = parseInt(slider.slider.value, 10);
                    ic = false;
                }
                out = {
                    value: nb,
                    isCorrect: ic,
                    totalMove: values.totalMove,
                    isWinner: isWinner,
                    time: values.time,
                    reward: 0
                };
                if (!out.isCorrect &&
                    ('undefined' === typeof opts.highlight || opts.highlight)) {

                        slider.highlight();
                }
                if (isWinner === true) out.reward = finalValue * that.boxValue;
                return out;
            },

            highlight: function() {
                slider.highlight();
            },

            unhighlight: function() {
                slider.unhighlight();
            },

            // slider: slider,

            append: function() {
                var nRows;

                // Main text.
                W.add('div', that.bodyDiv, {
                    innerHTML: that.mainText ||
                               that.getText('bomb_mainText', probBomb),
                    className: 'bomb-maintext'
                });

                // Slider.
                slider = node.widgets.add('Slider', that.bodyDiv, {
                    min: 0,
                    max: that.maxBoxes,
                    hint: that.getText('bomb_sliderHint'),
                    title: false,
                    initialValue: 0,
                    displayValue: false,
                    displayNoChange: false,
                    type: 'flat',
                    required: true,
                    panel: false,
                    // texts: {
                    //     currentValue: that.getText('sliderValue')
                    // },
                    onmove: function(value) {
                        var i, div, c, v;

                        // TODO: not working.
                        // if (that.isHighlighted()) that._unhighlight();
                        that._unhighlight();

                        if (value > 0) {
                            button.style.display = '';
                            button.disabled = false;
                            bombResult.innerHTML = '';
                        }
                        else {
                            button.style.display = 'none';
                            bombResult.innerHTML = that.getText('bomb_warn');
                            button.disabled = true;
                        }

                        // Need to do until maxBoxes
                        // in case we are reducing the value.
                        for (i = 0; i < that.maxBoxes; i++) {
                            div = W.gid(getBoxId(i));
                            if (value > i) div.style.background = '#1be139';
                            else div.style.background = '#000000';
                        }

                        // Update display.
                        W.gid('bomb_numBoxes').innerText = value;
                        c = that.currency;
                        v = that.boxValue;
                        if (that.withPrize) {
                            W.gid('bomb_boxValue').innerText = v + c;
                            W.gid('bomb_totalWin').innerText =
                                Number((value * v)).toFixed(2) + c;
                        }
                    },
                    storeRef: false,
                    width: '100%'
                });

                // Table.
                nRows = Math.ceil(that.totBoxes / that.boxesInRow);
                W.add('div', that.bodyDiv, {
                    innerHTML: makeTable(nRows, that.boxesInRow, that.totBoxes)
                });

                // Info div.
                infoDiv = W.add('div', that.bodyDiv, {
                    className: 'risk-info',
                });

                W.add('p', infoDiv, {
                    innerHTML: that.getText('bomb_numBoxes') +
                               '&nbsp;<span id="bomb_numBoxes">0</span>'
                });

                if (that.withPrize) {
                    W.add('p', infoDiv, {
                        innerHTML: that.getText('bomb_boxValue') +
                        '&nbsp;<span id="bomb_boxValue">' +
                        this.boxValue + '</span>'
                    });
                    W.add('p', infoDiv, {
                        innerHTML: that.getText('bomb_totalWin') +
                        '&nbsp;<span id="bomb_totalWin">0</span>'
                    });
                }

                bombResult = W.add('p', infoDiv, { id: 'bomb_result' });

                button = W.add('button', that.bodyDiv, {
                    className: 'btn-danger',
                    innerHTML: that.getText('bomb_openButton'),
                });
                // Initially hidden.
                button.style.display = 'none';

                button.onclick = function() {
                    var cl;
                    // Set global variables.
                    // slider.getValues().value fails (no int numbers).
                    finalValue = parseInt(slider.slider.value, 10);

                    // Update table.
                    if (bombBox > -1) {
                        // Variable bombBox is between 1 and totBoxes.
                        // Cells in table are 0-indexed.
                        W.gid(getBoxId(bombBox-1)).style.background = '#fa0404';
                        isWinner = finalValue < bombBox;
                    }
                    else {
                        isWinner = true;
                    }
                    // Hide slider and button
                    slider.hide();
                    W.hide(button);
                    // Give feedback.
                    cl = 'bomb_' + (isWinner ? 'won' : 'lost');
                    bombResult.innerHTML = that.getText(cl);
                    bombResult.className += (' ' + cl);

                    if (that.onopen) that.onopen(isWinner, that);
                };
            }
        };
    }

    // ### Helper methods.

    // Returns the Bomb Box Id in the HTML from its index.
    function getBoxId(i) {
        return 'bc_' + i;
    }

    //
    function makeBoxRow(rowId, boxesInRow, colSpan) {
        var i, out;
        out = '<tr>';
        for (i = 0; i < boxesInRow; i++) {
            // If there are not enough boxes in this row, do a long colspan.
            if (colSpan && i > colSpan) {
                out = out + '<td colspan="' + (boxesInRow - colSpan) +
                      '"></td>';
                break;
            }
            out = out + '<td><div class="bomb-box square" id="' +
            getBoxId(i + (boxesInRow * rowId)) + '"></td>';
        }
        out += '</tr>';
        return out;
    }

    function makeTable(nRows, boxesInRow, totBoxes) {
        var rowId, out, boxCount, colSpan;
        out = '<table class="bomb-table">';
        for (rowId = 0; rowId < nRows; rowId++) {
            // Check if the last row has less cells to complete the row.
            boxCount = (rowId+1) * boxesInRow;
            if (boxCount > totBoxes) {
                colSpan = totBoxes - (rowId * boxesInRow) - 1;
            }
            out = out + makeBoxRow(rowId, boxesInRow, colSpan);
        }
        out += '</table><br>';
        return out;
    }

})(node);

/**
 * # SDO
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Displays an interface to measure users' social dominance orientation (S.D.O.)
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('SDO', SDO);

    // ## Meta-data

    SDO.version = '0.3.0';
    SDO.description = 'Displays an interface to measure Social ' +
        'Dominance Orientation (S.D.O.).';

    SDO.title = 'SDO';
    SDO.className = 'SDO';


    var scales = {

        SDO7: [
            // Dominance Sub-Scale.
            'Some groups of people must be kept in their place.',
            'It\'s probably a good thing that certain groups are at the ' +
                'top and other groups are at the bottom.',
            'An ideal society requires some groups to be on top and others ' +
                'to be on the bottom.',
            'Some groups of people are simply inferior to other groups.',
            // Reverse-scored:
            'Groups at the bottom are just as deserving as groups at the top.',
            'No one group should dominate in society.',
            'Groups at the bottom should not have to stay in their place.',
            'Group dominance is a poor principle.',

            // Anti-Egalitarianism Sub-Scale.
            'We should not push for group equality.',
            'We shouldn\'t try to guarantee that every group has the same ' +
                'quality of life.',
            'It is unjust to try to make groups equal.',
            'Group equality should not be our primary goal.',
            // Reverse-scored:
            'We should work to give all groups an equal chance to succeed.',
            'We should do what we can to equalize conditions for ' +
                'different groups.',
            'No matter how much effort it takes, we ought to strive to ' +
                'ensure that all groups have the same chance in life.',
            'Group equality should be our ideal.'
        ],

        SDO16: [
            'Some groups of people are simply inferior to other groups.',
            'In getting what you want, it is sometimes necessary to use ' +
                'force against other groups.',
            'It\'s OK if some groups have more of a chance in life ' +
                'than others.',
            'To get ahead in life, it is sometimes necessary to step on ' +
                'other groups.',
            'If certain groups stayed in their place, we would have ' +
                'fewer problems.',
            'It\'s probably a good thing that certain groups are at the ' +
                'top and other groups are at the bottom.',
            'Inferior groups should stay in their place.',
            'Sometimes other groups must be kept in their place.',

            'It would be good if groups could be equal.',
            'Group equality should be our ideal.',
            'All groups should be given an equal chance in life.',
            'We should do what we can to equalize conditions for different ' +
                'groups.',
            'Increased social equality is beneficial to society.',
            'We would have fewer problems if we treated people more equally.',
            'We should strive to make incomes as equal as possible.',
            'No group should dominate in society.'
        ]
    };

    scales.SDO7s = [
        scales.SDO7[2], scales.SDO7[3], scales.SDO7[5], scales.SDO7[6],
        scales.SDO7[11], scales.SDO7[10], scales.SDO7[13], scales.SDO7[12]
    ];

    // var choices = [
    //     '1 ' + '<hr/>' + 'Strongly Oppose',
    //     '2 ' + '<hr/>' + 'Somewhat Oppose',
    //     '3 ' + '<hr/>' + 'Slightly Oppose',
    //     '4 ' + '<hr/>' + 'Neutral',
    //     '5 ' + '<hr/>' + 'Slightly Favor',
    //     '6 ' + '<hr/>' + 'Somewhat Favor',
    //     '7 ' + '<hr/>' + 'Strongly Favor'
    // ];

    var choices = [ 1,2,3,4,5,6,7 ];

    var header = [
        'Strongly Oppose',
        'Somewhat Oppose',
        'Slightly Oppose',
        'Neutral',
        'Slightly Favor',
        'Somewhat Favor',
        'Strongly Favor'
    ];

    SDO.texts = {

        mainText: 'Show how much you favor or oppose each idea below by ' +
        'selecting a number from 1 to 7 on the scale below. <em>You ' +
        'can work quickly, your first feeling is generally best.</em>',
    };

    // ## Dependencies

    SDO.dependencies = {};

    /**
     * ## SDO constructor
     *
     * Creates a new instance of SDO
     *
     * @param {object} options Optional. Configuration options
     * which is forwarded to SDO.init.
     *
     * @see SDO.init
     */
    function SDO() {

        /**
         * ## SDO.sdo
         *
         * The ChoiceTableGroup widget containing the items
         */
        this.sdo = null;

        /**
         * ## SDO.scale
         *
         * The scale used to measure SDO
         *
         * Available methods: SDO16, SDO7, SDO7s (default).
         *
         * References:
         *
         * SDO7
         * Ho et al. (2015). "The nature of social dominance orientation:
         * Theorizing and measuring preferences for intergroup inequality
         * using the new SDO scale".
         * Journal of Personality and Social Psychology. 109 (6): 10031028.
         *
         * SDO16
         * Sidanius and Pratto (1999). Social Dominance: An Intergroup
         * Theory of Social Hierarchy and Oppression.
         * Cambridge: Cambridge University Press.
         */
        this.scale = 'SDO7s';

        /**
         * ## SDO.choices
         *
         * The numerical scale used
         */
        this.choices = choices;

        /**
         * ## SDO.header
         *
         * The categorical scale used
         */
        this.header = header;

        /**
         * ### SDO.mainText
         *
         * A text preceeding the SDO scale
         */
        this.mainText = null;
    }

    // ## SDO methods.

    /**
     * ### SDO.init
     *
     * Initializes the widget
     *
     * @param {object} opts Optional. Configuration options.
     */
    SDO.prototype.init = function(opts) {
        opts = opts || {};

        if (opts.scale) {
            if (opts.scale !== 'SDO16' &&
                opts.scale !== 'SDO7' && opts.scale !== 'SDO7s') {

                throw new Error('SDO.init: scale must be SDO16, SDO7, SDO7s ' +
                                'or undefined. Found: ' + opts.scale);
            }

            this.scale = opts.scale;
        }

        if (opts.choices) {
            if (!J.isArray(opts.choices) || opts.choices.length < 2) {
                throw new Error('SDO.init: choices must be an array ' +
                                'of length > 1 or undefined. Found: ' +
                                opts.choices);
            }
            this.choices = opts.choices;
        }

        if (opts.header) {
            if (!J.isArray(opts.header) ||
                opts.header.length !== this.choices.length) {

                throw new Error('SDO.init: header must be an array ' +
                                'of length equal to the number of choices ' +
                                'or undefined. Found: ' + opts.header);
            }
            this.header = opts.header;
        }

        if (opts.mainText) {
            if ('string' !== typeof opts.mainText && opts.mainText !== false) {
                throw new Error('SDO.init: mainText must be string, ' +
                                'false, or undefined. Found: ' + opts.mainText);
            }
            this.mainText = opts.mainText;
        }
    };

    SDO.prototype.append = function() {
        this.sdo = node.widgets.add('ChoiceTableGroup', this.panelDiv, {
            id: this.id || 'SDO_choicetable',
            items: this.getItems(this.scale),
            choices: this.choices,
            mainText: (this.mainText || this.getText('mainText')),
            title: false,
            panel: false,
            requiredChoice: this.required,
            header: this.header
        });
    };

    SDO.prototype.getItems = function() {
        // E.g., ID: SDO7_1.
        var s = this.scale;
        return scales[s].map(function(item, idx) {
            return [ s + '_' + (idx+1), item ];
        });
    };

    SDO.prototype.getValues = function(opts) {
        opts = opts || {};
        return this.sdo.getValues(opts);
    };

    SDO.prototype.setValues = function(opts) {
        opts = opts || {};
        return this.sdo.setValues(opts);
    };

    SDO.prototype.enable = function(opts) {
        return this.sdo.enable(opts);
    };

    SDO.prototype.disable = function(opts) {
        return this.sdo.disable(opts);
    };

    SDO.prototype.highlight = function(opts) {
        return this.sdo.highlight(opts);
    };

    SDO.prototype.unhighlight = function(opts) {
        return this.sdo.unhighlight(opts);
    };

})(node);

/**
 * # Slider
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Creates a configurable slider.
 *
 * Kudos for initial code: https://codepen.io/gotpop/pen/RMZbya.
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('Slider', Slider);

    // ## Meta-data

    Slider.version = '0.5.0';
    Slider.description = 'Creates a configurable slider';

    Slider.title = false;
    Slider.className = 'slider';

    // ## Dependencies

    Slider.texts = {
        currentValue: function(widget, value) {
            return 'Value: ' + value;
        },
        noChange: 'No change'
    };


    /**
     * ## Slider constructor
     *
     * Creates a new instance of Slider
     */
    function Slider() {
        var that;
        that = this;

        /** Slider.slider
         *
         * The HTML input slider Element
         */
        this.slider = null;

        /** Slider.slider
         *
         * The HTML div Element creating the slider background
         */
        this.rangeFill = null;

        /** Slider.scale
         *
         * Scaling factor for the slider (fixed to 1 for now)
         */
        this.scale = 1;

        /** Slider.currentValue
         *
         * The current value of the slider
         */
        this.currentValue = 50;

        /** Slider.initialValue
        *
        * The initial value of the slider
        */
        this.initialValue = 50;

        /**
        * ### Slider.mainText
        *
        * A text preceeding the slider
        */
        this.mainText = null;

        /**
        * ### Slider.required
        *
        * If TRUE, the user must move the slider
        */
        this.required = null;

        /**
        * ### Slider.requiredChoice
        *
        * Same as Slider.required (backward compatibility)
        */
        this.requiredChoice = null;

        /**
        * ### Slider.hint
        *
        * An additional informative text
        *
        * If not specified, it may be auto-filled, e.g. '*'.
        *
        * TODO: autoHint
        * @see Slider.texts.autoHint
        */
        this.hint = null;

        /** Slider.min
         *
         * The value of the slider at the leftmost position
         */
        this.min = 0;

        /** Slider.max
         *
         * The value of the slider at the rightmost position
         */
        this.max = 100;

        /** Slider.correctValue
         *
         * The correct value of the slider, if any
         */
        this.correctValue = null;

        /** Slider.displayValue
         *
         * If TRUE, the current value of the slider is displayed
         */
        this.displayValue = true;

        /** Slider.valueSpan
         *
         * The SPAN element containing the current value
         *
         * @see Slider.displayValue
         */
        this.valueSpan = null;

        /** Slider.displayNoChange
        *
        * If TRUE, a checkbox for marking a no-change is added
        */
        this.displayNoChange = true;

        /** Slider.noChangeSpan
        *
        * The checkbox form marking the no-change
        *
        * @see Slider.displayNoChange
        * @see Slider.noChangeCheckbox
        */
        this.noChangeSpan = null;

        /** Slider.totalMove
         *
         * The total movement of the slider
         */
        this.totalMove = 0;

        /** Slider.volumeSlider
         *
         * If TRUE, only the slider to the left of the pointer is colored
         *
         * Available types: 'volume', 'flat'.
         */
        this.type = 'volume';

        /** Slider.hoverColor
         *
         * The color of the slider on mouse over
         */
        this.hoverColor = '#2076ea';

        /** Slider.left
         *
         * A text to be displayed at the leftmost position
         */
        this.left = null;

        /** Slider.right
         *
         * A text to be displayed at the righttmost position
         */
        this.right = null;

        /** Slider.listener
         *
         * The main function listening for slider movement
         *
         * Calls user-defined listener oninput
         *
         * @param {boolean} noChange Optional. The function is invoked
         *   by the no-change checkbox. Note: when the function is invoked
         *   by the browser, noChange is the change event.
         *
         * @see Slider.onmove
         */
        var timeOut = null;
        this.listener = function(noChange) {
            if (!noChange && timeOut) return;

            if (that.isHighlighted()) that.unhighlight();

            timeOut = setTimeout(function() {
                var percent, diffPercent;

                percent = (that.slider.value - that.min) * that.scale;
                diffPercent = percent - that.currentValue;
                that.currentValue = percent;

                // console.log(diffPercent);
                // console.log(that.slider.value, percent);

                if (that.type === 'volume') {
                    // Otherwise it goes a bit outside.
                    if (percent > 99) percent = 99;
                    that.rangeFill.style.width = percent + '%';
                }
                else {
                    that.rangeFill.style.width = '99%';
                }

                if (that.displayValue) {
                    that.valueSpan.innerHTML =
                        that.getText('currentValue', that.slider.value);
                }

                if (that.displayNoChange && noChange !== true) {
                    if (that.noChangeCheckbox.checked) {
                        that.noChangeCheckbox.checked = false;
                        J.removeClass(that.noChangeSpan, 'italic');
                    }
                }

                that.totalMove += Math.abs(diffPercent);

                if (that.onmove) {
                    that.onmove.call(that, that.slider.value, diffPercent);
                }

                timeOut = null;
            }, 0);
        }

        /** Slider.onmove
         *
         * User-defined listener function to slider movement
         *
         * @see Slider.listener
         */
         this.onmove = null;

         /**
         * ### Slider.timeFrom
         *
         * Time event from which measuring time
         *
         * Default: 'step'
         *
         * @see node.timer.getTimeSince
         */
         this.timeFrom = 'step';

    }

    // ## Slider methods

    /**
     * ### Slider.init
     *
     *
     * @param {object} opts Configuration options
     */
    Slider.prototype.init = function(opts) {
        var tmp, e;
        e = 'Slider.init: '

        if ('undefined' !== typeof opts.min) {
            tmp = J.isInt(opts.min);
            if ('number' !== typeof tmp) {
                throw new TypeError(e + 'min must be an integer or ' +
                'undefined. Found: ' + opts.min);
            }
            this.min = tmp;
        }
        if ('undefined' !== typeof opts.max) {
            tmp = J.isInt(opts.max);
            if ('number' !== typeof tmp) {
                throw new TypeError(e + 'max must be an integer or ' +
                'undefined. Found: ' + opts.max);
            }
            this.max = tmp;
        }

        this.scale = 100 / (this.max - this.min);

        tmp = opts.initialValue;
        if ('undefined' !== typeof tmp) {
            if (tmp === 'random') {
                tmp = J.randomInt((this.min-1), this.max);
            }
            else {
                tmp = J.isInt(tmp, this.min, this.max, true, true);
                if ('number' !== typeof tmp) {
                    throw new TypeError(e + 'initialValue must be an ' +
                    'integer >= ' + this.min + ' and =< ' + this.max +
                    ' or undefined. Found: ' + opts.initialValue);
                }

            }
            // currentValue is used with the first update.
            this.initialValue = this.currentValue = tmp;
        }

        if ('undefined' !== typeof opts.displayValue) {
            this.displayValue = !!opts.displayValue;
        }
        if ('undefined' !== typeof opts.displayNoChange) {
            this.displayNoChange = !!opts.displayNoChange;
        }

        if (opts.type) {
            if (opts.type !== 'volume' && opts.type !== 'flat') {
                throw new TypeError(e + 'type must be "volume", "flat", or ' +
                'undefined. Found: ' + opts.type);
            }
            this.type = opts.type;
        }

        tmp = opts.requiredChoice;

        if ('undefined' !== typeof tmp) {
            console.log('***Slider.init: requiredChoice is deprecated. Use ' +
            'required instead.***');
        }
        else if ('undefined' !== typeof opts.required) {
            tmp = opts.required;
        }
        if ('undefined' !== typeof tmp) {
            this.requiredChoice = this.required = !!tmp;
        }

        if (opts.mainText) {
            if ('string' !== typeof opts.mainText) {
                throw new TypeError(e + 'mainText must be string or ' +
                                    'undefined. Found: ' + opts.mainText);
            }
            this.mainText = opts.mainText;
        }
        if ('undefined' !== typeof opts.hint) {
            if (false !== opts.hint && 'string' !== typeof opts.hint) {
                throw new TypeError(e + 'hint must be a string, false, or ' +
                                    'undefined. Found: ' + opts.hint);
            }
            this.hint = opts.hint;
        }
        else {
            // TODO: Do we need it?
            // this.hint = this.getText('autoHint');
        }

        if (this.required && this.hint !== false) {
            if (!this.hint) this.hint = 'Movement required';
            this.hint += ' *';
        }

        if (opts.onmove) {
            if ('function' !== typeof opts.onmove) {
                throw new TypeError(e + 'onmove must be a function or ' +
                                    'undefined. Found: ' + opts.onmove);
            }
            this.onmove = opts.onmove;
        }

        if (opts.width) {
            if ('string' !== typeof opts.width) {
                throw new TypeError(e + 'width must be string or ' +
                                    'undefined. Found: ' + opts.width);
            }
            this.sliderWidth = opts.width;
        }

        if (opts.hoverColor) {
            if ('string' !== typeof opts.hoverColor) {
                throw new TypeError(e + 'hoverColor must be string or ' +
                                    'undefined. Found: ' + opts.hoverColor);
            }
            this.hoverColor = opts.hoverColor;
        }

        if ('undefined' !== typeof opts.correctValue) {
            if (false === J.isNumber(opts.correctValue,
                                     this.min, this.max, true, true)) {

                throw new Error(e + 'correctValue must be a number between ' +
                                this.min + ' and ' + this.max + '. Found: ' +
                                opts.correctValue);
            }
            this.correctValue = opts.correctValue;
        }

        tmp = opts.left;
        if ('undefined' !== typeof tmp) {
            if ('string' !== typeof tmp && 'number' !== typeof tmp) {
                throw new TypeError(e + 'left must be string, number or ' +
                                    'undefined. Found: ' + tmp);
            }
            this.left = '' + tmp;
        }
        tmp = opts.right;
        if ('undefined' !== typeof tmp) {
            if ('string' !== typeof tmp && 'number' !== typeof tmp) {
                throw new TypeError(e + 'right must be string, number or ' +
                                    'undefined. Found: ' + tmp);
            }
            this.right = '' + tmp;
        }
    };

    /**
     * ### Slider.append
     *
     *g
     * @param {object} opts Configuration options
     */
    Slider.prototype.append = function() {
        var container, tmp;

        // The original color of the rangeFill container (default black)
        // that is replaced upon highlighting.
        // Need to do js onmouseover because ccs:hover does not work here.
        var tmpColor;

        var that = this;

        // MainText.
        if (this.mainText) {
            this.spanMainText = W.append('span', this.bodyDiv, {
                className: 'slider-maintext',
                innerHTML: this.mainText
            });
        }
        // Hint.
        if (this.hint) {
            W.append('span', this.bodyDiv, {
                className: 'slider-hint',
                innerHTML: this.hint
            });
        }

        container = W.add('div', this.bodyDiv, {
            className: 'container-slider'
        });

        if (this.left) {
            tmp = W.add('span', container);
            tmp.innerHTML = this.left;
            tmp.style.position = 'relative';
            tmp.style.top = '-20px';
            tmp.style.float = 'left';
        }

        this.rangeFill = W.add('div', container, {
            className: 'fill-slider',
            // id: 'range-fill'
        });

        this.slider = W.add('input', container, {
            className: 'volume-slider',
            // id: 'range-slider-input',
            name: 'rangeslider',
            type: 'range',
            min: this.min,
            max: this.max
        });

        this.slider.onmouseover = function() {
            tmpColor = that.rangeFill.style.background || 'black';
            that.rangeFill.style.background = that.hoverColor;
        };
        this.slider.onmouseout = function() {
            that.rangeFill.style.background = tmpColor;
        };

        if (this.sliderWidth) this.slider.style.width = this.sliderWidth;


        if (this.right) {
            tmp = W.add('span', container);
            tmp.innerHTML = this.right;
            tmp.style.position = 'relative';
            tmp.style.top = '-20px';
            tmp.style.float = 'right';
        }

        if (this.displayValue) {
            this.valueSpan = W.add('span', this.bodyDiv, {
                className: 'slider-display-value'
            });
        }

        if (this.displayNoChange) {
            this.noChangeSpan = W.add('span', this.bodyDiv, {
                className: 'slider-display-nochange',
                innerHTML: this.getText('noChange') + '&nbsp;'
            });
            this.noChangeCheckbox = W.add('input', this.noChangeSpan, {
                type: 'checkbox'
            });
            this.noChangeCheckbox.onclick = function() {
                if (that.noChangeCheckbox.checked) {
                    if (that.slider.value === that.initialValue) return;
                    that.slider.value = that.initialValue;
                    that.listener(true);
                    J.addClass(that.noChangeSpan, 'italic');
                }
                else {
                    J.removeClass(that.noChangeSpan, 'italic');
                }

            };
        }

        this.slider.oninput = this.listener;
        this.slider.value = this.initialValue;

        this.slider.oninput();
    };

    Slider.prototype.getValues = function(opts) {
        var res, value, nochange;
        opts = opts || {};
        res = true;
        if ('undefined' === typeof opts.highlight) opts.highlight = true;
        value = this.currentValue;
        nochange = this.noChangeCheckbox && this.noChangeCheckbox.checked;
        if ((this.required && this.totalMove === 0 && !nochange) ||
           (null !== this.correctValue && this.correctValue !== value)) {

            if (opts.highlight) this.highlight();
            res = false;
        }

        return {
            value: value,
            noChange: !!nochange,
            initialValue: this.initialValue,
            totalMove: this.totalMove,
            isCorrect: res,
            time: node.timer.getTimeSince(this.timeFrom)
        };
    };

    Slider.prototype.setValues = function(opts) {
        if ('undefined' === typeof opts) opts = {};
        else if ('number' === typeof opts) opts = { value: opts };
        this.slider.value = opts.value;
        this.slider.oninput();
    };

    /**
     * ### Slider.disable
     *
     * Disables the slider
     */
    Slider.prototype.disable = function () {
        if (this.disabled === true) return;
        this.disabled = true;
        this.slider.disabled = true;
        this.emit('disabled');
    };

    /**
     * ### Slider.enable
     *
     * Enables the dropdown menu
     */
    Slider.prototype.enable = function () {
        if (this.disabled === false) return;
        this.disabled = false;
        this.slider.disabled = false;
        this.emit('enabled');
    };

})(node);

/**
 * # SVOGauge
 * Copyright(c) 2021 Stefano Balietti
 * MIT Licensed
 *
 * Displays an interface to measure users' social value orientation (S.V.O.)
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('SVOGauge', SVOGauge);

    // ## Meta-data

    SVOGauge.version = '0.8.1';
    SVOGauge.description = 'Displays an interface to measure social ' +
        'value orientation (S.V.O.).';

    SVOGauge.title = 'SVO Gauge';
    SVOGauge.className = 'svogauge';

    SVOGauge.texts = {
        mainText: 'You and another randomly selected participant ' +
        'will receive an <em>extra bonus</em>.<br/>' +
        'Choose the preferred bonus amounts (in cents) for you ' +
        'and the other participant in each row.<br/>' +
        'We will select <em>one row at random</em> ' +
        'and add the bonus to your and the ' +
        'other participant\'s payment. Your choice will remain '  +
        '<em>anonymous</em>.',

        left: 'Your Bonus:<hr/>Other\'s Bonus:'
    };

    /**
     * ## SVOGauge constructor
     *
     * Creates a new instance of SVOGauge
     *
     * @param {object} options Optional. Configuration options
     * which is forwarded to SVOGauge.init.
     *
     * @see SVOGauge.init
     */
    function SVOGauge() {

        /**
         * ### SVOGauge.methods
         *
         * List of available methods
         *
         * Maps names to functions.
         *
         * Each function is called with `this` instance as context,
         * and accepts the `options` parameters passed to constructor.
         * Each method must return widget-like gauge object
         * implementing functions: append, enable, disable, getValues
         *
         * or an error will be thrown
         */
        this.methods = {};

        /**
         * ## SVOGauge.method
         *
         * The method used to measure svo
         *
         * Available methods: 'Slider'
         *
         * Default method is: 'Slider'
         *
         * References:
         *
         * 'Slider', Murphy R.O., Ackermann K.A. and Handgraaf M.J.J. (2011).
         * "Measuring social value orientation"
         */
        this.method = 'Slider';

        /**
         * ### SVOGauge.mainText
         *
         * A text preceeding the SVO gauger
         */
        this.mainText = null;

        /**
         * ## SVOGauge.gauge
         *
         * The object measuring svo
         *
         * @see SVOGauge.method
         */
        this.gauge = null;

        this.addMethod('Slider', SVO_Slider);
    }

    // ## SVOGauge methods.

    /**
     * ### SVOGauge.init
     *
     * Initializes the widget
     *
     * @param {object} opts Optional. Configuration options.
     */
    SVOGauge.prototype.init = function(opts) {
        var gauge, that;
        if ('undefined' !== typeof opts.method) {
            if ('string' !== typeof opts.method) {
                throw new TypeError('SVOGauge.init: method must be string ' +
                                    'or undefined. Found: ' + opts.method);
            }
            if (!this.methods[opts.method]) {
                throw new Error('SVOGauge.init: method is invalid: ' +
                                opts.method);
            }
            this.method = opts.method;
        }
        if ('undefined' !== typeof opts.mainText) {
            if (opts.mainText !== false && 'string' !== typeof opts.mainText) {
                throw new TypeError('SVOGauge.init: mainText must be string ' +
                                    'false, or undefined. Found: ' +
                                     opts.mainText);
            }
            this.mainText = opts.mainText;
        }

        // Call method.
        gauge = this.methods[this.method].call(this, opts);

        // Add defaults.
        that = this;
        gauge.isHidden = function() { return that.isHidden(); };
        gauge.isCollapsed = function() { return that.isCollapsed(); };

        // Check properties.
        if (!node.widgets.isWidget(gauge)) {
            throw new Error('SVOGauge.init: method ' + this.method +
                            ' created invalid gauge: missing default widget ' +
                            'methods.')
        }
        // Approved.
        this.gauge = gauge;

        this.on('enabled', function() {
            gauge.enable();
        });

        this.on('disabled', function() {
            gauge.disable();
        });

        this.on('highlighted', function() {
            gauge.highlight();
        });

        this.on('unhighlighted', function() {
            gauge.unhighlight();
        });
    };

    SVOGauge.prototype.append = function() {
        node.widgets.append(this.gauge, this.bodyDiv);
    };

    /**
     * ## SVOGauge.addMethod
     *
     * Adds a new method to measure mood
     *
     * @param {string} name The name of the method
     * @param {function} cb The callback implementing it
     */
    SVOGauge.prototype.addMethod = function(name, cb) {
        if ('string' !== typeof name) {
            throw new Error('SVOGauge.addMethod: name must be string: ' +
                            name);
        }
        if ('function' !== typeof cb) {
            throw new Error('SVOGauge.addMethod: cb must be function: ' +
                            cb);
        }
        if (this.methods[name]) {
            throw new Error('SVOGauge.addMethod: name already existing: ' +
                            name);
        }
        this.methods[name] = cb;
    };

    SVOGauge.prototype.getValues = function(opts) {
        opts = opts || {};
        // Transform choice in numerical values.
        if ('undefined' === typeof opts.processChoice) {
            opts.processChoice = function(choice) {
                return choice === null ? null : this.choices[choice];
            };
        }
        return this.gauge.getValues(opts);
    };

    SVOGauge.prototype.setValues = function(opts) {
        return this.gauge.setValues(opts);
    };

    // ## Available methods.

    // ### SVO_Slider
    function SVO_Slider(options) {
        var items, sliders, mainText;
        var gauge, i, len;
        var renderer;

        sliders = options.sliders || [
            [
                [85, 85],
                [85, 76],
                [85, 68],
                [85, 59],
                [85, 50],
                [85, 41],
                [85, 33],
                [85, 24],
                [85, 15]
            ],
            [
                [85, 15],
                [87, 19],
                [89, 24],
                [91, 28],
                [93, 33],
                [94, 37],
                [96, 41],
                [98, 46],
                [100, 50]
            ],
            [
                [50, 100],
                [54, 98],
                [59, 96],
                [63, 94],
                [68, 93],
                [72, 91],
                [76, 89],
                [81, 87],
                [85, 85]
            ],
            [
                [50, 100],
                [54, 89],
                [59, 79],
                [63, 68],
                [68, 58],
                [72, 47],
                [76, 36],
                [81, 26],
                [85, 15]
            ],
            [
                [100, 50],
                [94, 56],
                [88, 63],
                [81, 69],
                [75, 75],
                [69, 81],
                [63, 88],
                [56, 94],
                [50, 100]
            ],
            [
                [100, 50],
                [98, 54],
                [96, 59],
                [94, 63],
                [93, 68],
                [91, 72],
                [89, 76],
                [87, 81],
                [85, 85]
            ]
        ];

        this.sliders = sliders;


        renderer = options.renderer || function(td, choice, idx) {
            td.innerHTML = choice[0] + '<hr/>' + choice[1];
        };

        len = sliders.length;
        items = new Array(len);

        i = -1;
        for ( ; ++i < len ; ) {
            items[i] = {
                id: (i+1),
                left: this.getText('left'),
                choices: sliders[i]
            };
        }

        if (this.mainText) {
            mainText = this.mainText;
        }
        else if (this.mainText !== false) {
            mainText = this.getText('mainText');
        }
        gauge = node.widgets.get('ChoiceTableGroup', {
            id: options.id || 'svo_slider',
            items: items,
            mainText: mainText,
            title: false,
            renderer: renderer,
            requiredChoice: this.required,
            storeRef: false
        });

        return gauge;
    }

})(node);

/**
 * # VisualRound
 * Copyright(c) 2020 Stefano Balietti
 * MIT Licensed
 *
 * Display information about rounds and/or stage in the game
 *
 * Accepts different visualization options (e.g. countdown, etc.).
 * See `VisualRound` constructor for a list of all available options.
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('VisualRound', VisualRound);

    // ## Meta-data

    VisualRound.version = '0.9.0';
    VisualRound.description = 'Displays current/total/left round/stage/step. ';

    VisualRound.title = false;
    VisualRound.className = 'visualround';

    VisualRound.texts = {
        round: 'Round',
        step: 'Step',
        stage: 'Stage',
        roundLeft: 'Rounds Left',
        stepLeft: 'Steps Left',
        stageLeft: 'Stages Left'
    };

    // ## Dependencies

    VisualRound.dependencies = {
        GamePlot: {}
    };

    /**
     * ## VisualRound constructor
     *
     * Displays information on the current and total rounds and stages
     */
    function VisualRound() {

        /**
         * ### VisualRound.options
         *
         * Current configuration
         */
        this.options = null;

        /**
         * ### VisualRound.displayMode
         *
         * Object which determines what information is displayed
         *
         * @see VisualRound.setDisplayMode
         */
        this.displayMode = null;

        /**
         * ### VisualRound.stager
         *
         * Reference to a `GameStager` object providing stage and round info
         *
         * @see GameStager
         */
        this.stager = null;

        /**
         * ### VisualRound.gamePlot
         *
         * `GamePlot` object to provide stage and round information
         *
         * @see GamePlot
         */
        this.gamePlot = null;

        /**
         * ### VisualRound.curStage
         *
         * Number of the current stage
         */
        this.curStage = null;

        /**
         * ### VisualRound.totStage
         *
         * Total number of stages. Might be null if in `flexibleMode`
         */
        this.totStage = null;

        /**
         * ### VisualRound.curRound
         *
         * Number of the current round
         */
        this.curRound = null;

        /**
         * ### VisualRound.totRound
         *
         * Total number of rounds. Might be null if in `flexibleMode`
         */
        this.totRound = null;

        /**
         * ### VisualRound.stageOffset
         *
         * Stage displayed is the actual stage minus stageOffset
         */
        this.stageOffset = null;

        /**
         * ### VisualRound.totStageOffset
         *
         * Total number of stages displayed minus totStageOffset
         *
         * If not set, and it is set equal to stageOffset
         */
        this.totStageOffset = null;

        /**
         * ### VisualRound.oldStageId
         *
         * Stage id of the previous stage
         *
         * Needed in `flexibleMode` to count rounds.
         */
        this.oldStageId = null;

        /**
         * ### VisualRound.separator
         *
         * Stages and rounds are separated with this string, if needed
         *
         * E.g., Stage 3/5
         */
        this.separator = ' / ';

        /**
         * ### VisualRound.layout
         *
         * Display layout
         *
         * @see VisualRound.setLayout
         */
        this.layout = null;

    }

    // ## VisualRound methods

    /**
     * ### VisualRound.init
     *
     * Initializes the instance
     *
     * If called on running instance, options are mixed-in into current
     * settings. See `VisualRound` constructor for which options are allowed.
     *
     * @param {object} options Optional. Configuration options.
     *   The options it can take are:
     *
     *   - `stageOffset`:
     *     Stage displayed is the actual stage minus stageOffset
     *   - `preprocess`: a function that may modify information about
     *     steps, rounds and stages before they are displayed; its context
     *     is the current widget and it receives an object to modify:
     *     ```js
     *     {
     *       totRound: 1,
     *       totStep: 2,
     *       totStage: 5,
     *       curStep: 1,
     *       curStage: 1,
     *       curRound: 1
     *     }
     *   ```
     *   - `flexibleMode`:
     *     Set `true`, if number of rounds and/or stages can change dynamically
     *   - `curStage`:
     *     When (re)starting in `flexibleMode`, sets the current stage
     *   - `curRound`:
     *     When (re)starting in `flexibleMode`, sets the current round
     *   - `totStage`:
     *     When (re)starting in `flexibleMode`, sets the total number of stages
     *   - `totRound`:
     *     When (re)starting in `flexibleMode`, sets the total number of
     *     rounds
     *   - `oldStageId`:
     *     When (re)starting in `flexibleMode`, sets the id of the current
     *     stage
     *
     *
     * @see VisualRound.setDisplayMode
     * @see GameStager
     * @see GamePlot
     */
    VisualRound.prototype.init = function(options) {
        options = options || {};

        J.mixout(options, this.options);
        this.options = options;

        this.stageOffset = this.options.stageOffset || 0;
        this.totStageOffset =
            'undefined' === typeof this.options.totStageOffset ?
            this.stageOffset : this.options.totStageOffset;

        if (this.options.flexibleMode) {
            this.curStage = this.options.curStage || 1;
            this.curStage -= this.options.stageOffset || 0;
            this.curStep = this.options.curStep || 1;
            this.curRound = this.options.curRound || 1;
            this.totStage = this.options.totStage;
            this.totRound = this.options.totRound;
            this.totStep = this.options.totStep;
            this.oldStageId = this.options.oldStageId;
        }

        // Save references to gamePlot and stager for convenience.
        if (!this.gamePlot) this.gamePlot = node.game.plot;
        if (!this.stager) this.stager = this.gamePlot.stager;

        this.updateInformation();

        if (!this.options.displayMode && this.options.displayModeNames) {
            console.log('***VisualTimer.init: options.displayModeNames is ' +
                        'deprecated. Use options.displayMode instead.***');
            this.options.displayMode = this.options.displayModeNames;
        }

        if (!this.options.displayMode) {
            this.setDisplayMode([
                'COUNT_UP_ROUNDS_TO_TOTAL_IFNOT1',
                'COUNT_UP_STAGES_TO_TOTAL'
            ]);
        }
        else {
            this.setDisplayMode(this.options.displayMode);
        }

        if ('undefined' !== typeof options.separator) {
            this.separator = options.separator;
        }

        if ('undefined' !== typeof options.layout) {
            this.layout = options.layout;
        }

        if ('undefined' !== typeof options.preprocess) {
            if ('function' === typeof options.preprocess) {
                this.preprocess = options.preprocess;
            }
            else {
                throw new TypeError('VisualRound.init: preprocess must ' +
                                    'function or undefined. Found: ' +
                                    options.preprocess);
            }
        }

        this.updateDisplay();
    };

    VisualRound.prototype.append = function() {
        this.activate(this.displayMode);
        this.updateDisplay();
    };

    /**
     * ### VisualRound.updateDisplay
     *
     * Updates the values displayed by forwarding the call to displayMode obj
     *
     * @see VisualRound.displayMode
     */
    VisualRound.prototype.updateDisplay = function() {
        if (this.displayMode) this.displayMode.updateDisplay();
    };

    /**
     * ### VisualRound.setDisplayMode
     *
     * Sets the `VisualRound.displayMode` value
     *
     * Multiple displayModes are allowed, and will be merged together into a
     * `CompoundDisplayMode` object. The old `displayMode` is deactivated and
     * the new one is activated.
     *
     * The following strings are valid display names:
     *
     * - `COUNT_UP_STAGES`: Display only current stage number.
     * - `COUNT_UP_STEPS`: Display only current step number.
     * - `COUNT_UP_STEPS_IFNOT1`: Skip stages with one step.
     * - `COUNT_UP_ROUNDS`: Display only current round number.
     * - `COUNT_UP_ROUNDS_IFNOT1`: Skip stages with one round.
     * - `COUNT_UP_STAGES_TO_TOTAL`: Display current and total stage number.
     * - `COUNT_UP_ROUNDS_TO_TOTAL`: Display current and total round number.
     * - `COUNT_UP_STEPS_TO_TOTAL`: Display current and total step number.
     * - `COUNT_UP_STEPS_TO_TOTAL_IFNOT1`: Skip stages with one step.
     * - `COUNT_UP_ROUNDS_TO_TOTAL_IFNOT1`: Skip stages with one round.
     * - `COUNT_DOWN_STAGES`: Display number of stages left to play.
     * - `COUNT_DOWN_STEPS`: Display number of steps left to play.
     * - `COUNT_DOWN_ROUNDS`: Display number of rounds left in this stage.
     *
     * @param {array|string} displayMode Array of strings representing the names
     *
     * @see VisualRound.displayMode
     * @see CompoundDisplayMode
     * @see VisualRound.init
     */
    VisualRound.prototype.setDisplayMode = function(displayMode) {
        var i, len, displayModes;

        if ('string' === typeof displayMode) {
            displayMode = [ displayMode ];
        }
        else if (!J.isArray(displayMode)) {
            throw new TypeError('VisualRound.setDisplayMode: ' +
                                'displayMode must be array or string. ' +
                                'Found: ' + displayMode);
        }
        len = displayMode.length;
        if (len === 0) {
            throw new Error('VisualRound.setDisplayMode: displayMode is empty');
        }

        if (this.displayMode) {
            // Nothing to do if mode is already active.
            if (displayMode.join('&') === this.displayMode.name) return;
            this.deactivate(this.displayMode);
        }

        // Build `CompoundDisplayMode`.
        displayModes = [];
        i = -1;
        for (; ++i < len; ) {
            switch (displayMode[i]) {
            case 'COUNT_UP_STAGES_TO_TOTAL':
                displayModes.push(new CountUpStages(this, { toTotal: true }));
                break;
            case 'COUNT_UP_STAGES':
                displayModes.push(new CountUpStages(this));
                break;
            case 'COUNT_DOWN_STAGES':
                displayModes.push(new CountDownStages(this));
                break;
            case 'COUNT_UP_STEPS_TO_TOTAL':
                displayModes.push(new CountUpSteps(this, { toTotal: true }));
                break;
            case 'COUNT_UP_STEPS_TO_TOTAL_IFNOT1':
                displayModes.push(new CountUpSteps(this, {
                    toTotal: true,
                    ifNotOne: true
                }));
                break;
            case 'COUNT_UP_STEPS':
                displayModes.push(new CountUpSteps(this));
                break;
            case 'COUNT_UP_STEPS_IFNOT1':
                displayModes.push(new CountUpSteps(this, { ifNotOne: true }));
                break;
            case 'COUNT_DOWN_STEPS':
                displayModes.push(new CountDownSteps(this));
                break;
            case 'COUNT_UP_ROUNDS_TO_TOTAL':
                displayModes.push(new CountUpRounds(this, { toTotal: true }));
                break;
            case 'COUNT_UP_ROUNDS':
                displayModes.push(new CountUpRounds(this));
                break;
            case 'COUNT_UP_ROUNDS_TO_TOTAL_IFNOT1':
                displayModes.push(new CountUpRounds(this, {
                    toTotal: true,
                    ifNotOne: true
                }));
                break;
            case 'COUNT_UP_ROUNDS_IFNOT1':
                displayModes.push(new CountUpRounds(this, { ifNotOne: true }));
                break;
            case 'COUNT_DOWN_ROUNDS':
                displayModes.push(new CountDownRounds(this));
                break;
            default:
                throw new Error('VisualRound.setDisplayMode: unknown mode: ' +
                                displayMode[i]);
            }
        }
        this.displayMode = new CompoundDisplayMode(this, displayModes);
        this.activate(this.displayMode);
    };

    /**
     * ### VisualRound.getDisplayMode
     *
     * Returns name of the current displayMode
     *
     * @return {string} Name of the current displayMode
     */
    VisualRound.prototype.getDisplayModeName = function() {
        return this.displayMode.name;
    };

    /**
     * ### VisualRound.activate
     *
     * Appends the displayDiv of the given displayMode to `this.bodyDiv`
     *
     * Calls `displayMode.activate`, if one is defined.
     *
     * @param {object} displayMode DisplayMode to activate
     *
     * @see VisualRound.deactivate
     */
    VisualRound.prototype.activate = function(displayMode) {
        if (this.bodyDiv) this.bodyDiv.appendChild(displayMode.displayDiv);
        if (displayMode.activate) displayMode.activate();
    };

    /**
     * ### VisualRound.deactivate
     *
     * Removes the displayDiv of the given displayMode from `this.bodyDiv`
     *
     * Calls `displayMode.deactivate` if it is defined.
     *
     * @param {object} displayMode DisplayMode to deactivate
     *
     * @see VisualRound.activate
     */
    VisualRound.prototype.deactivate = function(displayMode) {
        this.bodyDiv.removeChild(displayMode.displayDiv);
        if (displayMode.deactivate) displayMode.deactivate();
    };

    VisualRound.prototype.listeners = function() {
        var that;
        that = this;
        node.on('STEP_CALLBACK_EXECUTED', function() {
            that.updateInformation();
        });
        // TODO: Game over and init?
    };

    /**
     * ### VisualRound.updateInformation
     *
     * Updates information about rounds and stages and updates the display
     *
     * Updates `curRound`, `curStage`, `totRound`, `totStage`, `oldStageId` and
     * calls `VisualRound.updateDisplay`.
     *
     * @see VisualRound.updateDisplay
     */
    VisualRound.prototype.updateInformation = function() {
        var stage, len, tmp;

        stage = node.player.stage;

        // Game not started.
        if (stage.stage === 0) {
            this.curStage = 0;
            this.totStage = 0;
            this.totRound = 0;
        }
        // Flexible mode.
        else if (this.options.flexibleMode) {
            if (stage.id === this.oldStageId) {
                this.curRound += 1;
            }
            else if (stage.id) {
                this.curRound = 1;
                this.curStage += 1;
            }
            this.oldStageId = stage.id;
        }
        // Normal mode.
        else {

            // Compute current values.

            this.curStage = stage.stage;

            // Stage can be indexed by id or number in the sequence.
            if ('string' === typeof this.curStage) {
                this.curStage =
                    this.gamePlot.normalizeGameStage(stage).stage;
            }
            this.curStage -= this.stageOffset;
            // 0.0.0
            if (this.curStage < 1) return;

            this.curStep = stage.step;
            this.curRound = stage.round;

            // Compute total values.

            len = this.stager.sequence.length;
            this.totStage = len - this.totStageOffset;
            if (this.stager.sequence[(len-1)].type === 'gameover') {
                this.totStage--;
            }

            tmp = this.stager.sequence[this.curStage -1];
            this.totRound = tmp.num || 1;
            this.totStep = tmp.steps.length;

            // Let user preprocess.
            if (this.preprocess) {
                tmp = {
                    totRound: this.totRound,
                    totStep: this.totStep,
                    totStage: this.totStage,
                    curStep: this.curStep,
                    curStage: this.curStage,
                    curRound: this.curRound,
                };
                this.preprocess(tmp);

                this.curRound = tmp.curRound
                this.curStep = tmp.curStep;
                this.curStage = tmp.curStage
                this.totStage = tmp.totStage;
                this.totStep = tmp.totStep;
                this.totRound = tmp.totRound;
            }
        }
        // Update display.
        this.updateDisplay();
    };

    /**
     * ### VisualRound.setLayout
     *
     * Arranges the relative position of the various elements of VisualRound
     *
     * @param {string} layout. Valid options:
     *   - 'vertical' (alias: 'multimode_vertical')
     *   - 'horizontal'
     *   - 'multimode_horizontal'
     *   - 'all_horizontal'
     */
    VisualRound.prototype.setLayout = function(layout) {
        if ('string' !== typeof layout || layout.trim() === '') {
            throw new TypeError('VisualRound.setLayout: layout must be ' +
                                'a non-empty string. Found: ' + layout);
        }
        this.layout = layout;
        if (this.displayMode) this.displayMode.setLayout(layout);
    };

    // ## Display Modes.

    /**
     * # CountUpStages
     *
     * Display current/total number of stages
     */

    /**
     * ## CountUpStages constructor
     *
     * DisplayMode which displays the current number of stages
     *
     * Can be constructed to furthermore display the total number of stages.
     *
     * @param {VisualRound} visualRound The `VisualRound` object to which the
     *   displayMode belongs
     * @param {object} options Optional. Configuration options.
     *   If `options.toTotal == true`, then the total number of stages is
     *   displayed
     */
    function CountUpStages(visualRound, options) {
        generalConstructor(this, visualRound, 'COUNT_UP_STAGES', options);
        generalInit(this, 'stagediv', this.visualRound.getText('stage'));
    }

    // ## CountUpStages methods

    /**
     * ### CountUpStages.updateDisplay
     *
     * Updates the content of `curStageNumber` and `totStageNumber`
     *
     * Values are updated according to the state of `visualRound`.
     */
    CountUpStages.prototype.updateDisplay = function() {
        this.current.innerHTML = this.visualRound.curStage;
        if (this.total) this.total.innerHTML = this.visualRound.totStage || '?';
    };

   /**
     * # CountDownStages
     *
     * Defines a displayMode for the `VisualRound` which displays the remaining
     * number of stages
     */

    /**
     * ## CountDownStages constructor
     *
     * Display mode which displays the remaining number of stages
     *
     * @param {VisualRound} visualRound The `VisualRound` object to which the
     *   displayMode belongs.
     * @param {object} options Optional. Configuration options
     */
    function CountDownStages(visualRound, options) {
        generalConstructor(this, visualRound, 'COUNT_DOWN_STAGES', options);
        generalInit(this, 'stagediv', visualRound.getText('stageLeft'));
    }

    // ## CountDownStages methods

    /**
     * ### CountDownStages.updateDisplay
     *
     * Updates the content of `stagesLeft` according to `visualRound`
     */
    CountDownStages.prototype.updateDisplay = function() {
        var v;
        v = this.visualRound;
        if (v.totStage === v.curStage) {
            this.current.innerHTML = 0;
        }
        else {
            this.current.innerHTML = (v.totStage - v.curStage) || '?';
        }
    };

    /**
      * # CountUpSteps
      *
      * Displays the current/total number of steps
      */

    /**
     * ## CountUpSteps constructor
     *
     * DisplayMode which displays the current number of stages
     *
     * Can be constructed to furthermore display the total number of stages.
     *
     * @param {VisualRound} visualRound The `VisualRound` object to which the
     *   displayMode belongs
     * @param {object} options Optional. Configuration options.
     *   If `options.toTotal == true`, then the total number of stages is
     *   displayed
     */
    function CountUpSteps(visualRound, options) {
        generalConstructor(this, visualRound, 'COUNT_UP_STEPS', options);
        generalInit(this, 'stepdiv', this.visualRound.getText('step'));
    }

    /**
     * ### CountUpSteps.updateDisplay
     *
     * Updates the content of `curStageNumber` and `totStageNumber`
     *
     * Values are updated according to the state of `visualRound`.
     */
    CountUpSteps.prototype.updateDisplay = function() {
        if (this.options.ifNotOne && this.visualRound.totStep === 1) {
            this.displayDiv.style.display = 'none';
        }
        else {
            this.current.innerHTML = this.visualRound.curStep;
            if (this.total) {
                this.total.innerHTML = this.visualRound.totStep || '?';
            }
            this.displayDiv.style.display = '';
        }
    };

   /**
     * # CountDownSteps
     *
     * DisplayMode which displays the remaining number of steps
     */

    /**
     * ## CountDownStages constructor
     *
     * Display mode which displays the remaining number of steps
     *
     * @param {VisualRound} visualRound The `VisualRound` object to which the
     *   displayMode belongs.
     * @param {object} options Optional. Configuration options
     */
    function CountDownSteps(visualRound, options) {
        generalConstructor(this, visualRound, 'COUNT_DOWN_STEPS', options);
        generalInit(this, 'stepdiv', this.visualRound.getText('stepLeft'));
    }

    // ## CountDownSteps methods

    /**
     * ### CountDownSteps.updateDisplay
     *
     * Updates the content of `stagesLeft` according to `visualRound`
     */
    CountDownSteps.prototype.updateDisplay = function() {
        var v;
        v = this.visualRound;
        if (v.totStep === v.curStep) this.current.innerHTML = 0;
        else this.current.innerHTML = (v.totStep - v.curStep) || '?';
    };

   /**
     * # CountUpRounds
     *
     * Displays the current and possibly the total number of rounds
     */

    /**
     * ## CountUpRounds constructor
     *
     * Display mode which displays the current number of rounds
     *
     * Can be constructed to furthermore display the total number of stages.
     *
     * @param {VisualRound} visualRound The `VisualRound` object to which the
     *   displayMode belongs
     * @param {object} options Optional. Configuration options. If
     *   `options.toTotal == true`, then the total number of rounds is displayed
     */
    function CountUpRounds(visualRound, options) {
        generalConstructor(this, visualRound, 'COUNT_UP_ROUNDS', options);
        generalInit(this, 'rounddiv', visualRound.getText('round'));
    }

    // ## CountUpRounds methods

    /**
     * ### CountUpRounds.updateDisplay
     *
     * Updates the content of `curRoundNumber` and `totRoundNumber`
     *
     * Values are updated according to the state of `visualRound`.
     */
    CountUpRounds.prototype.updateDisplay = function() {
        if (this.options.ifNotOne && this.visualRound.totRound === 1) {
            this.displayDiv.style.display = 'none';
        }
        else {
            this.current.innerHTML = this.visualRound.curRound;
            if (this.total) {
                this.total.innerHTML = this.visualRound.totRound || '?';
            }
            this.displayDiv.style.display = '';
        }
    };


   /**
     * # CountDownRounds
     *
     * Displays the remaining number of rounds
     */

    /**
     * ## CountDownRounds constructor
     *
     * Display mode which displays the remaining number of rounds
     *
     * @param {VisualRound} visualRound The `VisualRound` object to which the
     *   displayMode belongs
     * @param {object} options Optional. Configuration options
     */
    function CountDownRounds(visualRound, options) {
        generalConstructor(this, visualRound, 'COUNT_DOWN_ROUNDS', options);
        generalInit(this, 'rounddiv', visualRound.getText('roundLeft'));
    }

    // ## CountDownRounds methods

    /**
     * ### CountDownRounds.updateDisplay
     *
     * Updates the content of `roundsLeft` according to `visualRound`
     */
    CountDownRounds.prototype.updateDisplay = function() {
        var v;
        v = this.visualRound;
        if (v.totRound === v.curRound) this.current.innerHTML = 0;
        else this.current.innerHTML = (v.totRound - v.curRound) || '?';
    };

    /**
     * # CompoundDisplayMode
     *
     * Creates a display mode which groups together other display modes
     */

    /**
     * ## CompoundDisplayMode constructor
     *
     * Display mode which combines multiple other display displayModes
     *
     * @param {VisualRound} visualRound The `VisualRound` object to which the
     *   displayMode belongs
     * @param {array} displayModes Array of displayModes to be used in
     *   combination
     * @param {object} options Optional. Configuration options
     */
    function CompoundDisplayMode(visualRound, displayModes, options) {

        /**
         * ### CompoundDisplayMode.visualRound
         *
         * The `VisualRound` object to which the displayMode belongs
         */
        this.visualRound = visualRound;

         /**
         * ### CompoundDisplayMode.displayModes
         *
         * The array of displayModes to be used in combination
         */
        this.displayModes = displayModes;

        /**
         * ### CompoundDisplayMode.name
         *
         * The name of the displayMode
         */
        this.name = displayModes.join('&');

        /**
         * ### CompoundDisplayMode.options
         *
         * Current options
         */
        this.options = options || {};

        /**
         * ### CompoundDisplayMode.displayDiv
         *
         * The DIV in which the information is displayed
         */
        this.displayDiv = null;

        this.init(options);
    }

    // ## CompoundDisplayMode methods

    /**
     * ### CompoundDisplayMode.init
     *
     * Initializes the instance
     *
     * @param {object} options Optional. Configuration options
     *
     * @see CompoundDisplayMode.updateDisplay
     */
     CompoundDisplayMode.prototype.init = function() {
         var i, len;
         this.displayDiv = W.get('div');
         i = -1, len = this.displayModes.length;
         for (; ++i < len; ) {
             this.displayDiv.appendChild(this.displayModes[i].displayDiv);
         }
         this.updateDisplay();
     };

    /**
     * ### CompoundDisplayMode.updateDisplay
     *
     * Calls `updateDisplay` for all displayModes in the combination
     */
    CompoundDisplayMode.prototype.updateDisplay = function() {
        var i, len;
        i = -1, len = this.displayModes.length;
        for (; ++i < len; ) {
            this.displayModes[i].updateDisplay();
        }
    };

    CompoundDisplayMode.prototype.activate = function() {
        var i, len, d, layout;
        layout = this.visualRound.layout;
        i = -1, len = this.displayModes.length;
        for (; ++i < len; ) {
            d = this.displayModes[i];
            if (d.activate) this.displayModes[i].activate();
            if (layout) setLayout(d, layout, i === (len-1));
        }
    };

    CompoundDisplayMode.prototype.deactivate = function() {
        var i, len, d;
        i = -1, len = this.displayModes.length;
        for (; ++i < len; ) {
            d = this.displayModes[i];
            if (d.deactivate) d.deactivate();
        }
    };

    CompoundDisplayMode.prototype.setLayout = function(layout) {
        var i, len, d;
        i = -1, len = this.displayModes.length;
        for (; ++i < len; ) {
            d = this.displayModes[i];
            setLayout(d, layout, i === (len-1));
        }
    };

    // ## Helper Methods.

    function setLayout(d, layout, lastDisplay) {
        if (layout === 'vertical' || layout === 'multimode_vertical' ||
            layout === 'all_vertical') {

            d.displayDiv.style.float = 'none';
            d.titleDiv.style.float = 'none';
            d.titleDiv.style['margin-right'] = '0px';
            d.contentDiv.style.float = 'none';
            return true;
        }
        if (layout === 'horizontal') {
            d.displayDiv.style.float = 'none';
            d.titleDiv.style.float = 'left';
            d.titleDiv.style['margin-right'] = '6px';
            d.contentDiv.style.float = 'right';
            return true;
        }
        if (layout === 'multimode_horizontal') {
            d.displayDiv.style.float = 'left';
            d.titleDiv.style.float = 'none';
            d.titleDiv.style['margin-right'] = '0px';
            d.contentDiv.style.float = 'none';
            if (!lastDisplay) {
                d.displayDiv.style['margin-right'] = '10px';
            }
            return true;
        }
        if (layout === 'all_horizontal') {
            d.displayDiv.style.float = 'left';
            d.titleDiv.style.float = 'left';
            d.titleDiv.style['margin-right'] = '6px';
            d.contentDiv.style.float = 'right';
            if (!lastDisplay) {
                d.displayDiv.style['margin-right'] = '10px';
            }
            return true;
        }
        return false;
    }

    /**
     * ### generalConstructor
     *
     * Sets up the basic attributes of visualization mode for VisualRound
     *
     * @param {object} that The visualization mode instance
     * @param {VisualRound} visualRound The VisualRound instance
     * @param {string} name The name of the visualization mode
     * @param {object} options Additional options, e.g. 'toTotal'
     */
    function generalConstructor(that, visualRound, name, options) {
        options = options || {};

        /**
         * #### visualRound
         *
         * The `VisualRound` object to which the displayMode belongs
         */
        that.visualRound = visualRound;

        /**
         * #### name
         *
         * The name of the displayMode
         */
        that.name = name;
        if (options.toTotal) that.name += '_TO_TOTAL';

        /**
         * #### options
         *
         * The options for this instance
         */
        that.options = options;

        /**
         * #### displayDiv
         *
         * The DIV in which the information is displayed
         */
        that.displayDiv = null;

        /**
         * #### displayDiv
         *
         * The DIV in which the title is displayed
         */
        that.titleDiv = null;

        /**
         * #### contentDiv
         *
         * The DIV containing the actual information
         */
        that.contentDiv = null;

        /**
         * #### current
         *
         * The span in which the number (of rounds, steps, stages) is displayed
         */
        that.current = null;

        /**
         * #### textDiv
         *
         * The span in which the text ` of ` is displayed
         *
         * It is created only if the display mode requires it
         */
        that.textDiv = null;

        /**
         * #### total
         *
         * The span in which the total number (of rounds, etc.) is displayed
         *
         * It is created only if the display mode requires it
         */
        that.total = null;
    }

    /**
     * ### generalInit
     *
     * Adds three divs: a container with a nested title and content div
     *
     * Adds references to the instance: displayDiv, titleDiv, contentDiv.
     *
     * @param {object} The instance to which the references are added.
     * @param {string} The name of the container div
     */
    function generalInit(that, containerName, title) {
        that.displayDiv = W.get('div', { className: containerName });
        that.titleDiv = W.add('div', that.displayDiv, {
            className: 'title',
            innerHTML: title
        });
        that.contentDiv = W.add('div', that.displayDiv, {
            className: 'content'
        });
        that.current = W.append('span', that.contentDiv, {
            className: 'number'
        });
        if (that.options.toTotal) {
            that.textDiv = W.append('span', that.contentDiv, {
                className: 'text',
                innerHTML: that.visualRound.separator
            });
            that.total = W.append('span', that.contentDiv, {
                className: 'number'
            });
        }
        that.updateDisplay();
    }

})(node);

/**
 * # VisualStage
 * Copyright(c) 2019 Stefano Balietti
 * MIT Licensed
 *
 * Shows the name of the current, previous and next step.
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    var Table = W.Table;

    node.widgets.register('VisualStage', VisualStage);

    // ## Meta-data

    VisualStage.version = '0.11.0';
    VisualStage.description =
        'Displays the name of the current, previous and next step of the game.';

    VisualStage.title = false;
    VisualStage.className = 'visualstage';

    VisualStage.texts = {
        miss: '',
        current: 'Stage: ',
        previous: 'Prev: ',
        next: 'Next: '
    };

    // ## Dependencies

    VisualStage.dependencies = {
        Table: {}
    };

    /**
     * ## VisualStage constructor
     */
    function VisualStage() {

        // ### VisualStage.displayMode
        //
        // The display mode: 'compact', 'table'.
        this.displayMode = 'inline';

        // ### VisualStage.table
        //
        // The HTML element containing the information in 'table' mode
        this.table = null;

        // ### VisualStage.preprocess
        //
        // A callback function preprocessing the information displayed
        this.preprocess = null;

        // ### VisualStage.order
        //
        // The order in which information is displayed, if available.
        //
        // In 'init' it gets reassigned based on displayMode.
        this.order = [ 'current', 'next', 'previous' ];

        // ### VisualStage.capitalize
        //
        // If TRUE, the name/id of a step is capitalized. Default: TRUE.
        this.capitalize = true;

        // ### VisualStage.replaceUnderscore
        //
        // If TRUE, underscores are replaced with spaces. Default: TRUE.
        this.replaceUnderscore = true;

        // Default display settings.

        // ### VisualStage.addRound
        //
        // If TRUE, round number is added to the name of steps in repeat stages
        this.addRound = true;

        // ### VisualStage.showPrevious
        //
        // If TRUE, the name of the previuos step is displayed.
        this.showPrevious = false;

        // ### VisualStage.showCurrent
        //
        // If TRUE, the name of the current step is displayed.
        this.showCurrent = true;

        // ### VisualStage.showNext
        //
        // If TRUE, the name of the next step is displayed.
        this.showNext = true;
    }

    // ## VisualStage methods

    VisualStage.prototype.init = function(opts) {
        var err;
        if ('undefined' !== typeof opts.displayMode) {
            if (opts.displayMode !== 'inline' &&
                opts.displayMode !== 'table') {

                throw new TypeError('VisualStage.init: displayMode must be ' +
                                    '"inline", "table" or undefined. ' +
                                    'Found: ' + opts.displayMode);
            }
            this.displayMode = opts.displayMode;
        }
        if ('undefined' !== typeof opts.addRound) {
            this.addRound = !!opts.addRound;
        }
        if ('undefined' !== typeof opts.previous) {
            this.showPrevious = !!opts.previous;
        }
        if ('undefined' !== typeof opts.next) {
            this.showNext = !!opts.next;
        }
        if ('undefined' !== typeof opts.current) {
            this.showCurrent = !!opts.current;
        }
        if ('undefined' !== typeof opts.order) {
            if (!J.isArray(opts.order) || opts.order.length !== 3) {
                throw new TypeError('VisualStage.init: order must be ' +
                                    'an array of length 3 or undefined. ' +
                                    'Found: ' + opts.order);
            }
            err = checkOrderOption(opts.order, this.order.slice(0));
            if (err) {
                throw new TypeError('VisualStage.init: order contains ' +
                                    'errors: ' + opts.order);
            }
            this.order = opts.order;
        }
        else {
            if (this.displayMode === 'inline') {
                this.order = [ 'previous', 'current', 'next' ];
            }
        }
        if ('undefined' !== typeof opts.preprocess) {
            if ('function' !== typeof opts.preprocess) {
                throw new TypeError('VisualStage.init: preprocess must be ' +
                                    'function or undefined. Found: ' +
                                    opts.preprocess);
            }
            this.preprocess = opts.preprocess;
        }
        if ('undefined' !== typeof opts.capitalize) {
            this.capitalize = !!opts.capitalize;
        }

        if ('undefined' !== typeof opts.replaceUnderscore) {
            this.replaceUnderscore = !!opts.replaceUnderscore;
        }
    };

    /**
     * ### VisualStage.append
     *
     * Appends widget to `this.bodyDiv` and writes the stage
     *
     * @see VisualStage.updateDisplay
     */
    VisualStage.prototype.append = function() {
        if (this.displayMode === 'table') {
            this.table = new Table();
            this.bodyDiv.appendChild(this.table.table);
        }
        else {
            this.div = W.append('div', this.bodyDiv);
        }
        this.updateDisplay();
    };

    VisualStage.prototype.listeners = function() {
        var that = this;
        node.on('STEP_CALLBACK_EXECUTED', function() {
            that.updateDisplay();
        });
        // Game over and init?
    };

    /**
     * ### VisualStage.updateDisplay
     *
     * Writes the current, previous and next step names
     *
     * It uses the step property `name`, if existing, otherwise `id`.
     * Depending on current settings, it capitalizes it, and preprocess it.
     *
     * @see VisualStage.getStepName
     */
    VisualStage.prototype.updateDisplay = function() {
        var curStep, nextStep, prevStep;
        var curStepName, nextStepName, prevStepName;
        var order, t;

        order = {};
        curStep = node.game.getCurrentGameStage();
        if (curStep) {
            if (this.showCurrent) {
                curStepName = this.getStepName(curStep, curStep, 'current');
                order.current = curStepName;
            }
            if (this.showNext) {
                nextStep = node.game.plot.next(curStep);
                if (nextStep) {
                    nextStepName = this.getStepName(nextStep, curStep, 'next');
                    order.next = nextStepName;
                }
            }
            if (this.showPrevious) {
                prevStep = node.game.plot.previous(curStep);
                if (prevStep) {
                    prevStepName = this.getStepName(prevStep, curStep,
                                                    'previous');
                    order.previous = prevStepName;
                }
            }
        }

        if (this.displayMode === 'table') {
            this.table.clear(true);
            addRow(this, 0, order);
            addRow(this, 1, order);
            addRow(this, 2, order);
            //
            t = this.table.selexec('y', '=', 0);
            t.addClass('strong');
            // t.selexec('x', '=', 1).addClass('underline');
            this.table.parse();
        }
        else {
            this.div.innerHTML = '';
            addSpan(this, 0, order);
            addSpan(this, 1, order);
            addSpan(this, 2, order);
        }
    };

    /**
     * ### VisualStage.getStepName
     *
     * Returns the step name of a given step
     *
     * @param {GameStage} gameStage The game stage we want to to get the name
     * @param {GameStage} curStage The current game stage
     * @param {string} mod A modifier: 'current', 'previous', 'next'.
     *
     * @return {string} name The name of the step
     */
    VisualStage.prototype.getStepName = function(gameStage, curStage, mod) {
        var name, round, preprocess, addRound;
        // Get the name. If no step property is defined, use the id and
        // do some text replacing.
        name = node.game.plot.getProperty(gameStage, 'name');
        if ('function' === typeof name) {
            preprocess = name;
            name = null;
        }
        else if ('object' === typeof name && name !== null) {
            preprocess = name.preprocess;
            addRound = name.addRound;
            name = name.name;
        }
        if (!name) {
            name = node.game.plot.getStep(gameStage);
            if (!name) {
                name = this.getText('miss');
            }
            else {
                name = name.id;
                if (this.replaceUnderscore) name = name.replace(/_/g, " ");
                if (this.capitalize) name = capitalize(name);
            }
        }
        if (!preprocess) preprocess = this.preprocess;
        if ('undefined' === typeof addRound) addRound = this.addRound;

        round = getRound(gameStage, curStage, mod);

        // If function, executes it.
        if (preprocess) name = preprocess.call(node.game, name, mod, round);
        if (addRound && round) name += ' ' + round;

        return name;
    };

    // ## Helper functions.


    /**
     * ### getRound
     *
     * Returns the round for a given step, if its stage is a repeat stage
     *
     * @param {GameStage} gameStage The game stage we want to to get the round
     * @param {GameStage} gameStage The current game stage
     * @param {string} A modifier: 'current', 'previous', 'next'.
     *
     * @return {number} round The round for the step
     *
     * @see getName
     */
    function getRound(gameStage, curStage, mod) {
        var round, totRounds;
        if (!gameStage.stage) return;
        totRounds = node.game.plot.stager.sequence[(gameStage.stage - 1)].num;
        if (!totRounds) return;
        round = node.game.getRound();
        // Same stage: can be current, next, or previous.
        if (curStage.stage === gameStage.stage) {
            if (mod === 'next') round++;
            else if (mod === 'previous') round--;
        }
        // This is a previous stage.
        else if (curStage.stage > gameStage.stage) {
            round = totRounds;
        }
        // This is a next stage.
        else {
            round = 1;
        }
        return round;
    }

    function capitalize(str) {
        var tks, i, len;
        tks = str.split(' ');
        str = capWord(tks[0]);
        len = tks.length;
        if (len > 1) str += ' ' + capWord(tks[1]);
        if (len > 2) {
            for (i = 2; i < len; i++) {
                str += ' ' + capWord(tks[i]);
            }
        }
        return str;
    }

    function capWord(word) {
        return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();
    }

    function addRow(that, idx, order) {
        var row, str, type, name, className, obj;
        type = that.order[idx];
        str = that.getText(type);
        name = order[type];
        if (!name) return;
        className = 'visualstage-' + type;
        obj = {
            className: className,
            content: name
        };
        if (str === false) row = [ obj ];
        else if (type === 'current') row = [ { content: name, colspan: 2 } ];
        else row = [ { className: className, content: str }, obj ];
        that.table.addRow(row);
    }

    function addSpan(that, idx, order) {
        var str, tmp;
        tmp = that.order[idx];
        str = order[tmp];
        if (!str) return;
        if (tmp !== 'current') {
            str = '<span class="strong">' +
                that.getText(tmp) + '</span>' + str;
        }
        W.add('span', that.div, {
            innerHTML: str,
            className: 'visualstage-' + tmp
        });
    }

    function checkOrderOption(order, arr) {
        var i;
        i = arr.indexOf(order[0]);
        if (i === -1) return 'unknown item: ' + order[0];
        arr.splice(i,1);
        i = arr.indexOf(order[1]);
        if (i === -1) return 'unknown item: ' + order[1];
        arr.splice(i,1);
        i = arr.indexOf(order[2]);
        if (i === -1) return 'unknown item: ' + order[2];
        arr.splice(i,1);
        if (arr.length) return 'duplicated entry: ' + arr[0];
        return;
    }

})(node);

/**
 * # VisualTimer
 * Copyright(c) 2021 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Display a configurable timer for the game
 *
 * Timer can trigger events, only for countdown smaller than 1h.
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('VisualTimer', VisualTimer);

    // ## Meta-data

    VisualTimer.version = '0.9.3';
    VisualTimer.description = 'Display a configurable timer for the game. ' +
        'Can trigger events. Only for countdown smaller than 1h.';

    VisualTimer.title = 'Time Left';
    VisualTimer.className = 'visualtimer';

    // ## Dependencies

    VisualTimer.dependencies = {
        GameTimer: {}
    };

    /**
     * ## VisualTimer constructor
     *
     * `VisualTimer` displays and manages a `GameTimer`
     *
     * @param {object} options Optional. Configuration options
     * The options it can take are:
     *
     *   - any options that can be passed to a `GameTimer`
     *   - `waitBoxOptions`: an option object to be passed to `TimerBox`
     *   - `mainBoxOptions`: an option object to be passed to `TimerBox`
     *
     * @see TimerBox
     * @see GameTimer
     */
    function VisualTimer() {

        /**
         * ### VisualTimer.gameTimer
         *
         * The timer which counts down the game time
         *
         * @see node.timer.createTimer
         */
        this.gameTimer = null;

        /**
         * ### VisualTimer.mainBox
         *
         * The `TimerBox` which displays the main timer
         *
         * @see TimerBox
         */
        this.mainBox = null;

        /**
         * ### VisualTimer.waitBox
         *
         * The `TimerBox` which displays the wait timer
         *
         * @see TimerBox
         */
        this.waitBox = null;

        /**
         * ### VisualTimer.activeBox
         *
         * The `TimerBox` in which to display the time
         *
         * This variable is always a reference to either `waitBox` or
         * `mainBox`.
         *
         * @see TimerBox
         */
        this.activeBox = null;

        /**
         * ### VisualTimer.isInitialized
         *
         * Indicates whether the instance has been initializded already
         */
        this.isInitialized = false;

        /**
         * ### VisualTimer.options
         *
         * Currently stored options
         */
        this.options = {};

        /**
         * ### VisualTimer.internalTimer
         *
         * TRUE, if the timer is created internally
         *
         * Internal timers are destroyed when widget is destroyed or cleared
         *
         * @see VisualTimer.gameTimer
         * @see VisualTimer.clear
         */
        this.internalTimer = null;
    }

    // ## VisualTimer methods

    /**
     * ### VisualTimer.init
     *
     * Initializes the instance. When called again, adds options to current ones
     *
     * The options it can take are:
     *
     * - any options that can be passed to a `GameTimer`
     * - waitBoxOptions: an option object to be passed to `TimerBox`
     * - mainBoxOptions: an option object to be passed to `TimerBox`
     *
     * @param {object} opts Optional. Configuration options
     *
     * @see TimerBox
     * @see GameTimer
     */
    VisualTimer.prototype.init = function(opts) {
        var gameTimerOptions;

        // We keep the check for object, because this widget is often
        // called by users and the restart methods does not guarantee
        // an object.
        opts = opts || {};
        if ('object' !== typeof opts) {
            throw new TypeError('VisualTimer.init: opts must be ' +
                                'object or undefined. Found: ' + opts);
        }

        // Important! Do not modify directly options, because it might
        // modify a step-property. Will manual clone later.
        gameTimerOptions = {};

        // If gameTimer is not already set, check options, then
        // try to use node.game.timer, if defined, otherwise crete a new timer.
        if ('undefined' !== typeof opts.gameTimer) {

            if (this.gameTimer) {
                throw new Error('GameTimer.init: opts.gameTimer cannot ' +
                                'be set if a gameTimer is already existing: ' +
                                this.name);
            }
            if ('object' !== typeof opts.gameTimer) {
                throw new TypeError('VisualTimer.init: opts.' +
                                    'gameTimer must be object or ' +
                                    'undefined. Found: ' + opts.gameTimer);
            }
            this.gameTimer = opts.gameTimer;
        }
        else {
            if (!this.isInitialized) {
                this.internalTimer = true;
                this.gameTimer = node.timer.createTimer({
                    name: opts.name || 'VisualTimer_' + J.randomInt(10000000)
                });
            }
        }

        if (opts.hooks) {
            if (!this.internalTimer) {
                throw new Error('VisualTimer.init: cannot add hooks on ' +
                                'external gameTimer.');
            }
            if (!J.isArray(opts.hooks)) {
                gameTimerOptions.hooks = [ opts.hooks ];
            }
        }
        else {
            gameTimerOptions.hooks = [];
        }

        // Only push this hook once.
        if (!this.isInitialized) {
            gameTimerOptions.hooks.push({
                name: 'VisualTimer_' + this.wid,
                hook: this.updateDisplay,
                ctx: this
            });
        }

        // Important! Manual clone must be done after hooks and gameTimer.

        // Parse milliseconds option.
        if ('undefined' !== typeof opts.milliseconds) {
            gameTimerOptions.milliseconds =
                node.timer.parseInput('milliseconds', opts.milliseconds);
        }

        // Parse update option.
        if ('undefined' !== typeof opts.update) {
            gameTimerOptions.update =
                node.timer.parseInput('update', opts.update);
        }
        else {
            gameTimerOptions.update = 1000;
        }

        // Parse timeup option.
        if ('undefined' !== typeof opts.timeup) {
            gameTimerOptions.timeup = opts.timeup;
        }

        // Init the gameTimer, regardless of the source (internal vs external).
        this.gameTimer.init(gameTimerOptions);

        // var t = this.gameTimer;

// TODO: not using session for now.
//         node.session.register('visualtimer', {
//             set: function(p) {
//                 // TODO
//             },
//             get: function() {
//                 return {
//                     startPaused: t.startPaused,
//                         status: t.status,
//                     timeLeft: t.timeLeft,
//                     timePassed: t.timePassed,
//                     update: t.update,
//                     updateRemaining: t.updateRemaining,
//                     updateStart: t. updateStart
//                 };
//             }
//         });

        this.options = gameTimerOptions;

        // Must be after this.options is assigned.
        if ('undefined' === typeof opts.stopOnDone) {
            this.options.stopOnDone = !!opts.stopOnDone;
        }
        else if ('undefined' === typeof this.options.stopOnDone) {
            this.options.stopOnDone = true;
        }

        if ('undefined' === typeof opts.startOnPlaying) {
            this.options.startOnPlaying = !!opts.startOnPlaying;
        }
        else if ('undefined' === typeof this.options.startOnPlaying) {
            this.options.startOnPlaying = true;
        }

        if (!this.options.mainBoxOptions) {
            this.options.mainBoxOptions = {};
        }
        if (!this.options.waitBoxOptions) {
            this.options.waitBoxOptions = {};
        }

        J.mixout(this.options.mainBoxOptions,
                {classNameBody: opts.className, hideTitle: true});
        J.mixout(this.options.waitBoxOptions,
                {title: 'Max. wait timer',
                classNameTitle: 'waitTimerTitle',
                classNameBody: 'waitTimerBody', hideBox: true});

        if (!this.mainBox) {
            this.mainBox = new TimerBox(this.options.mainBoxOptions);
        }
        else {
            this.mainBox.init(this.options.mainBoxOptions);
        }
        if (!this.waitBox) {
            this.waitBox = new TimerBox(this.options.waitBoxOptions);
        }
        else {
            this.waitBox.init(this.options.waitBoxOptions);
        }

        this.activeBox = this.options.activeBox || this.mainBox;

        this.isInitialized = true;
    };

    VisualTimer.prototype.append = function() {
        this.bodyDiv.appendChild(this.mainBox.boxDiv);
        this.bodyDiv.appendChild(this.waitBox.boxDiv);

        this.activeBox = this.mainBox;
        this.updateDisplay();
    };

    /**
     * ### VisualTimer.clear
     *
     * Reverts state of `VisualTimer` to right after creation
     *
     * @param {object} options Configuration object
     *
     * @return {object} oldOptions The Old options
     *
     * @see node.timer.destroyTimer
     * @see VisualTimer.init
     */
    VisualTimer.prototype.clear = function(options) {
        var oldOptions;
        options = options || {};
        oldOptions = this.options;

        destroyTimer(this);

        this.gameTimer = null;
        this.activeBox = null;
        this.isInitialized = false;
        this.init(options);

        return oldOptions;
    };

    /**
     * ### VisualTimer.updateDisplay
     *
     * Changes `activeBox` to display current time of `gameTimer`
     *
     * @see TimerBox.bodyDiv
     */
    VisualTimer.prototype.updateDisplay = function() {
        var time, minutes, seconds;
        if (!this.gameTimer.milliseconds || this.gameTimer.milliseconds === 0) {
            this.activeBox.bodyDiv.innerHTML = '00:00';
            return;
        }
        time = this.gameTimer.milliseconds - this.gameTimer.timePassed;
        time = J.parseMilliseconds(time);
        minutes = (time[2] < 10) ? '' + '0' + time[2] : time[2];
        seconds = (time[3] < 10) ? '' + '0' + time[3] : time[3];
        this.activeBox.bodyDiv.innerHTML = minutes + ':' + seconds;
    };

    /**
     * ### VisualTimer.start
     *
     * Starts the timer
     *
     * @see VisualTimer.updateDisplay
     * @see GameTimer.start
     */
    VisualTimer.prototype.start = function() {
        this.updateDisplay();
        this.gameTimer.start();
    };

    /**
     * ### VisualTimer.restart
     *
     * Restarts the timer with new options
     *
     * @param {object|number} options Configuration object or the number of
     *     milliseconds
     *
     * @see VisualTimer.init
     * @see VisualTimer.start
     * @see VisualTimer.stop
     */
    VisualTimer.prototype.restart = function(options) {
        this.stop();
        if ('number' === typeof options) options = { milliseconds: options };
        this.init(options);
        this.start();
    };

    /**
     * ### VisualTimer.stop
     *
     * Stops the timer display and stores the time left in `activeBox.timeLeft`
     *
     * @see GameTimer.isStopped
     * @see GameTimer.stop
     */
    VisualTimer.prototype.stop = function() {
        if (!this.gameTimer.isStopped()) {
            this.activeBox.timeLeft = this.gameTimer.timeLeft;
            this.gameTimer.stop();
        }
    };
    /**
     * ### VisualTimer.switchActiveBoxTo
     *
     * Switches the display of the `gameTimer` into the `TimerBox` `box`
     *
     * Stores `gameTimer.timeLeft` into `activeBox` and then switches
     * `activeBox` to reference `box`.
     *
     * @param {TimerBox} box TimerBox in which to display `gameTimer` time
     */
    VisualTimer.prototype.switchActiveBoxTo = function(box) {
        this.activeBox.timeLeft = this.gameTimer.timeLeft || 0;
        this.activeBox = box;
        this.updateDisplay();
    };

    /**
      * ### VisualTimer.startWaiting
      *
      * Stops the timer and changes the appearance to a max. wait timer
      *
      * If options and/or options.milliseconds are undefined, the wait timer
      * will start with the current time left on the `gameTimer`. The mainBox
      * will be striked out, the waitBox set active and unhidden. All other
      * options are forwarded directly to `VisualTimer.restart`.
      *
      * @param {object} options Configuration object
      *
      * @see VisualTimer.restart
      */
    VisualTimer.prototype.startWaiting = function(options) {
        if ('undefined' === typeof options) options = {};

        if ('undefined' === typeof options.milliseconds) {
            options.milliseconds = this.gameTimer.timeLeft;
        }
        if ('undefined' === typeof options.mainBoxOptions) {
            options.mainBoxOptions = {};
        }
        if ('undefined' === typeof options.waitBoxOptions) {
            options.waitBoxOptions = {};
        }
        options.mainBoxOptions.classNameBody = 'strike';
        options.mainBoxOptions.timeLeft = this.gameTimer.timeLeft || 0;
        options.activeBox = this.waitBox;
        options.waitBoxOptions.hideBox = false;
        this.restart(options);
    };

    /**
      * ### VisualTimer.startTiming
      *
      * Starts the timer and changes appearance to a regular countdown
      *
      * The mainBox will be unstriked and set active, the waitBox will be
      * hidden. All other options are forwarded directly to
      * `VisualTimer.restart`.
      *
      * @param {object} options Configuration object
      *
      * @see VisualTimer.restart
      */
    VisualTimer.prototype.startTiming = function(options) {
        if ('undefined' === typeof options) {
            options = {};
        }
        if ('undefined' === typeof options.mainBoxOptions) {
            options.mainBoxOptions = {};
        }
        if ('undefined' === typeof options.waitBoxOptions) {
            options.waitBoxOptions = {};
        }
        options.activeBox = this.mainBox;
        options.waitBoxOptions.timeLeft = this.gameTimer.timeLeft || 0;
        options.waitBoxOptions.hideBox = true;
        options.mainBoxOptions.classNameBody = '';
        this.restart(options);
    };

    /**
     * ### VisualTimer.resume
     *
     * Resumes the `gameTimer`
     *
     * @see GameTimer.resume
     */
    VisualTimer.prototype.resume = function() {
        this.gameTimer.resume();
    };

    /**
     * ### VisualTimer.setToZero
     *
     * Stops `gameTimer` and sets `activeBox` to display `00:00`
     *
     * @see GameTimer.resume
     */
    VisualTimer.prototype.setToZero = function() {
        this.stop();
        this.activeBox.bodyDiv.innerHTML = '00:00';
        this.activeBox.setClassNameBody('strike');
    };

    /**
     * ### VisualTimer.isTimeup
     *
     * Returns TRUE if the timer expired
     *
     * This method is added for backward compatibility.
     *
     * @see GameTimer.isTimeup
     */
    VisualTimer.prototype.isTimeup = function() {
        return this.gameTimer.isTimeup();
    };

    /**
     * ### VisualTimer.doTimeUp
     *
     * Stops the timer and calls the timeup
     *
     * @see GameTimer.doTimeup
     */
    VisualTimer.prototype.doTimeUp = function() {
        this.gameTimer.doTimeUp();
    };

    VisualTimer.prototype.listeners = function() {
        var that = this;

        // Add listeners only on internal timer.
        if (!this.internalTimer) return;

        node.on('PLAYING', function() {
            var options;
            if (that.options.startOnPlaying) {
                options = that.gameTimer.getStepOptions();
                if (options) {
                    // Visual update is here (1000 usually).
                    options.update = that.update;
                    // Make sure timeup is not used (game.timer does it).
                    options.timeup = undefined;
                    // Options other than `update`, `timeup`,
                    // `milliseconds`, `hooks`, `gameTimer` are ignored.
                    that.startTiming(options);
                }
                else {
                    // Set to zero if it was not started already.
                    if (!that.gameTimer.isRunning()) that.setToZero();
                }
            }
        });

        node.on('REALLY_DONE', function() {
            if (that.options.stopOnDone) {
                if (!that.gameTimer.isStopped()) {
                    // This was creating problems, so we just stop it.
                    // It could be an option, though.
                    // that.startWaiting();
                    that.stop();
                }
            }
        });

        // Handle destroy.
        this.on('destroyed', function() {
            destroyTimer(that);
            that.bodyDiv.removeChild(that.mainBox.boxDiv);
            that.bodyDiv.removeChild(that.waitBox.boxDiv);
        });
    };

   /**
     * # TimerBox
     *
     * Copyright(c) 2015 Stefano Balietti
     * MIT Licensed
     *
     * Represents a box wherin to display a `VisualTimer`
     */

    /**
     * ## TimerBox constructor
     *
     * `TimerBox` represents a box wherein to display the timer
     *
     * @param {object} options Optional. Configuration options
     *   The options it can take are:
     *
     *   - `hideTitle`
     *   - `hideBody`
     *   - `hideBox`
     *   - `title`
     *   - `classNameTitle`
     *   - `classNameBody`
     *   - `timeLeft`
     */
    function TimerBox(options) {
        /**
         * ### TimerBox.boxDiv
         *
         * The Div which will contain the title and body Divs
         */
        this.boxDiv = null;

        /**
         * ### TimerBox.titleDiv
         *
         * The Div which will contain the title
         */
        this.titleDiv = null;
        /**
         * ### TimerBox.bodyDiv
         *
         * The Div which will contain the numbers
         */
        this.bodyDiv = null;

        /**
         * ### TimerBox.timeLeft
         *
         * Used to store the last value before focus is taken away
         */
        this.timeLeft = null;

        this.boxDiv =   W.get('div');
        this.titleDiv = W.add('div', this.boxDiv);
        this.bodyDiv =  W.add('div', this.boxDiv);

        this.init(options);
    }

    TimerBox.prototype.init = function(options) {
        if (options) {
            if (options.hideTitle) {
                this.hideTitle();
            }
            else {
                this.unhideTitle();
            }
            if (options.hideBody) {
                this.hideBody();
            }
            else {
                this.unhideBody();
            }
            if (options.hideBox) {
                this.hideBox();
            }
            else {
                this.unhideBox();
            }
        }

        this.setTitle(options.title || '');
        this.setClassNameTitle(options.classNameTitle || '');
        this.setClassNameBody(options.classNameBody || '');

        if (options.timeLeft) {
            this.timeLeft = options.timeLeft;
        }
    };

    // ## TimerBox methods

    /**
     * ### TimerBox.hideBox
     *
     * Hides entire `TimerBox`
     */
    TimerBox.prototype.hideBox = function() {
        this.boxDiv.style.display = 'none';
    };

    /**
     * ### TimerBox.unhideBox
     *
     * Hides entire `TimerBox`
     */
    TimerBox.prototype.unhideBox = function() {
        this.boxDiv.style.display = '';
    };

    /**
     * ### TimerBox.hideTitle
     *
     * Hides title of `TimerBox`
     */
    TimerBox.prototype.hideTitle = function() {
        this.titleDiv.style.display = 'none';
    };

    /**
     * ### TimerBox.unhideTitle
     *
     * Unhides title of `TimerBox`
     */
    TimerBox.prototype.unhideTitle = function() {
        this.titleDiv.style.display = '';
    };

    /**
     * ### TimerBox.hideBody
     *
     * Hides body of `TimerBox`
     */
    TimerBox.prototype.hideBody = function() {
        this.bodyDiv.style.display = 'none';
    };

    /**
     * ### TimerBox.unhideBody
     *
     * Unhides Body of `TimerBox`
     */
    TimerBox.prototype.unhideBody = function() {
        this.bodyDiv.style.display = '';
    };

    /**
     * ### TimerBox.setTitle
     *
     * Sets title of `TimerBox`
     */
    TimerBox.prototype.setTitle = function(title) {
        this.titleDiv.innerHTML = title;
    };

    /**
     * ### TimerBox.setClassNameTitle
     *
     * Sets class name of title of `TimerBox`
     */
    TimerBox.prototype.setClassNameTitle = function(className) {
        this.titleDiv.className = className;
    };

    /**
     * ### TimerBox.setClassNameBody
     *
     * Sets class name of body of `TimerBox`
     */
    TimerBox.prototype.setClassNameBody = function(className) {
        this.bodyDiv.className = className;
    };

    // Helper function.

    function destroyTimer(that) {
        if (that.internalTimer) {
            if (!that.gameTimer.isDestroyed()) {
                node.timer.destroyTimer(that.gameTimer);
            }
            that.internalTimer = null;
        }
        else {
            that.gameTimer.removeHook('VisualTimer_' + that.wid);
        }
    }

    // if (this.internalTimer) {
    //     if (!this.gameTimer.isDestroyed()) {
    //         node.timer.destroyTimer(this.gameTimer);
    //     }
    //     this.internalTimer = null;
    // }
    // else {
    //     this.gameTimer.removeHook(this.updateHookName);
    // }

})(node);

/**
 * # WaitingRoom
 * Copyright(c) 2022 Stefano Balietti <ste@nodegame.org>
 * MIT Licensed
 *
 * Displays the number of connected/required players to start a game
 *
 * www.nodegame.org
 */
(function(node) {

    "use strict";

    node.widgets.register('WaitingRoom', WaitingRoom);
    // ## Meta-data

    WaitingRoom.version = '1.4.0';
    WaitingRoom.description = 'Displays a waiting room for clients.';

    WaitingRoom.title = 'Waiting Room';
    WaitingRoom.className = 'waitingroom';

    // ## Dependencies

    WaitingRoom.dependencies = {
        VisualTimer: {}
    };

    // ## Prototype Properties.

    /** ### WaitingRoom.sounds
     *
     * Default sounds to play on particular events
     */
    WaitingRoom.sounds = {

        // #### dispatch
        dispatch: '/sounds/doorbell.ogg'
    };

    /** ### WaitingRoom.texts
     *
     * Default texts to display
     */
    WaitingRoom.texts = {

        // #### blinkTitle
        blinkTitle: 'GAME STARTS!',

        // #### waitingForConf
        waitingForConf: 'Waiting to receive data',

        // #### executionMode
        executionMode: function(w) {
            if (w.executionMode === 'WAIT_FOR_N_PLAYERS') {
                return 'Waiting for All Players to Connect: ';
            }
            if (w.executionMode === 'WAIT_FOR_DISPATCH') {
                return 'Task will start soon. Please be patient.';
            }
            // TIMEOUT.
            return 'Task will start at: <br>' + w.startDate;
        },

        // #### disconnect
        disconnect: '<span style="color: red">You have been ' +
            '<strong>disconnected</strong>. Please try again later.' +
            '</span><br><br>',

        // #### waitedTooLong
        waitedTooLong: 'Waiting for too long. Please look ' +
            'for a HIT called <strong>Trouble Ticket</strong> and file' +
            ' a new trouble ticket reporting your experience.',

        // #### notEnoughPlayers
        notEnoughPlayers: '<h3 align="center" style="color: red">' +
            'Thank you for your patience.<br>' +
            'Unfortunately, there are not enough participants in ' +
            'your group to start the experiment.<br>',

        // #### roomClosed
        roomClosed: '<span style="color: red"> The ' +
            'waiting room is <strong>CLOSED</strong>. You have been ' +
            'disconnected. Please try again later.</span><br><br>',

        // #### tooManyPlayers
        tooManyPlayers: function(widget, data) {
            var str;
            str = 'There are more players in this waiting room ' +
                'than playslots in the game. ';
            if (widget.poolSize === 1) {
                str += 'Each player will play individually.';
            }
            else {
                str += 'Only ' + data.nGames + ' players will be selected ' +
                    'to play the game.';
            }
            return str;
        },

        // #### notSelectedClosed
        notSelectedClosed: '<h3 align="center">' +
            '<span style="color: red">Unfortunately, you were ' +
            '<strong>not selected</strong> to join the game this time. ' +
            'Thank you for your participation.</span></h3><br><br>',

        // #### notSelectedOpen
        notSelectedOpen: '<h3 align="center">' +
            '<span style="color: red">Unfortunately, you were ' +
            '<strong>not selected</strong> to join the game this time, ' +
            'but you may join the next one.</span><a class="hand" ' +
            'onclick=javascript:this.parentElement.innerHTML="">' +
            'Ok, I got it.</a></h3><br><br>' +
            'Thank you for your participation.</span></h3><br><br>',

        // #### exitCode
        exitCode: function(widget, data) {
            return '<br>You have been disconnected. ' +
                ('undefined' !== typeof data.exit ?
                 ('Please report this exit code: ' + data.exit) : '') +
                '<br></h3>';
        },

        // #### playBot
        playBot: function(widget) {
            if (widget.poolSize === widget.groupSize &&
                widget.groupSize === 1) {

                return 'Play';
            }
            if (widget.groupSize === 2) return 'Play With Bot';
            return 'Play With Bots';
        },

        // #### connectingBots
        connectingBots:  function(widget) {
            console.log(widget.poolSize, widget.groupSize);
            if (widget.poolSize === widget.groupSize &&
                widget.groupSize === 1) {

                return 'Starting, Please Wait...';
            }
            if (widget.groupSize === 2) return 'Connecting Bot, Please Wait...';
            return 'Connecting Bot/s, Please Wait...';
        },

        // #### selectTreatment
        // Trailing space makes it nicer.
        selectTreatment: 'Select Treatment ',

        // #### gameTreatments
        gameTreatments: 'Game:',

        // #### defaultTreatments
        defaultTreatments: 'Defaults:'

    };

    /**
     * ## WaitingRoom constructor
     *
     * Instantiates a new WaitingRoom object
     *
     * @param {object} options
     */
    function WaitingRoom() {

        /**
         * ### WaitingRoom.connected
         *
         * Number of players connected
         */
        this.connected = 0;

        /**
         * ### WaitingRoom.poolSize
         *
         * Number of players connected before groups are made
         */
        this.poolSize = 0;

        /**
         * ### WaitingRoom.nGames
         *
         * Total number of games to be dispatched
         *
         * Server will close the waiting room afterwards.
         *
         * Undefined means no limit.
         */
        this.nGames = undefined;

        /**
         * ### WaitingRoom.groupSize
         *
         * The size of the group
         */
        this.groupSize = 0;

        /**
         * ### WaitingRoom.waitTime
         *
         * The time in milliseconds for the timeout to expire
         */
        this.waitTime = null;

        /**
         * ### WaitingRoom.executionMode
         *
         * The execution mode.
         */
        this.executionMode = null;

        /**
         * ### WaitingRoom.startDate
         *
         * The exact date and time when the game starts
         */
        this.startDate = null;

        /**
         * ### WaitingRoom.timeoutId
         *
         * The id of the timeout, if created
         */
        this.timeoutId = null;

        /**
         * ### WaitingRoom.execModeDiv
         *
         * Div containing the span for displaying the number of players
         *
         * @see WaitingRoom.playerCount
         */
        this.execModeDiv = null;

        /**
         * ### WaitingRoom.playerCount
         *
         * Span displaying the number of connected players
         */
        this.playerCount = null;

        /**
         * ### WaitingRoom.startDateDiv
         *
         * Div containing the start date
         */
        this.startDateDiv = null;

        /**
         * ### WaitingRoom.msgDiv
         *
         * Div containing optional messages to display
         */
        this.msgDiv = null;

        /**
         * ### WaitingRoom.timerDiv
         *
         * Div containing the timer
         *
         * @see WaitingRoom.timer
         */
        this.timerDiv = null;

        /**
         * ### WaitingRoom.timer
         *
         * VisualTimer instance for max wait time.
         *
         * @see VisualTimer
         */
        this.timer = null;

        /**
         * ### WaitingRoom.dots
         *
         * Looping dots to give the user the feeling of code execution
         */
        this.dots = null;

        /**
         * ### WaitingRoom.onTimeout
         *
         * Callback to be executed if the timer expires
         */
        this.onTimeout = null;

        /**
         * ### WaitingRoom.disconnectIfNotSelected
         *
         * Flag that indicates whether to disconnect an not selected player
         */
        this.disconnectIfNotSelected = null;

        /**
         * ### WaitingRoom.playWithBotOption
         *
         * If TRUE, it displays a button to begin the game with bots
         *
         * This option is set by the server, local modifications will
         * not have an effect if server does not allow it
         *
         * @see WaitingRoom.playBotBtn
         */
        this.playWithBotOption = null;

        /**
         * ### WaitingRoom.playBotBtn
         *
         * Reference to the button to play with bots
         *
         * Will be created if requested by options.
         *
         * @see WaitingRoom.playWithBotOption
         */
        this.playBotBtn = null;

        /**
         * ### WaitingRoom.selectTreatmentOption
         *
         * If TRUE, it displays a selector to choose the treatment of the game
         *
         * This option is set by the server, local modifications will
         * not have an effect if server does not allow it
         */
        this.selectTreatmentOption = null;

        /**
         * ### WaitingRoom.treatmentBtn
         *
         * Holds the name of selected treatment
         *
         * Only used if `selectTreatmentOption` is enabled
         *
         * @see WaitingRoom.selectTreatmentOption
         */
        this.selectedTreatment = null;


        /**
         * ### WaitingRoom.addDefaultTreatments
         *
         * If TRUE, after the user defined treatments, it adds default ones
         *
         * It has effect only if WaitingRoom.selectTreatmentOption is TRUE.
         *
         * Default: TRUE
         *
         * @see WaitingRoom.selectTreatmentOption
         */
        this.addDefaultTreatments = null;

    }

    // ## WaitingRoom methods

    /**
     * ### WaitingRoom.init
     *
     * Setups the requirements widget
     *
     * TODO: Update this doc (list of options).
     *
     * Available options:
     *
     *   - onComplete: function executed with either failure or success
     *   - onTimeout: function executed when timer runs out
     *   - onSuccess: function executed when all tests succeed
     *   - waitTime: max waiting time to execute all tests (in milliseconds)
     *   - startDate: max waiting time to execute all tests (in milliseconds)
     *   - playWithBotOption: displays button to dispatch players with bots
     *   - selectTreatmentOption: displays treatment selector
     *
     * @param {object} conf Configuration object.
     */
    WaitingRoom.prototype.init = function(conf) {
        var t, that;
        that = this;

        if ('object' !== typeof conf) {
            throw new TypeError('WaitingRoom.init: conf must be object. ' +
                                'Found: ' + conf);
        }

        // It receives the TEXTS AND SOUNDS only first.
        if (!conf.executionMode) return;

        // TODO: check types and conditions?
        this.executionMode = conf.executionMode;

        if (conf.onTimeout) {
            if ('function' !== typeof conf.onTimeout) {
                throw new TypeError('WaitingRoom.init: conf.onTimeout must ' +
                                    'be function, null or undefined. Found: ' +
                                    conf.onTimeout);
            }
            this.onTimeout = conf.onTimeout;
        }

        if (conf.waitTime) {
            if (null !== conf.waitTime &&
                'number' !== typeof conf.waitTime) {

                throw new TypeError('WaitingRoom.init: conf.waitTime ' +
                                    'must be number, null or undefined. ' +
                                    'Found: ' + conf.waitTime);
            }
            this.waitTime = conf.waitTime;
        }

        if (conf.startDate) {
            this.startDate = new Date(conf.startDate).toString();
        }

        if (conf.poolSize) {
            if (conf.poolSize && 'number' !== typeof conf.poolSize) {
                throw new TypeError('WaitingRoom.init: conf.poolSize ' +
                                    'must be number or undefined. Found: ' +
                                    conf.poolSize);
            }
            this.poolSize = conf.poolSize;
        }

        if (conf.groupSize) {
            if (conf.groupSize && 'number' !== typeof conf.groupSize) {
                throw new TypeError('WaitingRoom.init: conf.groupSize ' +
                                    'must be number or undefined. Found: ' +
                                    conf.groupSize);
            }
            this.groupSize = conf.groupSize;
        }
        if (conf.nGames) {
            if (conf.nGames && 'number' !== typeof conf.nGames) {
                throw new TypeError('WaitingRoom.init: conf.nGames ' +
                                    'must be number or undefined. Found: ' +
                                    conf.nGames);
            }
            this.nGames = conf.nGames;
        }

        if (conf.connected) {
            if (conf.connected && 'number' !== typeof conf.connected) {
                throw new TypeError('WaitingRoom.init: conf.connected ' +
                                    'must be number or undefined. Found: ' +
                                    conf.connected);
            }
            this.connected = conf.connected;
        }

        if (conf.disconnectIfNotSelected) {
            if ('boolean' !== typeof conf.disconnectIfNotSelected) {
                throw new TypeError('WaitingRoom.init: ' +
                    'conf.disconnectIfNotSelected must be boolean or ' +
                    'undefined. Found: ' + conf.disconnectIfNotSelected);
            }
            this.disconnectIfNotSelected = conf.disconnectIfNotSelected;
        }
        else {
            this.disconnectIfNotSelected = false;
        }


        if (conf.playWithBotOption) this.playWithBotOption = true;
        else this.playWithBotOption = false;
        if (conf.selectTreatmentOption) this.selectTreatmentOption = true;
        else this.selectTreatmentOption = false;
        if ('undefined' === typeof conf.addDefaultTreatments) {
            this.addDefaultTreatments = !!conf.addDefaultTreatments;
        }
        else {
            this.addDefaultTreatments = true;
        }

        // Button for bots and treatments.
        if (conf.queryStringDispatch) {
            this.queryStringTreatmentVariable = 'lang';
            t = J.getQueryString(this.queryStringTreatmentVariable);

            if (t) {
                if (!conf.availableTreatments[t]) {
                    alert('Unknown t', t);
                }
                else {
                    node.say('PLAYWITHBOT', 'SERVER', t);
                    return;
                }
            }
        }

        if (conf.treatmentDisplayCb) {
            this.treatmentDisplayCb = conf.treatmentDisplayCb;
        }

        // Display Exec Mode.
        this.displayExecMode();

    // if (this.playWithBotOption && !document.getElementById('bot_btn')) {
    //     // Closure to create button group.
    //     (function(w) {
    //         var btnGroup = document.createElement('div');
    //         btnGroup.role = 'group';
    //         btnGroup['aria-label'] = 'Play Buttons';
    //         btnGroup.className = 'btn-group';
    //
    //         var playBotBtn = document.createElement('input');
    //         playBotBtn.className = 'btn btn-primary btn-lg';
    //         playBotBtn.value = w.getText('playBot');
    //         playBotBtn.id = 'bot_btn';
    //         playBotBtn.type = 'button';
    //         playBotBtn.onclick = function() {
    //             w.playBotBtn.value = w.getText('connectingBots');
    //             w.playBotBtn.disabled = true;
    //             node.say('PLAYWITHBOT', 'SERVER', w.selectedTreatment);
    //             setTimeout(function() {
    //                 w.playBotBtn.value = w.getText('playBot');
    //                 w.playBotBtn.disabled = false;
    //             }, 5000);
    //         };
    //
    //         btnGroup.appendChild(playBotBtn);
    //
    //         // Store reference in widget.
    //         w.playBotBtn = playBotBtn;
    //
    //         if (w.selectTreatmentOption) {
    //
    //             var btnGroupTreatments = document.createElement('div');
    //             btnGroupTreatments.role = 'group';
    //             btnGroupTreatments['aria-label'] = 'Select Treatment';
    //             btnGroupTreatments.className = 'btn-group';
    //
    //             var btnTreatment = document.createElement('button');
    //             btnTreatment.className = 'btn btn-default btn-lg ' +
    //                 'dropdown-toggle';
    //             btnTreatment['data-toggle'] = 'dropdown';
    //             btnTreatment['aria-haspopup'] = 'true';
    //             btnTreatment['aria-expanded'] = 'false';
    //             btnTreatment.innerHTML = w.getText('selectTreatment');
    //
    //             var span = document.createElement('span');
    //             span.className = 'caret';
    //
    //             btnTreatment.appendChild(span);
    //
    //             var ul = document.createElement('ul');
    //             ul.className = 'dropdown-menu';
    //             ul.style['text-align'] = 'left';
    //
    //             var li, a, t, liT1, liT2, liT3;
    //             if (conf.availableTreatments) {
    //                 li = document.createElement('li');
    //                 li.innerHTML = w.getText('gameTreatments');
    //                 li.className = 'dropdown-header';
    //                 ul.appendChild(li);
    //                 for (t in conf.availableTreatments) {
    //                     if (conf.availableTreatments.hasOwnProperty(t)) {
    //                         li = document.createElement('li');
    //                         li.id = t;
    //                         a = document.createElement('a');
    //                         a.href = '#';
    //                         a.innerHTML = '<strong>' + t + '</strong>: ' +
    //                             conf.availableTreatments[t];
    //                         li.appendChild(a);
    //                         if (t === 'treatment_latin_square') liT3 = li;
    //                         else if (t === 'treatment_rotate') liT1 = li;
    //                         else if (t === 'treatment_random') liT2 = li;
    //                         else ul.appendChild(li);
    //                     }
    //                 }
    //
    //                 if (w.addDefaultTreatments !== false) {
    //                     li = document.createElement('li');
    //                     li.role = 'separator';
    //                     li.className = 'divider';
    //                     ul.appendChild(li);
    //                     li = document.createElement('li');
    //                     li.innerHTML = w.getText('defaultTreatments');
    //                     li.className = 'dropdown-header';
    //                     ul.appendChild(li);
    //                     ul.appendChild(liT1);
    //                     ul.appendChild(liT2);
    //                     ul.appendChild(liT3);
    //                 }
    //
    //             }
    //
    //             btnGroupTreatments.appendChild(btnTreatment);
    //             btnGroupTreatments.appendChild(ul);
    //
    //             btnGroup.appendChild(btnGroupTreatments);
    //
    //             // We are not using bootstrap js files
    //             // and we redo the job manually here.
    //             btnTreatment.onclick = function() {
    //                 // When '' is hidden by bootstrap class.
    //                 if (ul.style.display === '') {
    //                     ul.style.display = 'block';
    //                 }
    //                 else {
    //                     ul.style.display = '';
    //                 }
    //             };
    //
    //             ul.onclick = function(eventData) {
    //                 var t;
    //                 t = eventData.target;
    //                 // When '' is hidden by bootstrap class.
    //                 ul.style.display = '';
    //                 t = t.parentNode.id;
    //                 // Clicked on description?
    //                 if (!t) t = eventData.target.parentNode.parentNode.id;
    //                 // Nothing relevant clicked (e.g., header).
    //                 if (!t) return;
    //                 btnTreatment.innerHTML = t + ' ';
    //                 btnTreatment.appendChild(span);
    //                 w.selectedTreatment = t;
    //             };
    //
    //             // Store Reference in widget.
    //             w.treatmentBtn = btnTreatment;
    //         }
    //         // Append button group.
    //         w.bodyDiv.appendChild(document.createElement('br'));
    //         w.bodyDiv.appendChild(btnGroup);
    //
    //     })(this);
    // }

        if (this.playWithBotOption && !document.getElementById('bot_btn')) {
            // Closure to create button group.
            (function(w) {
                // var btnGroup = document.createElement('div');
                // btnGroup.role = 'group';
                // btnGroup['aria-label'] = 'Play Buttons';
                // btnGroup.className = 'btn-group';
                //
                // var playBotBtn = document.createElement('input');
                // playBotBtn.className = 'btn btn-primary btn-lg';
                // playBotBtn.value = w.getText('playBot');
                // playBotBtn.id = 'bot_btn';
                // playBotBtn.type = 'button';
                // playBotBtn.onclick = function() {
                //     w.playBotBtn.value = w.getText('connectingBots');
                //     w.playBotBtn.disabled = true;
                //     node.say('PLAYWITHBOT', 'SERVER', w.selectedTreatment);
                //     setTimeout(function() {
                //         w.playBotBtn.value = w.getText('playBot');
                //         w.playBotBtn.disabled = false;
                //     }, 5000);
                // };
                //
                // btnGroup.appendChild(playBotBtn);
                //
                // // Store reference in widget.
                // w.playBotBtn = playBotBtn;

                if (w.selectTreatmentOption) {


                    var flexBox = W.add('div', w.bodyDiv);
                    flexBox.style.display = 'flex';
                    flexBox.style['flex-wrap'] = 'wrap';
                    flexBox.style['column-gap'] = '20px';
                    flexBox.style['justify-content'] = 'space-between';
                    flexBox.style['margin'] = '50px 100px 30px 150px';
                    flexBox.style['text-align'] = 'center';

                    // border: 1px solid #CCC;
                    //     border-radius: 10px;
                    //     box-shadow: 2px 2px 10px;
                    //     FONT-WEIGHT: 200;
                    //     padding: 10px;

                    var div, a, t, T, divT1, divT2, divT3, display, counter;
                    counter = 0;
                    if (conf.availableTreatments) {
                        for (t in conf.availableTreatments) {
                            if (conf.availableTreatments.hasOwnProperty(t)) {
                                div = document.createElement('div');
                                div.id = t;
                                div.style.flex = '200px';
                                div.style['margin-top'] = '10px';
                                div.className = 'treatment';
                                // div.style.display = 'flex';
                                a = document.createElement('span');
                                // a.className =
                                // 'btn btn-default btn-large round btn-icon';
                                // a.href = '#';
                                if (w.treatmentDisplayCb) {
                                    display = w.treatmentDisplayCb(t,
                                    conf.availableTreatments[t], ++counter, w);
                                }
                                else {
                                    T = t;
                                    if (t.length > 16) {
                                        T = '<span title="' + t + '">' +
                                        t.substr(0,13) + '...</span>';
                                    }
                                    display = '<strong>' + T + '</strong><br>' +
                                        '<span style="font-size: smaller">' +
                                        conf.availableTreatments[t] + '</span>';
                                }
                                a.innerHTML = display;

                                div.appendChild(a);

                                div.onclick = function() {
                                    var t;
                                    t = this.id;
                                    // Clicked on description?
                                    // btnTreatment.innerHTML = t + ' ';
                                    w.selectedTreatment = t;
                                    node.say('PLAYWITHBOT', 'SERVER',
                                    w.selectedTreatment);
                                };

                                if (t === 'treatment_latin_square') divT3 = div;
                                else if (t === 'treatment_rotate') divT1 = div;
                                else if (t === 'treatment_random') divT2 = div;
                                else flexBox.appendChild(div);

                            }
                        }
                        div = document.createElement('div');
                        div.style.flex = '200px';
                        div.style['margin-top'] = '10px';
                        // Hack to fit nicely the treatments.
                        flexBox.appendChild(div);

                        if (w.addDefaultTreatments !== false) {
                            flexBox.appendChild(divT1);
                            flexBox.appendChild(divT2);
                            flexBox.appendChild(divT3);
                        }
                    }

                   //  var btnGroupTreatments = document.createElement('div');
                   // btnGroupTreatments.role = 'group';
                   // btnGroupTreatments['aria-label'] = 'Select Treatment';
                   // btnGroupTreatments.className = 'btn-group';
                   //
                   // var btnTreatment = document.createElement('button');
                   // btnTreatment.className = 'btn btn-default btn-lg ' +
                   //     'dropdown-toggle';
                   // btnTreatment['data-toggle'] = 'dropdown';
                   // btnTreatment['aria-haspopup'] = 'true';
                   // btnTreatment['aria-expanded'] = 'false';
                   // btnTreatment.innerHTML = w.getText('selectTreatment');
                   //
                   //  btnGroupTreatments.appendChild(btnTreatment);

                    // btnGroup.appendChild(btnGroupTreatments);


                    // Store Reference in widget.
                    // w.treatmentBtn = btnTreatment;
                }
                // Append button group.
                // w.bodyDiv.appendChild(document.createElement('br'));
                // w.bodyDiv.appendChild(btnGroup);

            })(this);
        }

        // Handle destroy.
        this.on('destroyed', function() {
            if (that.dots) that.dots.stop();
            node.deregisterSetup('waitroom');
        });
    };

    /**
     * ### WaitingRoom.startTimer
     *
     * Starts a timeout for the max waiting time
     */
    WaitingRoom.prototype.startTimer = function() {
        var that = this;
        if (this.timer) return;
        if (!this.waitTime) return;
        if (!this.timerDiv) {
            this.timerDiv = document.createElement('div');
            this.timerDiv.id = 'timer-div';
        }
        this.timerDiv.appendChild(document.createTextNode(
            'Maximum Waiting Time: '
        ));
        this.timer = node.widgets.append('VisualTimer', this.timerDiv, {
            milliseconds: this.waitTime,
            timeup: function() {
                that.bodyDiv.innerHTML = that.getText('waitedTooLong');
            },
            update: 1000
        });
        // Style up: delete title and border;
        this.timer.setTitle();
        this.timer.panelDiv.className = 'ng_widget visualtimer';
        // Append to bodyDiv.
        this.bodyDiv.appendChild(this.timerDiv);
        this.timer.start();
    };

    /**
     * ### WaitingRoom.clearTimeout
     *
     * Clears the timeout for the max execution time of the requirements
     *
     * @see this.timeoutId
     * @see this.stillCheckings
     * @see this.requirements
     */
    WaitingRoom.prototype.clearTimeout = function() {
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
    };

    /**
     * ### WaitingRoom.updateState
     *
     * Displays the state of the waiting room on screen
     *
     * @see WaitingRoom.updateState
     */
    WaitingRoom.prototype.updateState = function(update) {
        if (!update) return;
        if ('number' === typeof update.connected) {
            this.connected = update.connected;
        }
        if ('number' === typeof update.poolSize) {
            this.poolSize = update.poolSize;
        }
        if ('number' === typeof update.groupSize) {
            this.groupSize = update.groupSize;
        }
    };

    /**
     * ### WaitingRoom.updateDisplay
     *
     * Displays the state of the waiting room on screen (player count)
     *
     * @see WaitingRoom.updateState
     */
    WaitingRoom.prototype.updateDisplay = function() {
        var numberOfGameSlots, numberOfGames;
        if (this.connected > this.poolSize) {
            numberOfGames = Math.floor(this.connected / this.groupSize);
            if ('undefined' !== typeof this.nGames) {
                numberOfGames = numberOfGames > this.nGames ?
                    this.nGames : numberOfGames;
            }
            numberOfGameSlots = numberOfGames * this.groupSize;

            this.playerCount.innerHTML = '<span style="color:red">' +
                this.connected + '</span>' + ' / ' + this.poolSize;
            this.playerCountTooHigh.style.display = '';

            // Update text.
            this.playerCountTooHigh.innerHTML =
                this.getText('tooManyPlayers', { nGames: numberOfGameSlots });
        }
        else {
            this.playerCount.innerHTML = this.connected + ' / ' + this.poolSize;
            this.playerCountTooHigh.style.display = 'none';
        }
    };

    /**
     * ### WaitingRoom.displayExecMode
     *
     * Builds the basic layout of the execution mode
     *
     * @see WaitingRoom.executionMode
     */
    WaitingRoom.prototype.displayExecMode = function() {
        this.bodyDiv.innerHTML = '';

        this.execModeDiv = document.createElement('div');
        this.execModeDiv.id = 'exec-mode-div';

        this.execModeDiv.innerHTML = this.getText('executionMode');

        // TODO: add only on some modes? Depending on settings?
        this.playerCount = document.createElement('p');
        this.playerCount.id = 'player-count';
        this.execModeDiv.appendChild(this.playerCount);

        this.playerCountTooHigh = document.createElement('div');
        this.playerCountTooHigh.style.display = 'none';
        this.execModeDiv.appendChild(this.playerCountTooHigh);

        this.startDateDiv = document.createElement('div');
        this.startDateDiv.style.display= 'none';
        this.execModeDiv.appendChild(this.startDateDiv);

        this.dots = W.getLoadingDots();
        this.execModeDiv.appendChild(this.dots.span);

        this.bodyDiv.appendChild(this.execModeDiv);

        this.msgDiv = document.createElement('div');
        this.bodyDiv.appendChild(this.msgDiv);


        // if (this.startDate) this.setStartDate(this.startDate);
        if (this.waitTime) this.startTimer();

    };

    WaitingRoom.prototype.append = function() {
        // Configuration will arrive soon.
        this.bodyDiv.innerHTML = this.getText('waitingForConf');
    };

    WaitingRoom.prototype.listeners = function() {
        var that;
        that = this;

        node.registerSetup('waitroom', function(conf) {
            if (!conf) return;
            if ('object' !== typeof conf) {
                node.warn('waiting room widget: invalid setup object: ' + conf);
                return;
            }

            // It receives 2 conf messages.
            if (!conf.executionMode) {
                // Sounds.
                that.setSounds(conf.sounds);
                // Texts.
                that.setTexts(conf.texts);
            }
            else {
                // Configure all requirements.
                that.init(conf);
            }

            return conf;
        });

        // NodeGame Listeners.
        node.on.data('PLAYERSCONNECTED', function(msg) {
            if (!msg.data) return;
            that.connected = msg.data;
            that.updateDisplay();
        });

        node.on.data('DISPATCH', function(msg) {
            var data, reportExitCode;
            msg = msg || {};
            data = msg.data || {};

            if (that.dots) that.dots.stop();

            // Alert player he/she is about to play.
            if (data.action === 'allPlayersConnected') {
                that.alertPlayer();
            }
            // Not selected/no game/etc.
            else {
                reportExitCode = that.getText('exitCode', data);

                if (data.action === 'notEnoughPlayers') {
                    that.bodyDiv.innerHTML = that.getText(data.action);
                    if (that.onTimeout) that.onTimeout(msg.data);
                    that.disconnect(that.bodyDiv.innerHTML + reportExitCode);
                }
                else if (data.action === 'notSelected') {

                    if (false === data.shouldDispatchMoreGames ||
                        that.disconnectIfNotSelected) {

                        that.bodyDiv.innerHTML =
                            that.getText('notSelectedClosed');

                        that.disconnect(that.bodyDiv.innerHTML +
                                        reportExitCode);
                    }
                    else {
                        that.msgDiv.innerHTML = that.getText('notSelectedOpen');
                    }
                }
                else if (data.action === 'disconnect') {
                    that.disconnect(that.bodyDiv.innerHTML + reportExitCode);
                }
            }
        });

        node.on.data('TIME', function() {
            node.info('waiting room: TIME IS UP!');
            that.stopTimer();
        });

        // Start waiting time timer.
        node.on.data('WAITTIME', function(msg) {

            // Avoid running multiple timers.
            // if (timeCheck) clearInterval(timeCheck);

            that.updateState(msg.data);
            that.updateDisplay();

        });

        node.on('SOCKET_DISCONNECT', function() {

            // Terminate countdown.
            that.stopTimer();

            // Write about disconnection in page.
            that.bodyDiv.innerHTML = that.getText('disconnect');

            // Enough to not display it in case of page refresh.
            // setTimeout(function() {
            //              alert('Disconnection from server detected!');
            //             }, 200);
        });

        node.on.data('ROOM_CLOSED', function() {
            that.disconnect(that.getText('roomClosed'));
        });
    };

    WaitingRoom.prototype.stopTimer = function() {
        if (this.timer) {
            node.info('waiting room: PAUSING TIMER');
            this.timer.stop();
        }
    };

    /**
     * ### WaitingRoom.disconnect
     *
     * Disconnects the playr, stops the timer, and displays a msg
     *
     * @param {string|function} msg. Optional. A disconnect message. If set,
     *    replaces the current value for future calls.
     *
     * @see WaitingRoom.setText
     */
    WaitingRoom.prototype.disconnect = function(msg) {
        if (msg) this.setText('disconnect', msg);
        node.socket.disconnect();
        this.stopTimer();
    };

    WaitingRoom.prototype.alertPlayer = function() {
        var clearBlink, onFrame;
        var blink, sound;

        blink = this.getText('blinkTitle');

        sound = this.getSound('dispatch');

        // Play sound, if requested.
        if (sound) J.playSound(sound);

        // If blinkTitle is falsy, don't blink the title.
        if (!blink) return;

        // If document.hasFocus() returns TRUE, then just one repeat is enough.
        if (document.hasFocus && document.hasFocus()) {
            J.blinkTitle(blink, { repeatFor: 1 });
        }
        // Otherwise we repeat blinking until an event that shows that the
        // user is active on the page happens, e.g. focus and click. However,
        // the iframe is not created yet, and even later. if the user clicks it
        // it won't be detected in the main window, so we need to handle it.
        else {
            clearBlink = J.blinkTitle(blink, {
                stopOnFocus: true,
                stopOnClick: window
            });
            onFrame = function() {
                var frame;
                clearBlink();
                frame = W.getFrame();
                if (frame) {
                    frame.removeEventListener('mouseover', onFrame, false);
                }
            };
            node.events.ng.once('FRAME_GENERATED', function(frame) {
                frame.addEventListener('mouseover', onFrame, false);
            });
        }
    };

})(node);
